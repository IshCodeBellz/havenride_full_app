/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/driver/page"],{

/***/ "(app-pages-browser)/./app/driver/page.tsx":
/*!*****************************!*\
  !*** ./app/driver/page.tsx ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DriverPage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _clerk_nextjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @clerk/nextjs */ \"(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/index.mjs\");\n/* harmony import */ var _lib_realtime_ably__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/realtime/ably */ \"(app-pages-browser)/./lib/realtime/ably.ts\");\n/* harmony import */ var _components_ChatWidget__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/ChatWidget */ \"(app-pages-browser)/./components/ChatWidget.tsx\");\n/* harmony import */ var _components_RoleGate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/RoleGate */ \"(app-pages-browser)/./components/RoleGate.tsx\");\n/* harmony import */ var _components_AppLayout__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/components/AppLayout */ \"(app-pages-browser)/./components/AppLayout.tsx\");\n/* harmony import */ var _components_RideDocumentationForm__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/components/RideDocumentationForm */ \"(app-pages-browser)/./components/RideDocumentationForm.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\nfunction DriverPageContent() {\n    _s();\n    const { user } = (0,_clerk_nextjs__WEBPACK_IMPORTED_MODULE_7__.useUser)();\n    const [online, setOnline] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [bookings, setBookings] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [activeBookingId, setActiveBookingId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [documentingBookingId, setDocumentingBookingId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const fetchingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const initialLoadRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(true);\n    const assigned = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"DriverPageContent.useMemo[assigned]\": ()=>bookings.find({\n                \"DriverPageContent.useMemo[assigned]\": (b)=>b.driverId === (user === null || user === void 0 ? void 0 : user.id) && b.status !== \"COMPLETED\"\n            }[\"DriverPageContent.useMemo[assigned]\"])\n    }[\"DriverPageContent.useMemo[assigned]\"], [\n        bookings,\n        user === null || user === void 0 ? void 0 : user.id\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"DriverPageContent.useEffect\": ()=>{\n            if (assigned === null || assigned === void 0 ? void 0 : assigned.id) setActiveBookingId(assigned.id);\n        }\n    }[\"DriverPageContent.useEffect\"], [\n        assigned === null || assigned === void 0 ? void 0 : assigned.id\n    ]);\n    async function toggleOnline(next) {\n        const res = await fetch(\"/api/drivers/set-online\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                driverId: user === null || user === void 0 ? void 0 : user.id,\n                online: next\n            })\n        });\n        if (!res.ok) {\n            const data = await res.json();\n            alert(data.error || \"Unable to change status\");\n            return;\n        }\n        setOnline(next);\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"DriverPageContent.useEffect\": ()=>{\n            let timer;\n            if (online) {\n                timer = setInterval({\n                    \"DriverPageContent.useEffect\": async ()=>{\n                        await fetch(\"/api/drivers/update-location\", {\n                            method: \"POST\",\n                            headers: {\n                                \"Content-Type\": \"application/json\"\n                            },\n                            body: JSON.stringify({\n                                driverId: user === null || user === void 0 ? void 0 : user.id,\n                                lat: 51.5 + Math.random() / 100,\n                                lng: -0.1 + Math.random() / 100\n                            })\n                        });\n                    }\n                }[\"DriverPageContent.useEffect\"], 8000);\n            }\n            return ({\n                \"DriverPageContent.useEffect\": ()=>timer && clearInterval(timer)\n            })[\"DriverPageContent.useEffect\"];\n        }\n    }[\"DriverPageContent.useEffect\"], [\n        online,\n        user === null || user === void 0 ? void 0 : user.id\n    ]);\n    // Memoized fetch function to prevent re-creating on every render\n    const fetchBookings = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"DriverPageContent.useCallback[fetchBookings]\": async ()=>{\n            // Prevent concurrent fetches\n            if (fetchingRef.current) return;\n            fetchingRef.current = true;\n            try {\n                const res = await fetch(\"/api/bookings\");\n                const data = await res.json();\n                setBookings(Array.isArray(data) ? data : []);\n            } catch (error) {\n                console.error(\"Failed to fetch bookings:\", error);\n            } finally{\n                fetchingRef.current = false;\n                initialLoadRef.current = false;\n            }\n        }\n    }[\"DriverPageContent.useCallback[fetchBookings]\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"DriverPageContent.useEffect\": ()=>{\n            if (!(user === null || user === void 0 ? void 0 : user.id)) return;\n            fetchBookings();\n            // Set up Ably subscription with error handling\n            let ch = null;\n            let subscribed = false;\n            let handler = null;\n            try {\n                ch = (0,_lib_realtime_ably__WEBPACK_IMPORTED_MODULE_2__.getChannel)(\"driver:\".concat(user.id));\n                handler = ({\n                    \"DriverPageContent.useEffect\": ()=>fetchBookings()\n                })[\"DriverPageContent.useEffect\"];\n                if (ch && !ch.isMock && typeof ch.subscribe === \"function\") {\n                    ch.subscribe(handler);\n                    subscribed = true;\n                }\n            } catch (error) {\n                console.warn(\"Ably subscription failed, using polling fallback\");\n            }\n            // Polling fallback (only if Ably didn't work, or as backup)\n            const timer = setInterval(fetchBookings, 15000); // Increased to 15 seconds\n            return ({\n                \"DriverPageContent.useEffect\": ()=>{\n                    clearInterval(timer);\n                    try {\n                        if (subscribed && ch && handler && typeof ch.unsubscribe === \"function\") {\n                            ch.unsubscribe(handler);\n                        }\n                    } catch (error) {\n                        console.warn(\"Cleanup error:\", error);\n                    }\n                }\n            })[\"DriverPageContent.useEffect\"];\n        }\n    }[\"DriverPageContent.useEffect\"], [\n        user === null || user === void 0 ? void 0 : user.id,\n        fetchBookings\n    ]);\n    async function take(id) {\n        await fetch(\"/api/bookings/\".concat(id, \"/status\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                status: \"ASSIGNED\",\n                driverId: user === null || user === void 0 ? void 0 : user.id\n            })\n        });\n        fetchBookings();\n    }\n    async function arrive(id) {\n        await fetch(\"/api/bookings/\".concat(id, \"/status\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                status: \"ARRIVED\"\n            })\n        });\n        fetchBookings();\n    }\n    async function startWithPin(id) {\n        const pin = prompt(\"Enter pickup PIN provided by rider\");\n        if (!pin) return;\n        const res = await fetch(\"/api/bookings/\".concat(id, \"/verify-pin\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                pin\n            })\n        });\n        if (!res.ok) {\n            alert(\"Invalid PIN\");\n            return;\n        }\n        fetchBookings();\n    }\n    async function complete(id) {\n        const input = prompt(\"Final fare (£)? Leave empty to keep estimate.\");\n        if (input && !isNaN(Number(input))) {\n            await fetch(\"/api/bookings/\".concat(id, \"/fare\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    amount: Number(input),\n                    currency: \"GBP\"\n                })\n            });\n        }\n        // Show documentation form instead of completing immediately\n        setDocumentingBookingId(id);\n    }\n    async function handleDocumentationSubmit(data) {\n        if (!documentingBookingId) return;\n        try {\n            const res = await fetch(\"/api/bookings/\".concat(documentingBookingId, \"/document\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(data)\n            });\n            if (!res.ok) {\n                throw new Error(\"Failed to document ride\");\n            }\n            setDocumentingBookingId(null);\n            await fetchBookings();\n        } catch (error) {\n            console.error(\"Failed to document ride:\", error);\n            throw error;\n        }\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"max-w-5xl mx-auto p-6 space-y-6\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex items-center justify-between\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                        className: \"text-2xl font-bold\",\n                        children: \"Driver Console\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                        lineNumber: 196,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                        className: \"flex items-center gap-2\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"checkbox\",\n                                checked: online,\n                                onChange: (e)=>toggleOnline(e.target.checked)\n                            }, void 0, false, {\n                                fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                                lineNumber: 198,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                children: online ? \"Online\" : \"Offline\"\n                            }, void 0, false, {\n                                fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                                lineNumber: 203,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                        lineNumber: 197,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                lineNumber: 195,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-1 lg:grid-cols-2 gap-6\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"space-y-3\",\n                        children: initialLoadRef.current ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"text-center text-gray-500 py-4\",\n                            children: \"Loading bookings...\"\n                        }, void 0, false, {\n                            fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                            lineNumber: 210,\n                            columnNumber: 13\n                        }, this) : bookings.length === 0 ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"text-center text-gray-500 py-4\",\n                            children: \"No bookings yet\"\n                        }, void 0, false, {\n                            fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                            lineNumber: 214,\n                            columnNumber: 13\n                        }, this) : bookings.map((b)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"border rounded p-3 \".concat(activeBookingId === b.id ? \"ring-2 ring-blue-400\" : \"\"),\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex items-center justify-between\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"font-semibold\",\n                                                        children: [\n                                                            b.pickupAddress,\n                                                            \" → \",\n                                                            b.dropoffAddress\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                                                        lineNumber: 227,\n                                                        columnNumber: 21\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"text-xs text-gray-600\",\n                                                        children: [\n                                                            \"Status: \",\n                                                            b.status,\n                                                            \" \",\n                                                            b.requiresWheelchair ? \"• ♿\" : \"\"\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                                                        lineNumber: 230,\n                                                        columnNumber: 21\n                                                    }, this),\n                                                    typeof b.finalFareAmount === \"number\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"text-xs text-gray-700\",\n                                                        children: [\n                                                            \"Final fare: \\xa3\",\n                                                            b.finalFareAmount.toFixed(2)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                                                        lineNumber: 234,\n                                                        columnNumber: 23\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                                                lineNumber: 226,\n                                                columnNumber: 19\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex gap-2\",\n                                                children: [\n                                                    !b.driverId && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                        className: \"px-3 py-1 border rounded\",\n                                                        onClick: ()=>take(b.id),\n                                                        children: \"Take\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                                                        lineNumber: 241,\n                                                        columnNumber: 23\n                                                    }, this),\n                                                    b.status !== \"ARRIVED\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                        className: \"px-3 py-1 border rounded\",\n                                                        onClick: ()=>arrive(b.id),\n                                                        children: \"Arrived\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                                                        lineNumber: 249,\n                                                        columnNumber: 23\n                                                    }, this),\n                                                    b.status === \"ARRIVED\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                        className: \"px-3 py-1 border rounded\",\n                                                        onClick: ()=>startWithPin(b.id),\n                                                        children: \"Start (PIN)\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                                                        lineNumber: 257,\n                                                        columnNumber: 23\n                                                    }, this),\n                                                    b.status === \"IN_PROGRESS\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                        className: \"px-3 py-1 border rounded\",\n                                                        onClick: ()=>complete(b.id),\n                                                        children: \"Complete\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                                                        lineNumber: 265,\n                                                        columnNumber: 23\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                                                lineNumber: 239,\n                                                columnNumber: 19\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                                        lineNumber: 225,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"text-xs text-gray-500 mt-1\",\n                                        children: [\n                                            \"Booking ID: \",\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"code\", {\n                                                children: [\n                                                    b.id.slice(0, 8),\n                                                    \"…\"\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                                                lineNumber: 275,\n                                                columnNumber: 31\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                                        lineNumber: 274,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"mt-2\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            className: \"text-xs underline\",\n                                            onClick: ()=>setActiveBookingId(b.id),\n                                            children: \"Open Chat\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                                            lineNumber: 278,\n                                            columnNumber: 19\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                                        lineNumber: 277,\n                                        columnNumber: 17\n                                    }, this)\n                                ]\n                            }, b.id, true, {\n                                fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                                lineNumber: 219,\n                                columnNumber: 15\n                            }, this))\n                    }, void 0, false, {\n                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                        lineNumber: 208,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: activeBookingId ? (()=>{\n                            const activeBooking = bookings.find((b)=>b.id === activeBookingId);\n                            const isCompleted = (activeBooking === null || activeBooking === void 0 ? void 0 : activeBooking.status) === \"COMPLETED\" || (activeBooking === null || activeBooking === void 0 ? void 0 : activeBooking.status) === \"CANCELED\";\n                            if (isCompleted) {\n                                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"text-sm text-gray-500 border rounded p-4 h-80 flex items-center justify-center\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"text-center\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"font-semibold\",\n                                                children: \"Chat Closed\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                                                lineNumber: 303,\n                                                columnNumber: 23\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"mt-2\",\n                                                children: \"This ride has been completed\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                                                lineNumber: 304,\n                                                columnNumber: 23\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                                        lineNumber: 302,\n                                        columnNumber: 21\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                                    lineNumber: 301,\n                                    columnNumber: 19\n                                }, this);\n                            }\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ChatWidget__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                bookingId: activeBookingId,\n                                sender: \"DRIVER\"\n                            }, activeBookingId, false, {\n                                fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                                lineNumber: 311,\n                                columnNumber: 17\n                            }, this);\n                        })() : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"text-sm text-gray-500 border rounded p-4\",\n                            children: \"Select a booking to open chat.\"\n                        }, void 0, false, {\n                            fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                            lineNumber: 319,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                        lineNumber: 289,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                lineNumber: 207,\n                columnNumber: 7\n            }, this),\n            documentingBookingId && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_RideDocumentationForm__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                bookingId: documentingBookingId,\n                onSubmit: handleDocumentationSubmit,\n                onCancel: ()=>setDocumentingBookingId(null)\n            }, void 0, false, {\n                fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                lineNumber: 328,\n                columnNumber: 9\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n        lineNumber: 194,\n        columnNumber: 5\n    }, this);\n}\n_s(DriverPageContent, \"Y1itQPbKkYTkjgSc6LRNesH+Pog=\", false, function() {\n    return [\n        _clerk_nextjs__WEBPACK_IMPORTED_MODULE_7__.useUser\n    ];\n});\n_c = DriverPageContent;\nfunction DriverPage() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_RoleGate__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n        requiredRole: [\n            \"DRIVER\"\n        ],\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_AppLayout__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n            userRole: \"DRIVER\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(DriverPageContent, {}, void 0, false, {\n                fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n                lineNumber: 342,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n            lineNumber: 341,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/ishaqbello/Website/havenride_full_app/app/driver/page.tsx\",\n        lineNumber: 340,\n        columnNumber: 5\n    }, this);\n}\n_c1 = DriverPage;\nvar _c, _c1;\n$RefreshReg$(_c, \"DriverPageContent\");\n$RefreshReg$(_c1, \"DriverPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9kcml2ZXIvcGFnZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQzBFO0FBQ2xDO0FBQ1M7QUFDQTtBQUNKO0FBQ0U7QUFHSDtBQUU1QyxTQUFTVzs7SUFDUCxNQUFNLEVBQUVDLElBQUksRUFBRSxHQUFHUCxzREFBT0E7SUFDeEIsTUFBTSxDQUFDUSxRQUFRQyxVQUFVLEdBQUdaLCtDQUFRQSxDQUFDO0lBQ3JDLE1BQU0sQ0FBQ2EsVUFBVUMsWUFBWSxHQUFHZCwrQ0FBUUEsQ0FBUSxFQUFFO0lBQ2xELE1BQU0sQ0FBQ2UsaUJBQWlCQyxtQkFBbUIsR0FBR2hCLCtDQUFRQSxDQUFnQjtJQUN0RSxNQUFNLENBQUNpQixzQkFBc0JDLHdCQUF3QixHQUFHbEIsK0NBQVFBLENBRTlEO0lBQ0YsTUFBTW1CLGNBQWNqQiw2Q0FBTUEsQ0FBQztJQUMzQixNQUFNa0IsaUJBQWlCbEIsNkNBQU1BLENBQUM7SUFFOUIsTUFBTW1CLFdBQVd0Qiw4Q0FBT0E7K0NBQ3RCLElBQ0VjLFNBQVNTLElBQUk7dURBQUMsQ0FBQ0MsSUFBTUEsRUFBRUMsUUFBUSxNQUFLZCxpQkFBQUEsMkJBQUFBLEtBQU1lLEVBQUUsS0FBSUYsRUFBRUcsTUFBTSxLQUFLOzs4Q0FDL0Q7UUFBQ2I7UUFBVUgsaUJBQUFBLDJCQUFBQSxLQUFNZSxFQUFFO0tBQUM7SUFHdEIzQixnREFBU0E7dUNBQUM7WUFDUixJQUFJdUIscUJBQUFBLCtCQUFBQSxTQUFVSSxFQUFFLEVBQUVULG1CQUFtQkssU0FBU0ksRUFBRTtRQUNsRDtzQ0FBRztRQUFDSixxQkFBQUEsK0JBQUFBLFNBQVVJLEVBQUU7S0FBQztJQUVqQixlQUFlRSxhQUFhQyxJQUFhO1FBQ3ZDLE1BQU1DLE1BQU0sTUFBTUMsTUFBTSwyQkFBMkI7WUFDakRDLFFBQVE7WUFDUkMsU0FBUztnQkFBRSxnQkFBZ0I7WUFBbUI7WUFDOUNDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztnQkFBRVgsUUFB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QUU7Ozs7Ozs7Ozs7a0NBcUVqQiw4REFBQ2dEO2tDQUNFMUQsa0JBQ0MsQ0FBQzs0QkFDQyxNQUFNK0UsZ0JBQWdCakYsU0FBU1MsSUFBSSxDQUNqQyxDQUFDQyxJQUFNQSxFQUFFRSxFQUFFLEtBQUtWOzRCQUVsQixNQUFNZ0YsY0FDSkQsQ0FBQUEsMEJBQUFBLG9DQUFBQSxjQUFlcEUsTUFBTSxNQUFLLGVBQzFCb0UsQ0FBQUEsMEJBQUFBLG9DQUFBQSxjQUFlcEUsTUFBTSxNQUFLOzRCQUU1QixJQUFJcUUsYUFBYTtnQ0FDZixxQkFDRSw4REFBQ3RCO29DQUFJQyxXQUFVOzhDQUNiLDRFQUFDRDt3Q0FBSUMsV0FBVTs7MERBQ2IsOERBQUNzQjtnREFBRXRCLFdBQVU7MERBQWdCOzs7Ozs7MERBQzdCLDhEQUFDc0I7Z0RBQUV0QixXQUFVOzBEQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs0QkFJNUI7NEJBRUEscUJBQ0UsOERBQUNyRSw4REFBVUE7Z0NBRVQ0RixXQUFXbEY7Z0NBQ1htRixRQUFPOytCQUZGbkY7Ozs7O3dCQUtYLHFCQUVBLDhEQUFDMEQ7NEJBQUlDLFdBQVU7c0NBQTJDOzs7Ozs7Ozs7Ozs7Ozs7OztZQVEvRHpELHNDQUNDLDhEQUFDVCx5RUFBcUJBO2dCQUNwQnlGLFdBQVdoRjtnQkFDWGtGLFVBQVU1QjtnQkFDVjZCLFVBQVUsSUFBTWxGLHdCQUF3Qjs7Ozs7Ozs7Ozs7O0FBS2xEO0dBcFVTVDs7UUFDVU4sa0RBQU9BOzs7S0FEakJNO0FBc1VNLFNBQVM0RjtJQUN0QixxQkFDRSw4REFBQy9GLDREQUFRQTtRQUFDZ0csY0FBYztZQUFDO1NBQVM7a0JBQ2hDLDRFQUFDL0YsNkRBQVNBO1lBQUNnRyxVQUFTO3NCQUNsQiw0RUFBQzlGOzs7Ozs7Ozs7Ozs7Ozs7QUFJVDtNQVJ3QjRGIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9hcHAvZHJpdmVyL3BhZ2UudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlVXNlciB9IGZyb20gXCJAY2xlcmsvbmV4dGpzXCI7XG5pbXBvcnQgeyBnZXRDaGFubmVsIH0gZnJvbSBcIkAvbGliL3JlYWx0aW1lL2FibHlcIjtcbmltcG9ydCBDaGF0V2lkZ2V0IGZyb20gXCJAL2NvbXBvbmVudHMvQ2hhdFdpZGdldFwiO1xuaW1wb3J0IFJvbGVHYXRlIGZyb20gXCJAL2NvbXBvbmVudHMvUm9sZUdhdGVcIjtcbmltcG9ydCBBcHBMYXlvdXQgZnJvbSBcIkAvY29tcG9uZW50cy9BcHBMYXlvdXRcIjtcbmltcG9ydCBSaWRlRG9jdW1lbnRhdGlvbkZvcm0sIHtcbiAgUmlkZURvY3VtZW50YXRpb24sXG59IGZyb20gXCJAL2NvbXBvbmVudHMvUmlkZURvY3VtZW50YXRpb25Gb3JtXCI7XG5cbmZ1bmN0aW9uIERyaXZlclBhZ2VDb250ZW50KCkge1xuICBjb25zdCB7IHVzZXIgfSA9IHVzZVVzZXIoKTtcbiAgY29uc3QgW29ubGluZSwgc2V0T25saW5lXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Jvb2tpbmdzLCBzZXRCb29raW5nc10gPSB1c2VTdGF0ZTxhbnlbXT4oW10pO1xuICBjb25zdCBbYWN0aXZlQm9va2luZ0lkLCBzZXRBY3RpdmVCb29raW5nSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtkb2N1bWVudGluZ0Jvb2tpbmdJZCwgc2V0RG9jdW1lbnRpbmdCb29raW5nSWRdID0gdXNlU3RhdGU8XG4gICAgc3RyaW5nIHwgbnVsbFxuICA+KG51bGwpO1xuICBjb25zdCBmZXRjaGluZ1JlZiA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGluaXRpYWxMb2FkUmVmID0gdXNlUmVmKHRydWUpO1xuXG4gIGNvbnN0IGFzc2lnbmVkID0gdXNlTWVtbyhcbiAgICAoKSA9PlxuICAgICAgYm9va2luZ3MuZmluZCgoYikgPT4gYi5kcml2ZXJJZCA9PT0gdXNlcj8uaWQgJiYgYi5zdGF0dXMgIT09IFwiQ09NUExFVEVEXCIpLFxuICAgIFtib29raW5ncywgdXNlcj8uaWRdXG4gICk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYXNzaWduZWQ/LmlkKSBzZXRBY3RpdmVCb29raW5nSWQoYXNzaWduZWQuaWQpO1xuICB9LCBbYXNzaWduZWQ/LmlkXSk7XG5cbiAgYXN5bmMgZnVuY3Rpb24gdG9nZ2xlT25saW5lKG5leHQ6IGJvb2xlYW4pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChcIi9hcGkvZHJpdmVycy9zZXQtb25saW5lXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGRyaXZlcklkOiB1c2VyPy5pZCwgb25saW5lOiBuZXh0IH0pLFxuICAgIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgIGFsZXJ0KGRhdGEuZXJyb3IgfHwgXCJVbmFibGUgdG8gY2hhbmdlIHN0YXR1c1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0T25saW5lKG5leHQpO1xuICB9XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgdGltZXI6IGFueTtcbiAgICBpZiAob25saW5lKSB7XG4gICAgICB0aW1lciA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgZmV0Y2goXCIvYXBpL2RyaXZlcnMvdXBkYXRlLWxvY2F0aW9uXCIsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBkcml2ZXJJZDogdXNlcj8uaWQsXG4gICAgICAgICAgICBsYXQ6IDUxLjUgKyBNYXRoLnJhbmRvbSgpIC8gMTAwLFxuICAgICAgICAgICAgbG5nOiAtMC4xICsgTWF0aC5yYW5kb20oKSAvIDEwMCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgICB9LCA4MDAwKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHRpbWVyICYmIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICB9LCBbb25saW5lLCB1c2VyPy5pZF0pO1xuXG4gIC8vIE1lbW9pemVkIGZldGNoIGZ1bmN0aW9uIHRvIHByZXZlbnQgcmUtY3JlYXRpbmcgb24gZXZlcnkgcmVuZGVyXG4gIGNvbnN0IGZldGNoQm9va2luZ3MgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgLy8gUHJldmVudCBjb25jdXJyZW50IGZldGNoZXNcbiAgICBpZiAoZmV0Y2hpbmdSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgZmV0Y2hpbmdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKFwiL2FwaS9ib29raW5nc1wiKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgc2V0Qm9va2luZ3MoQXJyYXkuaXNBcnJheShkYXRhKSA/IGRhdGEgOiBbXSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggYm9va2luZ3M6XCIsIGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZmV0Y2hpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgaW5pdGlhbExvYWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF1c2VyPy5pZCkgcmV0dXJuO1xuXG4gICAgZmV0Y2hCb29raW5ncygpO1xuXG4gICAgLy8gU2V0IHVwIEFibHkgc3Vic2NyaXB0aW9uIHdpdGggZXJyb3IgaGFuZGxpbmdcbiAgICBsZXQgY2g6IGFueSA9IG51bGw7XG4gICAgbGV0IHN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICBsZXQgaGFuZGxlcjogYW55ID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICBjaCA9IGdldENoYW5uZWwoYGRyaXZlcjoke3VzZXIuaWR9YCk7XG4gICAgICBoYW5kbGVyID0gKCkgPT4gZmV0Y2hCb29raW5ncygpO1xuXG4gICAgICBpZiAoY2ggJiYgIWNoLmlzTW9jayAmJiB0eXBlb2YgY2guc3Vic2NyaWJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2guc3Vic2NyaWJlKGhhbmRsZXIpO1xuICAgICAgICBzdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKFwiQWJseSBzdWJzY3JpcHRpb24gZmFpbGVkLCB1c2luZyBwb2xsaW5nIGZhbGxiYWNrXCIpO1xuICAgIH1cblxuICAgIC8vIFBvbGxpbmcgZmFsbGJhY2sgKG9ubHkgaWYgQWJseSBkaWRuJ3Qgd29yaywgb3IgYXMgYmFja3VwKVxuICAgIGNvbnN0IHRpbWVyID0gc2V0SW50ZXJ2YWwoZmV0Y2hCb29raW5ncywgMTUwMDApOyAvLyBJbmNyZWFzZWQgdG8gMTUgc2Vjb25kc1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHN1YnNjcmliZWQgJiZcbiAgICAgICAgICBjaCAmJlxuICAgICAgICAgIGhhbmRsZXIgJiZcbiAgICAgICAgICB0eXBlb2YgY2gudW5zdWJzY3JpYmUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICApIHtcbiAgICAgICAgICBjaC51bnN1YnNjcmliZShoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiQ2xlYW51cCBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFt1c2VyPy5pZCwgZmV0Y2hCb29raW5nc10pO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIHRha2UoaWQ6IHN0cmluZykge1xuICAgIGF3YWl0IGZldGNoKGAvYXBpL2Jvb2tpbmdzLyR7aWR9L3N0YXR1c2AsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHN0YXR1czogXCJBU1NJR05FRFwiLCBkcml2ZXJJZDogdXNlcj8uaWQgfSksXG4gICAgfSk7XG4gICAgZmV0Y2hCb29raW5ncygpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGFycml2ZShpZDogc3RyaW5nKSB7XG4gICAgYXdhaXQgZmV0Y2goYC9hcGkvYm9va2luZ3MvJHtpZH0vc3RhdHVzYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgc3RhdHVzOiBcIkFSUklWRURcIiB9KSxcbiAgICB9KTtcbiAgICBmZXRjaEJvb2tpbmdzKCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnRXaXRoUGluKGlkOiBzdHJpbmcpIHtcbiAgICBjb25zdCBwaW4gPSBwcm9tcHQoXCJFbnRlciBwaWNrdXAgUElOIHByb3ZpZGVkIGJ5IHJpZGVyXCIpO1xuICAgIGlmICghcGluKSByZXR1cm47XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYC9hcGkvYm9va2luZ3MvJHtpZH0vdmVyaWZ5LXBpbmAsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHBpbiB9KSxcbiAgICB9KTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgYWxlcnQoXCJJbnZhbGlkIFBJTlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmV0Y2hCb29raW5ncygpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNvbXBsZXRlKGlkOiBzdHJpbmcpIHtcbiAgICBjb25zdCBpbnB1dCA9IHByb21wdChcIkZpbmFsIGZhcmUgKMKjKT8gTGVhdmUgZW1wdHkgdG8ga2VlcCBlc3RpbWF0ZS5cIik7XG4gICAgaWYgKGlucHV0ICYmICFpc05hTihOdW1iZXIoaW5wdXQpKSkge1xuICAgICAgYXdhaXQgZmV0Y2goYC9hcGkvYm9va2luZ3MvJHtpZH0vZmFyZWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGFtb3VudDogTnVtYmVyKGlucHV0KSwgY3VycmVuY3k6IFwiR0JQXCIgfSksXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gU2hvdyBkb2N1bWVudGF0aW9uIGZvcm0gaW5zdGVhZCBvZiBjb21wbGV0aW5nIGltbWVkaWF0ZWx5XG4gICAgc2V0RG9jdW1lbnRpbmdCb29raW5nSWQoaWQpO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlRG9jdW1lbnRhdGlvblN1Ym1pdChkYXRhOiBSaWRlRG9jdW1lbnRhdGlvbikge1xuICAgIGlmICghZG9jdW1lbnRpbmdCb29raW5nSWQpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYC9hcGkvYm9va2luZ3MvJHtkb2N1bWVudGluZ0Jvb2tpbmdJZH0vZG9jdW1lbnRgLFxuICAgICAgICB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkb2N1bWVudCByaWRlXCIpO1xuICAgICAgfVxuXG4gICAgICBzZXREb2N1bWVudGluZ0Jvb2tpbmdJZChudWxsKTtcbiAgICAgIGF3YWl0IGZldGNoQm9va2luZ3MoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBkb2N1bWVudCByaWRlOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwibWF4LXctNXhsIG14LWF1dG8gcC02IHNwYWNlLXktNlwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW5cIj5cbiAgICAgICAgPGgxIGNsYXNzTmFtZT1cInRleHQtMnhsIGZvbnQtYm9sZFwiPkRyaXZlciBDb25zb2xlPC9oMT5cbiAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0yXCI+XG4gICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgY2hlY2tlZD17b25saW5lfVxuICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiB0b2dnbGVPbmxpbmUoZS50YXJnZXQuY2hlY2tlZCl9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8c3Bhbj57b25saW5lID8gXCJPbmxpbmVcIiA6IFwiT2ZmbGluZVwifTwvc3Bhbj5cbiAgICAgICAgPC9sYWJlbD5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTEgbGc6Z3JpZC1jb2xzLTIgZ2FwLTZcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGFjZS15LTNcIj5cbiAgICAgICAgICB7aW5pdGlhbExvYWRSZWYuY3VycmVudCA/IChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXIgdGV4dC1ncmF5LTUwMCBweS00XCI+XG4gICAgICAgICAgICAgIExvYWRpbmcgYm9va2luZ3MuLi5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICkgOiBib29raW5ncy5sZW5ndGggPT09IDAgPyAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtY2VudGVyIHRleHQtZ3JheS01MDAgcHktNFwiPlxuICAgICAgICAgICAgICBObyBib29raW5ncyB5ZXRcbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICBib29raW5ncy5tYXAoKGI6IGFueSkgPT4gKFxuICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAga2V5PXtiLmlkfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YGJvcmRlciByb3VuZGVkIHAtMyAke1xuICAgICAgICAgICAgICAgICAgYWN0aXZlQm9va2luZ0lkID09PSBiLmlkID8gXCJyaW5nLTIgcmluZy1ibHVlLTQwMFwiIDogXCJcIlxuICAgICAgICAgICAgICAgIH1gfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW5cIj5cbiAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9udC1zZW1pYm9sZFwiPlxuICAgICAgICAgICAgICAgICAgICAgIHtiLnBpY2t1cEFkZHJlc3N9IOKGkiB7Yi5kcm9wb2ZmQWRkcmVzc31cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC14cyB0ZXh0LWdyYXktNjAwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgU3RhdHVzOiB7Yi5zdGF0dXN9IHtiLnJlcXVpcmVzV2hlZWxjaGFpciA/IFwi4oCiIOKZv1wiIDogXCJcIn1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIHt0eXBlb2YgYi5maW5hbEZhcmVBbW91bnQgPT09IFwibnVtYmVyXCIgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC14cyB0ZXh0LWdyYXktNzAwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICBGaW5hbCBmYXJlOiDCo3tiLmZpbmFsRmFyZUFtb3VudC50b0ZpeGVkKDIpfVxuICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZ2FwLTJcIj5cbiAgICAgICAgICAgICAgICAgICAgeyFiLmRyaXZlcklkICYmIChcbiAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC0zIHB5LTEgYm9yZGVyIHJvdW5kZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gdGFrZShiLmlkKX1cbiAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICBUYWtlXG4gICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIHtiLnN0YXR1cyAhPT0gXCJBUlJJVkVEXCIgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTMgcHktMSBib3JkZXIgcm91bmRlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBhcnJpdmUoYi5pZCl9XG4gICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgQXJyaXZlZFxuICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICB7Yi5zdGF0dXMgPT09IFwiQVJSSVZFRFwiICYmIChcbiAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC0zIHB5LTEgYm9yZGVyIHJvdW5kZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc3RhcnRXaXRoUGluKGIuaWQpfVxuICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIFN0YXJ0IChQSU4pXG4gICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIHtiLnN0YXR1cyA9PT0gXCJJTl9QUk9HUkVTU1wiICYmIChcbiAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC0zIHB5LTEgYm9yZGVyIHJvdW5kZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gY29tcGxldGUoYi5pZCl9XG4gICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgQ29tcGxldGVcbiAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC14cyB0ZXh0LWdyYXktNTAwIG10LTFcIj5cbiAgICAgICAgICAgICAgICAgIEJvb2tpbmcgSUQ6IDxjb2RlPntiLmlkLnNsaWNlKDAsIDgpfeKApjwvY29kZT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTJcIj5cbiAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGV4dC14cyB1bmRlcmxpbmVcIlxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRBY3RpdmVCb29raW5nSWQoYi5pZCl9XG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIE9wZW4gQ2hhdFxuICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKSlcbiAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICB7YWN0aXZlQm9va2luZ0lkID8gKFxuICAgICAgICAgICAgKCgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgYWN0aXZlQm9va2luZyA9IGJvb2tpbmdzLmZpbmQoXG4gICAgICAgICAgICAgICAgKGIpID0+IGIuaWQgPT09IGFjdGl2ZUJvb2tpbmdJZFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBjb25zdCBpc0NvbXBsZXRlZCA9XG4gICAgICAgICAgICAgICAgYWN0aXZlQm9va2luZz8uc3RhdHVzID09PSBcIkNPTVBMRVRFRFwiIHx8XG4gICAgICAgICAgICAgICAgYWN0aXZlQm9va2luZz8uc3RhdHVzID09PSBcIkNBTkNFTEVEXCI7XG5cbiAgICAgICAgICAgICAgaWYgKGlzQ29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LWdyYXktNTAwIGJvcmRlciByb3VuZGVkIHAtNCBoLTgwIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJmb250LXNlbWlib2xkXCI+Q2hhdCBDbG9zZWQ8L3A+XG4gICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwibXQtMlwiPlRoaXMgcmlkZSBoYXMgYmVlbiBjb21wbGV0ZWQ8L3A+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPENoYXRXaWRnZXRcbiAgICAgICAgICAgICAgICAgIGtleT17YWN0aXZlQm9va2luZ0lkfVxuICAgICAgICAgICAgICAgICAgYm9va2luZ0lkPXthY3RpdmVCb29raW5nSWR9XG4gICAgICAgICAgICAgICAgICBzZW5kZXI9XCJEUklWRVJcIlxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KSgpXG4gICAgICAgICAgKSA6IChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LWdyYXktNTAwIGJvcmRlciByb3VuZGVkIHAtNFwiPlxuICAgICAgICAgICAgICBTZWxlY3QgYSBib29raW5nIHRvIG9wZW4gY2hhdC5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIHsvKiBSaWRlIERvY3VtZW50YXRpb24gTW9kYWwgKi99XG4gICAgICB7ZG9jdW1lbnRpbmdCb29raW5nSWQgJiYgKFxuICAgICAgICA8UmlkZURvY3VtZW50YXRpb25Gb3JtXG4gICAgICAgICAgYm9va2luZ0lkPXtkb2N1bWVudGluZ0Jvb2tpbmdJZH1cbiAgICAgICAgICBvblN1Ym1pdD17aGFuZGxlRG9jdW1lbnRhdGlvblN1Ym1pdH1cbiAgICAgICAgICBvbkNhbmNlbD17KCkgPT4gc2V0RG9jdW1lbnRpbmdCb29raW5nSWQobnVsbCl9XG4gICAgICAgIC8+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEcml2ZXJQYWdlKCkge1xuICByZXR1cm4gKFxuICAgIDxSb2xlR2F0ZSByZXF1aXJlZFJvbGU9e1tcIkRSSVZFUlwiXX0+XG4gICAgICA8QXBwTGF5b3V0IHVzZXJSb2xlPVwiRFJJVkVSXCI+XG4gICAgICAgIDxEcml2ZXJQYWdlQ29udGVudCAvPlxuICAgICAgPC9BcHBMYXlvdXQ+XG4gICAgPC9Sb2xlR2F0ZT5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZVJlZiIsInVzZVVzZXIiLCJnZXRDaGFubmVsIiwiQ2hhdFdpZGdldCIsIlJvbGVHYXRlIiwiQXBwTGF5b3V0IiwiUmlkZURvY3VtZW50YXRpb25Gb3JtIiwiRHJpdmVyUGFnZUNvbnRlbnQiLCJ1c2VyIiwib25saW5lIiwic2V0T25saW5lIiwiYm9va2luZ3MiLCJzZXRCb29raW5ncyIsImFjdGl2ZUJvb2tpbmdJZCIsInNldEFjdGl2ZUJvb2tpbmdJZCIsImRvY3VtZW50aW5nQm9va2luZ0lkIiwic2V0RG9jdW1lbnRpbmdCb29raW5nSWQiLCJmZXRjaGluZ1JlZiIsImluaXRpYWxMb2FkUmVmIiwiYXNzaWduZWQiLCJmaW5kIiwiYiIsImRyaXZlcklkIiwiaWQiLCJzdGF0dXMiLCJ0b2dnbGVPbmxpbmUiLCJuZXh0IiwicmVzIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJvayIsImRhdGEiLCJqc29uIiwiYWxlcnQiLCJlcnJvciIsInRpbWVyIiwic2V0SW50ZXJ2YWwiLCJsYXQiLCJNYXRoIiwicmFuZG9tIiwibG5nIiwiY2xlYXJJbnRlcnZhbCIsImZldGNoQm9va2luZ3MiLCJjdXJyZW50IiwiQXJyYXkiLCJpc0FycmF5IiwiY29uc29sZSIsImNoIiwic3Vic2NyaWJlZCIsImhhbmRsZXIiLCJpc01vY2siLCJzdWJzY3JpYmUiLCJ3YXJuIiwidW5zdWJzY3JpYmUiLCJ0YWtlIiwiYXJyaXZlIiwic3RhcnRXaXRoUGluIiwicGluIiwicHJvbXB0IiwiY29tcGxldGUiLCJpbnB1dCIsImlzTmFOIiwiTnVtYmVyIiwiYW1vdW50IiwiY3VycmVuY3kiLCJoYW5kbGVEb2N1bWVudGF0aW9uU3VibWl0IiwiRXJyb3IiLCJkaXYiLCJjbGFzc05hbWUiLCJoMSIsImxhYmVsIiwidHlwZSIsImNoZWNrZWQiLCJvbkNoYW5nZSIsImUiLCJ0YXJnZXQiLCJzcGFuIiwibGVuZ3RoIiwibWFwIiwicGlja3VwQWRkcmVzcyIsImRyb3BvZmZBZGRyZXNzIiwicmVxdWlyZXNXaGVlbGNoYWlyIiwiZmluYWxGYXJlQW1vdW50IiwidG9GaXhlZCIsImJ1dHRvbiIsIm9uQ2xpY2siLCJjb2RlIiwic2xpY2UiLCJhY3RpdmVCb29raW5nIiwiaXNDb21wbGV0ZWQiLCJwIiwiYm9va2luZ0lkIiwic2VuZGVyIiwib25TdWJtaXQiLCJvbkNhbmNlbCIsIkRyaXZlclBhZ2UiLCJyZXF1aXJlZFJvbGUiLCJ1c2VyUm9sZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/driver/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/AppLayout.tsx":
/*!**********************************!*\
  !*** ./components/AppLayout.tsx ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AppLayout)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _Sidebar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Sidebar */ \"(app-pages-browser)/./components/Sidebar.tsx\");\n/* harmony import */ var _SOSButton__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SOSButton */ \"(app-pages-browser)/./components/SOSButton.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\nfunction AppLayout(param) {\n    let { children, userRole } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex min-h-screen bg-gray-50\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Sidebar__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                userRole: userRole\n            }, void 0, false, {\n                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/AppLayout.tsx\",\n                lineNumber: 14,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                className: \"flex-1 overflow-auto\",\n                children: children\n            }, void 0, false, {\n                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/AppLayout.tsx\",\n                lineNumber: 15,\n                columnNumber: 7\n            }, this),\n            (userRole === \"RIDER\" || userRole === \"DRIVER\") && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_SOSButton__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/AppLayout.tsx\",\n                lineNumber: 17,\n                columnNumber: 59\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/AppLayout.tsx\",\n        lineNumber: 13,\n        columnNumber: 5\n    }, this);\n}\n_c = AppLayout;\nvar _c;\n$RefreshReg$(_c, \"AppLayout\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvQXBwTGF5b3V0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUVnQztBQUNJO0FBT3JCLFNBQVNFLFVBQVUsS0FBc0M7UUFBdEMsRUFBRUMsUUFBUSxFQUFFQyxRQUFRLEVBQWtCLEdBQXRDO0lBQ2hDLHFCQUNFLDhEQUFDQztRQUFJQyxXQUFVOzswQkFDYiw4REFBQ04sZ0RBQU9BO2dCQUFDSSxVQUFVQTs7Ozs7OzBCQUNuQiw4REFBQ0c7Z0JBQUtELFdBQVU7MEJBQXdCSDs7Ozs7O1lBRXRDQyxDQUFBQSxhQUFhLFdBQVdBLGFBQWEsUUFBTyxtQkFBTSw4REFBQ0gsa0RBQVNBOzs7Ozs7Ozs7OztBQUdwRTtLQVR3QkMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL2NvbXBvbmVudHMvQXBwTGF5b3V0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcbmltcG9ydCB7IFJlYWN0Tm9kZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFNpZGViYXIgZnJvbSBcIi4vU2lkZWJhclwiO1xuaW1wb3J0IFNPU0J1dHRvbiBmcm9tIFwiLi9TT1NCdXR0b25cIjtcblxuaW50ZXJmYWNlIEFwcExheW91dFByb3BzIHtcbiAgY2hpbGRyZW46IFJlYWN0Tm9kZTtcbiAgdXNlclJvbGU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFwcExheW91dCh7IGNoaWxkcmVuLCB1c2VyUm9sZSB9OiBBcHBMYXlvdXRQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBtaW4taC1zY3JlZW4gYmctZ3JheS01MFwiPlxuICAgICAgPFNpZGViYXIgdXNlclJvbGU9e3VzZXJSb2xlfSAvPlxuICAgICAgPG1haW4gY2xhc3NOYW1lPVwiZmxleC0xIG92ZXJmbG93LWF1dG9cIj57Y2hpbGRyZW59PC9tYWluPlxuICAgICAgey8qIFNPUyBCdXR0b24gZm9yIFJpZGVycyBhbmQgRHJpdmVycyAqL31cbiAgICAgIHsodXNlclJvbGUgPT09IFwiUklERVJcIiB8fCB1c2VyUm9sZSA9PT0gXCJEUklWRVJcIikgJiYgPFNPU0J1dHRvbiAvPn1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJTaWRlYmFyIiwiU09TQnV0dG9uIiwiQXBwTGF5b3V0IiwiY2hpbGRyZW4iLCJ1c2VyUm9sZSIsImRpdiIsImNsYXNzTmFtZSIsIm1haW4iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/AppLayout.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/ChatWidget.tsx":
/*!***********************************!*\
  !*** ./components/ChatWidget.tsx ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ChatWidget)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_realtime_ably__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/realtime/ably */ \"(app-pages-browser)/./lib/realtime/ably.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction ChatWidget(param) {\n    let { bookingId, sender } = param;\n    _s();\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [realtimeEnabled, setRealtimeEnabled] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const endRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const pollingIntervalRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Fetch initial messages\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ChatWidget.useEffect\": ()=>{\n            let mounted = true;\n            ({\n                \"ChatWidget.useEffect\": async ()=>{\n                    try {\n                        const res = await fetch(\"/api/bookings/\".concat(bookingId, \"/messages\"));\n                        if (res.ok && mounted) {\n                            const data = await res.json();\n                            setMessages(data);\n                        }\n                    } catch (error) {\n                        console.error(\"Failed to load messages:\", error);\n                    } finally{\n                        if (mounted) setLoading(false);\n                    }\n                }\n            })[\"ChatWidget.useEffect\"]();\n            return ({\n                \"ChatWidget.useEffect\": ()=>{\n                    mounted = false;\n                }\n            })[\"ChatWidget.useEffect\"];\n        }\n    }[\"ChatWidget.useEffect\"], [\n        bookingId\n    ]);\n    // Set up Ably subscription OR polling fallback\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ChatWidget.useEffect\": ()=>{\n            let ch = null;\n            let subscribed = false;\n            const handler = {\n                \"ChatWidget.useEffect.handler\": (msg)=>{\n                    if (msg.name === \"message\") {\n                        setMessages({\n                            \"ChatWidget.useEffect.handler\": (prev)=>{\n                                // Avoid duplicates - check by ID\n                                const exists = prev.some({\n                                    \"ChatWidget.useEffect.handler.exists\": (m)=>m.id === msg.data.id\n                                }[\"ChatWidget.useEffect.handler.exists\"]);\n                                if (exists) return prev;\n                                // Also check if this might replace a temp message with same text\n                                const tempIndex = prev.findIndex({\n                                    \"ChatWidget.useEffect.handler.tempIndex\": (m)=>m.id.startsWith(\"temp-\") && m.text === msg.data.text && m.sender === msg.data.sender\n                                }[\"ChatWidget.useEffect.handler.tempIndex\"]);\n                                if (tempIndex !== -1) {\n                                    // Replace the temp message with the real one\n                                    const newMessages = [\n                                        ...prev\n                                    ];\n                                    newMessages[tempIndex] = msg.data;\n                                    return newMessages;\n                                }\n                                return [\n                                    ...prev,\n                                    msg.data\n                                ];\n                            }\n                        }[\"ChatWidget.useEffect.handler\"]);\n                    }\n                }\n            }[\"ChatWidget.useEffect.handler\"];\n            try {\n                ch = (0,_lib_realtime_ably__WEBPACK_IMPORTED_MODULE_2__.getChannel)(\"booking:\".concat(bookingId));\n                // Safe subscription with error handling - check if it's not a mock\n                if (ch && !ch.isMock && typeof ch.subscribe === \"function\") {\n                    ch.subscribe(handler);\n                    subscribed = true;\n                    setRealtimeEnabled(true);\n                }\n            } catch (error) {\n                console.warn(\"Ably subscription failed, falling back to polling\");\n                setRealtimeEnabled(false);\n            }\n            // If Ably didn't work, use polling as fallback\n            if (!subscribed) {\n                pollingIntervalRef.current = setInterval({\n                    \"ChatWidget.useEffect\": async ()=>{\n                        try {\n                            const res = await fetch(\"/api/bookings/\".concat(bookingId, \"/messages\"));\n                            if (res.ok) {\n                                const data = await res.json();\n                                setMessages(data);\n                            }\n                        } catch (error) {\n                            console.error(\"Polling error:\", error);\n                        }\n                    }\n                }[\"ChatWidget.useEffect\"], 3000); // Poll every 3 seconds\n            }\n            return ({\n                \"ChatWidget.useEffect\": ()=>{\n                    try {\n                        // Clear polling interval\n                        if (pollingIntervalRef.current) {\n                            clearInterval(pollingIntervalRef.current);\n                            pollingIntervalRef.current = null;\n                        }\n                        // Safe unsubscription\n                        if (subscribed && ch && typeof ch.unsubscribe === \"function\") {\n                            ch.unsubscribe(handler);\n                        }\n                    } catch (error) {\n                        console.warn(\"Cleanup error (ignoring):\", error);\n                    }\n                }\n            })[\"ChatWidget.useEffect\"];\n        }\n    }[\"ChatWidget.useEffect\"], [\n        bookingId\n    ]);\n    // Auto-scroll to bottom when new messages arrive\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ChatWidget.useEffect\": ()=>{\n            var _endRef_current;\n            (_endRef_current = endRef.current) === null || _endRef_current === void 0 ? void 0 : _endRef_current.scrollIntoView({\n                behavior: \"smooth\"\n            });\n        }\n    }[\"ChatWidget.useEffect\"], [\n        messages.length\n    ]);\n    const send = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatWidget.useCallback[send]\": async ()=>{\n            if (!input.trim()) return;\n            const messageText = input.trim();\n            setInput(\"\"); // Clear input immediately for better UX\n            // Optimistic update - add message immediately to UI\n            const tempMessage = {\n                id: \"temp-\".concat(Date.now()),\n                bookingId,\n                sender,\n                text: messageText,\n                createdAt: new Date().toISOString()\n            };\n            setMessages({\n                \"ChatWidget.useCallback[send]\": (prev)=>[\n                        ...prev,\n                        tempMessage\n                    ]\n            }[\"ChatWidget.useCallback[send]\"]);\n            try {\n                const res = await fetch(\"/api/bookings/\".concat(bookingId, \"/messages\"), {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        sender,\n                        text: messageText\n                    })\n                });\n                if (res.ok) {\n                    // Get the actual message from server\n                    const actualMessage = await res.json();\n                    // Replace temp message with real one\n                    setMessages({\n                        \"ChatWidget.useCallback[send]\": (prev)=>prev.map({\n                                \"ChatWidget.useCallback[send]\": (m)=>m.id === tempMessage.id ? actualMessage : m\n                            }[\"ChatWidget.useCallback[send]\"])\n                    }[\"ChatWidget.useCallback[send]\"]);\n                } else {\n                    // If failed, remove the optimistic message and restore input\n                    setMessages({\n                        \"ChatWidget.useCallback[send]\": (prev)=>prev.filter({\n                                \"ChatWidget.useCallback[send]\": (m)=>m.id !== tempMessage.id\n                            }[\"ChatWidget.useCallback[send]\"])\n                    }[\"ChatWidget.useCallback[send]\"]);\n                    setInput(messageText);\n                    console.error(\"Failed to send message\");\n                }\n            } catch (error) {\n                // If failed, remove the optimistic message and restore input\n                setMessages({\n                    \"ChatWidget.useCallback[send]\": (prev)=>prev.filter({\n                            \"ChatWidget.useCallback[send]\": (m)=>m.id !== tempMessage.id\n                        }[\"ChatWidget.useCallback[send]\"])\n                }[\"ChatWidget.useCallback[send]\"]);\n                setInput(messageText);\n                console.error(\"Error sending message:\", error);\n            }\n        }\n    }[\"ChatWidget.useCallback[send]\"], [\n        input,\n        bookingId,\n        sender\n    ]);\n    const handleKeyPress = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatWidget.useCallback[handleKeyPress]\": (e)=>{\n            if (e.key === \"Enter\" && !e.shiftKey) {\n                e.preventDefault();\n                send();\n            }\n        }\n    }[\"ChatWidget.useCallback[handleKeyPress]\"], [\n        send\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"border rounded-lg flex flex-col h-80\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"p-2 border-b font-semibold bg-gray-50 flex items-center justify-between\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        children: \"Chat\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/ChatWidget.tsx\",\n                        lineNumber: 193,\n                        columnNumber: 9\n                    }, this),\n                    !realtimeEnabled && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text-xs text-gray-500\",\n                        children: \"(polling mode)\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/ChatWidget.tsx\",\n                        lineNumber: 195,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/ChatWidget.tsx\",\n                lineNumber: 192,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex-1 overflow-auto p-2 space-y-1 text-sm\",\n                children: [\n                    loading ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-center text-gray-500 py-4\",\n                        children: \"Loading messages...\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/ChatWidget.tsx\",\n                        lineNumber: 200,\n                        columnNumber: 11\n                    }, this) : messages.length === 0 ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-center text-gray-500 py-4\",\n                        children: \"No messages yet. Start the conversation!\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/ChatWidget.tsx\",\n                        lineNumber: 204,\n                        columnNumber: 11\n                    }, this) : messages.map((m)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: m.sender === \"RIDER\" ? \"text-blue-700\" : m.sender === \"DRIVER\" ? \"text-green-700\" : \"text-gray-800\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"font-semibold mr-1\",\n                                    children: [\n                                        m.sender,\n                                        \":\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/ChatWidget.tsx\",\n                                    lineNumber: 219,\n                                    columnNumber: 15\n                                }, this),\n                                m.text\n                            ]\n                        }, m.id, true, {\n                            fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/ChatWidget.tsx\",\n                            lineNumber: 209,\n                            columnNumber: 13\n                        }, this)),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        ref: endRef\n                    }, void 0, false, {\n                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/ChatWidget.tsx\",\n                        lineNumber: 224,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/ChatWidget.tsx\",\n                lineNumber: 198,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"p-2 flex gap-2 border-t bg-gray-50\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        value: input,\n                        onChange: (e)=>setInput(e.target.value),\n                        onKeyPress: handleKeyPress,\n                        className: \"border rounded px-2 py-1 flex-1 focus:outline-none focus:ring-2 focus:ring-blue-500\",\n                        placeholder: \"Type a message…\",\n                        autoComplete: \"off\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/ChatWidget.tsx\",\n                        lineNumber: 227,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: send,\n                        disabled: !input.trim(),\n                        className: \"px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed\",\n                        children: \"Send\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/ChatWidget.tsx\",\n                        lineNumber: 235,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/ChatWidget.tsx\",\n                lineNumber: 226,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/ChatWidget.tsx\",\n        lineNumber: 191,\n        columnNumber: 5\n    }, this);\n}\n_s(ChatWidget, \"q4tS4J/Pf1OHGKGFWByLkOQo14Q=\");\n_c = ChatWidget;\nvar _c;\n$RefreshReg$(_c, \"ChatWidget\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvQ2hhdFdpZGdldC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUNpRTtBQUNoQjtBQVVsQyxTQUFTSyxXQUFXLEtBTWxDO1FBTmtDLEVBQ2pDQyxTQUFTLEVBQ1RDLE1BQU0sRUFJUCxHQU5rQzs7SUFPakMsTUFBTSxDQUFDQyxVQUFVQyxZQUFZLEdBQUdQLCtDQUFRQSxDQUFZLEVBQUU7SUFDdEQsTUFBTSxDQUFDUSxPQUFPQyxTQUFTLEdBQUdULCtDQUFRQSxDQUFDO0lBQ25DLE1BQU0sQ0FBQ1UsU0FBU0MsV0FBVyxHQUFHWCwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNZLGlCQUFpQkMsbUJBQW1CLEdBQUdiLCtDQUFRQSxDQUFDO0lBQ3ZELE1BQU1jLFNBQVNmLDZDQUFNQSxDQUF3QjtJQUM3QyxNQUFNZ0IscUJBQXFCaEIsNkNBQU1BLENBQXdCO0lBRXpELHlCQUF5QjtJQUN6QkQsZ0RBQVNBO2dDQUFDO1lBQ1IsSUFBSWtCLFVBQVU7WUFFZDt3Q0FBQztvQkFDQyxJQUFJO3dCQUNGLE1BQU1DLE1BQU0sTUFBTUMsTUFBTSxpQkFBMkIsT0FBVmQsV0FBVTt3QkFDbkQsSUFBSWEsSUFBSUUsRUFBRSxJQUFJSCxTQUFTOzRCQUNyQixNQUFNSSxPQUFPLE1BQU1ILElBQUlJLElBQUk7NEJBQzNCZCxZQUFZYTt3QkFDZDtvQkFDRixFQUFFLE9BQU9FLE9BQU87d0JBQ2RDLFFBQVFELEtBQUssQ0FBQyw0QkFBNEJBO29CQUM1QyxTQUFVO3dCQUNSLElBQUlOLFNBQVNMLFdBQVc7b0JBQzFCO2dCQUNGOztZQUVBO3dDQUFPO29CQUNMSyxVQUFVO2dCQUNaOztRQUNGOytCQUFHO1FBQUNaO0tBQVU7SUFFZCwrQ0FBK0M7SUFDL0NOLGdEQUFTQTtnQ0FBQztZQUNSLElBQUkwQixLQUFVO1lBQ2QsSUFBSUMsYUFBYTtZQUVqQixNQUFNQztnREFBVSxDQUFDQztvQkFDZixJQUFJQSxJQUFJQyxJQUFJLEtBQUssV0FBVzt3QkFDMUJyQjs0REFBWSxDQUFDc0I7Z0NBQ1gsaUNBQWlDO2dDQUNqQyxNQUFNQyxTQUFTRCxLQUFLRSxJQUFJOzJFQUFDLENBQUNDLElBQU1BLEVBQUVDLEVBQUUsS0FBS04sSUFBSVAsSUFBSSxDQUFDYSxFQUFFOztnQ0FDcEQsSUFBSUgsUUFBUSxPQUFPRDtnQ0FFbkIsaUVBQWlFO2dDQUNqRSxNQUFNSyxZQUFZTCxLQUFLTSxTQUFTOzhFQUM5QixDQUFDSCxJQUNDQSxFQUFFQyxFQUFFLENBQUNHLFVBQVUsQ0FBQyxZQUNoQkosRUFBRUssSUFBSSxLQUFLVixJQUFJUCxJQUFJLENBQUNpQixJQUFJLElBQ3hCTCxFQUFFM0IsTUFBTSxLQUFLc0IsSUFBSVAsSUFBSSxDQUFDZixNQUFNOztnQ0FHaEMsSUFBSTZCLGNBQWMsQ0FBQyxHQUFHO29DQUNwQiw2Q0FBNkM7b0NBQzdDLE1BQU1JLGNBQWM7MkNBQUlUO3FDQUFLO29DQUM3QlMsV0FBVyxDQUFDSixVQUFVLEdBQUdQLElBQUlQLElBQUk7b0NBQ2pDLE9BQU9rQjtnQ0FDVDtnQ0FFQSxPQUFPO3VDQUFJVDtvQ0FBTUYsSUFBSVAsSUFBSTtpQ0FBQzs0QkFDNUI7O29CQUNGO2dCQUNGOztZQUVBLElBQUk7Z0JBQ0ZJLEtBQUt0Qiw4REFBVUEsQ0FBQyxXQUFxQixPQUFWRTtnQkFFM0IsbUVBQW1FO2dCQUNuRSxJQUFJb0IsTUFBTSxDQUFDQSxHQUFHZSxNQUFNLElBQUksT0FBT2YsR0FBR2dCLFNBQVMsS0FBSyxZQUFZO29CQUMxRGhCLEdBQUdnQixTQUFTLENBQUNkO29CQUNiRCxhQUFhO29CQUNiWixtQkFBbUI7Z0JBQ3JCO1lBQ0YsRUFBRSxPQUFPUyxPQUFPO2dCQUNkQyxRQUFRa0IsSUFBSSxDQUFDO2dCQUNiNUIsbUJBQW1CO1lBQ3JCO1lBRUEsK0NBQStDO1lBQy9DLElBQUksQ0FBQ1ksWUFBWTtnQkFDZlYsbUJBQW1CMkIsT0FBTyxHQUFHQzs0Q0FBWTt3QkFDdkMsSUFBSTs0QkFDRixNQUFNMUIsTUFBTSxNQUFNQyxNQUFNLGlCQUEyQixPQUFWZCxXQUFVOzRCQUNuRCxJQUFJYSxJQUFJRSxFQUFFLEVBQUU7Z0NBQ1YsTUFBTUMsT0FBTyxNQUFNSCxJQUFJSSxJQUFJO2dDQUMzQmQsWUFBWWE7NEJBQ2Q7d0JBQ0YsRUFBRSxPQUFPRSxPQUFPOzRCQUNkQyxRQUFRRCxLQUFLLENBQUMsa0JBQWtCQTt3QkFDbEM7b0JBQ0Y7MkNBQUcsT0FBTyx1QkFBdUI7WUFDbkM7WUFFQTt3Q0FBTztvQkFDTCxJQUFJO3dCQUNGLHlCQUF5Qjt3QkFDekIsSUFBSVAsbUJBQW1CMkIsT0FBTyxFQUFFOzRCQUM5QkUsY0FBYzdCLG1CQUFtQjJCLE9BQU87NEJBQ3hDM0IsbUJBQW1CMkIsT0FBTyxHQUFHO3dCQUMvQjt3QkFFQSxzQkFBc0I7d0JBQ3RCLElBQUlqQixjQUFjRCxNQUFNLE9BQU9BLEdBQUdxQixXQUFXLEtBQUssWUFBWTs0QkFDNURyQixHQUFHcUIsV0FBVyxDQUFDbkI7d0JBQ2pCO29CQUNGLEVBQUUsT0FBT0osT0FBTzt3QkFDZEMsUUFBUWtCLElBQUksQ0FBQyw2QkFBNkJuQjtvQkFDNUM7Z0JBQ0Y7O1FBQ0Y7K0JBQUc7UUFBQ2xCO0tBQVU7SUFFZCxpREFBaUQ7SUFDakROLGdEQUFTQTtnQ0FBQztnQkFDUmdCO2FBQUFBLGtCQUFBQSxPQUFPNEIsT0FBTyxjQUFkNUIsc0NBQUFBLGdCQUFnQmdDLGNBQWMsQ0FBQztnQkFBRUMsVUFBVTtZQUFTO1FBQ3REOytCQUFHO1FBQUN6QyxTQUFTMEMsTUFBTTtLQUFDO0lBRXBCLE1BQU1DLE9BQU9oRCxrREFBV0E7d0NBQUM7WUFDdkIsSUFBSSxDQUFDTyxNQUFNMEMsSUFBSSxJQUFJO1lBRW5CLE1BQU1DLGNBQWMzQyxNQUFNMEMsSUFBSTtZQUM5QnpDLFNBQVMsS0FBSyx3Q0FBd0M7WUFFdEQsb0RBQW9EO1lBQ3BELE1BQU0yQyxjQUF1QjtnQkFDM0JuQixJQUFJLFFBQW1CLE9BQVhvQixLQUFLQyxHQUFHO2dCQUNwQmxEO2dCQUNBQztnQkFDQWdDLE1BQU1jO2dCQUNOSSxXQUFXLElBQUlGLE9BQU9HLFdBQVc7WUFDbkM7WUFFQWpEO2dEQUFZLENBQUNzQixPQUFTOzJCQUFJQTt3QkFBTXVCO3FCQUFZOztZQUU1QyxJQUFJO2dCQUNGLE1BQU1uQyxNQUFNLE1BQU1DLE1BQU0saUJBQTJCLE9BQVZkLFdBQVUsY0FBWTtvQkFDN0RxRCxRQUFRO29CQUNSQyxTQUFTO3dCQUFFLGdCQUFnQjtvQkFBbUI7b0JBQzlDQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7d0JBQUV4RDt3QkFBUWdDLE1BQU1jO29CQUFZO2dCQUNuRDtnQkFFQSxJQUFJbEMsSUFBSUUsRUFBRSxFQUFFO29CQUNWLHFDQUFxQztvQkFDckMsTUFBTTJDLGdCQUFnQixNQUFNN0MsSUFBSUksSUFBSTtvQkFFcEMscUNBQXFDO29CQUNyQ2Q7d0RBQVksQ0FBQ3NCLE9BQ1hBLEtBQUtrQyxHQUFHO2dFQUFDLENBQUMvQixJQUFPQSxFQUFFQyxFQUFFLEtBQUttQixZQUFZbkIsRUFBRSxHQUFHNkIsZ0JBQWdCOUI7OztnQkFFL0QsT0FBTztvQkFDTCw2REFBNkQ7b0JBQzdEekI7d0RBQVksQ0FBQ3NCLE9BQVNBLEtBQUttQyxNQUFNO2dFQUFDLENBQUNoQyxJQUFNQSxFQUFFQyxFQUFFLEtBQUttQixZQUFZbkIsRUFBRTs7O29CQUNoRXhCLFNBQVMwQztvQkFDVDVCLFFBQVFELEtBQUssQ0FBQztnQkFDaEI7WUFDRixFQUFFLE9BQU9BLE9BQU87Z0JBQ2QsNkRBQTZEO2dCQUM3RGY7b0RBQVksQ0FBQ3NCLE9BQVNBLEtBQUttQyxNQUFNOzREQUFDLENBQUNoQyxJQUFNQSxFQUFFQyxFQUFFLEtBQUttQixZQUFZbkIsRUFBRTs7O2dCQUNoRXhCLFNBQVMwQztnQkFDVDVCLFFBQVFELEtBQUssQ0FBQywwQkFBMEJBO1lBQzFDO1FBQ0Y7dUNBQUc7UUFBQ2Q7UUFBT0o7UUFBV0M7S0FBTztJQUU3QixNQUFNNEQsaUJBQWlCaEUsa0RBQVdBO2tEQUNoQyxDQUFDaUU7WUFDQyxJQUFJQSxFQUFFQyxHQUFHLEtBQUssV0FBVyxDQUFDRCxFQUFFRSxRQUFRLEVBQUU7Z0JBQ3BDRixFQUFFRyxjQUFjO2dCQUNoQnBCO1lBQ0Y7UUFDRjtpREFDQTtRQUFDQTtLQUFLO0lBR1IscUJBQ0UsOERBQUNxQjtRQUFJQyxXQUFVOzswQkFDYiw4REFBQ0Q7Z0JBQUlDLFdBQVU7O2tDQUNiLDhEQUFDQztrQ0FBSzs7Ozs7O29CQUNMLENBQUM1RCxpQ0FDQSw4REFBQzREO3dCQUFLRCxXQUFVO2tDQUF3Qjs7Ozs7Ozs7Ozs7OzBCQUc1Qyw4REFBQ0Q7Z0JBQUlDLFdBQVU7O29CQUNaN0Qsd0JBQ0MsOERBQUM0RDt3QkFBSUMsV0FBVTtrQ0FBaUM7Ozs7OytCQUc5Q2pFLFNBQVMwQyxNQUFNLEtBQUssa0JBQ3RCLDhEQUFDc0I7d0JBQUlDLFdBQVU7a0NBQWlDOzs7OzsrQkFJaERqRSxTQUFTeUQsR0FBRyxDQUFDLENBQUMvQixrQkFDWiw4REFBQ3NDOzRCQUVDQyxXQUNFdkMsRUFBRTNCLE1BQU0sS0FBSyxVQUNULGtCQUNBMkIsRUFBRTNCLE1BQU0sS0FBSyxXQUNiLG1CQUNBOzs4Q0FHTiw4REFBQ21FO29DQUFLRCxXQUFVOzt3Q0FBc0J2QyxFQUFFM0IsTUFBTTt3Q0FBQzs7Ozs7OztnQ0FDOUMyQixFQUFFSyxJQUFJOzsyQkFWRkwsRUFBRUMsRUFBRTs7Ozs7a0NBY2YsOERBQUNxQzt3QkFBSUcsS0FBSzNEOzs7Ozs7Ozs7Ozs7MEJBRVosOERBQUN3RDtnQkFBSUMsV0FBVTs7a0NBQ2IsOERBQUMvRDt3QkFDQ2tFLE9BQU9sRTt3QkFDUG1FLFVBQVUsQ0FBQ1QsSUFBTXpELFNBQVN5RCxFQUFFVSxNQUFNLENBQUNGLEtBQUs7d0JBQ3hDRyxZQUFZWjt3QkFDWk0sV0FBVTt3QkFDVk8sYUFBWTt3QkFDWkMsY0FBYTs7Ozs7O2tDQUVmLDhEQUFDQzt3QkFDQ0MsU0FBU2hDO3dCQUNUaUMsVUFBVSxDQUFDMUUsTUFBTTBDLElBQUk7d0JBQ3JCcUIsV0FBVTtrQ0FDWDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTVQ7R0F4T3dCcEU7S0FBQUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL2NvbXBvbmVudHMvQ2hhdFdpZGdldC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBnZXRDaGFubmVsIH0gZnJvbSBcIkAvbGliL3JlYWx0aW1lL2FibHlcIjtcblxudHlwZSBNZXNzYWdlID0ge1xuICBpZDogc3RyaW5nO1xuICBib29raW5nSWQ6IHN0cmluZztcbiAgc2VuZGVyOiBcIlJJREVSXCIgfCBcIkRSSVZFUlwiIHwgXCJESVNQQVRDSEVSXCI7XG4gIHRleHQ6IHN0cmluZztcbiAgY3JlYXRlZEF0OiBzdHJpbmc7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDaGF0V2lkZ2V0KHtcbiAgYm9va2luZ0lkLFxuICBzZW5kZXIsXG59OiB7XG4gIGJvb2tpbmdJZDogc3RyaW5nO1xuICBzZW5kZXI6IFwiUklERVJcIiB8IFwiRFJJVkVSXCIgfCBcIkRJU1BBVENIRVJcIjtcbn0pIHtcbiAgY29uc3QgW21lc3NhZ2VzLCBzZXRNZXNzYWdlc10gPSB1c2VTdGF0ZTxNZXNzYWdlW10+KFtdKTtcbiAgY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZShcIlwiKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtyZWFsdGltZUVuYWJsZWQsIHNldFJlYWx0aW1lRW5hYmxlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IGVuZFJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBwb2xsaW5nSW50ZXJ2YWxSZWYgPSB1c2VSZWY8Tm9kZUpTLlRpbWVvdXQgfCBudWxsPihudWxsKTtcblxuICAvLyBGZXRjaCBpbml0aWFsIG1lc3NhZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IG1vdW50ZWQgPSB0cnVlO1xuXG4gICAgKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAvYXBpL2Jvb2tpbmdzLyR7Ym9va2luZ0lkfS9tZXNzYWdlc2ApO1xuICAgICAgICBpZiAocmVzLm9rICYmIG1vdW50ZWQpIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgICBzZXRNZXNzYWdlcyhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBsb2FkIG1lc3NhZ2VzOlwiLCBlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAobW91bnRlZCkgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSkoKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBtb3VudGVkID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW2Jvb2tpbmdJZF0pO1xuXG4gIC8vIFNldCB1cCBBYmx5IHN1YnNjcmlwdGlvbiBPUiBwb2xsaW5nIGZhbGxiYWNrXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGNoOiBhbnkgPSBudWxsO1xuICAgIGxldCBzdWJzY3JpYmVkID0gZmFsc2U7XG5cbiAgICBjb25zdCBoYW5kbGVyID0gKG1zZzogYW55KSA9PiB7XG4gICAgICBpZiAobXNnLm5hbWUgPT09IFwibWVzc2FnZVwiKSB7XG4gICAgICAgIHNldE1lc3NhZ2VzKChwcmV2KSA9PiB7XG4gICAgICAgICAgLy8gQXZvaWQgZHVwbGljYXRlcyAtIGNoZWNrIGJ5IElEXG4gICAgICAgICAgY29uc3QgZXhpc3RzID0gcHJldi5zb21lKChtKSA9PiBtLmlkID09PSBtc2cuZGF0YS5pZCk7XG4gICAgICAgICAgaWYgKGV4aXN0cykgcmV0dXJuIHByZXY7XG5cbiAgICAgICAgICAvLyBBbHNvIGNoZWNrIGlmIHRoaXMgbWlnaHQgcmVwbGFjZSBhIHRlbXAgbWVzc2FnZSB3aXRoIHNhbWUgdGV4dFxuICAgICAgICAgIGNvbnN0IHRlbXBJbmRleCA9IHByZXYuZmluZEluZGV4KFxuICAgICAgICAgICAgKG0pID0+XG4gICAgICAgICAgICAgIG0uaWQuc3RhcnRzV2l0aChcInRlbXAtXCIpICYmXG4gICAgICAgICAgICAgIG0udGV4dCA9PT0gbXNnLmRhdGEudGV4dCAmJlxuICAgICAgICAgICAgICBtLnNlbmRlciA9PT0gbXNnLmRhdGEuc2VuZGVyXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmICh0ZW1wSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSB0ZW1wIG1lc3NhZ2Ugd2l0aCB0aGUgcmVhbCBvbmVcbiAgICAgICAgICAgIGNvbnN0IG5ld01lc3NhZ2VzID0gWy4uLnByZXZdO1xuICAgICAgICAgICAgbmV3TWVzc2FnZXNbdGVtcEluZGV4XSA9IG1zZy5kYXRhO1xuICAgICAgICAgICAgcmV0dXJuIG5ld01lc3NhZ2VzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbLi4ucHJldiwgbXNnLmRhdGFdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGNoID0gZ2V0Q2hhbm5lbChgYm9va2luZzoke2Jvb2tpbmdJZH1gKTtcblxuICAgICAgLy8gU2FmZSBzdWJzY3JpcHRpb24gd2l0aCBlcnJvciBoYW5kbGluZyAtIGNoZWNrIGlmIGl0J3Mgbm90IGEgbW9ja1xuICAgICAgaWYgKGNoICYmICFjaC5pc01vY2sgJiYgdHlwZW9mIGNoLnN1YnNjcmliZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNoLnN1YnNjcmliZShoYW5kbGVyKTtcbiAgICAgICAgc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgIHNldFJlYWx0aW1lRW5hYmxlZCh0cnVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKFwiQWJseSBzdWJzY3JpcHRpb24gZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gcG9sbGluZ1wiKTtcbiAgICAgIHNldFJlYWx0aW1lRW5hYmxlZChmYWxzZSk7XG4gICAgfVxuXG4gICAgLy8gSWYgQWJseSBkaWRuJ3Qgd29yaywgdXNlIHBvbGxpbmcgYXMgZmFsbGJhY2tcbiAgICBpZiAoIXN1YnNjcmliZWQpIHtcbiAgICAgIHBvbGxpbmdJbnRlcnZhbFJlZi5jdXJyZW50ID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAvYXBpL2Jvb2tpbmdzLyR7Ym9va2luZ0lkfS9tZXNzYWdlc2ApO1xuICAgICAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgICAgICAgc2V0TWVzc2FnZXMoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQb2xsaW5nIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0sIDMwMDApOyAvLyBQb2xsIGV2ZXJ5IDMgc2Vjb25kc1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBDbGVhciBwb2xsaW5nIGludGVydmFsXG4gICAgICAgIGlmIChwb2xsaW5nSW50ZXJ2YWxSZWYuY3VycmVudCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwocG9sbGluZ0ludGVydmFsUmVmLmN1cnJlbnQpO1xuICAgICAgICAgIHBvbGxpbmdJbnRlcnZhbFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNhZmUgdW5zdWJzY3JpcHRpb25cbiAgICAgICAgaWYgKHN1YnNjcmliZWQgJiYgY2ggJiYgdHlwZW9mIGNoLnVuc3Vic2NyaWJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjaC51bnN1YnNjcmliZShoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiQ2xlYW51cCBlcnJvciAoaWdub3JpbmcpOlwiLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2Jvb2tpbmdJZF0pO1xuXG4gIC8vIEF1dG8tc2Nyb2xsIHRvIGJvdHRvbSB3aGVuIG5ldyBtZXNzYWdlcyBhcnJpdmVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBlbmRSZWYuY3VycmVudD8uc2Nyb2xsSW50b1ZpZXcoeyBiZWhhdmlvcjogXCJzbW9vdGhcIiB9KTtcbiAgfSwgW21lc3NhZ2VzLmxlbmd0aF0pO1xuXG4gIGNvbnN0IHNlbmQgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFpbnB1dC50cmltKCkpIHJldHVybjtcblxuICAgIGNvbnN0IG1lc3NhZ2VUZXh0ID0gaW5wdXQudHJpbSgpO1xuICAgIHNldElucHV0KFwiXCIpOyAvLyBDbGVhciBpbnB1dCBpbW1lZGlhdGVseSBmb3IgYmV0dGVyIFVYXG5cbiAgICAvLyBPcHRpbWlzdGljIHVwZGF0ZSAtIGFkZCBtZXNzYWdlIGltbWVkaWF0ZWx5IHRvIFVJXG4gICAgY29uc3QgdGVtcE1lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICBpZDogYHRlbXAtJHtEYXRlLm5vdygpfWAsXG4gICAgICBib29raW5nSWQsXG4gICAgICBzZW5kZXIsXG4gICAgICB0ZXh0OiBtZXNzYWdlVGV4dCxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH07XG5cbiAgICBzZXRNZXNzYWdlcygocHJldikgPT4gWy4uLnByZXYsIHRlbXBNZXNzYWdlXSk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYC9hcGkvYm9va2luZ3MvJHtib29raW5nSWR9L21lc3NhZ2VzYCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgc2VuZGVyLCB0ZXh0OiBtZXNzYWdlVGV4dCB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgIC8vIEdldCB0aGUgYWN0dWFsIG1lc3NhZ2UgZnJvbSBzZXJ2ZXJcbiAgICAgICAgY29uc3QgYWN0dWFsTWVzc2FnZSA9IGF3YWl0IHJlcy5qc29uKCk7XG5cbiAgICAgICAgLy8gUmVwbGFjZSB0ZW1wIG1lc3NhZ2Ugd2l0aCByZWFsIG9uZVxuICAgICAgICBzZXRNZXNzYWdlcygocHJldikgPT5cbiAgICAgICAgICBwcmV2Lm1hcCgobSkgPT4gKG0uaWQgPT09IHRlbXBNZXNzYWdlLmlkID8gYWN0dWFsTWVzc2FnZSA6IG0pKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgZmFpbGVkLCByZW1vdmUgdGhlIG9wdGltaXN0aWMgbWVzc2FnZSBhbmQgcmVzdG9yZSBpbnB1dFxuICAgICAgICBzZXRNZXNzYWdlcygocHJldikgPT4gcHJldi5maWx0ZXIoKG0pID0+IG0uaWQgIT09IHRlbXBNZXNzYWdlLmlkKSk7XG4gICAgICAgIHNldElucHV0KG1lc3NhZ2VUZXh0KTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzZW5kIG1lc3NhZ2VcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElmIGZhaWxlZCwgcmVtb3ZlIHRoZSBvcHRpbWlzdGljIG1lc3NhZ2UgYW5kIHJlc3RvcmUgaW5wdXRcbiAgICAgIHNldE1lc3NhZ2VzKChwcmV2KSA9PiBwcmV2LmZpbHRlcigobSkgPT4gbS5pZCAhPT0gdGVtcE1lc3NhZ2UuaWQpKTtcbiAgICAgIHNldElucHV0KG1lc3NhZ2VUZXh0KTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzZW5kaW5nIG1lc3NhZ2U6XCIsIGVycm9yKTtcbiAgICB9XG4gIH0sIFtpbnB1dCwgYm9va2luZ0lkLCBzZW5kZXJdKTtcblxuICBjb25zdCBoYW5kbGVLZXlQcmVzcyA9IHVzZUNhbGxiYWNrKFxuICAgIChlOiBSZWFjdC5LZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICBpZiAoZS5rZXkgPT09IFwiRW50ZXJcIiAmJiAhZS5zaGlmdEtleSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHNlbmQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtzZW5kXVxuICApO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJib3JkZXIgcm91bmRlZC1sZyBmbGV4IGZsZXgtY29sIGgtODBcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicC0yIGJvcmRlci1iIGZvbnQtc2VtaWJvbGQgYmctZ3JheS01MCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW5cIj5cbiAgICAgICAgPHNwYW4+Q2hhdDwvc3Bhbj5cbiAgICAgICAgeyFyZWFsdGltZUVuYWJsZWQgJiYgKFxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC1ncmF5LTUwMFwiPihwb2xsaW5nIG1vZGUpPC9zcGFuPlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgtMSBvdmVyZmxvdy1hdXRvIHAtMiBzcGFjZS15LTEgdGV4dC1zbVwiPlxuICAgICAgICB7bG9hZGluZyA/IChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtY2VudGVyIHRleHQtZ3JheS01MDAgcHktNFwiPlxuICAgICAgICAgICAgTG9hZGluZyBtZXNzYWdlcy4uLlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApIDogbWVzc2FnZXMubGVuZ3RoID09PSAwID8gKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXIgdGV4dC1ncmF5LTUwMCBweS00XCI+XG4gICAgICAgICAgICBObyBtZXNzYWdlcyB5ZXQuIFN0YXJ0IHRoZSBjb252ZXJzYXRpb24hXG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICkgOiAoXG4gICAgICAgICAgbWVzc2FnZXMubWFwKChtKSA9PiAoXG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgIGtleT17bS5pZH1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtcbiAgICAgICAgICAgICAgICBtLnNlbmRlciA9PT0gXCJSSURFUlwiXG4gICAgICAgICAgICAgICAgICA/IFwidGV4dC1ibHVlLTcwMFwiXG4gICAgICAgICAgICAgICAgICA6IG0uc2VuZGVyID09PSBcIkRSSVZFUlwiXG4gICAgICAgICAgICAgICAgICA/IFwidGV4dC1ncmVlbi03MDBcIlxuICAgICAgICAgICAgICAgICAgOiBcInRleHQtZ3JheS04MDBcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtc2VtaWJvbGQgbXItMVwiPnttLnNlbmRlcn06PC9zcGFuPlxuICAgICAgICAgICAgICB7bS50ZXh0fVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKSlcbiAgICAgICAgKX1cbiAgICAgICAgPGRpdiByZWY9e2VuZFJlZn0gLz5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJwLTIgZmxleCBnYXAtMiBib3JkZXItdCBiZy1ncmF5LTUwXCI+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIHZhbHVlPXtpbnB1dH1cbiAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldElucHV0KGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICBvbktleVByZXNzPXtoYW5kbGVLZXlQcmVzc31cbiAgICAgICAgICBjbGFzc05hbWU9XCJib3JkZXIgcm91bmRlZCBweC0yIHB5LTEgZmxleC0xIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1ibHVlLTUwMFwiXG4gICAgICAgICAgcGxhY2Vob2xkZXI9XCJUeXBlIGEgbWVzc2FnZeKAplwiXG4gICAgICAgICAgYXV0b0NvbXBsZXRlPVwib2ZmXCJcbiAgICAgICAgLz5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIG9uQ2xpY2s9e3NlbmR9XG4gICAgICAgICAgZGlzYWJsZWQ9eyFpbnB1dC50cmltKCl9XG4gICAgICAgICAgY2xhc3NOYW1lPVwicHgtMyBweS0xIGJnLWJsdWUtNjAwIHRleHQtd2hpdGUgcm91bmRlZCBob3ZlcjpiZy1ibHVlLTcwMCB0cmFuc2l0aW9uLWNvbG9ycyBkaXNhYmxlZDpvcGFjaXR5LTUwIGRpc2FibGVkOmN1cnNvci1ub3QtYWxsb3dlZFwiXG4gICAgICAgID5cbiAgICAgICAgICBTZW5kXG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsImdldENoYW5uZWwiLCJDaGF0V2lkZ2V0IiwiYm9va2luZ0lkIiwic2VuZGVyIiwibWVzc2FnZXMiLCJzZXRNZXNzYWdlcyIsImlucHV0Iiwic2V0SW5wdXQiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsInJlYWx0aW1lRW5hYmxlZCIsInNldFJlYWx0aW1lRW5hYmxlZCIsImVuZFJlZiIsInBvbGxpbmdJbnRlcnZhbFJlZiIsIm1vdW50ZWQiLCJyZXMiLCJmZXRjaCIsIm9rIiwiZGF0YSIsImpzb24iLCJlcnJvciIsImNvbnNvbGUiLCJjaCIsInN1YnNjcmliZWQiLCJoYW5kbGVyIiwibXNnIiwibmFtZSIsInByZXYiLCJleGlzdHMiLCJzb21lIiwibSIsImlkIiwidGVtcEluZGV4IiwiZmluZEluZGV4Iiwic3RhcnRzV2l0aCIsInRleHQiLCJuZXdNZXNzYWdlcyIsImlzTW9jayIsInN1YnNjcmliZSIsIndhcm4iLCJjdXJyZW50Iiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwidW5zdWJzY3JpYmUiLCJzY3JvbGxJbnRvVmlldyIsImJlaGF2aW9yIiwibGVuZ3RoIiwic2VuZCIsInRyaW0iLCJtZXNzYWdlVGV4dCIsInRlbXBNZXNzYWdlIiwiRGF0ZSIsIm5vdyIsImNyZWF0ZWRBdCIsInRvSVNPU3RyaW5nIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiYWN0dWFsTWVzc2FnZSIsIm1hcCIsImZpbHRlciIsImhhbmRsZUtleVByZXNzIiwiZSIsImtleSIsInNoaWZ0S2V5IiwicHJldmVudERlZmF1bHQiLCJkaXYiLCJjbGFzc05hbWUiLCJzcGFuIiwicmVmIiwidmFsdWUiLCJvbkNoYW5nZSIsInRhcmdldCIsIm9uS2V5UHJlc3MiLCJwbGFjZWhvbGRlciIsImF1dG9Db21wbGV0ZSIsImJ1dHRvbiIsIm9uQ2xpY2siLCJkaXNhYmxlZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/ChatWidget.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/RideDocumentationForm.tsx":
/*!**********************************************!*\
  !*** ./components/RideDocumentationForm.tsx ***!
  \**********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RideDocumentationForm)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction RideDocumentationForm(param) {\n    let { bookingId, onSubmit, onCancel } = param;\n    _s();\n    const [formData, setFormData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        rideQuality: \"good\",\n        clientComfort: \"comfortable\",\n        accessibilityNotes: \"\",\n        issuesReported: \"\"\n    });\n    const [submitting, setSubmitting] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const handleSubmit = async (e)=>{\n        e.preventDefault();\n        setSubmitting(true);\n        try {\n            await onSubmit(formData);\n        } catch (error) {\n            console.error(\"Failed to submit documentation:\", error);\n            alert(\"Failed to submit documentation. Please try again.\");\n        } finally{\n            setSubmitting(false);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"bg-white rounded-lg p-6 max-w-2xl w-full max-h-[90vh] overflow-y-auto\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                    className: \"text-2xl font-bold mb-4\",\n                    children: \"Document Ride Completion\"\n                }, void 0, false, {\n                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                    lineNumber: 50,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    className: \"text-gray-600 mb-6\",\n                    children: \"Please provide feedback about this ride to ensure quality service.\"\n                }, void 0, false, {\n                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                    lineNumber: 51,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n                    onSubmit: handleSubmit,\n                    className: \"space-y-6\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                    className: \"block text-sm font-semibold mb-2\",\n                                    children: [\n                                        \"Overall Ride Quality \",\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"text-red-500\",\n                                            children: \"*\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                                            lineNumber: 59,\n                                            columnNumber: 36\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                                    lineNumber: 58,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"grid grid-cols-2 gap-3\",\n                                    children: [\n                                        {\n                                            value: \"excellent\",\n                                            label: \"Excellent\",\n                                            emoji: \"🌟\"\n                                        },\n                                        {\n                                            value: \"good\",\n                                            label: \"Good\",\n                                            emoji: \"👍\"\n                                        },\n                                        {\n                                            value: \"fair\",\n                                            label: \"Fair\",\n                                            emoji: \"👌\"\n                                        },\n                                        {\n                                            value: \"poor\",\n                                            label: \"Poor\",\n                                            emoji: \"👎\"\n                                        }\n                                    ].map((option)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                            className: \"flex items-center gap-2 p-3 border rounded-lg cursor-pointer transition-colors \".concat(formData.rideQuality === option.value ? \"bg-blue-50 border-blue-500\" : \"hover:bg-gray-50\"),\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                    type: \"radio\",\n                                                    name: \"rideQuality\",\n                                                    value: option.value,\n                                                    checked: formData.rideQuality === option.value,\n                                                    onChange: (e)=>setFormData({\n                                                            ...formData,\n                                                            rideQuality: e.target.value\n                                                        }),\n                                                    className: \"w-4 h-4\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                                                    lineNumber: 76,\n                                                    columnNumber: 19\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    className: \"text-xl\",\n                                                    children: option.emoji\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                                                    lineNumber: 89,\n                                                    columnNumber: 19\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    className: \"font-medium\",\n                                                    children: option.label\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                                                    lineNumber: 90,\n                                                    columnNumber: 19\n                                                }, this)\n                                            ]\n                                        }, option.value, true, {\n                                            fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                                            lineNumber: 68,\n                                            columnNumber: 17\n                                        }, this))\n                                }, void 0, false, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                                    lineNumber: 61,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                            lineNumber: 57,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                    className: \"block text-sm font-semibold mb-2\",\n                                    children: [\n                                        \"Client Comfort Level \",\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"text-red-500\",\n                                            children: \"*\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                                            lineNumber: 99,\n                                            columnNumber: 36\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                                    lineNumber: 98,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"grid grid-cols-2 gap-3\",\n                                    children: [\n                                        {\n                                            value: \"very_comfortable\",\n                                            label: \"Very Comfortable\",\n                                            emoji: \"😊\"\n                                        },\n                                        {\n                                            value: \"comfortable\",\n                                            label: \"Comfortable\",\n                                            emoji: \"🙂\"\n                                        },\n                                        {\n                                            value: \"neutral\",\n                                            label: \"Neutral\",\n                                            emoji: \"😐\"\n                                        },\n                                        {\n                                            value: \"uncomfortable\",\n                                            label: \"Uncomfortable\",\n                                            emoji: \"😟\"\n                                        }\n                                    ].map((option)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                            className: \"flex items-center gap-2 p-3 border rounded-lg cursor-pointer transition-colors \".concat(formData.clientComfort === option.value ? \"bg-green-50 border-green-500\" : \"hover:bg-gray-50\"),\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                    type: \"radio\",\n                                                    name: \"clientComfort\",\n                                                    value: option.value,\n                                                    checked: formData.clientComfort === option.value,\n                                                    onChange: (e)=>setFormData({\n                                                            ...formData,\n                                                            clientComfort: e.target.value\n                                                        }),\n                                                    className: \"w-4 h-4\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                                                    lineNumber: 120,\n                                                    columnNumber: 19\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    className: \"text-xl\",\n                                                    children: option.emoji\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                                                    lineNumber: 133,\n                                                    columnNumber: 19\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    className: \"font-medium\",\n                                                    children: option.label\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                                                    lineNumber: 134,\n                                                    columnNumber: 19\n                                                }, this)\n                                            ]\n                                        }, option.value, true, {\n                                            fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                                            lineNumber: 112,\n                                            columnNumber: 17\n                                        }, this))\n                                }, void 0, false, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                                    lineNumber: 101,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                            lineNumber: 97,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                    className: \"block text-sm font-semibold mb-2\",\n                                    children: \"Accessibility Notes\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                                    lineNumber: 142,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"textarea\", {\n                                    value: formData.accessibilityNotes,\n                                    onChange: (e)=>setFormData({\n                                            ...formData,\n                                            accessibilityNotes: e.target.value\n                                        }),\n                                    placeholder: \"Any notes about wheelchair access, mobility assistance, or other accessibility considerations...\",\n                                    className: \"w-full border rounded-lg p-3 focus:outline-none focus:ring-2 focus:ring-blue-500\",\n                                    rows: 3\n                                }, void 0, false, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                                    lineNumber: 145,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                            lineNumber: 141,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                    className: \"block text-sm font-semibold mb-2\",\n                                    children: \"Issues or Concerns\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                                    lineNumber: 158,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"textarea\", {\n                                    value: formData.issuesReported,\n                                    onChange: (e)=>setFormData({\n                                            ...formData,\n                                            issuesReported: e.target.value\n                                        }),\n                                    placeholder: \"Report any issues, concerns, or incidents during the ride (leave empty if none)...\",\n                                    className: \"w-full border rounded-lg p-3 focus:outline-none focus:ring-2 focus:ring-blue-500\",\n                                    rows: 3\n                                }, void 0, false, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                                    lineNumber: 161,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"text-xs text-gray-500 mt-1\",\n                                    children: \"This helps us maintain high quality service and address any problems.\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                                    lineNumber: 170,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                            lineNumber: 157,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex gap-3 pt-4 border-t\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    type: \"button\",\n                                    onClick: onCancel,\n                                    disabled: submitting,\n                                    className: \"flex-1 px-4 py-3 border rounded-lg font-semibold hover:bg-gray-50 transition-colors disabled:opacity-50\",\n                                    children: \"Cancel\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                                    lineNumber: 178,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    type: \"submit\",\n                                    disabled: submitting,\n                                    className: \"flex-1 px-4 py-3 bg-blue-600 text-white rounded-lg font-semibold hover:bg-blue-700 transition-colors disabled:opacity-50\",\n                                    children: submitting ? \"Submitting...\" : \"Complete Ride\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                                    lineNumber: 186,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                            lineNumber: 177,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n                    lineNumber: 55,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n            lineNumber: 49,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RideDocumentationForm.tsx\",\n        lineNumber: 48,\n        columnNumber: 5\n    }, this);\n}\n_s(RideDocumentationForm, \"89GzMIAmusVsOcM3FXGFOi83GbY=\");\n_c = RideDocumentationForm;\nvar _c;\n$RefreshReg$(_c, \"RideDocumentationForm\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvUmlkZURvY3VtZW50YXRpb25Gb3JtLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFDaUM7QUFtQmxCLFNBQVNDLHNCQUFzQixLQUlqQjtRQUppQixFQUM1Q0MsU0FBUyxFQUNUQyxRQUFRLEVBQ1JDLFFBQVEsRUFDbUIsR0FKaUI7O0lBSzVDLE1BQU0sQ0FBQ0MsVUFBVUMsWUFBWSxHQUFHTiwrQ0FBUUEsQ0FBb0I7UUFDMURPLGFBQWE7UUFDYkMsZUFBZTtRQUNmQyxvQkFBb0I7UUFDcEJDLGdCQUFnQjtJQUNsQjtJQUNBLE1BQU0sQ0FBQ0MsWUFBWUMsY0FBYyxHQUFHWiwrQ0FBUUEsQ0FBQztJQUU3QyxNQUFNYSxlQUFlLE9BQU9DO1FBQzFCQSxFQUFFQyxjQUFjO1FBQ2hCSCxjQUFjO1FBQ2QsSUFBSTtZQUNGLE1BQU1ULFNBQVNFO1FBQ2pCLEVBQUUsT0FBT1csT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsbUNBQW1DQTtZQUNqREUsTUFBTTtRQUNSLFNBQVU7WUFDUk4sY0FBYztRQUNoQjtJQUNGO0lBRUEscUJBQ0UsOERBQUNPO1FBQUlDLFdBQVU7a0JBQ2IsNEVBQUNEO1lBQUlDLFdBQVU7OzhCQUNiLDhEQUFDQztvQkFBR0QsV0FBVTs4QkFBMEI7Ozs7Ozs4QkFDeEMsOERBQUNFO29CQUFFRixXQUFVOzhCQUFxQjs7Ozs7OzhCQUlsQyw4REFBQ0c7b0JBQUtwQixVQUFVVTtvQkFBY08sV0FBVTs7c0NBRXRDLDhEQUFDRDs7OENBQ0MsOERBQUNLO29DQUFNSixXQUFVOzt3Q0FBbUM7c0RBQzdCLDhEQUFDSzs0Q0FBS0wsV0FBVTtzREFBZTs7Ozs7Ozs7Ozs7OzhDQUV0RCw4REFBQ0Q7b0NBQUlDLFdBQVU7OENBQ1o7d0NBQ0M7NENBQUVNLE9BQU87NENBQWFGLE9BQU87NENBQWFHLE9BQU87d0NBQUs7d0NBQ3REOzRDQUFFRCxPQUFPOzRDQUFRRixPQUFPOzRDQUFRRyxPQUFPO3dDQUFL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OERBQUNoQjtvQ0FBRUYsV0FBVTs4Q0FBNkI7Ozs7Ozs7Ozs7OztzQ0FPNUMsOERBQUNEOzRCQUFJQyxXQUFVOzs4Q0FDYiw4REFBQ21CO29DQUNDUixNQUFLO29DQUNMUyxTQUFTcEM7b0NBQ1RxQyxVQUFVOUI7b0NBQ1ZTLFdBQVU7OENBQ1g7Ozs7Ozs4Q0FHRCw4REFBQ21CO29DQUNDUixNQUFLO29DQUNMVSxVQUFVOUI7b0NBQ1ZTLFdBQVU7OENBRVRULGFBQWEsa0JBQWtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU85QztHQWpMd0JWO0tBQUFBIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9jb21wb25lbnRzL1JpZGVEb2N1bWVudGF0aW9uRm9ybS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuXG5pbnRlcmZhY2UgUmlkZURvY3VtZW50YXRpb25Gb3JtUHJvcHMge1xuICBib29raW5nSWQ6IHN0cmluZztcbiAgb25TdWJtaXQ6IChkYXRhOiBSaWRlRG9jdW1lbnRhdGlvbikgPT4gUHJvbWlzZTx2b2lkPjtcbiAgb25DYW5jZWw6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmlkZURvY3VtZW50YXRpb24ge1xuICByaWRlUXVhbGl0eTogXCJleGNlbGxlbnRcIiB8IFwiZ29vZFwiIHwgXCJmYWlyXCIgfCBcInBvb3JcIjtcbiAgY2xpZW50Q29tZm9ydDpcbiAgICB8IFwidmVyeV9jb21mb3J0YWJsZVwiXG4gICAgfCBcImNvbWZvcnRhYmxlXCJcbiAgICB8IFwibmV1dHJhbFwiXG4gICAgfCBcInVuY29tZm9ydGFibGVcIjtcbiAgYWNjZXNzaWJpbGl0eU5vdGVzOiBzdHJpbmc7XG4gIGlzc3Vlc1JlcG9ydGVkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJpZGVEb2N1bWVudGF0aW9uRm9ybSh7XG4gIGJvb2tpbmdJZCxcbiAgb25TdWJtaXQsXG4gIG9uQ2FuY2VsLFxufTogUmlkZURvY3VtZW50YXRpb25Gb3JtUHJvcHMpIHtcbiAgY29uc3QgW2Zvcm1EYXRhLCBzZXRGb3JtRGF0YV0gPSB1c2VTdGF0ZTxSaWRlRG9jdW1lbnRhdGlvbj4oe1xuICAgIHJpZGVRdWFsaXR5OiBcImdvb2RcIixcbiAgICBjbGllbnRDb21mb3J0OiBcImNvbWZvcnRhYmxlXCIsXG4gICAgYWNjZXNzaWJpbGl0eU5vdGVzOiBcIlwiLFxuICAgIGlzc3Vlc1JlcG9ydGVkOiBcIlwiLFxuICB9KTtcbiAgY29uc3QgW3N1Ym1pdHRpbmcsIHNldFN1Ym1pdHRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IGFzeW5jIChlOiBSZWFjdC5Gb3JtRXZlbnQpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgc2V0U3VibWl0dGluZyh0cnVlKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgb25TdWJtaXQoZm9ybURhdGEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHN1Ym1pdCBkb2N1bWVudGF0aW9uOlwiLCBlcnJvcik7XG4gICAgICBhbGVydChcIkZhaWxlZCB0byBzdWJtaXQgZG9jdW1lbnRhdGlvbi4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldFN1Ym1pdHRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZml4ZWQgaW5zZXQtMCBiZy1ibGFjayBiZy1vcGFjaXR5LTUwIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHAtNCB6LTUwXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLXdoaXRlIHJvdW5kZWQtbGcgcC02IG1heC13LTJ4bCB3LWZ1bGwgbWF4LWgtWzkwdmhdIG92ZXJmbG93LXktYXV0b1wiPlxuICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC0yeGwgZm9udC1ib2xkIG1iLTRcIj5Eb2N1bWVudCBSaWRlIENvbXBsZXRpb248L2gyPlxuICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNjAwIG1iLTZcIj5cbiAgICAgICAgICBQbGVhc2UgcHJvdmlkZSBmZWVkYmFjayBhYm91dCB0aGlzIHJpZGUgdG8gZW5zdXJlIHF1YWxpdHkgc2VydmljZS5cbiAgICAgICAgPC9wPlxuXG4gICAgICAgIDxmb3JtIG9uU3VibWl0PXtoYW5kbGVTdWJtaXR9IGNsYXNzTmFtZT1cInNwYWNlLXktNlwiPlxuICAgICAgICAgIHsvKiBSaWRlIFF1YWxpdHkgKi99XG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJibG9jayB0ZXh0LXNtIGZvbnQtc2VtaWJvbGQgbWItMlwiPlxuICAgICAgICAgICAgICBPdmVyYWxsIFJpZGUgUXVhbGl0eSA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXJlZC01MDBcIj4qPC9zcGFuPlxuICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtMiBnYXAtM1wiPlxuICAgICAgICAgICAgICB7W1xuICAgICAgICAgICAgICAgIHsgdmFsdWU6IFwiZXhjZWxsZW50XCIsIGxhYmVsOiBcIkV4Y2VsbGVudFwiLCBlbW9qaTogXCLwn4yfXCIgfSxcbiAgICAgICAgICAgICAgICB7IHZhbHVlOiBcImdvb2RcIiwgbGFiZWw6IFwiR29vZFwiLCBlbW9qaTogXCLwn5GNXCIgfSxcbiAgICAgICAgICAgICAgICB7IHZhbHVlOiBcImZhaXJcIiwgbGFiZWw6IFwiRmFpclwiLCBlbW9qaTogXCLwn5GMXCIgfSxcbiAgICAgICAgICAgICAgICB7IHZhbHVlOiBcInBvb3JcIiwgbGFiZWw6IFwiUG9vclwiLCBlbW9qaTogXCLwn5GOXCIgfSxcbiAgICAgICAgICAgICAgXS5tYXAoKG9wdGlvbikgPT4gKFxuICAgICAgICAgICAgICAgIDxsYWJlbFxuICAgICAgICAgICAgICAgICAga2V5PXtvcHRpb24udmFsdWV9XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2BmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMiBwLTMgYm9yZGVyIHJvdW5kZWQtbGcgY3Vyc29yLXBvaW50ZXIgdHJhbnNpdGlvbi1jb2xvcnMgJHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEucmlkZVF1YWxpdHkgPT09IG9wdGlvbi52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgID8gXCJiZy1ibHVlLTUwIGJvcmRlci1ibHVlLTUwMFwiXG4gICAgICAgICAgICAgICAgICAgICAgOiBcImhvdmVyOmJnLWdyYXktNTBcIlxuICAgICAgICAgICAgICAgICAgfWB9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgICAgICAgICAgIG5hbWU9XCJyaWRlUXVhbGl0eVwiXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXtvcHRpb24udmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2Zvcm1EYXRhLnJpZGVRdWFsaXR5ID09PSBvcHRpb24udmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT5cbiAgICAgICAgICAgICAgICAgICAgICBzZXRGb3JtRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5mb3JtRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZGVRdWFsaXR5OiBlLnRhcmdldC52YWx1ZSBhcyBhbnksXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LTQgaC00XCJcbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXhsXCI+e29wdGlvbi5lbW9qaX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmb250LW1lZGl1bVwiPntvcHRpb24ubGFiZWx9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICB7LyogQ2xpZW50IENvbWZvcnQgKi99XG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJibG9jayB0ZXh0LXNtIGZvbnQtc2VtaWJvbGQgbWItMlwiPlxuICAgICAgICAgICAgICBDbGllbnQgQ29tZm9ydCBMZXZlbCA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXJlZC01MDBcIj4qPC9zcGFuPlxuICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtMiBnYXAtM1wiPlxuICAgICAgICAgICAgICB7W1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBcInZlcnlfY29tZm9ydGFibGVcIixcbiAgICAgICAgICAgICAgICAgIGxhYmVsOiBcIlZlcnkgQ29tZm9ydGFibGVcIixcbiAgICAgICAgICAgICAgICAgIGVtb2ppOiBcIvCfmIpcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHsgdmFsdWU6IFwiY29tZm9ydGFibGVcIiwgbGFiZWw6IFwiQ29tZm9ydGFibGVcIiwgZW1vamk6IFwi8J+ZglwiIH0sXG4gICAgICAgICAgICAgICAgeyB2YWx1ZTogXCJuZXV0cmFsXCIsIGxhYmVsOiBcIk5ldXRyYWxcIiwgZW1vamk6IFwi8J+YkFwiIH0sXG4gICAgICAgICAgICAgICAgeyB2YWx1ZTogXCJ1bmNvbWZvcnRhYmxlXCIsIGxhYmVsOiBcIlVuY29tZm9ydGFibGVcIiwgZW1vamk6IFwi8J+Yn1wiIH0sXG4gICAgICAgICAgICAgIF0ubWFwKChvcHRpb24pID0+IChcbiAgICAgICAgICAgICAgICA8bGFiZWxcbiAgICAgICAgICAgICAgICAgIGtleT17b3B0aW9uLnZhbHVlfVxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTIgcC0zIGJvcmRlciByb3VuZGVkLWxnIGN1cnNvci1wb2ludGVyIHRyYW5zaXRpb24tY29sb3JzICR7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmNsaWVudENvbWZvcnQgPT09IG9wdGlvbi52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgID8gXCJiZy1ncmVlbi01MCBib3JkZXItZ3JlZW4tNTAwXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IFwiaG92ZXI6YmctZ3JheS01MFwiXG4gICAgICAgICAgICAgICAgICB9YH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cInJhZGlvXCJcbiAgICAgICAgICAgICAgICAgICAgbmFtZT1cImNsaWVudENvbWZvcnRcIlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17b3B0aW9uLnZhbHVlfVxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXtmb3JtRGF0YS5jbGllbnRDb21mb3J0ID09PSBvcHRpb24udmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT5cbiAgICAgICAgICAgICAgICAgICAgICBzZXRGb3JtRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5mb3JtRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudENvbWZvcnQ6IGUudGFyZ2V0LnZhbHVlIGFzIGFueSxcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctNCBoLTRcIlxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQteGxcIj57b3B0aW9uLmVtb2ppfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtbWVkaXVtXCI+e29wdGlvbi5sYWJlbH08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIHsvKiBBY2Nlc3NpYmlsaXR5IE5vdGVzICovfVxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwiYmxvY2sgdGV4dC1zbSBmb250LXNlbWlib2xkIG1iLTJcIj5cbiAgICAgICAgICAgICAgQWNjZXNzaWJpbGl0eSBOb3Rlc1xuICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgIDx0ZXh0YXJlYVxuICAgICAgICAgICAgICB2YWx1ZT17Zm9ybURhdGEuYWNjZXNzaWJpbGl0eU5vdGVzfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+XG4gICAgICAgICAgICAgICAgc2V0Rm9ybURhdGEoeyAuLi5mb3JtRGF0YSwgYWNjZXNzaWJpbGl0eU5vdGVzOiBlLnRhcmdldC52YWx1ZSB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiQW55IG5vdGVzIGFib3V0IHdoZWVsY2hhaXIgYWNjZXNzLCBtb2JpbGl0eSBhc3Npc3RhbmNlLCBvciBvdGhlciBhY2Nlc3NpYmlsaXR5IGNvbnNpZGVyYXRpb25zLi4uXCJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsIGJvcmRlciByb3VuZGVkLWxnIHAtMyBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctYmx1ZS01MDBcIlxuICAgICAgICAgICAgICByb3dzPXszfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIHsvKiBJc3N1ZXMgUmVwb3J0ZWQgKi99XG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJibG9jayB0ZXh0LXNtIGZvbnQtc2VtaWJvbGQgbWItMlwiPlxuICAgICAgICAgICAgICBJc3N1ZXMgb3IgQ29uY2VybnNcbiAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICA8dGV4dGFyZWFcbiAgICAgICAgICAgICAgdmFsdWU9e2Zvcm1EYXRhLmlzc3Vlc1JlcG9ydGVkfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+XG4gICAgICAgICAgICAgICAgc2V0Rm9ybURhdGEoeyAuLi5mb3JtRGF0YSwgaXNzdWVzUmVwb3J0ZWQ6IGUudGFyZ2V0LnZhbHVlIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJSZXBvcnQgYW55IGlzc3VlcywgY29uY2VybnMsIG9yIGluY2lkZW50cyBkdXJpbmcgdGhlIHJpZGUgKGxlYXZlIGVtcHR5IGlmIG5vbmUpLi4uXCJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsIGJvcmRlciByb3VuZGVkLWxnIHAtMyBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctYmx1ZS01MDBcIlxuICAgICAgICAgICAgICByb3dzPXszfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC1ncmF5LTUwMCBtdC0xXCI+XG4gICAgICAgICAgICAgIFRoaXMgaGVscHMgdXMgbWFpbnRhaW4gaGlnaCBxdWFsaXR5IHNlcnZpY2UgYW5kIGFkZHJlc3MgYW55XG4gICAgICAgICAgICAgIHByb2JsZW1zLlxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgey8qIEFjdGlvbiBCdXR0b25zICovfVxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBnYXAtMyBwdC00IGJvcmRlci10XCI+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICBvbkNsaWNrPXtvbkNhbmNlbH1cbiAgICAgICAgICAgICAgZGlzYWJsZWQ9e3N1Ym1pdHRpbmd9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZsZXgtMSBweC00IHB5LTMgYm9yZGVyIHJvdW5kZWQtbGcgZm9udC1zZW1pYm9sZCBob3ZlcjpiZy1ncmF5LTUwIHRyYW5zaXRpb24tY29sb3JzIGRpc2FibGVkOm9wYWNpdHktNTBcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBDYW5jZWxcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICB0eXBlPVwic3VibWl0XCJcbiAgICAgICAgICAgICAgZGlzYWJsZWQ9e3N1Ym1pdHRpbmd9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZsZXgtMSBweC00IHB5LTMgYmctYmx1ZS02MDAgdGV4dC13aGl0ZSByb3VuZGVkLWxnIGZvbnQtc2VtaWJvbGQgaG92ZXI6YmctYmx1ZS03MDAgdHJhbnNpdGlvbi1jb2xvcnMgZGlzYWJsZWQ6b3BhY2l0eS01MFwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtzdWJtaXR0aW5nID8gXCJTdWJtaXR0aW5nLi4uXCIgOiBcIkNvbXBsZXRlIFJpZGVcIn1cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Zvcm0+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsIlJpZGVEb2N1bWVudGF0aW9uRm9ybSIsImJvb2tpbmdJZCIsIm9uU3VibWl0Iiwib25DYW5jZWwiLCJmb3JtRGF0YSIsInNldEZvcm1EYXRhIiwicmlkZVF1YWxpdHkiLCJjbGllbnRDb21mb3J0IiwiYWNjZXNzaWJpbGl0eU5vdGVzIiwiaXNzdWVzUmVwb3J0ZWQiLCJzdWJtaXR0aW5nIiwic2V0U3VibWl0dGluZyIsImhhbmRsZVN1Ym1pdCIsImUiLCJwcmV2ZW50RGVmYXVsdCIsImVycm9yIiwiY29uc29sZSIsImFsZXJ0IiwiZGl2IiwiY2xhc3NOYW1lIiwiaDIiLCJwIiwiZm9ybSIsImxhYmVsIiwic3BhbiIsInZhbHVlIiwiZW1vamkiLCJtYXAiLCJvcHRpb24iLCJpbnB1dCIsInR5cGUiLCJuYW1lIiwiY2hlY2tlZCIsIm9uQ2hhbmdlIiwidGFyZ2V0IiwidGV4dGFyZWEiLCJwbGFjZWhvbGRlciIsInJvd3MiLCJidXR0b24iLCJvbkNsaWNrIiwiZGlzYWJsZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/RideDocumentationForm.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/RoleGate.tsx":
/*!*********************************!*\
  !*** ./components/RoleGate.tsx ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RoleGate)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _clerk_nextjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @clerk/nextjs */ \"(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction RoleGate(param) {\n    let { children, requiredRole } = param;\n    _s();\n    const { user, isLoaded } = (0,_clerk_nextjs__WEBPACK_IMPORTED_MODULE_3__.useUser)();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    const [checking, setChecking] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [hasRole, setHasRole] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"RoleGate.useEffect\": ()=>{\n            async function checkRole() {\n                if (!isLoaded) return;\n                if (!(user === null || user === void 0 ? void 0 : user.id)) {\n                    router.push(\"/\");\n                    return;\n                }\n                try {\n                    // Try to ensure user has a role (may fail if user already exists with proper setup)\n                    try {\n                        const ensureRes = await fetch(\"/api/users/ensure-role\");\n                        if (!ensureRes.ok) {\n                            const errorText = await ensureRes.text();\n                            console.error(\"Failed to ensure role:\", errorText);\n                        // Don't stop here - continue to fetch user data\n                        }\n                    } catch (ensureError) {\n                        console.error(\"Error calling ensure-role:\", ensureError);\n                    // Continue anyway - user might already be set up\n                    }\n                    // Then fetch user data\n                    const res = await fetch(\"/api/users/me\");\n                    if (!res.ok) {\n                        console.error(\"Failed to fetch user data\");\n                        router.push(\"/\");\n                        return;\n                    }\n                    const data = await res.json();\n                    const userRole = data.role;\n                    console.log(\"RoleGate: User role is\", userRole, \"Required:\", requiredRole);\n                    if (!userRole) {\n                        // Still no role after ensure-role, redirect home\n                        console.log(\"RoleGate: No role found, redirecting home\");\n                        router.push(\"/\");\n                        return;\n                    }\n                    // If specific role required, check it\n                    if (requiredRole && !requiredRole.includes(userRole)) {\n                        // Redirect to their appropriate dashboard\n                        console.log(\"RoleGate: User doesn't have required role, redirecting to their dashboard\");\n                        if (userRole === \"RIDER\") {\n                            router.push(\"/rider\");\n                        } else if (userRole === \"DRIVER\") {\n                            router.push(\"/driver\");\n                        } else if (userRole === \"DISPATCHER\") {\n                            router.push(\"/dispatcher\");\n                        } else if (userRole === \"ADMIN\") {\n                            router.push(\"/admin\");\n                        } else {\n                            router.push(\"/\");\n                        }\n                        return;\n                    }\n                    console.log(\"RoleGate: Access granted\");\n                    setHasRole(true);\n                } catch (e) {\n                    console.error(\"Error checking role:\", e);\n                } finally{\n                    setChecking(false);\n                }\n            }\n            checkRole();\n        }\n    }[\"RoleGate.useEffect\"], [\n        user,\n        isLoaded,\n        router,\n        requiredRole\n    ]);\n    if (checking) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"max-w-4xl mx-auto p-6\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-center\",\n                children: \"Loading...\"\n            }, void 0, false, {\n                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RoleGate.tsx\",\n                lineNumber: 100,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/RoleGate.tsx\",\n            lineNumber: 99,\n            columnNumber: 7\n        }, this);\n    }\n    if (!hasRole) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: children\n    }, void 0, false);\n}\n_s(RoleGate, \"qDWWjvvJW3Vm1m4qIuL8FvwZ8TU=\", false, function() {\n    return [\n        _clerk_nextjs__WEBPACK_IMPORTED_MODULE_3__.useUser,\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = RoleGate;\nvar _c;\n$RefreshReg$(_c, \"RoleGate\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvUm9sZUdhdGUudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQzRDO0FBQ0E7QUFDSjtBQU96QixTQUFTSSxTQUFTLEtBQXlDO1FBQXpDLEVBQUVDLFFBQVEsRUFBRUMsWUFBWSxFQUFpQixHQUF6Qzs7SUFDL0IsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLFFBQVEsRUFBRSxHQUFHTCxzREFBT0E7SUFDbEMsTUFBTU0sU0FBU1AsMERBQVNBO0lBQ3hCLE1BQU0sQ0FBQ1EsVUFBVUMsWUFBWSxHQUFHViwrQ0FBUUEsQ0FBQztJQUN6QyxNQUFNLENBQUNXLFNBQVNDLFdBQVcsR0FBR1osK0NBQVFBLENBQUM7SUFFdkNELGdEQUFTQTs4QkFBQztZQUNSLGVBQWVjO2dCQUNiLElBQUksQ0FBQ04sVUFBVTtnQkFFZixJQUFJLEVBQUNELGlCQUFBQSwyQkFBQUEsS0FBTVEsRUFBRSxHQUFFO29CQUNiTixPQUFPTyxJQUFJLENBQUM7b0JBQ1o7Z0JBQ0Y7Z0JBRUEsSUFBSTtvQkFDRixvRkFBb0Y7b0JBQ3BGLElBQUk7d0JBQ0YsTUFBTUMsWUFBWSxNQUFNQyxNQUFNO3dCQUM5QixJQUFJLENBQUNELFVBQVVFLEVBQUUsRUFBRTs0QkFDakIsTUFBTUMsWUFBWSxNQUFNSCxVQUFVSSxJQUFJOzRCQUN0Q0MsUUFBUUMsS0FBSyxDQUFDLDBCQUEwQkg7d0JBQ3hDLGdEQUFnRDt3QkFDbEQ7b0JBQ0YsRUFBRSxPQUFPSSxhQUFhO3dCQUNwQkYsUUFBUUMsS0FBSyxDQUFDLDhCQUE4QkM7b0JBQzVDLGlEQUFpRDtvQkFDbkQ7b0JBRUEsdUJBQXVCO29CQUN2QixNQUFNQyxNQUFNLE1BQU1QLE1BQU07b0JBQ3hCLElBQUksQ0FBQ08sSUFBSU4sRUFBRSxFQUFFO3dCQUNYRyxRQUFRQyxLQUFLLENBQUM7d0JBQ2RkLE9BQU9PLElBQUksQ0FBQzt3QkFDWjtvQkFDRjtvQkFFQSxNQUFNVSxPQUFPLE1BQU1ELElBQUlFLElBQUk7b0JBQzNCLE1BQU1DLFdBQVdGLEtBQUtHLElBQUk7b0JBRTFCUCxRQUFRUSxHQUFHLENBQ1QsMEJBQ0FGLFVBQ0EsYUFDQXRCO29CQUdGLElBQUksQ0FBQ3NCLFVBQVU7d0JBQ2IsaURBQWlEO3dCQUNqRE4sUUFBUVEsR0FBRyxDQUFDO3dCQUNackIsT0FBT08sSUFBSSxDQUFDO3dCQUNaO29CQUNGO29CQUVBLHNDQUFzQztvQkFDdEMsSUFBSVYsZ0JBQWdCLENBQUNBLGFBQWF5QixRQUFRLENBQUNILFdBQVc7d0JBQ3BELDBDQUEwQzt3QkFDMUNOLFFBQVFRLEdBQUcsQ0FDVDt3QkFFRixJQUFJRixhQUFhLFNBQVM7NEJBQ3hCbkIsT0FBT08sSUFBSSxDQUFDO3dCQUNkLE9BQU8sSUFBSVksYUFBYSxVQUFVOzRCQUNoQ25CLE9BQU9PLElBQUksQ0FBQzt3QkFDZCxPQUFPLElBQUlZLGFBQWEsY0FBYzs0QkFDcENuQixPQUFPTyxJQUFJLENBQUM7d0JBQ2QsT0FBTyxJQUFJWSxhQUFhLFNBQVM7NEJBQy9CbkIsT0FBT08sSUFBSSxDQUFDO3dCQUNkLE9BQU87NEJBQ0xQLE9BQU9PLElBQUksQ0FBQzt3QkFDZDt3QkFDQTtvQkFDRjtvQkFFQU0sUUFBUVEsR0FBRyxDQUFDO29CQUNaakIsV0FBVztnQkFDYixFQUFFLE9BQU9tQixHQUFHO29CQUNWVixRQUFRQyxLQUFLLENBQUMsd0JBQXdCUztnQkFDeEMsU0FBVTtvQkFDUnJCLFlBQVk7Z0JBQ2Q7WUFDRjtZQUVBRztRQUNGOzZCQUFHO1FBQUNQO1FBQU1DO1FBQVVDO1FBQVFIO0tBQWE7SUFFekMsSUFBSUksVUFBVTtRQUNaLHFCQUNFLDhEQUFDdUI7WUFBSUMsV0FBVTtzQkFDYiw0RUFBQ0Q7Z0JBQUlDLFdBQVU7MEJBQWM7Ozs7Ozs7Ozs7O0lBR25DO0lBRUEsSUFBSSxDQUFDdEIsU0FBUztRQUNaLE9BQU87SUFDVDtJQUVBLHFCQUFPO2tCQUFHUDs7QUFDWjtHQW5Hd0JEOztRQUNLRCxrREFBT0E7UUFDbkJELHNEQUFTQTs7O0tBRkZFIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9jb21wb25lbnRzL1JvbGVHYXRlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gXCJuZXh0L25hdmlnYXRpb25cIjtcbmltcG9ydCB7IHVzZVVzZXIgfSBmcm9tIFwiQGNsZXJrL25leHRqc1wiO1xuXG5pbnRlcmZhY2UgUm9sZUdhdGVQcm9wcyB7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG4gIHJlcXVpcmVkUm9sZT86IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSb2xlR2F0ZSh7IGNoaWxkcmVuLCByZXF1aXJlZFJvbGUgfTogUm9sZUdhdGVQcm9wcykge1xuICBjb25zdCB7IHVzZXIsIGlzTG9hZGVkIH0gPSB1c2VVc2VyKCk7XG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuICBjb25zdCBbY2hlY2tpbmcsIHNldENoZWNraW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbaGFzUm9sZSwgc2V0SGFzUm9sZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBhc3luYyBmdW5jdGlvbiBjaGVja1JvbGUoKSB7XG4gICAgICBpZiAoIWlzTG9hZGVkKSByZXR1cm47XG5cbiAgICAgIGlmICghdXNlcj8uaWQpIHtcbiAgICAgICAgcm91dGVyLnB1c2goXCIvXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRyeSB0byBlbnN1cmUgdXNlciBoYXMgYSByb2xlIChtYXkgZmFpbCBpZiB1c2VyIGFscmVhZHkgZXhpc3RzIHdpdGggcHJvcGVyIHNldHVwKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGVuc3VyZVJlcyA9IGF3YWl0IGZldGNoKFwiL2FwaS91c2Vycy9lbnN1cmUtcm9sZVwiKTtcbiAgICAgICAgICBpZiAoIWVuc3VyZVJlcy5vaykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgZW5zdXJlUmVzLnRleHQoKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZW5zdXJlIHJvbGU6XCIsIGVycm9yVGV4dCk7XG4gICAgICAgICAgICAvLyBEb24ndCBzdG9wIGhlcmUgLSBjb250aW51ZSB0byBmZXRjaCB1c2VyIGRhdGFcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVuc3VyZUVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNhbGxpbmcgZW5zdXJlLXJvbGU6XCIsIGVuc3VyZUVycm9yKTtcbiAgICAgICAgICAvLyBDb250aW51ZSBhbnl3YXkgLSB1c2VyIG1pZ2h0IGFscmVhZHkgYmUgc2V0IHVwXG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGVuIGZldGNoIHVzZXIgZGF0YVxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChcIi9hcGkvdXNlcnMvbWVcIik7XG4gICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCB1c2VyIGRhdGFcIik7XG4gICAgICAgICAgcm91dGVyLnB1c2goXCIvXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgICBjb25zdCB1c2VyUm9sZSA9IGRhdGEucm9sZTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBcIlJvbGVHYXRlOiBVc2VyIHJvbGUgaXNcIixcbiAgICAgICAgICB1c2VyUm9sZSxcbiAgICAgICAgICBcIlJlcXVpcmVkOlwiLFxuICAgICAgICAgIHJlcXVpcmVkUm9sZVxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghdXNlclJvbGUpIHtcbiAgICAgICAgICAvLyBTdGlsbCBubyByb2xlIGFmdGVyIGVuc3VyZS1yb2xlLCByZWRpcmVjdCBob21lXG4gICAgICAgICAgY29uc29sZS5sb2coXCJSb2xlR2F0ZTogTm8gcm9sZSBmb3VuZCwgcmVkaXJlY3RpbmcgaG9tZVwiKTtcbiAgICAgICAgICByb3V0ZXIucHVzaChcIi9cIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgc3BlY2lmaWMgcm9sZSByZXF1aXJlZCwgY2hlY2sgaXRcbiAgICAgICAgaWYgKHJlcXVpcmVkUm9sZSAmJiAhcmVxdWlyZWRSb2xlLmluY2x1ZGVzKHVzZXJSb2xlKSkge1xuICAgICAgICAgIC8vIFJlZGlyZWN0IHRvIHRoZWlyIGFwcHJvcHJpYXRlIGRhc2hib2FyZFxuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgXCJSb2xlR2F0ZTogVXNlciBkb2Vzbid0IGhhdmUgcmVxdWlyZWQgcm9sZSwgcmVkaXJlY3RpbmcgdG8gdGhlaXIgZGFzaGJvYXJkXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICh1c2VyUm9sZSA9PT0gXCJSSURFUlwiKSB7XG4gICAgICAgICAgICByb3V0ZXIucHVzaChcIi9yaWRlclwiKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHVzZXJSb2xlID09PSBcIkRSSVZFUlwiKSB7XG4gICAgICAgICAgICByb3V0ZXIucHVzaChcIi9kcml2ZXJcIik7XG4gICAgICAgICAgfSBlbHNlIGlmICh1c2VyUm9sZSA9PT0gXCJESVNQQVRDSEVSXCIpIHtcbiAgICAgICAgICAgIHJvdXRlci5wdXNoKFwiL2Rpc3BhdGNoZXJcIik7XG4gICAgICAgICAgfSBlbHNlIGlmICh1c2VyUm9sZSA9PT0gXCJBRE1JTlwiKSB7XG4gICAgICAgICAgICByb3V0ZXIucHVzaChcIi9hZG1pblwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm91dGVyLnB1c2goXCIvXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhcIlJvbGVHYXRlOiBBY2Nlc3MgZ3JhbnRlZFwiKTtcbiAgICAgICAgc2V0SGFzUm9sZSh0cnVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNoZWNraW5nIHJvbGU6XCIsIGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0Q2hlY2tpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrUm9sZSgpO1xuICB9LCBbdXNlciwgaXNMb2FkZWQsIHJvdXRlciwgcmVxdWlyZWRSb2xlXSk7XG5cbiAgaWYgKGNoZWNraW5nKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWF4LXctNHhsIG14LWF1dG8gcC02XCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXJcIj5Mb2FkaW5nLi4uPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgaWYgKCFoYXNSb2xlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gPD57Y2hpbGRyZW59PC8+O1xufVxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlUm91dGVyIiwidXNlVXNlciIsIlJvbGVHYXRlIiwiY2hpbGRyZW4iLCJyZXF1aXJlZFJvbGUiLCJ1c2VyIiwiaXNMb2FkZWQiLCJyb3V0ZXIiLCJjaGVja2luZyIsInNldENoZWNraW5nIiwiaGFzUm9sZSIsInNldEhhc1JvbGUiLCJjaGVja1JvbGUiLCJpZCIsInB1c2giLCJlbnN1cmVSZXMiLCJmZXRjaCIsIm9rIiwiZXJyb3JUZXh0IiwidGV4dCIsImNvbnNvbGUiLCJlcnJvciIsImVuc3VyZUVycm9yIiwicmVzIiwiZGF0YSIsImpzb24iLCJ1c2VyUm9sZSIsInJvbGUiLCJsb2ciLCJpbmNsdWRlcyIsImUiLCJkaXYiLCJjbGFzc05hbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/RoleGate.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/SOSButton.tsx":
/*!**********************************!*\
  !*** ./components/SOSButton.tsx ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SOSButton)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction SOSButton(param) {\n    let { onTrigger } = param;\n    _s();\n    const [showModal, setShowModal] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const handleTriggerSOS = ()=>{\n        setShowModal(true);\n        if (onTrigger) onTrigger();\n    };\n    const handleCall999 = ()=>{\n        window.location.href = \"tel:999\";\n    };\n    const handleContactSafety = ()=>{\n        // TODO: Implement contact safety desk\n        alert(\"Contacting HavenRide Safety Desk...\");\n    };\n    const handleCancelAlert = ()=>{\n        setShowModal(false);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                onClick: handleTriggerSOS,\n                className: \"fixed bottom-6 right-6 w-16 h-16 bg-red-600 rounded-full shadow-lg hover:bg-red-700 transition-all hover:scale-110 z-50 flex items-center justify-center\",\n                title: \"Emergency SOS\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                    className: \"text-white font-bold text-lg\",\n                    children: \"SOS\"\n                }, void 0, false, {\n                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/SOSButton.tsx\",\n                    lineNumber: 37,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/SOSButton.tsx\",\n                lineNumber: 32,\n                columnNumber: 7\n            }, this),\n            showModal && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"bg-white rounded-2xl p-8 max-w-md w-full\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex justify-center mb-6\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"w-24 h-24 bg-red-600 rounded-full flex items-center justify-center\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"text-white font-bold text-3xl\",\n                                    children: \"SOS\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/SOSButton.tsx\",\n                                    lineNumber: 47,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/SOSButton.tsx\",\n                                lineNumber: 46,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/SOSButton.tsx\",\n                            lineNumber: 45,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                            className: \"text-2xl font-bold text-center text-gray-900 mb-4\",\n                            children: \"Emergency in Progress\"\n                        }, void 0, false, {\n                            fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/SOSButton.tsx\",\n                            lineNumber: 52,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-center text-gray-600 mb-6\",\n                            children: \"Your location and driver details will be shared with HavenRide Safety Desk\"\n                        }, void 0, false, {\n                            fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/SOSButton.tsx\",\n                            lineNumber: 57,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"space-y-3\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handleCall999,\n                                    className: \"w-full bg-red-600 text-white py-4 rounded-lg font-semibold hover:bg-red-700 transition-colors flex items-center justify-center gap-2\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                            className: \"w-5 h-5\",\n                                            fill: \"none\",\n                                            stroke: \"currentColor\",\n                                            viewBox: \"0 0 24 24\",\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                                strokeLinecap: \"round\",\n                                                strokeLinejoin: \"round\",\n                                                strokeWidth: 2,\n                                                d: \"M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/SOSButton.tsx\",\n                                                lineNumber: 74,\n                                                columnNumber: 19\n                                            }, this)\n                                        }, void 0, false, {\n                                            fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/SOSButton.tsx\",\n                                            lineNumber: 68,\n                                            columnNumber: 17\n                                        }, this),\n                                        \"Call 999\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/SOSButton.tsx\",\n                                    lineNumber: 64,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handleContactSafety,\n                                    className: \"w-full border-2 border-gray-300 text-gray-700 py-4 rounded-lg font-semibold hover:bg-gray-50 transition-colors\",\n                                    children: \"Contact HavenRide Safety Desk\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/SOSButton.tsx\",\n                                    lineNumber: 84,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handleCancelAlert,\n                                    className: \"w-full border-2 border-gray-300 text-gray-700 py-4 rounded-lg font-semibold hover:bg-gray-50 transition-colors\",\n                                    children: \"Cancel Alert\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/SOSButton.tsx\",\n                                    lineNumber: 91,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/SOSButton.tsx\",\n                            lineNumber: 63,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-xs text-center text-gray-500 mt-6\",\n                            children: \"In case of immediate danger, contact local emergency services.\"\n                        }, void 0, false, {\n                            fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/SOSButton.tsx\",\n                            lineNumber: 100,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/SOSButton.tsx\",\n                    lineNumber: 43,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/SOSButton.tsx\",\n                lineNumber: 42,\n                columnNumber: 9\n            }, this)\n        ]\n    }, void 0, true);\n}\n_s(SOSButton, \"uVlnG5KLfXemZk5i5Fl+Cg356FU=\");\n_c = SOSButton;\nvar _c;\n$RefreshReg$(_c, \"SOSButton\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvU09TQnV0dG9uLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFDaUM7QUFNbEIsU0FBU0MsVUFBVSxLQUE2QjtRQUE3QixFQUFFQyxTQUFTLEVBQWtCLEdBQTdCOztJQUNoQyxNQUFNLENBQUNDLFdBQVdDLGFBQWEsR0FBR0osK0NBQVFBLENBQUM7SUFFM0MsTUFBTUssbUJBQW1CO1FBQ3ZCRCxhQUFhO1FBQ2IsSUFBSUYsV0FBV0E7SUFDakI7SUFFQSxNQUFNSSxnQkFBZ0I7UUFDcEJDLE9BQU9DLFFBQVEsQ0FBQ0MsSUFBSSxHQUFHO0lBQ3pCO0lBRUEsTUFBTUMsc0JBQXNCO1FBQzFCLHNDQUFzQztRQUN0Q0MsTUFBTTtJQUNSO0lBRUEsTUFBTUMsb0JBQW9CO1FBQ3hCUixhQUFhO0lBQ2Y7SUFFQSxxQkFDRTs7MEJBRUUsOERBQUNTO2dCQUNDQyxTQUFTVDtnQkFDVFUsV0FBVTtnQkFDVkMsT0FBTTswQkFFTiw0RUFBQ0M7b0JBQUtGLFdBQVU7OEJBQStCOzs7Ozs7Ozs7OztZQUloRFosMkJBQ0MsOERBQUNlO2dCQUFJSCxXQUFVOzBCQUNiLDRFQUFDRztvQkFBSUgsV0FBVTs7c0NBRWIsOERBQUNHOzRCQUFJSCxXQUFVO3NDQUNiLDRFQUFDRztnQ0FBSUgsV0FBVTswQ0FDYiw0RUFBQ0U7b0NBQUtGLFdBQVU7OENBQWdDOzs7Ozs7Ozs7Ozs7Ozs7O3NDQUtwRCw4REFBQ0k7NEJBQUdKLFdBQVU7c0NBQW9EOzs7Ozs7c0NBS2xFLDhEQUFDSzs0QkFBRUwsV0FBVTtzQ0FBaUM7Ozs7OztzQ0FNOUMsOERBQUNHOzRCQUFJSCxXQUFVOzs4Q0FDYiw4REFBQ0Y7b0NBQ0NDLFNBQVNSO29DQUNUUyxXQUFVOztzREFFViw4REFBQ007NENBQ0NOLFdBQVU7NENBQ1ZPLE1BQUs7NENBQ0xDLFFBQU87NENBQ1BDLFNBQVE7c0RBRVIsNEVBQUNDO2dEQUNDQyxlQUFjO2dEQUNkQyxnQkFBZTtnREFDZkMsYUFBYTtnREFDYkMsR0FBRTs7Ozs7Ozs7Ozs7d0NBRUE7Ozs7Ozs7OENBSVIsOERBQUNoQjtvQ0FDQ0MsU0FBU0o7b0NBQ1RLLFdBQVU7OENBQ1g7Ozs7Ozs4Q0FJRCw4REFBQ0Y7b0NBQ0NDLFNBQVNGO29DQUNURyxXQUFVOzhDQUNYOzs7Ozs7Ozs7Ozs7c0NBTUgsOERBQUNLOzRCQUFFTCxXQUFVO3NDQUF5Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVFsRTtHQXBHd0JkO0tBQUFBIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9jb21wb25lbnRzL1NPU0J1dHRvbi50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuXG5pbnRlcmZhY2UgU09TQnV0dG9uUHJvcHMge1xuICBvblRyaWdnZXI/OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTT1NCdXR0b24oeyBvblRyaWdnZXIgfTogU09TQnV0dG9uUHJvcHMpIHtcbiAgY29uc3QgW3Nob3dNb2RhbCwgc2V0U2hvd01vZGFsXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICBjb25zdCBoYW5kbGVUcmlnZ2VyU09TID0gKCkgPT4ge1xuICAgIHNldFNob3dNb2RhbCh0cnVlKTtcbiAgICBpZiAob25UcmlnZ2VyKSBvblRyaWdnZXIoKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVDYWxsOTk5ID0gKCkgPT4ge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gXCJ0ZWw6OTk5XCI7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlQ29udGFjdFNhZmV0eSA9ICgpID0+IHtcbiAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29udGFjdCBzYWZldHkgZGVza1xuICAgIGFsZXJ0KFwiQ29udGFjdGluZyBIYXZlblJpZGUgU2FmZXR5IERlc2suLi5cIik7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlQ2FuY2VsQWxlcnQgPSAoKSA9PiB7XG4gICAgc2V0U2hvd01vZGFsKGZhbHNlKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICB7LyogU09TIEZsb2F0aW5nIEJ1dHRvbiAqL31cbiAgICAgIDxidXR0b25cbiAgICAgICAgb25DbGljaz17aGFuZGxlVHJpZ2dlclNPU31cbiAgICAgICAgY2xhc3NOYW1lPVwiZml4ZWQgYm90dG9tLTYgcmlnaHQtNiB3LTE2IGgtMTYgYmctcmVkLTYwMCByb3VuZGVkLWZ1bGwgc2hhZG93LWxnIGhvdmVyOmJnLXJlZC03MDAgdHJhbnNpdGlvbi1hbGwgaG92ZXI6c2NhbGUtMTEwIHotNTAgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXJcIlxuICAgICAgICB0aXRsZT1cIkVtZXJnZW5jeSBTT1NcIlxuICAgICAgPlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXdoaXRlIGZvbnQtYm9sZCB0ZXh0LWxnXCI+U09TPC9zcGFuPlxuICAgICAgPC9idXR0b24+XG5cbiAgICAgIHsvKiBTT1MgTW9kYWwgKi99XG4gICAgICB7c2hvd01vZGFsICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmaXhlZCBpbnNldC0wIGJnLWJsYWNrIGJnLW9wYWNpdHktNjAgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgcC00IHotNTBcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLXdoaXRlIHJvdW5kZWQtMnhsIHAtOCBtYXgtdy1tZCB3LWZ1bGxcIj5cbiAgICAgICAgICAgIHsvKiBTT1MgSWNvbiAqL31cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWNlbnRlciBtYi02XCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy0yNCBoLTI0IGJnLXJlZC02MDAgcm91bmRlZC1mdWxsIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC13aGl0ZSBmb250LWJvbGQgdGV4dC0zeGxcIj5TT1M8L3NwYW4+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIHsvKiBUaXRsZSAqL31cbiAgICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LTJ4bCBmb250LWJvbGQgdGV4dC1jZW50ZXIgdGV4dC1ncmF5LTkwMCBtYi00XCI+XG4gICAgICAgICAgICAgIEVtZXJnZW5jeSBpbiBQcm9ncmVzc1xuICAgICAgICAgICAgPC9oMj5cblxuICAgICAgICAgICAgey8qIERlc2NyaXB0aW9uICovfVxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXIgdGV4dC1ncmF5LTYwMCBtYi02XCI+XG4gICAgICAgICAgICAgIFlvdXIgbG9jYXRpb24gYW5kIGRyaXZlciBkZXRhaWxzIHdpbGwgYmUgc2hhcmVkIHdpdGggSGF2ZW5SaWRlXG4gICAgICAgICAgICAgIFNhZmV0eSBEZXNrXG4gICAgICAgICAgICA8L3A+XG5cbiAgICAgICAgICAgIHsvKiBBY3Rpb24gQnV0dG9ucyAqL31cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0zXCI+XG4gICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVDYWxsOTk5fVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBiZy1yZWQtNjAwIHRleHQtd2hpdGUgcHktNCByb3VuZGVkLWxnIGZvbnQtc2VtaWJvbGQgaG92ZXI6YmctcmVkLTcwMCB0cmFuc2l0aW9uLWNvbG9ycyBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBnYXAtMlwiXG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8c3ZnXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LTUgaC01XCJcbiAgICAgICAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICB2aWV3Qm94PVwiMCAwIDI0IDI0XCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbj1cInJvdW5kXCJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezJ9XG4gICAgICAgICAgICAgICAgICAgIGQ9XCJNMyA1YTIgMiAwIDAxMi0yaDMuMjhhMSAxIDAgMDEuOTQ4LjY4NGwxLjQ5OCA0LjQ5M2ExIDEgMCAwMS0uNTAyIDEuMjFsLTIuMjU3IDEuMTNhMTEuMDQyIDExLjA0MiAwIDAwNS41MTYgNS41MTZsMS4xMy0yLjI1N2ExIDEgMCAwMTEuMjEtLjUwMmw0LjQ5MyAxLjQ5OGExIDEgMCAwMS42ODQuOTQ5VjE5YTIgMiAwIDAxLTIgMmgtMUM5LjcxNiAyMSAzIDE0LjI4NCAzIDZWNXpcIlxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICBDYWxsIDk5OVxuICAgICAgICAgICAgICA8L2J1dHRvbj5cblxuICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlQ29udGFjdFNhZmV0eX1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGwgYm9yZGVyLTIgYm9yZGVyLWdyYXktMzAwIHRleHQtZ3JheS03MDAgcHktNCByb3VuZGVkLWxnIGZvbnQtc2VtaWJvbGQgaG92ZXI6YmctZ3JheS01MCB0cmFuc2l0aW9uLWNvbG9yc1wiXG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBDb250YWN0IEhhdmVuUmlkZSBTYWZldHkgRGVza1xuICAgICAgICAgICAgICA8L2J1dHRvbj5cblxuICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlQ2FuY2VsQWxlcnR9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsIGJvcmRlci0yIGJvcmRlci1ncmF5LTMwMCB0ZXh0LWdyYXktNzAwIHB5LTQgcm91bmRlZC1sZyBmb250LXNlbWlib2xkIGhvdmVyOmJnLWdyYXktNTAgdHJhbnNpdGlvbi1jb2xvcnNcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgQ2FuY2VsIEFsZXJ0XG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIHsvKiBFbWVyZ2VuY3kgTm90aWNlICovfVxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC14cyB0ZXh0LWNlbnRlciB0ZXh0LWdyYXktNTAwIG10LTZcIj5cbiAgICAgICAgICAgICAgSW4gY2FzZSBvZiBpbW1lZGlhdGUgZGFuZ2VyLCBjb250YWN0IGxvY2FsIGVtZXJnZW5jeSBzZXJ2aWNlcy5cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgIDwvPlxuICApO1xufVxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwiU09TQnV0dG9uIiwib25UcmlnZ2VyIiwic2hvd01vZGFsIiwic2V0U2hvd01vZGFsIiwiaGFuZGxlVHJpZ2dlclNPUyIsImhhbmRsZUNhbGw5OTkiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJoYW5kbGVDb250YWN0U2FmZXR5IiwiYWxlcnQiLCJoYW5kbGVDYW5jZWxBbGVydCIsImJ1dHRvbiIsIm9uQ2xpY2siLCJjbGFzc05hbWUiLCJ0aXRsZSIsInNwYW4iLCJkaXYiLCJoMiIsInAiLCJzdmciLCJmaWxsIiwic3Ryb2tlIiwidmlld0JveCIsInBhdGgiLCJzdHJva2VMaW5lY2FwIiwic3Ryb2tlTGluZWpvaW4iLCJzdHJva2VXaWR0aCIsImQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/SOSButton.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/Sidebar.tsx":
/*!********************************!*\
  !*** ./components/Sidebar.tsx ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Sidebar)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/next/dist/client/app-dir/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/image */ \"(app-pages-browser)/./node_modules/next/dist/api/image.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _clerk_nextjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @clerk/nextjs */ \"(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nfunction Sidebar(param) {\n    let { userRole } = param;\n    _s();\n    const pathname = (0,next_navigation__WEBPACK_IMPORTED_MODULE_3__.usePathname)();\n    const isActive = (path)=>pathname === path;\n    const getRoleBasePath = ()=>{\n        if (userRole === \"DRIVER\") return \"/driver\";\n        if (userRole === \"DISPATCHER\") return \"/dispatcher\";\n        if (userRole === \"ADMIN\") return \"/admin\";\n        return \"/rider\";\n    };\n    const basePath = getRoleBasePath();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"w-64 min-h-screen bg-[#0F3D3E] text-white flex flex-col\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"p-6 flex justify-center\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"w-32 h-32 bg-white rounded-full flex items-center justify-center\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                        src: \"/images/HavenRideIcon.png\",\n                        alt: \"HavenRide Logo\",\n                        width: 120,\n                        height: 120,\n                        className: \"object-contain\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                        lineNumber: 30,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                    lineNumber: 29,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                lineNumber: 28,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n                className: \"flex-1 px-4 space-y-2\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                        href: basePath,\n                        className: \"flex items-center gap-3 px-4 py-3 rounded-lg transition-colors \".concat(isActive(basePath) ? \"bg-[#1a5557]\" : \"hover:bg-[#1a5557] hover:bg-opacity-50\"),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                className: \"w-5 h-5\",\n                                fill: \"none\",\n                                stroke: \"currentColor\",\n                                viewBox: \"0 0 24 24\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                    strokeLinecap: \"round\",\n                                    strokeLinejoin: \"round\",\n                                    strokeWidth: 2,\n                                    d: \"M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                                    lineNumber: 56,\n                                    columnNumber: 13\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                                lineNumber: 50,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                children: \"Home\"\n                            }, void 0, false, {\n                                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                                lineNumber: 63,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                        lineNumber: 42,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                        href: \"\".concat(basePath, \"/past-rides\"),\n                        className: \"flex items-center gap-3 px-4 py-3 rounded-lg transition-colors \".concat(isActive(\"\".concat(basePath, \"/past-rides\")) ? \"bg-[#1a5557]\" : \"hover:bg-[#1a5557] hover:bg-opacity-50\"),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                className: \"w-5 h-5\",\n                                fill: \"none\",\n                                stroke: \"currentColor\",\n                                viewBox: \"0 0 24 24\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                    strokeLinecap: \"round\",\n                                    strokeLinejoin: \"round\",\n                                    strokeWidth: 2,\n                                    d: \"M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                                    lineNumber: 80,\n                                    columnNumber: 13\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                                lineNumber: 74,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                children: \"Past Rides\"\n                            }, void 0, false, {\n                                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                                lineNumber: 87,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                        lineNumber: 66,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                        href: \"\".concat(basePath, \"/support\"),\n                        className: \"flex items-center gap-3 px-4 py-3 rounded-lg transition-colors \".concat(isActive(\"\".concat(basePath, \"/support\")) ? \"bg-[#1a5557]\" : \"hover:bg-[#1a5557] hover:bg-opacity-50\"),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                className: \"w-5 h-5\",\n                                fill: \"none\",\n                                stroke: \"currentColor\",\n                                viewBox: \"0 0 24 24\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                    strokeLinecap: \"round\",\n                                    strokeLinejoin: \"round\",\n                                    strokeWidth: 2,\n                                    d: \"M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                                    lineNumber: 104,\n                                    columnNumber: 13\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                                lineNumber: 98,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                children: \"Support\"\n                            }, void 0, false, {\n                                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                                lineNumber: 111,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                        lineNumber: 90,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                        href: \"\".concat(basePath, \"/profile\"),\n                        className: \"flex items-center gap-3 px-4 py-3 rounded-lg transition-colors \".concat(isActive(\"\".concat(basePath, \"/profile\")) ? \"bg-[#1a5557]\" : \"hover:bg-[#1a5557] hover:bg-opacity-50\"),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                className: \"w-5 h-5\",\n                                fill: \"none\",\n                                stroke: \"currentColor\",\n                                viewBox: \"0 0 24 24\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                    strokeLinecap: \"round\",\n                                    strokeLinejoin: \"round\",\n                                    strokeWidth: 2,\n                                    d: \"M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                                    lineNumber: 128,\n                                    columnNumber: 13\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                                lineNumber: 122,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                children: \"Profile\"\n                            }, void 0, false, {\n                                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                                lineNumber: 135,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                        lineNumber: 114,\n                        columnNumber: 9\n                    }, this),\n                    userRole === \"DRIVER\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                        href: \"/driver/earnings\",\n                        className: \"flex items-center gap-3 px-4 py-3 rounded-lg transition-colors \".concat(isActive(\"/driver/earnings\") ? \"bg-[#1a5557]\" : \"hover:bg-[#1a5557] hover:bg-opacity-50\"),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                className: \"w-5 h-5\",\n                                fill: \"none\",\n                                stroke: \"currentColor\",\n                                viewBox: \"0 0 24 24\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                    strokeLinecap: \"round\",\n                                    strokeLinejoin: \"round\",\n                                    strokeWidth: 2,\n                                    d: \"M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                                    lineNumber: 154,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                                lineNumber: 148,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                children: \"Earnings\"\n                            }, void 0, false, {\n                                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                                lineNumber: 161,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                        lineNumber: 140,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                lineNumber: 41,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"p-4 border-t border-[#1a5557]\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex items-center gap-3\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_clerk_nextjs__WEBPACK_IMPORTED_MODULE_4__.UserButton, {\n                            afterSignOutUrl: \"/\"\n                        }, void 0, false, {\n                            fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                            lineNumber: 169,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex-1\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"text-sm font-medium\",\n                                    children: \"Account\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                                    lineNumber: 171,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"text-xs text-gray-300\",\n                                    children: userRole || \"User\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                                    lineNumber: 172,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                            lineNumber: 170,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                    lineNumber: 168,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n                lineNumber: 167,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ishaqbello/Website/havenride_full_app/components/Sidebar.tsx\",\n        lineNumber: 26,\n        columnNumber: 5\n    }, this);\n}\n_s(Sidebar, \"xbyQPtUVMO7MNj7WjJlpdWqRcTo=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_3__.usePathname\n    ];\n});\n_c = Sidebar;\nvar _c;\n$RefreshReg$(_c, \"Sidebar\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvU2lkZWJhci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQzZCO0FBQ0U7QUFDZTtBQUNIO0FBTTVCLFNBQVNJLFFBQVEsS0FBMEI7UUFBMUIsRUFBRUMsUUFBUSxFQUFnQixHQUExQjs7SUFDOUIsTUFBTUMsV0FBV0osNERBQVdBO0lBRTVCLE1BQU1LLFdBQVcsQ0FBQ0MsT0FBaUJGLGFBQWFFO0lBRWhELE1BQU1DLGtCQUFrQjtRQUN0QixJQUFJSixhQUFhLFVBQVUsT0FBTztRQUNsQyxJQUFJQSxhQUFhLGNBQWMsT0FBTztRQUN0QyxJQUFJQSxhQUFhLFNBQVMsT0FBTztRQUNqQyxPQUFPO0lBQ1Q7SUFFQSxNQUFNSyxXQUFXRDtJQUVqQixxQkFDRSw4REFBQ0U7UUFBSUMsV0FBVTs7MEJBRWIsOERBQUNEO2dCQUFJQyxXQUFVOzBCQUNiLDRFQUFDRDtvQkFBSUMsV0FBVTs4QkFDYiw0RUFBQ1gsa0RBQUtBO3dCQUNKWSxLQUFJO3dCQUNKQyxLQUFJO3dCQUNKQyxPQUFPO3dCQUNQQyxRQUFRO3dCQUNSSixXQUFVOzs7Ozs7Ozs7Ozs7Ozs7OzBCQU1oQiw4REFBQ0s7Z0JBQUlMLFdBQVU7O2tDQUNiLDhEQUFDWixrREFBSUE7d0JBQ0hrQixNQUFNUjt3QkFDTkUsV0FBVyxrRUFJVixPQUhDTCxTQUFTRyxZQUNMLGlCQUNBOzswQ0FHTiw4REFBQ1M7Z0NBQ0NQLFdBQVU7Z0NBQ1ZRLE1BQUs7Z0NBQ0xDLFFBQU87Z0NBQ1BDLFNBQVE7MENBRVIsNEVBQUNkO29DQUNDZSxlQUFjO29DQUNkQyxnQkFBZTtvQ0FDZkMsYUFBYTtvQ0FDYkMsR0FBRTs7Ozs7Ozs7Ozs7MENBR04sOERBQUNDOzBDQUFLOzs7Ozs7Ozs7Ozs7a0NBR1IsOERBQUMzQixrREFBSUE7d0JBQ0hrQixNQUFNLEdBQVksT0FBVFIsVUFBUzt3QkFDbEJFLFdBQVcsa0VBSVYsT0FIQ0wsU0FBUyxHQUFZLE9BQVRHLFVBQVMsa0JBQ2pCLGlCQUNBOzswQ0FHTiw4REFBQ1M7Z0NBQ0NQLFdBQVU7Z0NBQ1ZRLE1BQUs7Z0NBQ0xDLFFBQU87Z0NBQ1BDLFNBQVE7MENBRVIsNEVBQUNkO29DQUNDZSxlQUFjO29DQUNkQyxnQkFBZTtvQ0FDZkMsYUFBYTtvQ0FDYkMsR0FBRTs7Ozs7Ozs7Ozs7MENBR04sOERBQUNDOzBDQUFLOzs7Ozs7Ozs7Ozs7a0NBR1IsOERBQUMzQixrREFBSUE7d0JBQ0hrQixNQUFNLEdBQVksT0FBVFIsVUFBUzt3QkFDbEJFLFdBQVcsa0VBSVYsT0FIQ0wsU0FBUyxHQUFZLE9BQVRHLFVBQVMsZUFDakIsaUJBQ0E7OzBDQUdOLDhEQUFDUztnQ0FDQ1AsV0FBVTtnQ0FDVlEsTUFBSztnQ0FDTEMsUUFBTztnQ0FDUEMsU0FBUTswQ0FFUiw0RUFBQ2Q7b0NBQ0NlLGVBQWM7b0NBQ2RDLGdCQUFlO29DQUNmQyxhQUFhO29DQUNiQyxHQUFFOzs7Ozs7Ozs7OzswQ0FHTiw4REFBQ0M7MENBQUs7Ozs7Ozs7Ozs7OztrQ0FHUiw4REFBQzNCLGtEQUFJQTt3QkFDSGtCLE1BQU0sR0FBWSxPQUFUUixVQUFTO3dCQUNsQkUsV0FBVyxrRUFJVixPQUhDTCxTQUFTLEdBQVksT0FBVEcsVUFBUyxlQUNqQixpQkFDQTs7MENBR04sOERBQUNTO2dDQUNDUCxXQUFVO2dDQUNWUSxNQUFLO2dDQUNMQyxRQUFPO2dDQUNQQyxTQUFROzBDQUVSLDRFQUFDZDtvQ0FDQ2UsZUFBYztvQ0FDZEMsZ0JBQWU7b0NBQ2ZDLGFBQWE7b0NBQ2JDLEdBQUU7Ozs7Ozs7Ozs7OzBDQUdOLDhEQUFDQzswQ0FBSzs7Ozs7Ozs7Ozs7O29CQUlQdEIsYUFBYSwwQkFDWiw4REFBQ0wsa0RBQUlBO3dCQUNIa0IsTUFBSzt3QkFDTE4sV0FBVyxrRUFJVixPQUhDTCxTQUFTLHNCQUNMLGlCQUNBOzswQ0FHTiw4REFBQ1k7Z0NBQ0NQLFdBQVU7Z0NBQ1ZRLE1BQUs7Z0NBQ0xDLFFBQU87Z0NBQ1BDLFNBQVE7MENBRVIsNEVBQUNkO29DQUNDZSxlQUFjO29DQUNkQyxnQkFBZTtvQ0FDZkMsYUFBYTtvQ0FDYkMsR0FBRTs7Ozs7Ozs7Ozs7MENBR04sOERBQUNDOzBDQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBTVosOERBQUNoQjtnQkFBSUMsV0FBVTswQkFDYiw0RUFBQ0Q7b0JBQUlDLFdBQVU7O3NDQUNiLDhEQUFDVCxxREFBVUE7NEJBQUN5QixpQkFBZ0I7Ozs7OztzQ0FDNUIsOERBQUNqQjs0QkFBSUMsV0FBVTs7OENBQ2IsOERBQUNpQjtvQ0FBRWpCLFdBQVU7OENBQXNCOzs7Ozs7OENBQ25DLDhEQUFDaUI7b0NBQUVqQixXQUFVOzhDQUF5QlAsWUFBWTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNOUQ7R0F2S3dCRDs7UUFDTEYsd0RBQVdBOzs7S0FETkUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL2NvbXBvbmVudHMvU2lkZWJhci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgTGluayBmcm9tIFwibmV4dC9saW5rXCI7XG5pbXBvcnQgSW1hZ2UgZnJvbSBcIm5leHQvaW1hZ2VcIjtcbmltcG9ydCB7IHVzZVBhdGhuYW1lIH0gZnJvbSBcIm5leHQvbmF2aWdhdGlvblwiO1xuaW1wb3J0IHsgVXNlckJ1dHRvbiB9IGZyb20gXCJAY2xlcmsvbmV4dGpzXCI7XG5cbmludGVyZmFjZSBTaWRlYmFyUHJvcHMge1xuICB1c2VyUm9sZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2lkZWJhcih7IHVzZXJSb2xlIH06IFNpZGViYXJQcm9wcykge1xuICBjb25zdCBwYXRobmFtZSA9IHVzZVBhdGhuYW1lKCk7XG5cbiAgY29uc3QgaXNBY3RpdmUgPSAocGF0aDogc3RyaW5nKSA9PiBwYXRobmFtZSA9PT0gcGF0aDtcblxuICBjb25zdCBnZXRSb2xlQmFzZVBhdGggPSAoKSA9PiB7XG4gICAgaWYgKHVzZXJSb2xlID09PSBcIkRSSVZFUlwiKSByZXR1cm4gXCIvZHJpdmVyXCI7XG4gICAgaWYgKHVzZXJSb2xlID09PSBcIkRJU1BBVENIRVJcIikgcmV0dXJuIFwiL2Rpc3BhdGNoZXJcIjtcbiAgICBpZiAodXNlclJvbGUgPT09IFwiQURNSU5cIikgcmV0dXJuIFwiL2FkbWluXCI7XG4gICAgcmV0dXJuIFwiL3JpZGVyXCI7XG4gIH07XG5cbiAgY29uc3QgYmFzZVBhdGggPSBnZXRSb2xlQmFzZVBhdGgoKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidy02NCBtaW4taC1zY3JlZW4gYmctWyMwRjNEM0VdIHRleHQtd2hpdGUgZmxleCBmbGV4LWNvbFwiPlxuICAgICAgey8qIExvZ28gKi99XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInAtNiBmbGV4IGp1c3RpZnktY2VudGVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy0zMiBoLTMyIGJnLXdoaXRlIHJvdW5kZWQtZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiPlxuICAgICAgICAgIDxJbWFnZVxuICAgICAgICAgICAgc3JjPVwiL2ltYWdlcy9IYXZlblJpZGVJY29uLnBuZ1wiXG4gICAgICAgICAgICBhbHQ9XCJIYXZlblJpZGUgTG9nb1wiXG4gICAgICAgICAgICB3aWR0aD17MTIwfVxuICAgICAgICAgICAgaGVpZ2h0PXsxMjB9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJvYmplY3QtY29udGFpblwiXG4gICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAgey8qIE5hdmlnYXRpb24gKi99XG4gICAgICA8bmF2IGNsYXNzTmFtZT1cImZsZXgtMSBweC00IHNwYWNlLXktMlwiPlxuICAgICAgICA8TGlua1xuICAgICAgICAgIGhyZWY9e2Jhc2VQYXRofVxuICAgICAgICAgIGNsYXNzTmFtZT17YGZsZXggaXRlbXMtY2VudGVyIGdhcC0zIHB4LTQgcHktMyByb3VuZGVkLWxnIHRyYW5zaXRpb24tY29sb3JzICR7XG4gICAgICAgICAgICBpc0FjdGl2ZShiYXNlUGF0aClcbiAgICAgICAgICAgICAgPyBcImJnLVsjMWE1NTU3XVwiXG4gICAgICAgICAgICAgIDogXCJob3ZlcjpiZy1bIzFhNTU1N10gaG92ZXI6Ymctb3BhY2l0eS01MFwiXG4gICAgICAgICAgfWB9XG4gICAgICAgID5cbiAgICAgICAgICA8c3ZnXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJ3LTUgaC01XCJcbiAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICB2aWV3Qm94PVwiMCAwIDI0IDI0XCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbj1cInJvdW5kXCJcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezJ9XG4gICAgICAgICAgICAgIGQ9XCJNMyAxMmwyLTJtMCAwbDctNyA3IDdNNSAxMHYxMGExIDEgMCAwMDEgMWgzbTEwLTExbDIgMm0tMi0ydjEwYTEgMSAwIDAxLTEgMWgtM20tNiAwYTEgMSAwIDAwMS0xdi00YTEgMSAwIDAxMS0xaDJhMSAxIDAgMDExIDF2NGExIDEgMCAwMDEgMW0tNiAwaDZcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICA8c3Bhbj5Ib21lPC9zcGFuPlxuICAgICAgICA8L0xpbms+XG5cbiAgICAgICAgPExpbmtcbiAgICAgICAgICBocmVmPXtgJHtiYXNlUGF0aH0vcGFzdC1yaWRlc2B9XG4gICAgICAgICAgY2xhc3NOYW1lPXtgZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTMgcHgtNCBweS0zIHJvdW5kZWQtbGcgdHJhbnNpdGlvbi1jb2xvcnMgJHtcbiAgICAgICAgICAgIGlzQWN0aXZlKGAke2Jhc2VQYXRofS9wYXN0LXJpZGVzYClcbiAgICAgICAgICAgICAgPyBcImJnLVsjMWE1NTU3XVwiXG4gICAgICAgICAgICAgIDogXCJob3ZlcjpiZy1bIzFhNTU1N10gaG92ZXI6Ymctb3BhY2l0eS01MFwiXG4gICAgICAgICAgfWB9XG4gICAgICAgID5cbiAgICAgICAgICA8c3ZnXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJ3LTUgaC01XCJcbiAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICB2aWV3Qm94PVwiMCAwIDI0IDI0XCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbj1cInJvdW5kXCJcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezJ9XG4gICAgICAgICAgICAgIGQ9XCJNMTIgOHY0bDMgM202LTNhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6XCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgPHNwYW4+UGFzdCBSaWRlczwvc3Bhbj5cbiAgICAgICAgPC9MaW5rPlxuXG4gICAgICAgIDxMaW5rXG4gICAgICAgICAgaHJlZj17YCR7YmFzZVBhdGh9L3N1cHBvcnRgfVxuICAgICAgICAgIGNsYXNzTmFtZT17YGZsZXggaXRlbXMtY2VudGVyIGdhcC0zIHB4LTQgcHktMyByb3VuZGVkLWxnIHRyYW5zaXRpb24tY29sb3JzICR7XG4gICAgICAgICAgICBpc0FjdGl2ZShgJHtiYXNlUGF0aH0vc3VwcG9ydGApXG4gICAgICAgICAgICAgID8gXCJiZy1bIzFhNTU1N11cIlxuICAgICAgICAgICAgICA6IFwiaG92ZXI6YmctWyMxYTU1NTddIGhvdmVyOmJnLW9wYWNpdHktNTBcIlxuICAgICAgICAgIH1gfVxuICAgICAgICA+XG4gICAgICAgICAgPHN2Z1xuICAgICAgICAgICAgY2xhc3NOYW1lPVwidy01IGgtNVwiXG4gICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcD1cInJvdW5kXCJcbiAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsyfVxuICAgICAgICAgICAgICBkPVwiTTguMjI4IDljLjU0OS0xLjE2NSAyLjAzLTIgMy43NzItMiAyLjIxIDAgNCAxLjM0MyA0IDMgMCAxLjQtMS4yNzggMi41NzUtMy4wMDYgMi45MDctLjU0Mi4xMDQtLjk5NC41NC0uOTk0IDEuMDkzbTAgM2guMDFNMjEgMTJhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6XCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgPHNwYW4+U3VwcG9ydDwvc3Bhbj5cbiAgICAgICAgPC9MaW5rPlxuXG4gICAgICAgIDxMaW5rXG4gICAgICAgICAgaHJlZj17YCR7YmFzZVBhdGh9L3Byb2ZpbGVgfVxuICAgICAgICAgIGNsYXNzTmFtZT17YGZsZXggaXRlbXMtY2VudGVyIGdhcC0zIHB4LTQgcHktMyByb3VuZGVkLWxnIHRyYW5zaXRpb24tY29sb3JzICR7XG4gICAgICAgICAgICBpc0FjdGl2ZShgJHtiYXNlUGF0aH0vcHJvZmlsZWApXG4gICAgICAgICAgICAgID8gXCJiZy1bIzFhNTU1N11cIlxuICAgICAgICAgICAgICA6IFwiaG92ZXI6YmctWyMxYTU1NTddIGhvdmVyOmJnLW9wYWNpdHktNTBcIlxuICAgICAgICAgIH1gfVxuICAgICAgICA+XG4gICAgICAgICAgPHN2Z1xuICAgICAgICAgICAgY2xhc3NOYW1lPVwidy01IGgtNVwiXG4gICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcD1cInJvdW5kXCJcbiAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsyfVxuICAgICAgICAgICAgICBkPVwiTTE2IDdhNCA0IDAgMTEtOCAwIDQgNCAwIDAxOCAwek0xMiAxNGE3IDcgMCAwMC03IDdoMTRhNyA3IDAgMDAtNy03elwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgIDxzcGFuPlByb2ZpbGU8L3NwYW4+XG4gICAgICAgIDwvTGluaz5cblxuICAgICAgICB7LyogRHJpdmVyLXNwZWNpZmljIGxpbmtzICovfVxuICAgICAgICB7dXNlclJvbGUgPT09IFwiRFJJVkVSXCIgJiYgKFxuICAgICAgICAgIDxMaW5rXG4gICAgICAgICAgICBocmVmPVwiL2RyaXZlci9lYXJuaW5nc1wiXG4gICAgICAgICAgICBjbGFzc05hbWU9e2BmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMyBweC00IHB5LTMgcm91bmRlZC1sZyB0cmFuc2l0aW9uLWNvbG9ycyAke1xuICAgICAgICAgICAgICBpc0FjdGl2ZShcIi9kcml2ZXIvZWFybmluZ3NcIilcbiAgICAgICAgICAgICAgICA/IFwiYmctWyMxYTU1NTddXCJcbiAgICAgICAgICAgICAgICA6IFwiaG92ZXI6YmctWyMxYTU1NTddIGhvdmVyOmJnLW9wYWNpdHktNTBcIlxuICAgICAgICAgICAgfWB9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPHN2Z1xuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LTUgaC01XCJcbiAgICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICB2aWV3Qm94PVwiMCAwIDI0IDI0XCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsyfVxuICAgICAgICAgICAgICAgIGQ9XCJNMTIgOGMtMS42NTcgMC0zIC44OTUtMyAyczEuMzQzIDIgMyAyIDMgLjg5NSAzIDItMS4zNDMgMi0zIDJtMC04YzEuMTEgMCAyLjA4LjQwMiAyLjU5OSAxTTEyIDhWN20wIDF2OG0wIDB2MW0wLTFjLTEuMTEgMC0yLjA4LS40MDItMi41OTktMU0yMSAxMmE5IDkgMCAxMS0xOCAwIDkgOSAwIDAxMTggMHpcIlxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICA8c3Bhbj5FYXJuaW5nczwvc3Bhbj5cbiAgICAgICAgICA8L0xpbms+XG4gICAgICAgICl9XG4gICAgICA8L25hdj5cblxuICAgICAgey8qIFVzZXIgUHJvZmlsZSBhdCBib3R0b20gKi99XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInAtNCBib3JkZXItdCBib3JkZXItWyMxYTU1NTddXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTNcIj5cbiAgICAgICAgICA8VXNlckJ1dHRvbiBhZnRlclNpZ25PdXRVcmw9XCIvXCIgLz5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgtMVwiPlxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSBmb250LW1lZGl1bVwiPkFjY291bnQ8L3A+XG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtZ3JheS0zMDBcIj57dXNlclJvbGUgfHwgXCJVc2VyXCJ9PC9wPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufVxuIl0sIm5hbWVzIjpbIkxpbmsiLCJJbWFnZSIsInVzZVBhdGhuYW1lIiwiVXNlckJ1dHRvbiIsIlNpZGViYXIiLCJ1c2VyUm9sZSIsInBhdGhuYW1lIiwiaXNBY3RpdmUiLCJwYXRoIiwiZ2V0Um9sZUJhc2VQYXRoIiwiYmFzZVBhdGgiLCJkaXYiLCJjbGFzc05hbWUiLCJzcmMiLCJhbHQiLCJ3aWR0aCIsImhlaWdodCIsIm5hdiIsImhyZWYiLCJzdmciLCJmaWxsIiwic3Ryb2tlIiwidmlld0JveCIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VMaW5lam9pbiIsInN0cm9rZVdpZHRoIiwiZCIsInNwYW4iLCJhZnRlclNpZ25PdXRVcmwiLCJwIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/Sidebar.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/realtime/ably.ts":
/*!******************************!*\
  !*** ./lib/realtime/ably.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getChannel: () => (/* binding */ getChannel),\n/* harmony export */   getRealtime: () => (/* binding */ getRealtime)\n/* harmony export */ });\n/* harmony import */ var ably__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ably */ \"(app-pages-browser)/./node_modules/ably/build/ably.js\");\n/* harmony import */ var ably__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ably__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ getRealtime,getChannel auto */ \nlet realtime = null;\nlet initializationFailed = false;\nfunction getRealtime() {\n    if (initializationFailed) return null;\n    if (realtime) return realtime;\n    const key = \"xxx:yyy\";\n    if (!key) {\n        console.warn(\"Ably key not configured - real-time features will be disabled\");\n        initializationFailed = true;\n        return null;\n    }\n    try {\n        realtime = new ably__WEBPACK_IMPORTED_MODULE_0__.Realtime(key);\n        // Handle connection errors\n        realtime.connection.on(\"failed\", (stateChange)=>{\n            console.error(\"Ably connection failed:\", stateChange.reason);\n            initializationFailed = true;\n        });\n        return realtime;\n    } catch (error) {\n        console.error(\"Failed to initialize Ably:\", error);\n        initializationFailed = true;\n        return null;\n    }\n}\nfunction getChannel(name) {\n    const r = getRealtime();\n    if (!r) {\n        // Return a mock channel that does nothing\n        return {\n            subscribe: (_)=>{},\n            unsubscribe: (_)=>{},\n            isMock: true\n        };\n    }\n    return r.channels.get(name);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9yZWFsdGltZS9hYmx5LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7NEVBQzZCO0FBRTdCLElBQUlDLFdBQWlDO0FBQ3JDLElBQUlDLHVCQUF1QjtBQUVwQixTQUFTQztJQUNkLElBQUlELHNCQUFzQixPQUFPO0lBQ2pDLElBQUlELFVBQVUsT0FBT0E7SUFFckIsTUFBTUcsTUFBTUMsU0FBZ0M7SUFDNUMsSUFBSSxDQUFDRCxLQUFLO1FBQ1JJLFFBQVFDLElBQUksQ0FDVjtRQUVGUCx1QkFBdUI7UUFDdkIsT0FBTztJQUNUO0lBRUEsSUFBSTtRQUNGRCxXQUFXLElBQUlELDBDQUFhLENBQUNJO1FBRTdCLDJCQUEyQjtRQUMzQkgsU0FBU1UsVUFBVSxDQUFDQyxFQUFFLENBQUMsVUFBVSxDQUFDQztZQUNoQ0wsUUFBUU0sS0FBSyxDQUFDLDJCQUEyQkQsWUFBWUUsTUFBTTtZQUMzRGIsdUJBQXVCO1FBQ3pCO1FBRUEsT0FBT0Q7SUFDVCxFQUFFLE9BQU9hLE9BQU87UUFDZE4sUUFBUU0sS0FBSyxDQUFDLDhCQUE4QkE7UUFDNUNaLHVCQUF1QjtRQUN2QixPQUFPO0lBQ1Q7QUFDRjtBQVNPLFNBQVNjLFdBQVdDLElBQVk7SUFDckMsTUFBTUMsSUFBSWY7SUFDVixJQUFJLENBQUNlLEdBQUc7UUFDTiwwQ0FBMEM7UUFDMUMsT0FBTztZQUNMQyxXQUFXLENBQUNDLEtBQVk7WUFDeEJDLGFBQWEsQ0FBQ0QsS0FBWTtZQUMxQkUsUUFBUTtRQUNWO0lBQ0Y7SUFDQSxPQUFPSixFQUFFSyxRQUFRLENBQUNDLEdBQUcsQ0FBQ1A7QUFDeEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL2xpYi9yZWFsdGltZS9hYmx5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0ICogYXMgQWJseSBmcm9tIFwiYWJseVwiO1xuXG5sZXQgcmVhbHRpbWU6IEFibHkuUmVhbHRpbWUgfCBudWxsID0gbnVsbDtcbmxldCBpbml0aWFsaXphdGlvbkZhaWxlZCA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVhbHRpbWUoKSB7XG4gIGlmIChpbml0aWFsaXphdGlvbkZhaWxlZCkgcmV0dXJuIG51bGw7XG4gIGlmIChyZWFsdGltZSkgcmV0dXJuIHJlYWx0aW1lO1xuXG4gIGNvbnN0IGtleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FCTFlfS0VZO1xuICBpZiAoIWtleSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiQWJseSBrZXkgbm90IGNvbmZpZ3VyZWQgLSByZWFsLXRpbWUgZmVhdHVyZXMgd2lsbCBiZSBkaXNhYmxlZFwiXG4gICAgKTtcbiAgICBpbml0aWFsaXphdGlvbkZhaWxlZCA9IHRydWU7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIHJlYWx0aW1lID0gbmV3IEFibHkuUmVhbHRpbWUoa2V5KTtcblxuICAgIC8vIEhhbmRsZSBjb25uZWN0aW9uIGVycm9yc1xuICAgIHJlYWx0aW1lLmNvbm5lY3Rpb24ub24oXCJmYWlsZWRcIiwgKHN0YXRlQ2hhbmdlKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQWJseSBjb25uZWN0aW9uIGZhaWxlZDpcIiwgc3RhdGVDaGFuZ2UucmVhc29uKTtcbiAgICAgIGluaXRpYWxpemF0aW9uRmFpbGVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZWFsdGltZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGluaXRpYWxpemUgQWJseTpcIiwgZXJyb3IpO1xuICAgIGluaXRpYWxpemF0aW9uRmFpbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vLyBUeXBlLXNhZmUgY2hhbm5lbCBpbnRlcmZhY2VcbmludGVyZmFjZSBNb2NrQ2hhbm5lbCB7XG4gIHN1YnNjcmliZTogKGhhbmRsZXI6IGFueSkgPT4gdm9pZDtcbiAgdW5zdWJzY3JpYmU6IChoYW5kbGVyOiBhbnkpID0+IHZvaWQ7XG4gIGlzTW9jazogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENoYW5uZWwobmFtZTogc3RyaW5nKTogYW55IHtcbiAgY29uc3QgciA9IGdldFJlYWx0aW1lKCk7XG4gIGlmICghcikge1xuICAgIC8vIFJldHVybiBhIG1vY2sgY2hhbm5lbCB0aGF0IGRvZXMgbm90aGluZ1xuICAgIHJldHVybiB7XG4gICAgICBzdWJzY3JpYmU6IChfOiBhbnkpID0+IHt9LFxuICAgICAgdW5zdWJzY3JpYmU6IChfOiBhbnkpID0+IHt9LFxuICAgICAgaXNNb2NrOiB0cnVlLFxuICAgIH0gYXMgTW9ja0NoYW5uZWw7XG4gIH1cbiAgcmV0dXJuIHIuY2hhbm5lbHMuZ2V0KG5hbWUpO1xufVxuIl0sIm5hbWVzIjpbIkFibHkiLCJyZWFsdGltZSIsImluaXRpYWxpemF0aW9uRmFpbGVkIiwiZ2V0UmVhbHRpbWUiLCJrZXkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQUJMWV9LRVkiLCJjb25zb2xlIiwid2FybiIsIlJlYWx0aW1lIiwiY29ubmVjdGlvbiIsIm9uIiwic3RhdGVDaGFuZ2UiLCJlcnJvciIsInJlYXNvbiIsImdldENoYW5uZWwiLCJuYW1lIiwiciIsInN1YnNjcmliZSIsIl8iLCJ1bnN1YnNjcmliZSIsImlzTW9jayIsImNoYW5uZWxzIiwiZ2V0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/realtime/ably.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/chunk-JPAFWK3P.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@clerk/clerk-react/dist/chunk-JPAFWK3P.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthenticateWithRedirectCallback: () => (/* binding */ AuthenticateWithRedirectCallback),\n/* harmony export */   ClerkDegraded: () => (/* binding */ ClerkDegraded),\n/* harmony export */   ClerkFailed: () => (/* binding */ ClerkFailed),\n/* harmony export */   ClerkLoaded: () => (/* binding */ ClerkLoaded),\n/* harmony export */   ClerkLoading: () => (/* binding */ ClerkLoading),\n/* harmony export */   MultisessionAppSupport: () => (/* binding */ MultisessionAppSupport),\n/* harmony export */   Protect: () => (/* binding */ Protect),\n/* harmony export */   RedirectToCreateOrganization: () => (/* binding */ RedirectToCreateOrganization),\n/* harmony export */   RedirectToOrganizationProfile: () => (/* binding */ RedirectToOrganizationProfile),\n/* harmony export */   RedirectToSignIn: () => (/* binding */ RedirectToSignIn),\n/* harmony export */   RedirectToSignUp: () => (/* binding */ RedirectToSignUp),\n/* harmony export */   RedirectToTasks: () => (/* binding */ RedirectToTasks),\n/* harmony export */   RedirectToUserProfile: () => (/* binding */ RedirectToUserProfile),\n/* harmony export */   SignedIn: () => (/* binding */ SignedIn),\n/* harmony export */   SignedOut: () => (/* binding */ SignedOut)\n/* harmony export */ });\n/* harmony import */ var _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-XIVXL4LQ.mjs */ \"(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/chunk-XIVXL4LQ.mjs\");\n/* harmony import */ var _clerk_shared_deprecated__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @clerk/shared/deprecated */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/deprecated.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _clerk_shared_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @clerk/shared/react */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/react/index.mjs\");\n\n\n// src/components/controlComponents.tsx\n\n\n\n// src/contexts/SessionContext.tsx\n\n\n// src/components/controlComponents.tsx\nvar SignedIn = ({ children, treatPendingAsSignedOut }) => {\n  (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.useAssertWrappedByClerkProvider)(\"SignedIn\");\n  const { userId } = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.useAuth)({ treatPendingAsSignedOut });\n  if (userId) {\n    return children;\n  }\n  return null;\n};\nvar SignedOut = ({ children, treatPendingAsSignedOut }) => {\n  (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.useAssertWrappedByClerkProvider)(\"SignedOut\");\n  const { userId } = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.useAuth)({ treatPendingAsSignedOut });\n  if (userId === null) {\n    return children;\n  }\n  return null;\n};\nvar ClerkLoaded = ({ children }) => {\n  (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.useAssertWrappedByClerkProvider)(\"ClerkLoaded\");\n  const isomorphicClerk = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.useIsomorphicClerkContext)();\n  if (!isomorphicClerk.loaded) {\n    return null;\n  }\n  return children;\n};\nvar ClerkLoading = ({ children }) => {\n  (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.useAssertWrappedByClerkProvider)(\"ClerkLoading\");\n  const isomorphicClerk = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.useIsomorphicClerkContext)();\n  if (isomorphicClerk.status !== \"loading\") {\n    return null;\n  }\n  return children;\n};\nvar ClerkFailed = ({ children }) => {\n  (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.useAssertWrappedByClerkProvider)(\"ClerkFailed\");\n  const isomorphicClerk = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.useIsomorphicClerkContext)();\n  if (isomorphicClerk.status !== \"error\") {\n    return null;\n  }\n  return children;\n};\nvar ClerkDegraded = ({ children }) => {\n  (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.useAssertWrappedByClerkProvider)(\"ClerkDegraded\");\n  const isomorphicClerk = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.useIsomorphicClerkContext)();\n  if (isomorphicClerk.status !== \"degraded\") {\n    return null;\n  }\n  return children;\n};\nvar Protect = ({ children, fallback, treatPendingAsSignedOut, ...restAuthorizedParams }) => {\n  (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.useAssertWrappedByClerkProvider)(\"Protect\");\n  const { isLoaded, has, userId } = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.useAuth)({ treatPendingAsSignedOut });\n  if (!isLoaded) {\n    return null;\n  }\n  const unauthorized = fallback != null ? fallback : null;\n  const authorized = children;\n  if (!userId) {\n    return unauthorized;\n  }\n  if (typeof restAuthorizedParams.condition === \"function\") {\n    if (restAuthorizedParams.condition(has)) {\n      return authorized;\n    }\n    return unauthorized;\n  }\n  if (restAuthorizedParams.role || restAuthorizedParams.permission || restAuthorizedParams.feature || restAuthorizedParams.plan) {\n    if (has(restAuthorizedParams)) {\n      return authorized;\n    }\n    return unauthorized;\n  }\n  return authorized;\n};\nvar RedirectToSignIn = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(({ clerk, ...props }) => {\n  const { client, session } = clerk;\n  const hasSignedInSessions = client.signedInSessions ? client.signedInSessions.length > 0 : (\n    // Compat for clerk-js<5.54.0 (which was released with the `signedInSessions` property)\n    client.activeSessions && client.activeSessions.length > 0\n  );\n  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {\n    if (session === null && hasSignedInSessions) {\n      void clerk.redirectToAfterSignOut();\n    } else {\n      void clerk.redirectToSignIn(props);\n    }\n  }, []);\n  return null;\n}, \"RedirectToSignIn\");\nvar RedirectToSignUp = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(({ clerk, ...props }) => {\n  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {\n    void clerk.redirectToSignUp(props);\n  }, []);\n  return null;\n}, \"RedirectToSignUp\");\nvar RedirectToTasks = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(({ clerk, ...props }) => {\n  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {\n    void clerk.redirectToTasks(props);\n  }, []);\n  return null;\n}, \"RedirectToTasks\");\nvar RedirectToUserProfile = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(({ clerk }) => {\n  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {\n    (0,_clerk_shared_deprecated__WEBPACK_IMPORTED_MODULE_1__.deprecated)(\"RedirectToUserProfile\", \"Use the `redirectToUserProfile()` method instead.\");\n    void clerk.redirectToUserProfile();\n  }, []);\n  return null;\n}, \"RedirectToUserProfile\");\nvar RedirectToOrganizationProfile = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(({ clerk }) => {\n  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {\n    (0,_clerk_shared_deprecated__WEBPACK_IMPORTED_MODULE_1__.deprecated)(\"RedirectToOrganizationProfile\", \"Use the `redirectToOrganizationProfile()` method instead.\");\n    void clerk.redirectToOrganizationProfile();\n  }, []);\n  return null;\n}, \"RedirectToOrganizationProfile\");\nvar RedirectToCreateOrganization = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(({ clerk }) => {\n  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {\n    (0,_clerk_shared_deprecated__WEBPACK_IMPORTED_MODULE_1__.deprecated)(\"RedirectToCreateOrganization\", \"Use the `redirectToCreateOrganization()` method instead.\");\n    void clerk.redirectToCreateOrganization();\n  }, []);\n  return null;\n}, \"RedirectToCreateOrganization\");\nvar AuthenticateWithRedirectCallback = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(\n  ({ clerk, ...handleRedirectCallbackParams }) => {\n    react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {\n      void clerk.handleRedirectCallback(handleRedirectCallbackParams);\n    }, []);\n    return null;\n  },\n  \"AuthenticateWithRedirectCallback\"\n);\nvar MultisessionAppSupport = ({ children }) => {\n  (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.useAssertWrappedByClerkProvider)(\"MultisessionAppSupport\");\n  const session = (0,_clerk_shared_react__WEBPACK_IMPORTED_MODULE_3__.useSessionContext)();\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, { key: session ? session.id : \"no-users\" }, children);\n};\n\n\n//# sourceMappingURL=chunk-JPAFWK3P.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvY2xlcmstcmVhY3QvZGlzdC9jaHVuay1KUEFGV0szUC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUs4Qjs7QUFFOUI7QUFDc0Q7QUFDNUI7O0FBRTFCO0FBQ3dFOztBQUV4RTtBQUNBLGtCQUFrQixtQ0FBbUM7QUFDckQsRUFBRSxvRkFBK0I7QUFDakMsVUFBVSxTQUFTLEVBQUUsNERBQU8sR0FBRyx5QkFBeUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQ0FBbUM7QUFDdEQsRUFBRSxvRkFBK0I7QUFDakMsVUFBVSxTQUFTLEVBQUUsNERBQU8sR0FBRyx5QkFBeUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixVQUFVO0FBQy9CLEVBQUUsb0ZBQStCO0FBQ2pDLDBCQUEwQiw4RUFBeUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDLEVBQUUsb0ZBQStCO0FBQ2pDLDBCQUEwQiw4RUFBeUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixVQUFVO0FBQy9CLEVBQUUsb0ZBQStCO0FBQ2pDLDBCQUEwQiw4RUFBeUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDLEVBQUUsb0ZBQStCO0FBQ2pDLDBCQUEwQiw4RUFBeUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzRUFBc0U7QUFDdkYsRUFBRSxvRkFBK0I7QUFDakMsVUFBVSx3QkFBd0IsRUFBRSw0REFBTyxHQUFHLHlCQUF5QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4REFBUyxJQUFJLGlCQUFpQjtBQUNyRCxVQUFVLGtCQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNELHVCQUF1Qiw4REFBUyxJQUFJLGlCQUFpQjtBQUNyRCxFQUFFLDRDQUFlO0FBQ2pCO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNELHNCQUFzQiw4REFBUyxJQUFJLGlCQUFpQjtBQUNwRCxFQUFFLDRDQUFlO0FBQ2pCO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNELDRCQUE0Qiw4REFBUyxJQUFJLE9BQU87QUFDaEQsRUFBRSw0Q0FBZTtBQUNqQixJQUFJLG9FQUFVO0FBQ2Q7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Qsb0NBQW9DLDhEQUFTLElBQUksT0FBTztBQUN4RCxFQUFFLDRDQUFlO0FBQ2pCLElBQUksb0VBQVU7QUFDZDtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRCxtQ0FBbUMsOERBQVMsSUFBSSxPQUFPO0FBQ3ZELEVBQUUsNENBQWU7QUFDakIsSUFBSSxvRUFBVTtBQUNkO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNELHVDQUF1Qyw4REFBUztBQUNoRCxLQUFLLHdDQUF3QztBQUM3QyxJQUFJLDRDQUFlO0FBQ25CO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVTtBQUMxQyxFQUFFLG9GQUErQjtBQUNqQyxrQkFBa0Isc0VBQWlCO0FBQ25DLHlCQUF5QixnREFBbUIsQ0FBQywyQ0FBYyxJQUFJLHdDQUF3QztBQUN2Rzs7QUFrQkU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2lzaGFxYmVsbG8vV2Vic2l0ZS9oYXZlbnJpZGVfZnVsbF9hcHAvbm9kZV9tb2R1bGVzL0BjbGVyay9jbGVyay1yZWFjdC9kaXN0L2NodW5rLUpQQUZXSzNQLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICB1c2VBc3NlcnRXcmFwcGVkQnlDbGVya1Byb3ZpZGVyLFxuICB1c2VBdXRoLFxuICB1c2VJc29tb3JwaGljQ2xlcmtDb250ZXh0LFxuICB3aXRoQ2xlcmtcbn0gZnJvbSBcIi4vY2h1bmstWElWWEw0TFEubWpzXCI7XG5cbi8vIHNyYy9jb21wb25lbnRzL2NvbnRyb2xDb21wb25lbnRzLnRzeFxuaW1wb3J0IHsgZGVwcmVjYXRlZCB9IGZyb20gXCJAY2xlcmsvc2hhcmVkL2RlcHJlY2F0ZWRcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2NvbnRleHRzL1Nlc3Npb25Db250ZXh0LnRzeFxuaW1wb3J0IHsgU2Vzc2lvbkNvbnRleHQsIHVzZVNlc3Npb25Db250ZXh0IH0gZnJvbSBcIkBjbGVyay9zaGFyZWQvcmVhY3RcIjtcblxuLy8gc3JjL2NvbXBvbmVudHMvY29udHJvbENvbXBvbmVudHMudHN4XG52YXIgU2lnbmVkSW4gPSAoeyBjaGlsZHJlbiwgdHJlYXRQZW5kaW5nQXNTaWduZWRPdXQgfSkgPT4ge1xuICB1c2VBc3NlcnRXcmFwcGVkQnlDbGVya1Byb3ZpZGVyKFwiU2lnbmVkSW5cIik7XG4gIGNvbnN0IHsgdXNlcklkIH0gPSB1c2VBdXRoKHsgdHJlYXRQZW5kaW5nQXNTaWduZWRPdXQgfSk7XG4gIGlmICh1c2VySWQpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIFNpZ25lZE91dCA9ICh7IGNoaWxkcmVuLCB0cmVhdFBlbmRpbmdBc1NpZ25lZE91dCB9KSA9PiB7XG4gIHVzZUFzc2VydFdyYXBwZWRCeUNsZXJrUHJvdmlkZXIoXCJTaWduZWRPdXRcIik7XG4gIGNvbnN0IHsgdXNlcklkIH0gPSB1c2VBdXRoKHsgdHJlYXRQZW5kaW5nQXNTaWduZWRPdXQgfSk7XG4gIGlmICh1c2VySWQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIENsZXJrTG9hZGVkID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICB1c2VBc3NlcnRXcmFwcGVkQnlDbGVya1Byb3ZpZGVyKFwiQ2xlcmtMb2FkZWRcIik7XG4gIGNvbnN0IGlzb21vcnBoaWNDbGVyayA9IHVzZUlzb21vcnBoaWNDbGVya0NvbnRleHQoKTtcbiAgaWYgKCFpc29tb3JwaGljQ2xlcmsubG9hZGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuO1xufTtcbnZhciBDbGVya0xvYWRpbmcgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIHVzZUFzc2VydFdyYXBwZWRCeUNsZXJrUHJvdmlkZXIoXCJDbGVya0xvYWRpbmdcIik7XG4gIGNvbnN0IGlzb21vcnBoaWNDbGVyayA9IHVzZUlzb21vcnBoaWNDbGVya0NvbnRleHQoKTtcbiAgaWYgKGlzb21vcnBoaWNDbGVyay5zdGF0dXMgIT09IFwibG9hZGluZ1wiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuO1xufTtcbnZhciBDbGVya0ZhaWxlZCA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgdXNlQXNzZXJ0V3JhcHBlZEJ5Q2xlcmtQcm92aWRlcihcIkNsZXJrRmFpbGVkXCIpO1xuICBjb25zdCBpc29tb3JwaGljQ2xlcmsgPSB1c2VJc29tb3JwaGljQ2xlcmtDb250ZXh0KCk7XG4gIGlmIChpc29tb3JwaGljQ2xlcmsuc3RhdHVzICE9PSBcImVycm9yXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY2hpbGRyZW47XG59O1xudmFyIENsZXJrRGVncmFkZWQgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIHVzZUFzc2VydFdyYXBwZWRCeUNsZXJrUHJvdmlkZXIoXCJDbGVya0RlZ3JhZGVkXCIpO1xuICBjb25zdCBpc29tb3JwaGljQ2xlcmsgPSB1c2VJc29tb3JwaGljQ2xlcmtDb250ZXh0KCk7XG4gIGlmIChpc29tb3JwaGljQ2xlcmsuc3RhdHVzICE9PSBcImRlZ3JhZGVkXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY2hpbGRyZW47XG59O1xudmFyIFByb3RlY3QgPSAoeyBjaGlsZHJlbiwgZmFsbGJhY2ssIHRyZWF0UGVuZGluZ0FzU2lnbmVkT3V0LCAuLi5yZXN0QXV0aG9yaXplZFBhcmFtcyB9KSA9PiB7XG4gIHVzZUFzc2VydFdyYXBwZWRCeUNsZXJrUHJvdmlkZXIoXCJQcm90ZWN0XCIpO1xuICBjb25zdCB7IGlzTG9hZGVkLCBoYXMsIHVzZXJJZCB9ID0gdXNlQXV0aCh7IHRyZWF0UGVuZGluZ0FzU2lnbmVkT3V0IH0pO1xuICBpZiAoIWlzTG9hZGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgdW5hdXRob3JpemVkID0gZmFsbGJhY2sgIT0gbnVsbCA/IGZhbGxiYWNrIDogbnVsbDtcbiAgY29uc3QgYXV0aG9yaXplZCA9IGNoaWxkcmVuO1xuICBpZiAoIXVzZXJJZCkge1xuICAgIHJldHVybiB1bmF1dGhvcml6ZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiByZXN0QXV0aG9yaXplZFBhcmFtcy5jb25kaXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGlmIChyZXN0QXV0aG9yaXplZFBhcmFtcy5jb25kaXRpb24oaGFzKSkge1xuICAgICAgcmV0dXJuIGF1dGhvcml6ZWQ7XG4gICAgfVxuICAgIHJldHVybiB1bmF1dGhvcml6ZWQ7XG4gIH1cbiAgaWYgKHJlc3RBdXRob3JpemVkUGFyYW1zLnJvbGUgfHwgcmVzdEF1dGhvcml6ZWRQYXJhbXMucGVybWlzc2lvbiB8fCByZXN0QXV0aG9yaXplZFBhcmFtcy5mZWF0dXJlIHx8IHJlc3RBdXRob3JpemVkUGFyYW1zLnBsYW4pIHtcbiAgICBpZiAoaGFzKHJlc3RBdXRob3JpemVkUGFyYW1zKSkge1xuICAgICAgcmV0dXJuIGF1dGhvcml6ZWQ7XG4gICAgfVxuICAgIHJldHVybiB1bmF1dGhvcml6ZWQ7XG4gIH1cbiAgcmV0dXJuIGF1dGhvcml6ZWQ7XG59O1xudmFyIFJlZGlyZWN0VG9TaWduSW4gPSB3aXRoQ2xlcmsoKHsgY2xlcmssIC4uLnByb3BzIH0pID0+IHtcbiAgY29uc3QgeyBjbGllbnQsIHNlc3Npb24gfSA9IGNsZXJrO1xuICBjb25zdCBoYXNTaWduZWRJblNlc3Npb25zID0gY2xpZW50LnNpZ25lZEluU2Vzc2lvbnMgPyBjbGllbnQuc2lnbmVkSW5TZXNzaW9ucy5sZW5ndGggPiAwIDogKFxuICAgIC8vIENvbXBhdCBmb3IgY2xlcmstanM8NS41NC4wICh3aGljaCB3YXMgcmVsZWFzZWQgd2l0aCB0aGUgYHNpZ25lZEluU2Vzc2lvbnNgIHByb3BlcnR5KVxuICAgIGNsaWVudC5hY3RpdmVTZXNzaW9ucyAmJiBjbGllbnQuYWN0aXZlU2Vzc2lvbnMubGVuZ3RoID4gMFxuICApO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzZXNzaW9uID09PSBudWxsICYmIGhhc1NpZ25lZEluU2Vzc2lvbnMpIHtcbiAgICAgIHZvaWQgY2xlcmsucmVkaXJlY3RUb0FmdGVyU2lnbk91dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2b2lkIGNsZXJrLnJlZGlyZWN0VG9TaWduSW4ocHJvcHMpO1xuICAgIH1cbiAgfSwgW10pO1xuICByZXR1cm4gbnVsbDtcbn0sIFwiUmVkaXJlY3RUb1NpZ25JblwiKTtcbnZhciBSZWRpcmVjdFRvU2lnblVwID0gd2l0aENsZXJrKCh7IGNsZXJrLCAuLi5wcm9wcyB9KSA9PiB7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdm9pZCBjbGVyay5yZWRpcmVjdFRvU2lnblVwKHByb3BzKTtcbiAgfSwgW10pO1xuICByZXR1cm4gbnVsbDtcbn0sIFwiUmVkaXJlY3RUb1NpZ25VcFwiKTtcbnZhciBSZWRpcmVjdFRvVGFza3MgPSB3aXRoQ2xlcmsoKHsgY2xlcmssIC4uLnByb3BzIH0pID0+IHtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB2b2lkIGNsZXJrLnJlZGlyZWN0VG9UYXNrcyhwcm9wcyk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIG51bGw7XG59LCBcIlJlZGlyZWN0VG9UYXNrc1wiKTtcbnZhciBSZWRpcmVjdFRvVXNlclByb2ZpbGUgPSB3aXRoQ2xlcmsoKHsgY2xlcmsgfSkgPT4ge1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGRlcHJlY2F0ZWQoXCJSZWRpcmVjdFRvVXNlclByb2ZpbGVcIiwgXCJVc2UgdGhlIGByZWRpcmVjdFRvVXNlclByb2ZpbGUoKWAgbWV0aG9kIGluc3RlYWQuXCIpO1xuICAgIHZvaWQgY2xlcmsucmVkaXJlY3RUb1VzZXJQcm9maWxlKCk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIG51bGw7XG59LCBcIlJlZGlyZWN0VG9Vc2VyUHJvZmlsZVwiKTtcbnZhciBSZWRpcmVjdFRvT3JnYW5pemF0aW9uUHJvZmlsZSA9IHdpdGhDbGVyaygoeyBjbGVyayB9KSA9PiB7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZGVwcmVjYXRlZChcIlJlZGlyZWN0VG9Pcmdhbml6YXRpb25Qcm9maWxlXCIsIFwiVXNlIHRoZSBgcmVkaXJlY3RUb09yZ2FuaXphdGlvblByb2ZpbGUoKWAgbWV0aG9kIGluc3RlYWQuXCIpO1xuICAgIHZvaWQgY2xlcmsucmVkaXJlY3RUb09yZ2FuaXphdGlvblByb2ZpbGUoKTtcbiAgfSwgW10pO1xuICByZXR1cm4gbnVsbDtcbn0sIFwiUmVkaXJlY3RUb09yZ2FuaXphdGlvblByb2ZpbGVcIik7XG52YXIgUmVkaXJlY3RUb0NyZWF0ZU9yZ2FuaXphdGlvbiA9IHdpdGhDbGVyaygoeyBjbGVyayB9KSA9PiB7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZGVwcmVjYXRlZChcIlJlZGlyZWN0VG9DcmVhdGVPcmdhbml6YXRpb25cIiwgXCJVc2UgdGhlIGByZWRpcmVjdFRvQ3JlYXRlT3JnYW5pemF0aW9uKClgIG1ldGhvZCBpbnN0ZWFkLlwiKTtcbiAgICB2b2lkIGNsZXJrLnJlZGlyZWN0VG9DcmVhdGVPcmdhbml6YXRpb24oKTtcbiAgfSwgW10pO1xuICByZXR1cm4gbnVsbDtcbn0sIFwiUmVkaXJlY3RUb0NyZWF0ZU9yZ2FuaXphdGlvblwiKTtcbnZhciBBdXRoZW50aWNhdGVXaXRoUmVkaXJlY3RDYWxsYmFjayA9IHdpdGhDbGVyayhcbiAgKHsgY2xlcmssIC4uLmhhbmRsZVJlZGlyZWN0Q2FsbGJhY2tQYXJhbXMgfSkgPT4ge1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICB2b2lkIGNsZXJrLmhhbmRsZVJlZGlyZWN0Q2FsbGJhY2soaGFuZGxlUmVkaXJlY3RDYWxsYmFja1BhcmFtcyk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBudWxsO1xuICB9LFxuICBcIkF1dGhlbnRpY2F0ZVdpdGhSZWRpcmVjdENhbGxiYWNrXCJcbik7XG52YXIgTXVsdGlzZXNzaW9uQXBwU3VwcG9ydCA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgdXNlQXNzZXJ0V3JhcHBlZEJ5Q2xlcmtQcm92aWRlcihcIk11bHRpc2Vzc2lvbkFwcFN1cHBvcnRcIik7XG4gIGNvbnN0IHNlc3Npb24gPSB1c2VTZXNzaW9uQ29udGV4dCgpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIHsga2V5OiBzZXNzaW9uID8gc2Vzc2lvbi5pZCA6IFwibm8tdXNlcnNcIiB9LCBjaGlsZHJlbik7XG59O1xuXG5leHBvcnQge1xuICBTaWduZWRJbixcbiAgU2lnbmVkT3V0LFxuICBDbGVya0xvYWRlZCxcbiAgQ2xlcmtMb2FkaW5nLFxuICBDbGVya0ZhaWxlZCxcbiAgQ2xlcmtEZWdyYWRlZCxcbiAgUHJvdGVjdCxcbiAgUmVkaXJlY3RUb1NpZ25JbixcbiAgUmVkaXJlY3RUb1NpZ25VcCxcbiAgUmVkaXJlY3RUb1Rhc2tzLFxuICBSZWRpcmVjdFRvVXNlclByb2ZpbGUsXG4gIFJlZGlyZWN0VG9Pcmdhbml6YXRpb25Qcm9maWxlLFxuICBSZWRpcmVjdFRvQ3JlYXRlT3JnYW5pemF0aW9uLFxuICBBdXRoZW50aWNhdGVXaXRoUmVkaXJlY3RDYWxsYmFjayxcbiAgTXVsdGlzZXNzaW9uQXBwU3VwcG9ydFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLUpQQUZXSzNQLm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/chunk-JPAFWK3P.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/chunk-OANWQR3B.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@clerk/clerk-react/dist/chunk-OANWQR3B.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __privateAdd: () => (/* binding */ __privateAdd),\n/* harmony export */   __privateGet: () => (/* binding */ __privateGet),\n/* harmony export */   __privateMethod: () => (/* binding */ __privateMethod),\n/* harmony export */   __privateSet: () => (/* binding */ __privateSet)\n/* harmony export */ });\nvar __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\n\n\n//# sourceMappingURL=chunk-OANWQR3B.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvY2xlcmstcmVhY3QvZGlzdC9jaHVuay1PQU5XUVIzQi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBT0U7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2lzaGFxYmVsbG8vV2Vic2l0ZS9oYXZlbnJpZGVfZnVsbF9hcHAvbm9kZV9tb2R1bGVzL0BjbGVyay9jbGVyay1yZWFjdC9kaXN0L2NodW5rLU9BTldRUjNCLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX190eXBlRXJyb3IgPSAobXNnKSA9PiB7XG4gIHRocm93IFR5cGVFcnJvcihtc2cpO1xufTtcbnZhciBfX2FjY2Vzc0NoZWNrID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IG1lbWJlci5oYXMob2JqKSB8fCBfX3R5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG52YXIgX19wcml2YXRlR2V0ID0gKG9iaiwgbWVtYmVyLCBnZXR0ZXIpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpLCBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopKTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiBtZW1iZXIuaGFzKG9iaikgPyBfX3R5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIikgOiBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbnZhciBfX3ByaXZhdGVTZXQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIiksIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKSwgdmFsdWUpO1xudmFyIF9fcHJpdmF0ZU1ldGhvZCA9IChvYmosIG1lbWJlciwgbWV0aG9kKSA9PiAoX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJhY2Nlc3MgcHJpdmF0ZSBtZXRob2RcIiksIG1ldGhvZCk7XG5cbmV4cG9ydCB7XG4gIF9fcHJpdmF0ZUdldCxcbiAgX19wcml2YXRlQWRkLFxuICBfX3ByaXZhdGVTZXQsXG4gIF9fcHJpdmF0ZU1ldGhvZFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLU9BTldRUjNCLm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/chunk-OANWQR3B.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/chunk-SOK75ZUK.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@clerk/clerk-react/dist/chunk-SOK75ZUK.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIKeys: () => (/* binding */ APIKeys),\n/* harmony export */   CreateOrganization: () => (/* binding */ CreateOrganization),\n/* harmony export */   GoogleOneTap: () => (/* binding */ GoogleOneTap),\n/* harmony export */   OrganizationList: () => (/* binding */ OrganizationList),\n/* harmony export */   OrganizationProfile: () => (/* binding */ OrganizationProfile),\n/* harmony export */   OrganizationSwitcher: () => (/* binding */ OrganizationSwitcher),\n/* harmony export */   PricingTable: () => (/* binding */ PricingTable),\n/* harmony export */   SignIn: () => (/* binding */ SignIn),\n/* harmony export */   SignUp: () => (/* binding */ SignUp),\n/* harmony export */   TaskChooseOrganization: () => (/* binding */ TaskChooseOrganization),\n/* harmony export */   UserAvatar: () => (/* binding */ UserAvatar),\n/* harmony export */   UserButton: () => (/* binding */ UserButton),\n/* harmony export */   UserProfile: () => (/* binding */ UserProfile),\n/* harmony export */   Waitlist: () => (/* binding */ Waitlist),\n/* harmony export */   assertSingleChild: () => (/* binding */ assertSingleChild),\n/* harmony export */   isConstructor: () => (/* binding */ isConstructor),\n/* harmony export */   normalizeWithDefaultValue: () => (/* binding */ normalizeWithDefaultValue),\n/* harmony export */   safeExecute: () => (/* binding */ safeExecute),\n/* harmony export */   withMaxAllowedInstancesGuard: () => (/* binding */ withMaxAllowedInstancesGuard)\n/* harmony export */ });\n/* harmony import */ var _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-XIVXL4LQ.mjs */ \"(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/chunk-XIVXL4LQ.mjs\");\n/* harmony import */ var _clerk_shared_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @clerk/shared/utils */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/utils/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var _clerk_shared_object__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @clerk/shared/object */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/object.mjs\");\n/* harmony import */ var _clerk_shared_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @clerk/shared/react */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/react/index.mjs\");\n\n\n// src/components/uiComponents.tsx\n\n\n\n// src/utils/childrenUtils.tsx\n\nvar assertSingleChild = (children) => (name) => {\n  try {\n    return react__WEBPACK_IMPORTED_MODULE_2__.Children.only(children);\n  } catch {\n    return _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.errorThrower.throw((0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.multipleChildrenInButtonComponent)(name));\n  }\n};\nvar normalizeWithDefaultValue = (children, defaultText) => {\n  if (!children) {\n    children = defaultText;\n  }\n  if (typeof children === \"string\") {\n    children = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"button\", null, children);\n  }\n  return children;\n};\nvar safeExecute = (cb) => (...args) => {\n  if (cb && typeof cb === \"function\") {\n    return cb(...args);\n  }\n};\n\n// src/utils/isConstructor.ts\nfunction isConstructor(f) {\n  return typeof f === \"function\";\n}\n\n// src/utils/useMaxAllowedInstancesGuard.tsx\n\nvar counts = /* @__PURE__ */ new Map();\nfunction useMaxAllowedInstancesGuard(name, error, maxCount = 1) {\n  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {\n    const count = counts.get(name) || 0;\n    if (count == maxCount) {\n      return _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.errorThrower.throw(error);\n    }\n    counts.set(name, count + 1);\n    return () => {\n      counts.set(name, (counts.get(name) || 1) - 1);\n    };\n  }, []);\n}\nfunction withMaxAllowedInstancesGuard(WrappedComponent, name, error) {\n  const displayName = WrappedComponent.displayName || WrappedComponent.name || name || \"Component\";\n  const Hoc = (props) => {\n    useMaxAllowedInstancesGuard(name, error);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(WrappedComponent, { ...props });\n  };\n  Hoc.displayName = `withMaxAllowedInstancesGuard(${displayName})`;\n  return Hoc;\n}\n\n// src/utils/useCustomElementPortal.tsx\n\n\nvar useCustomElementPortal = (elements) => {\n  const [nodeMap, setNodeMap] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(/* @__PURE__ */ new Map());\n  return elements.map((el) => ({\n    id: el.id,\n    mount: (node) => setNodeMap((prev) => new Map(prev).set(String(el.id), node)),\n    unmount: () => setNodeMap((prev) => {\n      const newMap = new Map(prev);\n      newMap.set(String(el.id), null);\n      return newMap;\n    }),\n    portal: () => {\n      const node = nodeMap.get(String(el.id));\n      return node ? (0,react_dom__WEBPACK_IMPORTED_MODULE_3__.createPortal)(el.component, node) : null;\n    }\n  }));\n};\n\n// src/utils/useCustomPages.tsx\n\n\n\n// src/utils/componentValidation.ts\n\nvar isThatComponent = (v, component) => {\n  return !!v && react__WEBPACK_IMPORTED_MODULE_2__.isValidElement(v) && (v == null ? void 0 : v.type) === component;\n};\n\n// src/utils/useCustomPages.tsx\nvar useUserProfileCustomPages = (children, options) => {\n  const reorderItemsLabels = [\"account\", \"security\"];\n  return useCustomPages(\n    {\n      children,\n      reorderItemsLabels,\n      LinkComponent: UserProfileLink,\n      PageComponent: UserProfilePage,\n      MenuItemsComponent: MenuItems,\n      componentName: \"UserProfile\"\n    },\n    options\n  );\n};\nvar useOrganizationProfileCustomPages = (children, options) => {\n  const reorderItemsLabels = [\"general\", \"members\"];\n  return useCustomPages(\n    {\n      children,\n      reorderItemsLabels,\n      LinkComponent: OrganizationProfileLink,\n      PageComponent: OrganizationProfilePage,\n      componentName: \"OrganizationProfile\"\n    },\n    options\n  );\n};\nvar useSanitizedChildren = (children) => {\n  const sanitizedChildren = [];\n  const excludedComponents = [\n    OrganizationProfileLink,\n    OrganizationProfilePage,\n    MenuItems,\n    UserProfilePage,\n    UserProfileLink\n  ];\n  react__WEBPACK_IMPORTED_MODULE_2__.Children.forEach(children, (child) => {\n    if (!excludedComponents.some((component) => isThatComponent(child, component))) {\n      sanitizedChildren.push(child);\n    }\n  });\n  return sanitizedChildren;\n};\nvar useCustomPages = (params, options) => {\n  const { children, LinkComponent, PageComponent, MenuItemsComponent, reorderItemsLabels, componentName } = params;\n  const { allowForAnyChildren = false } = options || {};\n  const validChildren = [];\n  react__WEBPACK_IMPORTED_MODULE_2__.Children.forEach(children, (child) => {\n    if (!isThatComponent(child, PageComponent) && !isThatComponent(child, LinkComponent) && !isThatComponent(child, MenuItemsComponent)) {\n      if (child && !allowForAnyChildren) {\n        (0,_clerk_shared_utils__WEBPACK_IMPORTED_MODULE_1__.logErrorInDevMode)((0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.customPagesIgnoredComponent)(componentName));\n      }\n      return;\n    }\n    const { props } = child;\n    const { children: children2, label, url, labelIcon } = props;\n    if (isThatComponent(child, PageComponent)) {\n      if (isReorderItem(props, reorderItemsLabels)) {\n        validChildren.push({ label });\n      } else if (isCustomPage(props)) {\n        validChildren.push({ label, labelIcon, children: children2, url });\n      } else {\n        (0,_clerk_shared_utils__WEBPACK_IMPORTED_MODULE_1__.logErrorInDevMode)((0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.customPageWrongProps)(componentName));\n        return;\n      }\n    }\n    if (isThatComponent(child, LinkComponent)) {\n      if (isExternalLink(props)) {\n        validChildren.push({ label, labelIcon, url });\n      } else {\n        (0,_clerk_shared_utils__WEBPACK_IMPORTED_MODULE_1__.logErrorInDevMode)((0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.customLinkWrongProps)(componentName));\n        return;\n      }\n    }\n  });\n  const customPageContents = [];\n  const customPageLabelIcons = [];\n  const customLinkLabelIcons = [];\n  validChildren.forEach((cp, index) => {\n    if (isCustomPage(cp)) {\n      customPageContents.push({ component: cp.children, id: index });\n      customPageLabelIcons.push({ component: cp.labelIcon, id: index });\n      return;\n    }\n    if (isExternalLink(cp)) {\n      customLinkLabelIcons.push({ component: cp.labelIcon, id: index });\n    }\n  });\n  const customPageContentsPortals = useCustomElementPortal(customPageContents);\n  const customPageLabelIconsPortals = useCustomElementPortal(customPageLabelIcons);\n  const customLinkLabelIconsPortals = useCustomElementPortal(customLinkLabelIcons);\n  const customPages = [];\n  const customPagesPortals = [];\n  validChildren.forEach((cp, index) => {\n    if (isReorderItem(cp, reorderItemsLabels)) {\n      customPages.push({ label: cp.label });\n      return;\n    }\n    if (isCustomPage(cp)) {\n      const {\n        portal: contentPortal,\n        mount,\n        unmount\n      } = customPageContentsPortals.find((p) => p.id === index);\n      const {\n        portal: labelPortal,\n        mount: mountIcon,\n        unmount: unmountIcon\n      } = customPageLabelIconsPortals.find((p) => p.id === index);\n      customPages.push({ label: cp.label, url: cp.url, mount, unmount, mountIcon, unmountIcon });\n      customPagesPortals.push(contentPortal);\n      customPagesPortals.push(labelPortal);\n      return;\n    }\n    if (isExternalLink(cp)) {\n      const {\n        portal: labelPortal,\n        mount: mountIcon,\n        unmount: unmountIcon\n      } = customLinkLabelIconsPortals.find((p) => p.id === index);\n      customPages.push({ label: cp.label, url: cp.url, mountIcon, unmountIcon });\n      customPagesPortals.push(labelPortal);\n      return;\n    }\n  });\n  return { customPages, customPagesPortals };\n};\nvar isReorderItem = (childProps, validItems) => {\n  const { children, label, url, labelIcon } = childProps;\n  return !children && !url && !labelIcon && validItems.some((v) => v === label);\n};\nvar isCustomPage = (childProps) => {\n  const { children, label, url, labelIcon } = childProps;\n  return !!children && !!url && !!labelIcon && !!label;\n};\nvar isExternalLink = (childProps) => {\n  const { children, label, url, labelIcon } = childProps;\n  return !children && !!url && !!labelIcon && !!label;\n};\n\n// src/utils/useCustomMenuItems.tsx\n\n\nvar useUserButtonCustomMenuItems = (children, options) => {\n  var _a;\n  const reorderItemsLabels = [\"manageAccount\", \"signOut\"];\n  return useCustomMenuItems({\n    children,\n    reorderItemsLabels,\n    MenuItemsComponent: MenuItems,\n    MenuActionComponent: MenuAction,\n    MenuLinkComponent: MenuLink,\n    UserProfileLinkComponent: UserProfileLink,\n    UserProfilePageComponent: UserProfilePage,\n    allowForAnyChildren: (_a = options == null ? void 0 : options.allowForAnyChildren) != null ? _a : false\n  });\n};\nvar useCustomMenuItems = ({\n  children,\n  MenuItemsComponent,\n  MenuActionComponent,\n  MenuLinkComponent,\n  UserProfileLinkComponent,\n  UserProfilePageComponent,\n  reorderItemsLabels,\n  allowForAnyChildren = false\n}) => {\n  const validChildren = [];\n  const customMenuItems = [];\n  const customMenuItemsPortals = [];\n  react__WEBPACK_IMPORTED_MODULE_2__.Children.forEach(children, (child) => {\n    if (!isThatComponent(child, MenuItemsComponent) && !isThatComponent(child, UserProfileLinkComponent) && !isThatComponent(child, UserProfilePageComponent)) {\n      if (child && !allowForAnyChildren) {\n        (0,_clerk_shared_utils__WEBPACK_IMPORTED_MODULE_1__.logErrorInDevMode)(_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.userButtonIgnoredComponent);\n      }\n      return;\n    }\n    if (isThatComponent(child, UserProfileLinkComponent) || isThatComponent(child, UserProfilePageComponent)) {\n      return;\n    }\n    const { props } = child;\n    react__WEBPACK_IMPORTED_MODULE_2__.Children.forEach(props.children, (child2) => {\n      if (!isThatComponent(child2, MenuActionComponent) && !isThatComponent(child2, MenuLinkComponent)) {\n        if (child2) {\n          (0,_clerk_shared_utils__WEBPACK_IMPORTED_MODULE_1__.logErrorInDevMode)(_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.customMenuItemsIgnoredComponent);\n        }\n        return;\n      }\n      const { props: props2 } = child2;\n      const { label, labelIcon, href, onClick, open } = props2;\n      if (isThatComponent(child2, MenuActionComponent)) {\n        if (isReorderItem2(props2, reorderItemsLabels)) {\n          validChildren.push({ label });\n        } else if (isCustomMenuItem(props2)) {\n          const baseItem = {\n            label,\n            labelIcon\n          };\n          if (onClick !== void 0) {\n            validChildren.push({\n              ...baseItem,\n              onClick\n            });\n          } else if (open !== void 0) {\n            validChildren.push({\n              ...baseItem,\n              open: open.startsWith(\"/\") ? open : `/${open}`\n            });\n          } else {\n            (0,_clerk_shared_utils__WEBPACK_IMPORTED_MODULE_1__.logErrorInDevMode)(\"Custom menu item must have either onClick or open property\");\n            return;\n          }\n        } else {\n          (0,_clerk_shared_utils__WEBPACK_IMPORTED_MODULE_1__.logErrorInDevMode)(_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.userButtonMenuItemsActionWrongsProps);\n          return;\n        }\n      }\n      if (isThatComponent(child2, MenuLinkComponent)) {\n        if (isExternalLink2(props2)) {\n          validChildren.push({ label, labelIcon, href });\n        } else {\n          (0,_clerk_shared_utils__WEBPACK_IMPORTED_MODULE_1__.logErrorInDevMode)(_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.userButtonMenuItemLinkWrongProps);\n          return;\n        }\n      }\n    });\n  });\n  const customMenuItemLabelIcons = [];\n  const customLinkLabelIcons = [];\n  validChildren.forEach((mi, index) => {\n    if (isCustomMenuItem(mi)) {\n      customMenuItemLabelIcons.push({ component: mi.labelIcon, id: index });\n    }\n    if (isExternalLink2(mi)) {\n      customLinkLabelIcons.push({ component: mi.labelIcon, id: index });\n    }\n  });\n  const customMenuItemLabelIconsPortals = useCustomElementPortal(customMenuItemLabelIcons);\n  const customLinkLabelIconsPortals = useCustomElementPortal(customLinkLabelIcons);\n  validChildren.forEach((mi, index) => {\n    if (isReorderItem2(mi, reorderItemsLabels)) {\n      customMenuItems.push({\n        label: mi.label\n      });\n    }\n    if (isCustomMenuItem(mi)) {\n      const {\n        portal: iconPortal,\n        mount: mountIcon,\n        unmount: unmountIcon\n      } = customMenuItemLabelIconsPortals.find((p) => p.id === index);\n      const menuItem = {\n        label: mi.label,\n        mountIcon,\n        unmountIcon\n      };\n      if (\"onClick\" in mi) {\n        menuItem.onClick = mi.onClick;\n      } else if (\"open\" in mi) {\n        menuItem.open = mi.open;\n      }\n      customMenuItems.push(menuItem);\n      customMenuItemsPortals.push(iconPortal);\n    }\n    if (isExternalLink2(mi)) {\n      const {\n        portal: iconPortal,\n        mount: mountIcon,\n        unmount: unmountIcon\n      } = customLinkLabelIconsPortals.find((p) => p.id === index);\n      customMenuItems.push({\n        label: mi.label,\n        href: mi.href,\n        mountIcon,\n        unmountIcon\n      });\n      customMenuItemsPortals.push(iconPortal);\n    }\n  });\n  return { customMenuItems, customMenuItemsPortals };\n};\nvar isReorderItem2 = (childProps, validItems) => {\n  const { children, label, onClick, labelIcon } = childProps;\n  return !children && !onClick && !labelIcon && validItems.some((v) => v === label);\n};\nvar isCustomMenuItem = (childProps) => {\n  const { label, labelIcon, onClick, open } = childProps;\n  return !!labelIcon && !!label && (typeof onClick === \"function\" || typeof open === \"string\");\n};\nvar isExternalLink2 = (childProps) => {\n  const { label, href, labelIcon } = childProps;\n  return !!href && !!labelIcon && !!label;\n};\n\n// src/utils/useWaitForComponentMount.ts\n\nvar createAwaitableMutationObserver = (globalOptions) => {\n  const isReady = globalOptions == null ? void 0 : globalOptions.isReady;\n  return (options) => new Promise((resolve, reject) => {\n    const { root = document == null ? void 0 : document.body, selector, timeout = 0 } = options;\n    if (!root) {\n      reject(new Error(\"No root element provided\"));\n      return;\n    }\n    let elementToWatch = root;\n    if (selector) {\n      elementToWatch = root == null ? void 0 : root.querySelector(selector);\n    }\n    if (isReady(elementToWatch, selector)) {\n      resolve();\n      return;\n    }\n    const observer = new MutationObserver((mutationsList) => {\n      for (const mutation of mutationsList) {\n        if (!elementToWatch && selector) {\n          elementToWatch = root == null ? void 0 : root.querySelector(selector);\n        }\n        if (globalOptions.childList && mutation.type === \"childList\" || globalOptions.attributes && mutation.type === \"attributes\") {\n          if (isReady(elementToWatch, selector)) {\n            observer.disconnect();\n            resolve();\n            return;\n          }\n        }\n      }\n    });\n    observer.observe(root, globalOptions);\n    if (timeout > 0) {\n      setTimeout(() => {\n        observer.disconnect();\n        reject(new Error(`Timeout waiting for ${selector}`));\n      }, timeout);\n    }\n  });\n};\nvar waitForElementChildren = createAwaitableMutationObserver({\n  childList: true,\n  subtree: true,\n  isReady: (el, selector) => {\n    var _a;\n    return !!(el == null ? void 0 : el.childElementCount) && ((_a = el == null ? void 0 : el.matches) == null ? void 0 : _a.call(el, selector)) && el.childElementCount > 0;\n  }\n});\nfunction useWaitForComponentMount(component, options) {\n  const watcherRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)();\n  const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"rendering\");\n  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(() => {\n    if (!component) {\n      throw new Error(\"Clerk: no component name provided, unable to detect mount.\");\n    }\n    if (typeof window !== \"undefined\" && !watcherRef.current) {\n      const defaultSelector = `[data-clerk-component=\"${component}\"]`;\n      const selector = options == null ? void 0 : options.selector;\n      watcherRef.current = waitForElementChildren({\n        selector: selector ? (\n          // Allows for `[data-clerk-component=\"xxxx\"][data-some-attribute=\"123\"] .my-class`\n          defaultSelector + selector\n        ) : defaultSelector\n      }).then(() => {\n        setStatus(\"rendered\");\n      }).catch(() => {\n        setStatus(\"error\");\n      });\n    }\n  }, [component, options == null ? void 0 : options.selector]);\n  return status;\n}\n\n// src/components/ClerkHostRenderer.tsx\n\n\n\nvar isMountProps = (props) => {\n  return \"mount\" in props;\n};\nvar isOpenProps = (props) => {\n  return \"open\" in props;\n};\nvar stripMenuItemIconHandlers = (menuItems) => {\n  return menuItems == null ? void 0 : menuItems.map(({ mountIcon, unmountIcon, ...rest }) => rest);\n};\nvar ClerkHostRenderer = class extends react__WEBPACK_IMPORTED_MODULE_2__.PureComponent {\n  constructor() {\n    super(...arguments);\n    this.rootRef = react__WEBPACK_IMPORTED_MODULE_2__.createRef();\n  }\n  componentDidUpdate(_prevProps) {\n    var _a, _b, _c, _d;\n    if (!isMountProps(_prevProps) || !isMountProps(this.props)) {\n      return;\n    }\n    const prevProps = (0,_clerk_shared_object__WEBPACK_IMPORTED_MODULE_4__.without)(_prevProps.props, \"customPages\", \"customMenuItems\", \"children\");\n    const newProps = (0,_clerk_shared_object__WEBPACK_IMPORTED_MODULE_4__.without)(this.props.props, \"customPages\", \"customMenuItems\", \"children\");\n    const customPagesChanged = ((_a = prevProps.customPages) == null ? void 0 : _a.length) !== ((_b = newProps.customPages) == null ? void 0 : _b.length);\n    const customMenuItemsChanged = ((_c = prevProps.customMenuItems) == null ? void 0 : _c.length) !== ((_d = newProps.customMenuItems) == null ? void 0 : _d.length);\n    const prevMenuItemsWithoutHandlers = stripMenuItemIconHandlers(_prevProps.props.customMenuItems);\n    const newMenuItemsWithoutHandlers = stripMenuItemIconHandlers(this.props.props.customMenuItems);\n    if (!(0,_clerk_shared_react__WEBPACK_IMPORTED_MODULE_5__.isDeeplyEqual)(prevProps, newProps) || !(0,_clerk_shared_react__WEBPACK_IMPORTED_MODULE_5__.isDeeplyEqual)(prevMenuItemsWithoutHandlers, newMenuItemsWithoutHandlers) || customPagesChanged || customMenuItemsChanged) {\n      if (this.rootRef.current) {\n        this.props.updateProps({ node: this.rootRef.current, props: this.props.props });\n      }\n    }\n  }\n  componentDidMount() {\n    if (this.rootRef.current) {\n      if (isMountProps(this.props)) {\n        this.props.mount(this.rootRef.current, this.props.props);\n      }\n      if (isOpenProps(this.props)) {\n        this.props.open(this.props.props);\n      }\n    }\n  }\n  componentWillUnmount() {\n    if (this.rootRef.current) {\n      if (isMountProps(this.props)) {\n        this.props.unmount(this.rootRef.current);\n      }\n      if (isOpenProps(this.props)) {\n        this.props.close();\n      }\n    }\n  }\n  render() {\n    const { hideRootHtmlElement = false } = this.props;\n    const rootAttributes = {\n      ref: this.rootRef,\n      ...this.props.rootProps,\n      ...this.props.component && { \"data-clerk-component\": this.props.component }\n    };\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, !hideRootHtmlElement && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"div\", { ...rootAttributes }), this.props.children);\n  }\n};\n\n// src/components/uiComponents.tsx\nvar CustomPortalsRenderer = (props) => {\n  var _a, _b;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, (_a = props == null ? void 0 : props.customPagesPortals) == null ? void 0 : _a.map((portal, index) => (0,react__WEBPACK_IMPORTED_MODULE_2__.createElement)(portal, { key: index })), (_b = props == null ? void 0 : props.customMenuItemsPortals) == null ? void 0 : _b.map((portal, index) => (0,react__WEBPACK_IMPORTED_MODULE_2__.createElement)(portal, { key: index })));\n};\nvar SignIn = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(\n  ({ clerk, component, fallback, ...props }) => {\n    const mountingStatus = useWaitForComponentMount(component);\n    const shouldShowFallback = mountingStatus === \"rendering\" || !clerk.loaded;\n    const rendererRootProps = {\n      ...shouldShowFallback && fallback && { style: { display: \"none\" } }\n    };\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, shouldShowFallback && fallback, clerk.loaded && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\n      ClerkHostRenderer,\n      {\n        component,\n        mount: clerk.mountSignIn,\n        unmount: clerk.unmountSignIn,\n        updateProps: clerk.__unstable__updateProps,\n        props,\n        rootProps: rendererRootProps\n      }\n    ));\n  },\n  { component: \"SignIn\", renderWhileLoading: true }\n);\nvar SignUp = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(\n  ({ clerk, component, fallback, ...props }) => {\n    const mountingStatus = useWaitForComponentMount(component);\n    const shouldShowFallback = mountingStatus === \"rendering\" || !clerk.loaded;\n    const rendererRootProps = {\n      ...shouldShowFallback && fallback && { style: { display: \"none\" } }\n    };\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, shouldShowFallback && fallback, clerk.loaded && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\n      ClerkHostRenderer,\n      {\n        component,\n        mount: clerk.mountSignUp,\n        unmount: clerk.unmountSignUp,\n        updateProps: clerk.__unstable__updateProps,\n        props,\n        rootProps: rendererRootProps\n      }\n    ));\n  },\n  { component: \"SignUp\", renderWhileLoading: true }\n);\nfunction UserProfilePage({ children }) {\n  (0,_clerk_shared_utils__WEBPACK_IMPORTED_MODULE_1__.logErrorInDevMode)(_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.userProfilePageRenderedError);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, children);\n}\nfunction UserProfileLink({ children }) {\n  (0,_clerk_shared_utils__WEBPACK_IMPORTED_MODULE_1__.logErrorInDevMode)(_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.userProfileLinkRenderedError);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, children);\n}\nvar _UserProfile = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(\n  ({\n    clerk,\n    component,\n    fallback,\n    ...props\n  }) => {\n    const mountingStatus = useWaitForComponentMount(component);\n    const shouldShowFallback = mountingStatus === \"rendering\" || !clerk.loaded;\n    const rendererRootProps = {\n      ...shouldShowFallback && fallback && { style: { display: \"none\" } }\n    };\n    const { customPages, customPagesPortals } = useUserProfileCustomPages(props.children);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, shouldShowFallback && fallback, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\n      ClerkHostRenderer,\n      {\n        component,\n        mount: clerk.mountUserProfile,\n        unmount: clerk.unmountUserProfile,\n        updateProps: clerk.__unstable__updateProps,\n        props: { ...props, customPages },\n        rootProps: rendererRootProps\n      },\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(CustomPortalsRenderer, { customPagesPortals })\n    ));\n  },\n  { component: \"UserProfile\", renderWhileLoading: true }\n);\nvar UserProfile = Object.assign(_UserProfile, {\n  Page: UserProfilePage,\n  Link: UserProfileLink\n});\nvar UserButtonContext = (0,react__WEBPACK_IMPORTED_MODULE_2__.createContext)({\n  mount: () => {\n  },\n  unmount: () => {\n  },\n  updateProps: () => {\n  }\n});\nvar _UserButton = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(\n  ({\n    clerk,\n    component,\n    fallback,\n    ...props\n  }) => {\n    const mountingStatus = useWaitForComponentMount(component);\n    const shouldShowFallback = mountingStatus === \"rendering\" || !clerk.loaded;\n    const rendererRootProps = {\n      ...shouldShowFallback && fallback && { style: { display: \"none\" } }\n    };\n    const { customPages, customPagesPortals } = useUserProfileCustomPages(props.children, {\n      allowForAnyChildren: !!props.__experimental_asProvider\n    });\n    const userProfileProps = Object.assign(props.userProfileProps || {}, { customPages });\n    const { customMenuItems, customMenuItemsPortals } = useUserButtonCustomMenuItems(props.children, {\n      allowForAnyChildren: !!props.__experimental_asProvider\n    });\n    const sanitizedChildren = useSanitizedChildren(props.children);\n    const passableProps = {\n      mount: clerk.mountUserButton,\n      unmount: clerk.unmountUserButton,\n      updateProps: clerk.__unstable__updateProps,\n      props: { ...props, userProfileProps, customMenuItems }\n    };\n    const portalProps = {\n      customPagesPortals,\n      customMenuItemsPortals\n    };\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(UserButtonContext.Provider, { value: passableProps }, shouldShowFallback && fallback, clerk.loaded && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\n      ClerkHostRenderer,\n      {\n        component,\n        ...passableProps,\n        hideRootHtmlElement: !!props.__experimental_asProvider,\n        rootProps: rendererRootProps\n      },\n      props.__experimental_asProvider ? sanitizedChildren : null,\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(CustomPortalsRenderer, { ...portalProps })\n    ));\n  },\n  { component: \"UserButton\", renderWhileLoading: true }\n);\nfunction MenuItems({ children }) {\n  (0,_clerk_shared_utils__WEBPACK_IMPORTED_MODULE_1__.logErrorInDevMode)(_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.userButtonMenuItemsRenderedError);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, children);\n}\nfunction MenuAction({ children }) {\n  (0,_clerk_shared_utils__WEBPACK_IMPORTED_MODULE_1__.logErrorInDevMode)(_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.userButtonMenuActionRenderedError);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, children);\n}\nfunction MenuLink({ children }) {\n  (0,_clerk_shared_utils__WEBPACK_IMPORTED_MODULE_1__.logErrorInDevMode)(_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.userButtonMenuLinkRenderedError);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, children);\n}\nfunction UserButtonOutlet(outletProps) {\n  const providerProps = (0,react__WEBPACK_IMPORTED_MODULE_2__.useContext)(UserButtonContext);\n  const portalProps = {\n    ...providerProps,\n    props: {\n      ...providerProps.props,\n      ...outletProps\n    }\n  };\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(ClerkHostRenderer, { ...portalProps });\n}\nvar UserButton = Object.assign(_UserButton, {\n  UserProfilePage,\n  UserProfileLink,\n  MenuItems,\n  Action: MenuAction,\n  Link: MenuLink,\n  __experimental_Outlet: UserButtonOutlet\n});\nfunction OrganizationProfilePage({ children }) {\n  (0,_clerk_shared_utils__WEBPACK_IMPORTED_MODULE_1__.logErrorInDevMode)(_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.organizationProfilePageRenderedError);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, children);\n}\nfunction OrganizationProfileLink({ children }) {\n  (0,_clerk_shared_utils__WEBPACK_IMPORTED_MODULE_1__.logErrorInDevMode)(_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.organizationProfileLinkRenderedError);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, children);\n}\nvar _OrganizationProfile = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(\n  ({\n    clerk,\n    component,\n    fallback,\n    ...props\n  }) => {\n    const mountingStatus = useWaitForComponentMount(component);\n    const shouldShowFallback = mountingStatus === \"rendering\" || !clerk.loaded;\n    const rendererRootProps = {\n      ...shouldShowFallback && fallback && { style: { display: \"none\" } }\n    };\n    const { customPages, customPagesPortals } = useOrganizationProfileCustomPages(props.children);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, shouldShowFallback && fallback, clerk.loaded && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\n      ClerkHostRenderer,\n      {\n        component,\n        mount: clerk.mountOrganizationProfile,\n        unmount: clerk.unmountOrganizationProfile,\n        updateProps: clerk.__unstable__updateProps,\n        props: { ...props, customPages },\n        rootProps: rendererRootProps\n      },\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(CustomPortalsRenderer, { customPagesPortals })\n    ));\n  },\n  { component: \"OrganizationProfile\", renderWhileLoading: true }\n);\nvar OrganizationProfile = Object.assign(_OrganizationProfile, {\n  Page: OrganizationProfilePage,\n  Link: OrganizationProfileLink\n});\nvar CreateOrganization = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(\n  ({ clerk, component, fallback, ...props }) => {\n    const mountingStatus = useWaitForComponentMount(component);\n    const shouldShowFallback = mountingStatus === \"rendering\" || !clerk.loaded;\n    const rendererRootProps = {\n      ...shouldShowFallback && fallback && { style: { display: \"none\" } }\n    };\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, shouldShowFallback && fallback, clerk.loaded && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\n      ClerkHostRenderer,\n      {\n        component,\n        mount: clerk.mountCreateOrganization,\n        unmount: clerk.unmountCreateOrganization,\n        updateProps: clerk.__unstable__updateProps,\n        props,\n        rootProps: rendererRootProps\n      }\n    ));\n  },\n  { component: \"CreateOrganization\", renderWhileLoading: true }\n);\nvar OrganizationSwitcherContext = (0,react__WEBPACK_IMPORTED_MODULE_2__.createContext)({\n  mount: () => {\n  },\n  unmount: () => {\n  },\n  updateProps: () => {\n  }\n});\nvar _OrganizationSwitcher = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(\n  ({\n    clerk,\n    component,\n    fallback,\n    ...props\n  }) => {\n    const mountingStatus = useWaitForComponentMount(component);\n    const shouldShowFallback = mountingStatus === \"rendering\" || !clerk.loaded;\n    const rendererRootProps = {\n      ...shouldShowFallback && fallback && { style: { display: \"none\" } }\n    };\n    const { customPages, customPagesPortals } = useOrganizationProfileCustomPages(props.children, {\n      allowForAnyChildren: !!props.__experimental_asProvider\n    });\n    const organizationProfileProps = Object.assign(props.organizationProfileProps || {}, { customPages });\n    const sanitizedChildren = useSanitizedChildren(props.children);\n    const passableProps = {\n      mount: clerk.mountOrganizationSwitcher,\n      unmount: clerk.unmountOrganizationSwitcher,\n      updateProps: clerk.__unstable__updateProps,\n      props: { ...props, organizationProfileProps },\n      rootProps: rendererRootProps,\n      component\n    };\n    clerk.__experimental_prefetchOrganizationSwitcher();\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(OrganizationSwitcherContext.Provider, { value: passableProps }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, shouldShowFallback && fallback, clerk.loaded && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\n      ClerkHostRenderer,\n      {\n        ...passableProps,\n        hideRootHtmlElement: !!props.__experimental_asProvider\n      },\n      props.__experimental_asProvider ? sanitizedChildren : null,\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(CustomPortalsRenderer, { customPagesPortals })\n    )));\n  },\n  { component: \"OrganizationSwitcher\", renderWhileLoading: true }\n);\nfunction OrganizationSwitcherOutlet(outletProps) {\n  const providerProps = (0,react__WEBPACK_IMPORTED_MODULE_2__.useContext)(OrganizationSwitcherContext);\n  const portalProps = {\n    ...providerProps,\n    props: {\n      ...providerProps.props,\n      ...outletProps\n    }\n  };\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(ClerkHostRenderer, { ...portalProps });\n}\nvar OrganizationSwitcher = Object.assign(_OrganizationSwitcher, {\n  OrganizationProfilePage,\n  OrganizationProfileLink,\n  __experimental_Outlet: OrganizationSwitcherOutlet\n});\nvar OrganizationList = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(\n  ({ clerk, component, fallback, ...props }) => {\n    const mountingStatus = useWaitForComponentMount(component);\n    const shouldShowFallback = mountingStatus === \"rendering\" || !clerk.loaded;\n    const rendererRootProps = {\n      ...shouldShowFallback && fallback && { style: { display: \"none\" } }\n    };\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, shouldShowFallback && fallback, clerk.loaded && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\n      ClerkHostRenderer,\n      {\n        component,\n        mount: clerk.mountOrganizationList,\n        unmount: clerk.unmountOrganizationList,\n        updateProps: clerk.__unstable__updateProps,\n        props,\n        rootProps: rendererRootProps\n      }\n    ));\n  },\n  { component: \"OrganizationList\", renderWhileLoading: true }\n);\nvar GoogleOneTap = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(\n  ({ clerk, component, fallback, ...props }) => {\n    const mountingStatus = useWaitForComponentMount(component);\n    const shouldShowFallback = mountingStatus === \"rendering\" || !clerk.loaded;\n    const rendererRootProps = {\n      ...shouldShowFallback && fallback && { style: { display: \"none\" } }\n    };\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, shouldShowFallback && fallback, clerk.loaded && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\n      ClerkHostRenderer,\n      {\n        component,\n        open: clerk.openGoogleOneTap,\n        close: clerk.closeGoogleOneTap,\n        updateProps: clerk.__unstable__updateProps,\n        props,\n        rootProps: rendererRootProps\n      }\n    ));\n  },\n  { component: \"GoogleOneTap\", renderWhileLoading: true }\n);\nvar Waitlist = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(\n  ({ clerk, component, fallback, ...props }) => {\n    const mountingStatus = useWaitForComponentMount(component);\n    const shouldShowFallback = mountingStatus === \"rendering\" || !clerk.loaded;\n    const rendererRootProps = {\n      ...shouldShowFallback && fallback && { style: { display: \"none\" } }\n    };\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, shouldShowFallback && fallback, clerk.loaded && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\n      ClerkHostRenderer,\n      {\n        component,\n        mount: clerk.mountWaitlist,\n        unmount: clerk.unmountWaitlist,\n        updateProps: clerk.__unstable__updateProps,\n        props,\n        rootProps: rendererRootProps\n      }\n    ));\n  },\n  { component: \"Waitlist\", renderWhileLoading: true }\n);\nvar PricingTable = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(\n  ({ clerk, component, fallback, ...props }) => {\n    const mountingStatus = useWaitForComponentMount(component, {\n      // This attribute is added to the PricingTable root element after we've successfully fetched the plans asynchronously.\n      selector: '[data-component-status=\"ready\"]'\n    });\n    const shouldShowFallback = mountingStatus === \"rendering\" || !clerk.loaded;\n    const rendererRootProps = {\n      ...shouldShowFallback && fallback && { style: { display: \"none\" } }\n    };\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, shouldShowFallback && fallback, clerk.loaded && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\n      ClerkHostRenderer,\n      {\n        component,\n        mount: clerk.mountPricingTable,\n        unmount: clerk.unmountPricingTable,\n        updateProps: clerk.__unstable__updateProps,\n        props,\n        rootProps: rendererRootProps\n      }\n    ));\n  },\n  { component: \"PricingTable\", renderWhileLoading: true }\n);\nvar APIKeys = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(\n  ({ clerk, component, fallback, ...props }) => {\n    const mountingStatus = useWaitForComponentMount(component);\n    const shouldShowFallback = mountingStatus === \"rendering\" || !clerk.loaded;\n    const rendererRootProps = {\n      ...shouldShowFallback && fallback && { style: { display: \"none\" } }\n    };\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, shouldShowFallback && fallback, clerk.loaded && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\n      ClerkHostRenderer,\n      {\n        component,\n        mount: clerk.mountApiKeys,\n        unmount: clerk.unmountApiKeys,\n        updateProps: clerk.__unstable__updateProps,\n        props,\n        rootProps: rendererRootProps\n      }\n    ));\n  },\n  { component: \"ApiKeys\", renderWhileLoading: true }\n);\nvar UserAvatar = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(\n  ({ clerk, component, fallback, ...props }) => {\n    const mountingStatus = useWaitForComponentMount(component);\n    const shouldShowFallback = mountingStatus === \"rendering\" || !clerk.loaded;\n    const rendererRootProps = {\n      ...shouldShowFallback && fallback && { style: { display: \"none\" } }\n    };\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, shouldShowFallback && fallback, clerk.loaded && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\n      ClerkHostRenderer,\n      {\n        component,\n        mount: clerk.mountUserAvatar,\n        unmount: clerk.unmountUserAvatar,\n        updateProps: clerk.__unstable__updateProps,\n        props,\n        rootProps: rendererRootProps\n      }\n    ));\n  },\n  { component: \"UserAvatar\", renderWhileLoading: true }\n);\nvar TaskChooseOrganization = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(\n  ({ clerk, component, fallback, ...props }) => {\n    const mountingStatus = useWaitForComponentMount(component);\n    const shouldShowFallback = mountingStatus === \"rendering\" || !clerk.loaded;\n    const rendererRootProps = {\n      ...shouldShowFallback && fallback && { style: { display: \"none\" } }\n    };\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, shouldShowFallback && fallback, clerk.loaded && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\n      ClerkHostRenderer,\n      {\n        component,\n        mount: clerk.mountTaskChooseOrganization,\n        unmount: clerk.unmountTaskChooseOrganization,\n        updateProps: clerk.__unstable__updateProps,\n        props,\n        rootProps: rendererRootProps\n      }\n    ));\n  },\n  { component: \"TaskChooseOrganization\", renderWhileLoading: true }\n);\n\n\n//# sourceMappingURL=chunk-SOK75ZUK.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvY2xlcmstcmVhY3QvZGlzdC9jaHVuay1TT0s3NVpVSy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCOEI7O0FBRTlCO0FBQzhFO0FBQ0w7O0FBRXpFO0FBQzBCO0FBQzFCO0FBQ0E7QUFDQSxXQUFXLDJDQUFjO0FBQ3pCLElBQUk7QUFDSixXQUFXLDZEQUFZLE9BQU8sc0ZBQWlDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdEQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzJCO0FBQzNCO0FBQ0E7QUFDQSxFQUFFLDRDQUFnQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYSw2REFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQW9CLHFCQUFxQixVQUFVO0FBQzlFO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTs7QUFFQTtBQUNpQztBQUNRO0FBQ3pDO0FBQ0EsZ0NBQWdDLCtDQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQkFBb0IsdURBQVk7QUFDaEM7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDd0Q7QUFDN0I7O0FBRTNCO0FBQzJCO0FBQzNCO0FBQ0EsZ0JBQWdCLGlEQUFxQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FB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O0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBLDJCQUEyQixnREFBb0IsQ0FBQywyQ0FBZSx3RUFBd0UsZ0RBQW9CO0FBQzNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILElBQUk7QUFDSjtBQUNBLDZCQUE2Qiw4REFBUztBQUN0QyxLQUFLLHNDQUFzQztBQUMzQztBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBLDJCQUEyQixnREFBb0IsQ0FBQywyQ0FBZSx3RUFBd0UsZ0RBQW9CO0FBQzNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILElBQUk7QUFDSjs7QUFzQkU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2lzaGFxYmVsbG8vV2Vic2l0ZS9oYXZlbnJpZGVfZnVsbF9hcHAvbm9kZV9tb2R1bGVzL0BjbGVyay9jbGVyay1yZWFjdC9kaXN0L2NodW5rLVNPSzc1WlVLLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBjdXN0b21MaW5rV3JvbmdQcm9wcyxcbiAgY3VzdG9tTWVudUl0ZW1zSWdub3JlZENvbXBvbmVudCxcbiAgY3VzdG9tUGFnZVdyb25nUHJvcHMsXG4gIGN1c3RvbVBhZ2VzSWdub3JlZENvbXBvbmVudCxcbiAgZXJyb3JUaHJvd2VyLFxuICBtdWx0aXBsZUNoaWxkcmVuSW5CdXR0b25Db21wb25lbnQsXG4gIG9yZ2FuaXphdGlvblByb2ZpbGVMaW5rUmVuZGVyZWRFcnJvcixcbiAgb3JnYW5pemF0aW9uUHJvZmlsZVBhZ2VSZW5kZXJlZEVycm9yLFxuICB1c2VyQnV0dG9uSWdub3JlZENvbXBvbmVudCxcbiAgdXNlckJ1dHRvbk1lbnVBY3Rpb25SZW5kZXJlZEVycm9yLFxuICB1c2VyQnV0dG9uTWVudUl0ZW1MaW5rV3JvbmdQcm9wcyxcbiAgdXNlckJ1dHRvbk1lbnVJdGVtc0FjdGlvbldyb25nc1Byb3BzLFxuICB1c2VyQnV0dG9uTWVudUl0ZW1zUmVuZGVyZWRFcnJvcixcbiAgdXNlckJ1dHRvbk1lbnVMaW5rUmVuZGVyZWRFcnJvcixcbiAgdXNlclByb2ZpbGVMaW5rUmVuZGVyZWRFcnJvcixcbiAgdXNlclByb2ZpbGVQYWdlUmVuZGVyZWRFcnJvcixcbiAgd2l0aENsZXJrXG59IGZyb20gXCIuL2NodW5rLVhJVlhMNExRLm1qc1wiO1xuXG4vLyBzcmMvY29tcG9uZW50cy91aUNvbXBvbmVudHMudHN4XG5pbXBvcnQgeyBsb2dFcnJvckluRGV2TW9kZSBhcyBsb2dFcnJvckluRGV2TW9kZTMgfSBmcm9tIFwiQGNsZXJrL3NoYXJlZC91dGlsc1wiO1xuaW1wb3J0IFJlYWN0NywgeyBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCB1c2VDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy91dGlscy9jaGlsZHJlblV0aWxzLnRzeFxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xudmFyIGFzc2VydFNpbmdsZUNoaWxkID0gKGNoaWxkcmVuKSA9PiAobmFtZSkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGVycm9yVGhyb3dlci50aHJvdyhtdWx0aXBsZUNoaWxkcmVuSW5CdXR0b25Db21wb25lbnQobmFtZSkpO1xuICB9XG59O1xudmFyIG5vcm1hbGl6ZVdpdGhEZWZhdWx0VmFsdWUgPSAoY2hpbGRyZW4sIGRlZmF1bHRUZXh0KSA9PiB7XG4gIGlmICghY2hpbGRyZW4pIHtcbiAgICBjaGlsZHJlbiA9IGRlZmF1bHRUZXh0O1xuICB9XG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICBjaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIG51bGwsIGNoaWxkcmVuKTtcbiAgfVxuICByZXR1cm4gY2hpbGRyZW47XG59O1xudmFyIHNhZmVFeGVjdXRlID0gKGNiKSA9PiAoLi4uYXJncykgPT4ge1xuICBpZiAoY2IgJiYgdHlwZW9mIGNiID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gY2IoLi4uYXJncyk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9pc0NvbnN0cnVjdG9yLnRzXG5mdW5jdGlvbiBpc0NvbnN0cnVjdG9yKGYpIHtcbiAgcmV0dXJuIHR5cGVvZiBmID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8vIHNyYy91dGlscy91c2VNYXhBbGxvd2VkSW5zdGFuY2VzR3VhcmQudHN4XG5pbXBvcnQgUmVhY3QyIGZyb20gXCJyZWFjdFwiO1xudmFyIGNvdW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiB1c2VNYXhBbGxvd2VkSW5zdGFuY2VzR3VhcmQobmFtZSwgZXJyb3IsIG1heENvdW50ID0gMSkge1xuICBSZWFjdDIudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjb3VudCA9IGNvdW50cy5nZXQobmFtZSkgfHwgMDtcbiAgICBpZiAoY291bnQgPT0gbWF4Q291bnQpIHtcbiAgICAgIHJldHVybiBlcnJvclRocm93ZXIudGhyb3coZXJyb3IpO1xuICAgIH1cbiAgICBjb3VudHMuc2V0KG5hbWUsIGNvdW50ICsgMSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvdW50cy5zZXQobmFtZSwgKGNvdW50cy5nZXQobmFtZSkgfHwgMSkgLSAxKTtcbiAgICB9O1xuICB9LCBbXSk7XG59XG5mdW5jdGlvbiB3aXRoTWF4QWxsb3dlZEluc3RhbmNlc0d1YXJkKFdyYXBwZWRDb21wb25lbnQsIG5hbWUsIGVycm9yKSB7XG4gIGNvbnN0IGRpc3BsYXlOYW1lID0gV3JhcHBlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBXcmFwcGVkQ29tcG9uZW50Lm5hbWUgfHwgbmFtZSB8fCBcIkNvbXBvbmVudFwiO1xuICBjb25zdCBIb2MgPSAocHJvcHMpID0+IHtcbiAgICB1c2VNYXhBbGxvd2VkSW5zdGFuY2VzR3VhcmQobmFtZSwgZXJyb3IpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoV3JhcHBlZENvbXBvbmVudCwgeyAuLi5wcm9wcyB9KTtcbiAgfTtcbiAgSG9jLmRpc3BsYXlOYW1lID0gYHdpdGhNYXhBbGxvd2VkSW5zdGFuY2VzR3VhcmQoJHtkaXNwbGF5TmFtZX0pYDtcbiAgcmV0dXJuIEhvYztcbn1cblxuLy8gc3JjL3V0aWxzL3VzZUN1c3RvbUVsZW1lbnRQb3J0YWwudHN4XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSBcInJlYWN0LWRvbVwiO1xudmFyIHVzZUN1c3RvbUVsZW1lbnRQb3J0YWwgPSAoZWxlbWVudHMpID0+IHtcbiAgY29uc3QgW25vZGVNYXAsIHNldE5vZGVNYXBdID0gdXNlU3RhdGUoLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIHJldHVybiBlbGVtZW50cy5tYXAoKGVsKSA9PiAoe1xuICAgIGlkOiBlbC5pZCxcbiAgICBtb3VudDogKG5vZGUpID0+IHNldE5vZGVNYXAoKHByZXYpID0+IG5ldyBNYXAocHJldikuc2V0KFN0cmluZyhlbC5pZCksIG5vZGUpKSxcbiAgICB1bm1vdW50OiAoKSA9PiBzZXROb2RlTWFwKChwcmV2KSA9PiB7XG4gICAgICBjb25zdCBuZXdNYXAgPSBuZXcgTWFwKHByZXYpO1xuICAgICAgbmV3TWFwLnNldChTdHJpbmcoZWwuaWQpLCBudWxsKTtcbiAgICAgIHJldHVybiBuZXdNYXA7XG4gICAgfSksXG4gICAgcG9ydGFsOiAoKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZU1hcC5nZXQoU3RyaW5nKGVsLmlkKSk7XG4gICAgICByZXR1cm4gbm9kZSA/IGNyZWF0ZVBvcnRhbChlbC5jb21wb25lbnQsIG5vZGUpIDogbnVsbDtcbiAgICB9XG4gIH0pKTtcbn07XG5cbi8vIHNyYy91dGlscy91c2VDdXN0b21QYWdlcy50c3hcbmltcG9ydCB7IGxvZ0Vycm9ySW5EZXZNb2RlIH0gZnJvbSBcIkBjbGVyay9zaGFyZWQvdXRpbHNcIjtcbmltcG9ydCBSZWFjdDQgZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy91dGlscy9jb21wb25lbnRWYWxpZGF0aW9uLnRzXG5pbXBvcnQgUmVhY3QzIGZyb20gXCJyZWFjdFwiO1xudmFyIGlzVGhhdENvbXBvbmVudCA9ICh2LCBjb21wb25lbnQpID0+IHtcbiAgcmV0dXJuICEhdiAmJiBSZWFjdDMuaXNWYWxpZEVsZW1lbnQodikgJiYgKHYgPT0gbnVsbCA/IHZvaWQgMCA6IHYudHlwZSkgPT09IGNvbXBvbmVudDtcbn07XG5cbi8vIHNyYy91dGlscy91c2VDdXN0b21QYWdlcy50c3hcbnZhciB1c2VVc2VyUHJvZmlsZUN1c3RvbVBhZ2VzID0gKGNoaWxkcmVuLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHJlb3JkZXJJdGVtc0xhYmVscyA9IFtcImFjY291bnRcIiwgXCJzZWN1cml0eVwiXTtcbiAgcmV0dXJuIHVzZUN1c3RvbVBhZ2VzKFxuICAgIHtcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcmVvcmRlckl0ZW1zTGFiZWxzLFxuICAgICAgTGlua0NvbXBvbmVudDogVXNlclByb2ZpbGVMaW5rLFxuICAgICAgUGFnZUNvbXBvbmVudDogVXNlclByb2ZpbGVQYWdlLFxuICAgICAgTWVudUl0ZW1zQ29tcG9uZW50OiBNZW51SXRlbXMsXG4gICAgICBjb21wb25lbnROYW1lOiBcIlVzZXJQcm9maWxlXCJcbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbn07XG52YXIgdXNlT3JnYW5pemF0aW9uUHJvZmlsZUN1c3RvbVBhZ2VzID0gKGNoaWxkcmVuLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHJlb3JkZXJJdGVtc0xhYmVscyA9IFtcImdlbmVyYWxcIiwgXCJtZW1iZXJzXCJdO1xuICByZXR1cm4gdXNlQ3VzdG9tUGFnZXMoXG4gICAge1xuICAgICAgY2hpbGRyZW4sXG4gICAgICByZW9yZGVySXRlbXNMYWJlbHMsXG4gICAgICBMaW5rQ29tcG9uZW50OiBPcmdhbml6YXRpb25Qcm9maWxlTGluayxcbiAgICAgIFBhZ2VDb21wb25lbnQ6IE9yZ2FuaXphdGlvblByb2ZpbGVQYWdlLFxuICAgICAgY29tcG9uZW50TmFtZTogXCJPcmdhbml6YXRpb25Qcm9maWxlXCJcbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbn07XG52YXIgdXNlU2FuaXRpemVkQ2hpbGRyZW4gPSAoY2hpbGRyZW4pID0+IHtcbiAgY29uc3Qgc2FuaXRpemVkQ2hpbGRyZW4gPSBbXTtcbiAgY29uc3QgZXhjbHVkZWRDb21wb25lbnRzID0gW1xuICAgIE9yZ2FuaXphdGlvblByb2ZpbGVMaW5rLFxuICAgIE9yZ2FuaXphdGlvblByb2ZpbGVQYWdlLFxuICAgIE1lbnVJdGVtcyxcbiAgICBVc2VyUHJvZmlsZVBhZ2UsXG4gICAgVXNlclByb2ZpbGVMaW5rXG4gIF07XG4gIFJlYWN0NC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICBpZiAoIWV4Y2x1ZGVkQ29tcG9uZW50cy5zb21lKChjb21wb25lbnQpID0+IGlzVGhhdENvbXBvbmVudChjaGlsZCwgY29tcG9uZW50KSkpIHtcbiAgICAgIHNhbml0aXplZENoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzYW5pdGl6ZWRDaGlsZHJlbjtcbn07XG52YXIgdXNlQ3VzdG9tUGFnZXMgPSAocGFyYW1zLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIExpbmtDb21wb25lbnQsIFBhZ2VDb21wb25lbnQsIE1lbnVJdGVtc0NvbXBvbmVudCwgcmVvcmRlckl0ZW1zTGFiZWxzLCBjb21wb25lbnROYW1lIH0gPSBwYXJhbXM7XG4gIGNvbnN0IHsgYWxsb3dGb3JBbnlDaGlsZHJlbiA9IGZhbHNlIH0gPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCB2YWxpZENoaWxkcmVuID0gW107XG4gIFJlYWN0NC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICBpZiAoIWlzVGhhdENvbXBvbmVudChjaGlsZCwgUGFnZUNvbXBvbmVudCkgJiYgIWlzVGhhdENvbXBvbmVudChjaGlsZCwgTGlua0NvbXBvbmVudCkgJiYgIWlzVGhhdENvbXBvbmVudChjaGlsZCwgTWVudUl0ZW1zQ29tcG9uZW50KSkge1xuICAgICAgaWYgKGNoaWxkICYmICFhbGxvd0ZvckFueUNoaWxkcmVuKSB7XG4gICAgICAgIGxvZ0Vycm9ySW5EZXZNb2RlKGN1c3RvbVBhZ2VzSWdub3JlZENvbXBvbmVudChjb21wb25lbnROYW1lKSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgcHJvcHMgfSA9IGNoaWxkO1xuICAgIGNvbnN0IHsgY2hpbGRyZW46IGNoaWxkcmVuMiwgbGFiZWwsIHVybCwgbGFiZWxJY29uIH0gPSBwcm9wcztcbiAgICBpZiAoaXNUaGF0Q29tcG9uZW50KGNoaWxkLCBQYWdlQ29tcG9uZW50KSkge1xuICAgICAgaWYgKGlzUmVvcmRlckl0ZW0ocHJvcHMsIHJlb3JkZXJJdGVtc0xhYmVscykpIHtcbiAgICAgICAgdmFsaWRDaGlsZHJlbi5wdXNoKHsgbGFiZWwgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tUGFnZShwcm9wcykpIHtcbiAgICAgICAgdmFsaWRDaGlsZHJlbi5wdXNoKHsgbGFiZWwsIGxhYmVsSWNvbiwgY2hpbGRyZW46IGNoaWxkcmVuMiwgdXJsIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nRXJyb3JJbkRldk1vZGUoY3VzdG9tUGFnZVdyb25nUHJvcHMoY29tcG9uZW50TmFtZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1RoYXRDb21wb25lbnQoY2hpbGQsIExpbmtDb21wb25lbnQpKSB7XG4gICAgICBpZiAoaXNFeHRlcm5hbExpbmsocHJvcHMpKSB7XG4gICAgICAgIHZhbGlkQ2hpbGRyZW4ucHVzaCh7IGxhYmVsLCBsYWJlbEljb24sIHVybCB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ0Vycm9ySW5EZXZNb2RlKGN1c3RvbUxpbmtXcm9uZ1Byb3BzKGNvbXBvbmVudE5hbWUpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGN1c3RvbVBhZ2VDb250ZW50cyA9IFtdO1xuICBjb25zdCBjdXN0b21QYWdlTGFiZWxJY29ucyA9IFtdO1xuICBjb25zdCBjdXN0b21MaW5rTGFiZWxJY29ucyA9IFtdO1xuICB2YWxpZENoaWxkcmVuLmZvckVhY2goKGNwLCBpbmRleCkgPT4ge1xuICAgIGlmIChpc0N1c3RvbVBhZ2UoY3ApKSB7XG4gICAgICBjdXN0b21QYWdlQ29udGVudHMucHVzaCh7IGNvbXBvbmVudDogY3AuY2hpbGRyZW4sIGlkOiBpbmRleCB9KTtcbiAgICAgIGN1c3RvbVBhZ2VMYWJlbEljb25zLnB1c2goeyBjb21wb25lbnQ6IGNwLmxhYmVsSWNvbiwgaWQ6IGluZGV4IH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNFeHRlcm5hbExpbmsoY3ApKSB7XG4gICAgICBjdXN0b21MaW5rTGFiZWxJY29ucy5wdXNoKHsgY29tcG9uZW50OiBjcC5sYWJlbEljb24sIGlkOiBpbmRleCB9KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBjdXN0b21QYWdlQ29udGVudHNQb3J0YWxzID0gdXNlQ3VzdG9tRWxlbWVudFBvcnRhbChjdXN0b21QYWdlQ29udGVudHMpO1xuICBjb25zdCBjdXN0b21QYWdlTGFiZWxJY29uc1BvcnRhbHMgPSB1c2VDdXN0b21FbGVtZW50UG9ydGFsKGN1c3RvbVBhZ2VMYWJlbEljb25zKTtcbiAgY29uc3QgY3VzdG9tTGlua0xhYmVsSWNvbnNQb3J0YWxzID0gdXNlQ3VzdG9tRWxlbWVudFBvcnRhbChjdXN0b21MaW5rTGFiZWxJY29ucyk7XG4gIGNvbnN0IGN1c3RvbVBhZ2VzID0gW107XG4gIGNvbnN0IGN1c3RvbVBhZ2VzUG9ydGFscyA9IFtdO1xuICB2YWxpZENoaWxkcmVuLmZvckVhY2goKGNwLCBpbmRleCkgPT4ge1xuICAgIGlmIChpc1Jlb3JkZXJJdGVtKGNwLCByZW9yZGVySXRlbXNMYWJlbHMpKSB7XG4gICAgICBjdXN0b21QYWdlcy5wdXNoKHsgbGFiZWw6IGNwLmxhYmVsIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNDdXN0b21QYWdlKGNwKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwb3J0YWw6IGNvbnRlbnRQb3J0YWwsXG4gICAgICAgIG1vdW50LFxuICAgICAgICB1bm1vdW50XG4gICAgICB9ID0gY3VzdG9tUGFnZUNvbnRlbnRzUG9ydGFscy5maW5kKChwKSA9PiBwLmlkID09PSBpbmRleCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBvcnRhbDogbGFiZWxQb3J0YWwsXG4gICAgICAgIG1vdW50OiBtb3VudEljb24sXG4gICAgICAgIHVubW91bnQ6IHVubW91bnRJY29uXG4gICAgICB9ID0gY3VzdG9tUGFnZUxhYmVsSWNvbnNQb3J0YWxzLmZpbmQoKHApID0+IHAuaWQgPT09IGluZGV4KTtcbiAgICAgIGN1c3RvbVBhZ2VzLnB1c2goeyBsYWJlbDogY3AubGFiZWwsIHVybDogY3AudXJsLCBtb3VudCwgdW5tb3VudCwgbW91bnRJY29uLCB1bm1vdW50SWNvbiB9KTtcbiAgICAgIGN1c3RvbVBhZ2VzUG9ydGFscy5wdXNoKGNvbnRlbnRQb3J0YWwpO1xuICAgICAgY3VzdG9tUGFnZXNQb3J0YWxzLnB1c2gobGFiZWxQb3J0YWwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNFeHRlcm5hbExpbmsoY3ApKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBvcnRhbDogbGFiZWxQb3J0YWwsXG4gICAgICAgIG1vdW50OiBtb3VudEljb24sXG4gICAgICAgIHVubW91bnQ6IHVubW91bnRJY29uXG4gICAgICB9ID0gY3VzdG9tTGlua0xhYmVsSWNvbnNQb3J0YWxzLmZpbmQoKHApID0+IHAuaWQgPT09IGluZGV4KTtcbiAgICAgIGN1c3RvbVBhZ2VzLnB1c2goeyBsYWJlbDogY3AubGFiZWwsIHVybDogY3AudXJsLCBtb3VudEljb24sIHVubW91bnRJY29uIH0pO1xuICAgICAgY3VzdG9tUGFnZXNQb3J0YWxzLnB1c2gobGFiZWxQb3J0YWwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7IGN1c3RvbVBhZ2VzLCBjdXN0b21QYWdlc1BvcnRhbHMgfTtcbn07XG52YXIgaXNSZW9yZGVySXRlbSA9IChjaGlsZFByb3BzLCB2YWxpZEl0ZW1zKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGxhYmVsLCB1cmwsIGxhYmVsSWNvbiB9ID0gY2hpbGRQcm9wcztcbiAgcmV0dXJuICFjaGlsZHJlbiAmJiAhdXJsICYmICFsYWJlbEljb24gJiYgdmFsaWRJdGVtcy5zb21lKCh2KSA9PiB2ID09PSBsYWJlbCk7XG59O1xudmFyIGlzQ3VzdG9tUGFnZSA9IChjaGlsZFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGxhYmVsLCB1cmwsIGxhYmVsSWNvbiB9ID0gY2hpbGRQcm9wcztcbiAgcmV0dXJuICEhY2hpbGRyZW4gJiYgISF1cmwgJiYgISFsYWJlbEljb24gJiYgISFsYWJlbDtcbn07XG52YXIgaXNFeHRlcm5hbExpbmsgPSAoY2hpbGRQcm9wcykgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBsYWJlbCwgdXJsLCBsYWJlbEljb24gfSA9IGNoaWxkUHJvcHM7XG4gIHJldHVybiAhY2hpbGRyZW4gJiYgISF1cmwgJiYgISFsYWJlbEljb24gJiYgISFsYWJlbDtcbn07XG5cbi8vIHNyYy91dGlscy91c2VDdXN0b21NZW51SXRlbXMudHN4XG5pbXBvcnQgeyBsb2dFcnJvckluRGV2TW9kZSBhcyBsb2dFcnJvckluRGV2TW9kZTIgfSBmcm9tIFwiQGNsZXJrL3NoYXJlZC91dGlsc1wiO1xuaW1wb3J0IFJlYWN0NSBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VVc2VyQnV0dG9uQ3VzdG9tTWVudUl0ZW1zID0gKGNoaWxkcmVuLCBvcHRpb25zKSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgcmVvcmRlckl0ZW1zTGFiZWxzID0gW1wibWFuYWdlQWNjb3VudFwiLCBcInNpZ25PdXRcIl07XG4gIHJldHVybiB1c2VDdXN0b21NZW51SXRlbXMoe1xuICAgIGNoaWxkcmVuLFxuICAgIHJlb3JkZXJJdGVtc0xhYmVscyxcbiAgICBNZW51SXRlbXNDb21wb25lbnQ6IE1lbnVJdGVtcyxcbiAgICBNZW51QWN0aW9uQ29tcG9uZW50OiBNZW51QWN0aW9uLFxuICAgIE1lbnVMaW5rQ29tcG9uZW50OiBNZW51TGluayxcbiAgICBVc2VyUHJvZmlsZUxpbmtDb21wb25lbnQ6IFVzZXJQcm9maWxlTGluayxcbiAgICBVc2VyUHJvZmlsZVBhZ2VDb21wb25lbnQ6IFVzZXJQcm9maWxlUGFnZSxcbiAgICBhbGxvd0ZvckFueUNoaWxkcmVuOiAoX2EgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmFsbG93Rm9yQW55Q2hpbGRyZW4pICE9IG51bGwgPyBfYSA6IGZhbHNlXG4gIH0pO1xufTtcbnZhciB1c2VDdXN0b21NZW51SXRlbXMgPSAoe1xuICBjaGlsZHJlbixcbiAgTWVudUl0ZW1zQ29tcG9uZW50LFxuICBNZW51QWN0aW9uQ29tcG9uZW50LFxuICBNZW51TGlua0NvbXBvbmVudCxcbiAgVXNlclByb2ZpbGVMaW5rQ29tcG9uZW50LFxuICBVc2VyUHJvZmlsZVBhZ2VDb21wb25lbnQsXG4gIHJlb3JkZXJJdGVtc0xhYmVscyxcbiAgYWxsb3dGb3JBbnlDaGlsZHJlbiA9IGZhbHNlXG59KSA9PiB7XG4gIGNvbnN0IHZhbGlkQ2hpbGRyZW4gPSBbXTtcbiAgY29uc3QgY3VzdG9tTWVudUl0ZW1zID0gW107XG4gIGNvbnN0IGN1c3RvbU1lbnVJdGVtc1BvcnRhbHMgPSBbXTtcbiAgUmVhY3Q1LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChjaGlsZCkgPT4ge1xuICAgIGlmICghaXNUaGF0Q29tcG9uZW50KGNoaWxkLCBNZW51SXRlbXNDb21wb25lbnQpICYmICFpc1RoYXRDb21wb25lbnQoY2hpbGQsIFVzZXJQcm9maWxlTGlua0NvbXBvbmVudCkgJiYgIWlzVGhhdENvbXBvbmVudChjaGlsZCwgVXNlclByb2ZpbGVQYWdlQ29tcG9uZW50KSkge1xuICAgICAgaWYgKGNoaWxkICYmICFhbGxvd0ZvckFueUNoaWxkcmVuKSB7XG4gICAgICAgIGxvZ0Vycm9ySW5EZXZNb2RlMih1c2VyQnV0dG9uSWdub3JlZENvbXBvbmVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc1RoYXRDb21wb25lbnQoY2hpbGQsIFVzZXJQcm9maWxlTGlua0NvbXBvbmVudCkgfHwgaXNUaGF0Q29tcG9uZW50KGNoaWxkLCBVc2VyUHJvZmlsZVBhZ2VDb21wb25lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgcHJvcHMgfSA9IGNoaWxkO1xuICAgIFJlYWN0NS5DaGlsZHJlbi5mb3JFYWNoKHByb3BzLmNoaWxkcmVuLCAoY2hpbGQyKSA9PiB7XG4gICAgICBpZiAoIWlzVGhhdENvbXBvbmVudChjaGlsZDIsIE1lbnVBY3Rpb25Db21wb25lbnQpICYmICFpc1RoYXRDb21wb25lbnQoY2hpbGQyLCBNZW51TGlua0NvbXBvbmVudCkpIHtcbiAgICAgICAgaWYgKGNoaWxkMikge1xuICAgICAgICAgIGxvZ0Vycm9ySW5EZXZNb2RlMihjdXN0b21NZW51SXRlbXNJZ25vcmVkQ29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IHByb3BzOiBwcm9wczIgfSA9IGNoaWxkMjtcbiAgICAgIGNvbnN0IHsgbGFiZWwsIGxhYmVsSWNvbiwgaHJlZiwgb25DbGljaywgb3BlbiB9ID0gcHJvcHMyO1xuICAgICAgaWYgKGlzVGhhdENvbXBvbmVudChjaGlsZDIsIE1lbnVBY3Rpb25Db21wb25lbnQpKSB7XG4gICAgICAgIGlmIChpc1Jlb3JkZXJJdGVtMihwcm9wczIsIHJlb3JkZXJJdGVtc0xhYmVscykpIHtcbiAgICAgICAgICB2YWxpZENoaWxkcmVuLnB1c2goeyBsYWJlbCB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbU1lbnVJdGVtKHByb3BzMikpIHtcbiAgICAgICAgICBjb25zdCBiYXNlSXRlbSA9IHtcbiAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgbGFiZWxJY29uXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAob25DbGljayAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB2YWxpZENoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgICAuLi5iYXNlSXRlbSxcbiAgICAgICAgICAgICAgb25DbGlja1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvcGVuICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHZhbGlkQ2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAgIC4uLmJhc2VJdGVtLFxuICAgICAgICAgICAgICBvcGVuOiBvcGVuLnN0YXJ0c1dpdGgoXCIvXCIpID8gb3BlbiA6IGAvJHtvcGVufWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dFcnJvckluRGV2TW9kZTIoXCJDdXN0b20gbWVudSBpdGVtIG11c3QgaGF2ZSBlaXRoZXIgb25DbGljayBvciBvcGVuIHByb3BlcnR5XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dFcnJvckluRGV2TW9kZTIodXNlckJ1dHRvbk1lbnVJdGVtc0FjdGlvbldyb25nc1Byb3BzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc1RoYXRDb21wb25lbnQoY2hpbGQyLCBNZW51TGlua0NvbXBvbmVudCkpIHtcbiAgICAgICAgaWYgKGlzRXh0ZXJuYWxMaW5rMihwcm9wczIpKSB7XG4gICAgICAgICAgdmFsaWRDaGlsZHJlbi5wdXNoKHsgbGFiZWwsIGxhYmVsSWNvbiwgaHJlZiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dFcnJvckluRGV2TW9kZTIodXNlckJ1dHRvbk1lbnVJdGVtTGlua1dyb25nUHJvcHMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgY29uc3QgY3VzdG9tTWVudUl0ZW1MYWJlbEljb25zID0gW107XG4gIGNvbnN0IGN1c3RvbUxpbmtMYWJlbEljb25zID0gW107XG4gIHZhbGlkQ2hpbGRyZW4uZm9yRWFjaCgobWksIGluZGV4KSA9PiB7XG4gICAgaWYgKGlzQ3VzdG9tTWVudUl0ZW0obWkpKSB7XG4gICAgICBjdXN0b21NZW51SXRlbUxhYmVsSWNvbnMucHVzaCh7IGNvbXBvbmVudDogbWkubGFiZWxJY29uLCBpZDogaW5kZXggfSk7XG4gICAgfVxuICAgIGlmIChpc0V4dGVybmFsTGluazIobWkpKSB7XG4gICAgICBjdXN0b21MaW5rTGFiZWxJY29ucy5wdXNoKHsgY29tcG9uZW50OiBtaS5sYWJlbEljb24sIGlkOiBpbmRleCB9KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBjdXN0b21NZW51SXRlbUxhYmVsSWNvbnNQb3J0YWxzID0gdXNlQ3VzdG9tRWxlbWVudFBvcnRhbChjdXN0b21NZW51SXRlbUxhYmVsSWNvbnMpO1xuICBjb25zdCBjdXN0b21MaW5rTGFiZWxJY29uc1BvcnRhbHMgPSB1c2VDdXN0b21FbGVtZW50UG9ydGFsKGN1c3RvbUxpbmtMYWJlbEljb25zKTtcbiAgdmFsaWRDaGlsZHJlbi5mb3JFYWNoKChtaSwgaW5kZXgpID0+IHtcbiAgICBpZiAoaXNSZW9yZGVySXRlbTIobWksIHJlb3JkZXJJdGVtc0xhYmVscykpIHtcbiAgICAgIGN1c3RvbU1lbnVJdGVtcy5wdXNoKHtcbiAgICAgICAgbGFiZWw6IG1pLmxhYmVsXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGlzQ3VzdG9tTWVudUl0ZW0obWkpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBvcnRhbDogaWNvblBvcnRhbCxcbiAgICAgICAgbW91bnQ6IG1vdW50SWNvbixcbiAgICAgICAgdW5tb3VudDogdW5tb3VudEljb25cbiAgICAgIH0gPSBjdXN0b21NZW51SXRlbUxhYmVsSWNvbnNQb3J0YWxzLmZpbmQoKHApID0+IHAuaWQgPT09IGluZGV4KTtcbiAgICAgIGNvbnN0IG1lbnVJdGVtID0ge1xuICAgICAgICBsYWJlbDogbWkubGFiZWwsXG4gICAgICAgIG1vdW50SWNvbixcbiAgICAgICAgdW5tb3VudEljb25cbiAgICAgIH07XG4gICAgICBpZiAoXCJvbkNsaWNrXCIgaW4gbWkpIHtcbiAgICAgICAgbWVudUl0ZW0ub25DbGljayA9IG1pLm9uQ2xpY2s7XG4gICAgICB9IGVsc2UgaWYgKFwib3BlblwiIGluIG1pKSB7XG4gICAgICAgIG1lbnVJdGVtLm9wZW4gPSBtaS5vcGVuO1xuICAgICAgfVxuICAgICAgY3VzdG9tTWVudUl0ZW1zLnB1c2gobWVudUl0ZW0pO1xuICAgICAgY3VzdG9tTWVudUl0ZW1zUG9ydGFscy5wdXNoKGljb25Qb3J0YWwpO1xuICAgIH1cbiAgICBpZiAoaXNFeHRlcm5hbExpbmsyKG1pKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwb3J0YWw6IGljb25Qb3J0YWwsXG4gICAgICAgIG1vdW50OiBtb3VudEljb24sXG4gICAgICAgIHVubW91bnQ6IHVubW91bnRJY29uXG4gICAgICB9ID0gY3VzdG9tTGlua0xhYmVsSWNvbnNQb3J0YWxzLmZpbmQoKHApID0+IHAuaWQgPT09IGluZGV4KTtcbiAgICAgIGN1c3RvbU1lbnVJdGVtcy5wdXNoKHtcbiAgICAgICAgbGFiZWw6IG1pLmxhYmVsLFxuICAgICAgICBocmVmOiBtaS5ocmVmLFxuICAgICAgICBtb3VudEljb24sXG4gICAgICAgIHVubW91bnRJY29uXG4gICAgICB9KTtcbiAgICAgIGN1c3RvbU1lbnVJdGVtc1BvcnRhbHMucHVzaChpY29uUG9ydGFsKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4geyBjdXN0b21NZW51SXRlbXMsIGN1c3RvbU1lbnVJdGVtc1BvcnRhbHMgfTtcbn07XG52YXIgaXNSZW9yZGVySXRlbTIgPSAoY2hpbGRQcm9wcywgdmFsaWRJdGVtcykgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBsYWJlbCwgb25DbGljaywgbGFiZWxJY29uIH0gPSBjaGlsZFByb3BzO1xuICByZXR1cm4gIWNoaWxkcmVuICYmICFvbkNsaWNrICYmICFsYWJlbEljb24gJiYgdmFsaWRJdGVtcy5zb21lKCh2KSA9PiB2ID09PSBsYWJlbCk7XG59O1xudmFyIGlzQ3VzdG9tTWVudUl0ZW0gPSAoY2hpbGRQcm9wcykgPT4ge1xuICBjb25zdCB7IGxhYmVsLCBsYWJlbEljb24sIG9uQ2xpY2ssIG9wZW4gfSA9IGNoaWxkUHJvcHM7XG4gIHJldHVybiAhIWxhYmVsSWNvbiAmJiAhIWxhYmVsICYmICh0eXBlb2Ygb25DbGljayA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBvcGVuID09PSBcInN0cmluZ1wiKTtcbn07XG52YXIgaXNFeHRlcm5hbExpbmsyID0gKGNoaWxkUHJvcHMpID0+IHtcbiAgY29uc3QgeyBsYWJlbCwgaHJlZiwgbGFiZWxJY29uIH0gPSBjaGlsZFByb3BzO1xuICByZXR1cm4gISFocmVmICYmICEhbGFiZWxJY29uICYmICEhbGFiZWw7XG59O1xuXG4vLyBzcmMvdXRpbHMvdXNlV2FpdEZvckNvbXBvbmVudE1vdW50LnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgYXMgdXNlU3RhdGUyIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgY3JlYXRlQXdhaXRhYmxlTXV0YXRpb25PYnNlcnZlciA9IChnbG9iYWxPcHRpb25zKSA9PiB7XG4gIGNvbnN0IGlzUmVhZHkgPSBnbG9iYWxPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBnbG9iYWxPcHRpb25zLmlzUmVhZHk7XG4gIHJldHVybiAob3B0aW9ucykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHsgcm9vdCA9IGRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb2N1bWVudC5ib2R5LCBzZWxlY3RvciwgdGltZW91dCA9IDAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFyb290KSB7XG4gICAgICByZWplY3QobmV3IEVycm9yKFwiTm8gcm9vdCBlbGVtZW50IHByb3ZpZGVkXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGVsZW1lbnRUb1dhdGNoID0gcm9vdDtcbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIGVsZW1lbnRUb1dhdGNoID0gcm9vdCA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICB9XG4gICAgaWYgKGlzUmVhZHkoZWxlbWVudFRvV2F0Y2gsIHNlbGVjdG9yKSkge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnNMaXN0KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9uc0xpc3QpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50VG9XYXRjaCAmJiBzZWxlY3Rvcikge1xuICAgICAgICAgIGVsZW1lbnRUb1dhdGNoID0gcm9vdCA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2xvYmFsT3B0aW9ucy5jaGlsZExpc3QgJiYgbXV0YXRpb24udHlwZSA9PT0gXCJjaGlsZExpc3RcIiB8fCBnbG9iYWxPcHRpb25zLmF0dHJpYnV0ZXMgJiYgbXV0YXRpb24udHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgICAgICBpZiAoaXNSZWFkeShlbGVtZW50VG9XYXRjaCwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShyb290LCBnbG9iYWxPcHRpb25zKTtcbiAgICBpZiAodGltZW91dCA+IDApIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFRpbWVvdXQgd2FpdGluZyBmb3IgJHtzZWxlY3Rvcn1gKSk7XG4gICAgICB9LCB0aW1lb3V0KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciB3YWl0Rm9yRWxlbWVudENoaWxkcmVuID0gY3JlYXRlQXdhaXRhYmxlTXV0YXRpb25PYnNlcnZlcih7XG4gIGNoaWxkTGlzdDogdHJ1ZSxcbiAgc3VidHJlZTogdHJ1ZSxcbiAgaXNSZWFkeTogKGVsLCBzZWxlY3RvcikgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gISEoZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGVsLmNoaWxkRWxlbWVudENvdW50KSAmJiAoKF9hID0gZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGVsLm1hdGNoZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGVsLCBzZWxlY3RvcikpICYmIGVsLmNoaWxkRWxlbWVudENvdW50ID4gMDtcbiAgfVxufSk7XG5mdW5jdGlvbiB1c2VXYWl0Rm9yQ29tcG9uZW50TW91bnQoY29tcG9uZW50LCBvcHRpb25zKSB7XG4gIGNvbnN0IHdhdGNoZXJSZWYgPSB1c2VSZWYoKTtcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IHVzZVN0YXRlMihcInJlbmRlcmluZ1wiKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2xlcms6IG5vIGNvbXBvbmVudCBuYW1lIHByb3ZpZGVkLCB1bmFibGUgdG8gZGV0ZWN0IG1vdW50LlwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgIXdhdGNoZXJSZWYuY3VycmVudCkge1xuICAgICAgY29uc3QgZGVmYXVsdFNlbGVjdG9yID0gYFtkYXRhLWNsZXJrLWNvbXBvbmVudD1cIiR7Y29tcG9uZW50fVwiXWA7XG4gICAgICBjb25zdCBzZWxlY3RvciA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc2VsZWN0b3I7XG4gICAgICB3YXRjaGVyUmVmLmN1cnJlbnQgPSB3YWl0Rm9yRWxlbWVudENoaWxkcmVuKHtcbiAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yID8gKFxuICAgICAgICAgIC8vIEFsbG93cyBmb3IgYFtkYXRhLWNsZXJrLWNvbXBvbmVudD1cInh4eHhcIl1bZGF0YS1zb21lLWF0dHJpYnV0ZT1cIjEyM1wiXSAubXktY2xhc3NgXG4gICAgICAgICAgZGVmYXVsdFNlbGVjdG9yICsgc2VsZWN0b3JcbiAgICAgICAgKSA6IGRlZmF1bHRTZWxlY3RvclxuICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgIHNldFN0YXR1cyhcInJlbmRlcmVkXCIpO1xuICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICBzZXRTdGF0dXMoXCJlcnJvclwiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2NvbXBvbmVudCwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5zZWxlY3Rvcl0pO1xuICByZXR1cm4gc3RhdHVzO1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9DbGVya0hvc3RSZW5kZXJlci50c3hcbmltcG9ydCB7IHdpdGhvdXQgfSBmcm9tIFwiQGNsZXJrL3NoYXJlZC9vYmplY3RcIjtcbmltcG9ydCB7IGlzRGVlcGx5RXF1YWwgfSBmcm9tIFwiQGNsZXJrL3NoYXJlZC9yZWFjdFwiO1xuaW1wb3J0IFJlYWN0NiBmcm9tIFwicmVhY3RcIjtcbnZhciBpc01vdW50UHJvcHMgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIFwibW91bnRcIiBpbiBwcm9wcztcbn07XG52YXIgaXNPcGVuUHJvcHMgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIFwib3BlblwiIGluIHByb3BzO1xufTtcbnZhciBzdHJpcE1lbnVJdGVtSWNvbkhhbmRsZXJzID0gKG1lbnVJdGVtcykgPT4ge1xuICByZXR1cm4gbWVudUl0ZW1zID09IG51bGwgPyB2b2lkIDAgOiBtZW51SXRlbXMubWFwKCh7IG1vdW50SWNvbiwgdW5tb3VudEljb24sIC4uLnJlc3QgfSkgPT4gcmVzdCk7XG59O1xudmFyIENsZXJrSG9zdFJlbmRlcmVyID0gY2xhc3MgZXh0ZW5kcyBSZWFjdDYuUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5yb290UmVmID0gUmVhY3Q2LmNyZWF0ZVJlZigpO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShfcHJldlByb3BzKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGlmICghaXNNb3VudFByb3BzKF9wcmV2UHJvcHMpIHx8ICFpc01vdW50UHJvcHModGhpcy5wcm9wcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHJldlByb3BzID0gd2l0aG91dChfcHJldlByb3BzLnByb3BzLCBcImN1c3RvbVBhZ2VzXCIsIFwiY3VzdG9tTWVudUl0ZW1zXCIsIFwiY2hpbGRyZW5cIik7XG4gICAgY29uc3QgbmV3UHJvcHMgPSB3aXRob3V0KHRoaXMucHJvcHMucHJvcHMsIFwiY3VzdG9tUGFnZXNcIiwgXCJjdXN0b21NZW51SXRlbXNcIiwgXCJjaGlsZHJlblwiKTtcbiAgICBjb25zdCBjdXN0b21QYWdlc0NoYW5nZWQgPSAoKF9hID0gcHJldlByb3BzLmN1c3RvbVBhZ2VzKSA9PSBudWxsID8gdm9pZCAwIDogX2EubGVuZ3RoKSAhPT0gKChfYiA9IG5ld1Byb3BzLmN1c3RvbVBhZ2VzKSA9PSBudWxsID8gdm9pZCAwIDogX2IubGVuZ3RoKTtcbiAgICBjb25zdCBjdXN0b21NZW51SXRlbXNDaGFuZ2VkID0gKChfYyA9IHByZXZQcm9wcy5jdXN0b21NZW51SXRlbXMpID09IG51bGwgPyB2b2lkIDAgOiBfYy5sZW5ndGgpICE9PSAoKF9kID0gbmV3UHJvcHMuY3VzdG9tTWVudUl0ZW1zKSA9PSBudWxsID8gdm9pZCAwIDogX2QubGVuZ3RoKTtcbiAgICBjb25zdCBwcmV2TWVudUl0ZW1zV2l0aG91dEhhbmRsZXJzID0gc3RyaXBNZW51SXRlbUljb25IYW5kbGVycyhfcHJldlByb3BzLnByb3BzLmN1c3RvbU1lbnVJdGVtcyk7XG4gICAgY29uc3QgbmV3TWVudUl0ZW1zV2l0aG91dEhhbmRsZXJzID0gc3RyaXBNZW51SXRlbUljb25IYW5kbGVycyh0aGlzLnByb3BzLnByb3BzLmN1c3RvbU1lbnVJdGVtcyk7XG4gICAgaWYgKCFpc0RlZXBseUVxdWFsKHByZXZQcm9wcywgbmV3UHJvcHMpIHx8ICFpc0RlZXBseUVxdWFsKHByZXZNZW51SXRlbXNXaXRob3V0SGFuZGxlcnMsIG5ld01lbnVJdGVtc1dpdGhvdXRIYW5kbGVycykgfHwgY3VzdG9tUGFnZXNDaGFuZ2VkIHx8IGN1c3RvbU1lbnVJdGVtc0NoYW5nZWQpIHtcbiAgICAgIGlmICh0aGlzLnJvb3RSZWYuY3VycmVudCkge1xuICAgICAgICB0aGlzLnByb3BzLnVwZGF0ZVByb3BzKHsgbm9kZTogdGhpcy5yb290UmVmLmN1cnJlbnQsIHByb3BzOiB0aGlzLnByb3BzLnByb3BzIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAodGhpcy5yb290UmVmLmN1cnJlbnQpIHtcbiAgICAgIGlmIChpc01vdW50UHJvcHModGhpcy5wcm9wcykpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5tb3VudCh0aGlzLnJvb3RSZWYuY3VycmVudCwgdGhpcy5wcm9wcy5wcm9wcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNPcGVuUHJvcHModGhpcy5wcm9wcykpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vcGVuKHRoaXMucHJvcHMucHJvcHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5yb290UmVmLmN1cnJlbnQpIHtcbiAgICAgIGlmIChpc01vdW50UHJvcHModGhpcy5wcm9wcykpIHtcbiAgICAgICAgdGhpcy5wcm9wcy51bm1vdW50KHRoaXMucm9vdFJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc09wZW5Qcm9wcyh0aGlzLnByb3BzKSkge1xuICAgICAgICB0aGlzLnByb3BzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGhpZGVSb290SHRtbEVsZW1lbnQgPSBmYWxzZSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCByb290QXR0cmlidXRlcyA9IHtcbiAgICAgIHJlZjogdGhpcy5yb290UmVmLFxuICAgICAgLi4udGhpcy5wcm9wcy5yb290UHJvcHMsXG4gICAgICAuLi50aGlzLnByb3BzLmNvbXBvbmVudCAmJiB7IFwiZGF0YS1jbGVyay1jb21wb25lbnRcIjogdGhpcy5wcm9wcy5jb21wb25lbnQgfVxuICAgIH07XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDYuY3JlYXRlRWxlbWVudChSZWFjdDYuRnJhZ21lbnQsIG51bGwsICFoaWRlUm9vdEh0bWxFbGVtZW50ICYmIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDYuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IC4uLnJvb3RBdHRyaWJ1dGVzIH0pLCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbXBvbmVudHMvdWlDb21wb25lbnRzLnRzeFxudmFyIEN1c3RvbVBvcnRhbHNSZW5kZXJlciA9IChwcm9wcykgPT4ge1xuICB2YXIgX2EsIF9iO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFJlYWN0Ny5GcmFnbWVudCwgbnVsbCwgKF9hID0gcHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IHByb3BzLmN1c3RvbVBhZ2VzUG9ydGFscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm1hcCgocG9ydGFsLCBpbmRleCkgPT4gY3JlYXRlRWxlbWVudChwb3J0YWwsIHsga2V5OiBpbmRleCB9KSksIChfYiA9IHByb3BzID09IG51bGwgPyB2b2lkIDAgOiBwcm9wcy5jdXN0b21NZW51SXRlbXNQb3J0YWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2IubWFwKChwb3J0YWwsIGluZGV4KSA9PiBjcmVhdGVFbGVtZW50KHBvcnRhbCwgeyBrZXk6IGluZGV4IH0pKSk7XG59O1xudmFyIFNpZ25JbiA9IHdpdGhDbGVyayhcbiAgKHsgY2xlcmssIGNvbXBvbmVudCwgZmFsbGJhY2ssIC4uLnByb3BzIH0pID0+IHtcbiAgICBjb25zdCBtb3VudGluZ1N0YXR1cyA9IHVzZVdhaXRGb3JDb21wb25lbnRNb3VudChjb21wb25lbnQpO1xuICAgIGNvbnN0IHNob3VsZFNob3dGYWxsYmFjayA9IG1vdW50aW5nU3RhdHVzID09PSBcInJlbmRlcmluZ1wiIHx8ICFjbGVyay5sb2FkZWQ7XG4gICAgY29uc3QgcmVuZGVyZXJSb290UHJvcHMgPSB7XG4gICAgICAuLi5zaG91bGRTaG93RmFsbGJhY2sgJiYgZmFsbGJhY2sgJiYgeyBzdHlsZTogeyBkaXNwbGF5OiBcIm5vbmVcIiB9IH1cbiAgICB9O1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoUmVhY3Q3LkZyYWdtZW50LCBudWxsLCBzaG91bGRTaG93RmFsbGJhY2sgJiYgZmFsbGJhY2ssIGNsZXJrLmxvYWRlZCAmJiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBDbGVya0hvc3RSZW5kZXJlcixcbiAgICAgIHtcbiAgICAgICAgY29tcG9uZW50LFxuICAgICAgICBtb3VudDogY2xlcmsubW91bnRTaWduSW4sXG4gICAgICAgIHVubW91bnQ6IGNsZXJrLnVubW91bnRTaWduSW4sXG4gICAgICAgIHVwZGF0ZVByb3BzOiBjbGVyay5fX3Vuc3RhYmxlX191cGRhdGVQcm9wcyxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHJvb3RQcm9wczogcmVuZGVyZXJSb290UHJvcHNcbiAgICAgIH1cbiAgICApKTtcbiAgfSxcbiAgeyBjb21wb25lbnQ6IFwiU2lnbkluXCIsIHJlbmRlcldoaWxlTG9hZGluZzogdHJ1ZSB9XG4pO1xudmFyIFNpZ25VcCA9IHdpdGhDbGVyayhcbiAgKHsgY2xlcmssIGNvbXBvbmVudCwgZmFsbGJhY2ssIC4uLnByb3BzIH0pID0+IHtcbiAgICBjb25zdCBtb3VudGluZ1N0YXR1cyA9IHVzZVdhaXRGb3JDb21wb25lbnRNb3VudChjb21wb25lbnQpO1xuICAgIGNvbnN0IHNob3VsZFNob3dGYWxsYmFjayA9IG1vdW50aW5nU3RhdHVzID09PSBcInJlbmRlcmluZ1wiIHx8ICFjbGVyay5sb2FkZWQ7XG4gICAgY29uc3QgcmVuZGVyZXJSb290UHJvcHMgPSB7XG4gICAgICAuLi5zaG91bGRTaG93RmFsbGJhY2sgJiYgZmFsbGJhY2sgJiYgeyBzdHlsZTogeyBkaXNwbGF5OiBcIm5vbmVcIiB9IH1cbiAgICB9O1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoUmVhY3Q3LkZyYWdtZW50LCBudWxsLCBzaG91bGRTaG93RmFsbGJhY2sgJiYgZmFsbGJhY2ssIGNsZXJrLmxvYWRlZCAmJiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBDbGVya0hvc3RSZW5kZXJlcixcbiAgICAgIHtcbiAgICAgICAgY29tcG9uZW50LFxuICAgICAgICBtb3VudDogY2xlcmsubW91bnRTaWduVXAsXG4gICAgICAgIHVubW91bnQ6IGNsZXJrLnVubW91bnRTaWduVXAsXG4gICAgICAgIHVwZGF0ZVByb3BzOiBjbGVyay5fX3Vuc3RhYmxlX191cGRhdGVQcm9wcyxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHJvb3RQcm9wczogcmVuZGVyZXJSb290UHJvcHNcbiAgICAgIH1cbiAgICApKTtcbiAgfSxcbiAgeyBjb21wb25lbnQ6IFwiU2lnblVwXCIsIHJlbmRlcldoaWxlTG9hZGluZzogdHJ1ZSB9XG4pO1xuZnVuY3Rpb24gVXNlclByb2ZpbGVQYWdlKHsgY2hpbGRyZW4gfSkge1xuICBsb2dFcnJvckluRGV2TW9kZTModXNlclByb2ZpbGVQYWdlUmVuZGVyZWRFcnJvcik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoUmVhY3Q3LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBVc2VyUHJvZmlsZUxpbmsoeyBjaGlsZHJlbiB9KSB7XG4gIGxvZ0Vycm9ySW5EZXZNb2RlMyh1c2VyUHJvZmlsZUxpbmtSZW5kZXJlZEVycm9yKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChSZWFjdDcuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn1cbnZhciBfVXNlclByb2ZpbGUgPSB3aXRoQ2xlcmsoXG4gICh7XG4gICAgY2xlcmssXG4gICAgY29tcG9uZW50LFxuICAgIGZhbGxiYWNrLFxuICAgIC4uLnByb3BzXG4gIH0pID0+IHtcbiAgICBjb25zdCBtb3VudGluZ1N0YXR1cyA9IHVzZVdhaXRGb3JDb21wb25lbnRNb3VudChjb21wb25lbnQpO1xuICAgIGNvbnN0IHNob3VsZFNob3dGYWxsYmFjayA9IG1vdW50aW5nU3RhdHVzID09PSBcInJlbmRlcmluZ1wiIHx8ICFjbGVyay5sb2FkZWQ7XG4gICAgY29uc3QgcmVuZGVyZXJSb290UHJvcHMgPSB7XG4gICAgICAuLi5zaG91bGRTaG93RmFsbGJhY2sgJiYgZmFsbGJhY2sgJiYgeyBzdHlsZTogeyBkaXNwbGF5OiBcIm5vbmVcIiB9IH1cbiAgICB9O1xuICAgIGNvbnN0IHsgY3VzdG9tUGFnZXMsIGN1c3RvbVBhZ2VzUG9ydGFscyB9ID0gdXNlVXNlclByb2ZpbGVDdXN0b21QYWdlcyhwcm9wcy5jaGlsZHJlbik7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChSZWFjdDcuRnJhZ21lbnQsIG51bGwsIHNob3VsZFNob3dGYWxsYmFjayAmJiBmYWxsYmFjaywgLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFxuICAgICAgQ2xlcmtIb3N0UmVuZGVyZXIsXG4gICAgICB7XG4gICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgbW91bnQ6IGNsZXJrLm1vdW50VXNlclByb2ZpbGUsXG4gICAgICAgIHVubW91bnQ6IGNsZXJrLnVubW91bnRVc2VyUHJvZmlsZSxcbiAgICAgICAgdXBkYXRlUHJvcHM6IGNsZXJrLl9fdW5zdGFibGVfX3VwZGF0ZVByb3BzLFxuICAgICAgICBwcm9wczogeyAuLi5wcm9wcywgY3VzdG9tUGFnZXMgfSxcbiAgICAgICAgcm9vdFByb3BzOiByZW5kZXJlclJvb3RQcm9wc1xuICAgICAgfSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChDdXN0b21Qb3J0YWxzUmVuZGVyZXIsIHsgY3VzdG9tUGFnZXNQb3J0YWxzIH0pXG4gICAgKSk7XG4gIH0sXG4gIHsgY29tcG9uZW50OiBcIlVzZXJQcm9maWxlXCIsIHJlbmRlcldoaWxlTG9hZGluZzogdHJ1ZSB9XG4pO1xudmFyIFVzZXJQcm9maWxlID0gT2JqZWN0LmFzc2lnbihfVXNlclByb2ZpbGUsIHtcbiAgUGFnZTogVXNlclByb2ZpbGVQYWdlLFxuICBMaW5rOiBVc2VyUHJvZmlsZUxpbmtcbn0pO1xudmFyIFVzZXJCdXR0b25Db250ZXh0ID0gY3JlYXRlQ29udGV4dCh7XG4gIG1vdW50OiAoKSA9PiB7XG4gIH0sXG4gIHVubW91bnQ6ICgpID0+IHtcbiAgfSxcbiAgdXBkYXRlUHJvcHM6ICgpID0+IHtcbiAgfVxufSk7XG52YXIgX1VzZXJCdXR0b24gPSB3aXRoQ2xlcmsoXG4gICh7XG4gICAgY2xlcmssXG4gICAgY29tcG9uZW50LFxuICAgIGZhbGxiYWNrLFxuICAgIC4uLnByb3BzXG4gIH0pID0+IHtcbiAgICBjb25zdCBtb3VudGluZ1N0YXR1cyA9IHVzZVdhaXRGb3JDb21wb25lbnRNb3VudChjb21wb25lbnQpO1xuICAgIGNvbnN0IHNob3VsZFNob3dGYWxsYmFjayA9IG1vdW50aW5nU3RhdHVzID09PSBcInJlbmRlcmluZ1wiIHx8ICFjbGVyay5sb2FkZWQ7XG4gICAgY29uc3QgcmVuZGVyZXJSb290UHJvcHMgPSB7XG4gICAgICAuLi5zaG91bGRTaG93RmFsbGJhY2sgJiYgZmFsbGJhY2sgJiYgeyBzdHlsZTogeyBkaXNwbGF5OiBcIm5vbmVcIiB9IH1cbiAgICB9O1xuICAgIGNvbnN0IHsgY3VzdG9tUGFnZXMsIGN1c3RvbVBhZ2VzUG9ydGFscyB9ID0gdXNlVXNlclByb2ZpbGVDdXN0b21QYWdlcyhwcm9wcy5jaGlsZHJlbiwge1xuICAgICAgYWxsb3dGb3JBbnlDaGlsZHJlbjogISFwcm9wcy5fX2V4cGVyaW1lbnRhbF9hc1Byb3ZpZGVyXG4gICAgfSk7XG4gICAgY29uc3QgdXNlclByb2ZpbGVQcm9wcyA9IE9iamVjdC5hc3NpZ24ocHJvcHMudXNlclByb2ZpbGVQcm9wcyB8fCB7fSwgeyBjdXN0b21QYWdlcyB9KTtcbiAgICBjb25zdCB7IGN1c3RvbU1lbnVJdGVtcywgY3VzdG9tTWVudUl0ZW1zUG9ydGFscyB9ID0gdXNlVXNlckJ1dHRvbkN1c3RvbU1lbnVJdGVtcyhwcm9wcy5jaGlsZHJlbiwge1xuICAgICAgYWxsb3dGb3JBbnlDaGlsZHJlbjogISFwcm9wcy5fX2V4cGVyaW1lbnRhbF9hc1Byb3ZpZGVyXG4gICAgfSk7XG4gICAgY29uc3Qgc2FuaXRpemVkQ2hpbGRyZW4gPSB1c2VTYW5pdGl6ZWRDaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG4gICAgY29uc3QgcGFzc2FibGVQcm9wcyA9IHtcbiAgICAgIG1vdW50OiBjbGVyay5tb3VudFVzZXJCdXR0b24sXG4gICAgICB1bm1vdW50OiBjbGVyay51bm1vdW50VXNlckJ1dHRvbixcbiAgICAgIHVwZGF0ZVByb3BzOiBjbGVyay5fX3Vuc3RhYmxlX191cGRhdGVQcm9wcyxcbiAgICAgIHByb3BzOiB7IC4uLnByb3BzLCB1c2VyUHJvZmlsZVByb3BzLCBjdXN0b21NZW51SXRlbXMgfVxuICAgIH07XG4gICAgY29uc3QgcG9ydGFsUHJvcHMgPSB7XG4gICAgICBjdXN0b21QYWdlc1BvcnRhbHMsXG4gICAgICBjdXN0b21NZW51SXRlbXNQb3J0YWxzXG4gICAgfTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFVzZXJCdXR0b25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBwYXNzYWJsZVByb3BzIH0sIHNob3VsZFNob3dGYWxsYmFjayAmJiBmYWxsYmFjaywgY2xlcmsubG9hZGVkICYmIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChcbiAgICAgIENsZXJrSG9zdFJlbmRlcmVyLFxuICAgICAge1xuICAgICAgICBjb21wb25lbnQsXG4gICAgICAgIC4uLnBhc3NhYmxlUHJvcHMsXG4gICAgICAgIGhpZGVSb290SHRtbEVsZW1lbnQ6ICEhcHJvcHMuX19leHBlcmltZW50YWxfYXNQcm92aWRlcixcbiAgICAgICAgcm9vdFByb3BzOiByZW5kZXJlclJvb3RQcm9wc1xuICAgICAgfSxcbiAgICAgIHByb3BzLl9fZXhwZXJpbWVudGFsX2FzUHJvdmlkZXIgPyBzYW5pdGl6ZWRDaGlsZHJlbiA6IG51bGwsXG4gICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoQ3VzdG9tUG9ydGFsc1JlbmRlcmVyLCB7IC4uLnBvcnRhbFByb3BzIH0pXG4gICAgKSk7XG4gIH0sXG4gIHsgY29tcG9uZW50OiBcIlVzZXJCdXR0b25cIiwgcmVuZGVyV2hpbGVMb2FkaW5nOiB0cnVlIH1cbik7XG5mdW5jdGlvbiBNZW51SXRlbXMoeyBjaGlsZHJlbiB9KSB7XG4gIGxvZ0Vycm9ySW5EZXZNb2RlMyh1c2VyQnV0dG9uTWVudUl0ZW1zUmVuZGVyZWRFcnJvcik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoUmVhY3Q3LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBNZW51QWN0aW9uKHsgY2hpbGRyZW4gfSkge1xuICBsb2dFcnJvckluRGV2TW9kZTModXNlckJ1dHRvbk1lbnVBY3Rpb25SZW5kZXJlZEVycm9yKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChSZWFjdDcuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIE1lbnVMaW5rKHsgY2hpbGRyZW4gfSkge1xuICBsb2dFcnJvckluRGV2TW9kZTModXNlckJ1dHRvbk1lbnVMaW5rUmVuZGVyZWRFcnJvcik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoUmVhY3Q3LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBVc2VyQnV0dG9uT3V0bGV0KG91dGxldFByb3BzKSB7XG4gIGNvbnN0IHByb3ZpZGVyUHJvcHMgPSB1c2VDb250ZXh0KFVzZXJCdXR0b25Db250ZXh0KTtcbiAgY29uc3QgcG9ydGFsUHJvcHMgPSB7XG4gICAgLi4ucHJvdmlkZXJQcm9wcyxcbiAgICBwcm9wczoge1xuICAgICAgLi4ucHJvdmlkZXJQcm9wcy5wcm9wcyxcbiAgICAgIC4uLm91dGxldFByb3BzXG4gICAgfVxuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KENsZXJrSG9zdFJlbmRlcmVyLCB7IC4uLnBvcnRhbFByb3BzIH0pO1xufVxudmFyIFVzZXJCdXR0b24gPSBPYmplY3QuYXNzaWduKF9Vc2VyQnV0dG9uLCB7XG4gIFVzZXJQcm9maWxlUGFnZSxcbiAgVXNlclByb2ZpbGVMaW5rLFxuICBNZW51SXRlbXMsXG4gIEFjdGlvbjogTWVudUFjdGlvbixcbiAgTGluazogTWVudUxpbmssXG4gIF9fZXhwZXJpbWVudGFsX091dGxldDogVXNlckJ1dHRvbk91dGxldFxufSk7XG5mdW5jdGlvbiBPcmdhbml6YXRpb25Qcm9maWxlUGFnZSh7IGNoaWxkcmVuIH0pIHtcbiAgbG9nRXJyb3JJbkRldk1vZGUzKG9yZ2FuaXphdGlvblByb2ZpbGVQYWdlUmVuZGVyZWRFcnJvcik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoUmVhY3Q3LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBPcmdhbml6YXRpb25Qcm9maWxlTGluayh7IGNoaWxkcmVuIH0pIHtcbiAgbG9nRXJyb3JJbkRldk1vZGUzKG9yZ2FuaXphdGlvblByb2ZpbGVMaW5rUmVuZGVyZWRFcnJvcik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoUmVhY3Q3LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59XG52YXIgX09yZ2FuaXphdGlvblByb2ZpbGUgPSB3aXRoQ2xlcmsoXG4gICh7XG4gICAgY2xlcmssXG4gICAgY29tcG9uZW50LFxuICAgIGZhbGxiYWNrLFxuICAgIC4uLnByb3BzXG4gIH0pID0+IHtcbiAgICBjb25zdCBtb3VudGluZ1N0YXR1cyA9IHVzZVdhaXRGb3JDb21wb25lbnRNb3VudChjb21wb25lbnQpO1xuICAgIGNvbnN0IHNob3VsZFNob3dGYWxsYmFjayA9IG1vdW50aW5nU3RhdHVzID09PSBcInJlbmRlcmluZ1wiIHx8ICFjbGVyay5sb2FkZWQ7XG4gICAgY29uc3QgcmVuZGVyZXJSb290UHJvcHMgPSB7XG4gICAgICAuLi5zaG91bGRTaG93RmFsbGJhY2sgJiYgZmFsbGJhY2sgJiYgeyBzdHlsZTogeyBkaXNwbGF5OiBcIm5vbmVcIiB9IH1cbiAgICB9O1xuICAgIGNvbnN0IHsgY3VzdG9tUGFnZXMsIGN1c3RvbVBhZ2VzUG9ydGFscyB9ID0gdXNlT3JnYW5pemF0aW9uUHJvZmlsZUN1c3RvbVBhZ2VzKHByb3BzLmNoaWxkcmVuKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFJlYWN0Ny5GcmFnbWVudCwgbnVsbCwgc2hvdWxkU2hvd0ZhbGxiYWNrICYmIGZhbGxiYWNrLCBjbGVyay5sb2FkZWQgJiYgLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFxuICAgICAgQ2xlcmtIb3N0UmVuZGVyZXIsXG4gICAgICB7XG4gICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgbW91bnQ6IGNsZXJrLm1vdW50T3JnYW5pemF0aW9uUHJvZmlsZSxcbiAgICAgICAgdW5tb3VudDogY2xlcmsudW5tb3VudE9yZ2FuaXphdGlvblByb2ZpbGUsXG4gICAgICAgIHVwZGF0ZVByb3BzOiBjbGVyay5fX3Vuc3RhYmxlX191cGRhdGVQcm9wcyxcbiAgICAgICAgcHJvcHM6IHsgLi4ucHJvcHMsIGN1c3RvbVBhZ2VzIH0sXG4gICAgICAgIHJvb3RQcm9wczogcmVuZGVyZXJSb290UHJvcHNcbiAgICAgIH0sXG4gICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoQ3VzdG9tUG9ydGFsc1JlbmRlcmVyLCB7IGN1c3RvbVBhZ2VzUG9ydGFscyB9KVxuICAgICkpO1xuICB9LFxuICB7IGNvbXBvbmVudDogXCJPcmdhbml6YXRpb25Qcm9maWxlXCIsIHJlbmRlcldoaWxlTG9hZGluZzogdHJ1ZSB9XG4pO1xudmFyIE9yZ2FuaXphdGlvblByb2ZpbGUgPSBPYmplY3QuYXNzaWduKF9Pcmdhbml6YXRpb25Qcm9maWxlLCB7XG4gIFBhZ2U6IE9yZ2FuaXphdGlvblByb2ZpbGVQYWdlLFxuICBMaW5rOiBPcmdhbml6YXRpb25Qcm9maWxlTGlua1xufSk7XG52YXIgQ3JlYXRlT3JnYW5pemF0aW9uID0gd2l0aENsZXJrKFxuICAoeyBjbGVyaywgY29tcG9uZW50LCBmYWxsYmFjaywgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IG1vdW50aW5nU3RhdHVzID0gdXNlV2FpdEZvckNvbXBvbmVudE1vdW50KGNvbXBvbmVudCk7XG4gICAgY29uc3Qgc2hvdWxkU2hvd0ZhbGxiYWNrID0gbW91bnRpbmdTdGF0dXMgPT09IFwicmVuZGVyaW5nXCIgfHwgIWNsZXJrLmxvYWRlZDtcbiAgICBjb25zdCByZW5kZXJlclJvb3RQcm9wcyA9IHtcbiAgICAgIC4uLnNob3VsZFNob3dGYWxsYmFjayAmJiBmYWxsYmFjayAmJiB7IHN0eWxlOiB7IGRpc3BsYXk6IFwibm9uZVwiIH0gfVxuICAgIH07XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChSZWFjdDcuRnJhZ21lbnQsIG51bGwsIHNob3VsZFNob3dGYWxsYmFjayAmJiBmYWxsYmFjaywgY2xlcmsubG9hZGVkICYmIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChcbiAgICAgIENsZXJrSG9zdFJlbmRlcmVyLFxuICAgICAge1xuICAgICAgICBjb21wb25lbnQsXG4gICAgICAgIG1vdW50OiBjbGVyay5tb3VudENyZWF0ZU9yZ2FuaXphdGlvbixcbiAgICAgICAgdW5tb3VudDogY2xlcmsudW5tb3VudENyZWF0ZU9yZ2FuaXphdGlvbixcbiAgICAgICAgdXBkYXRlUHJvcHM6IGNsZXJrLl9fdW5zdGFibGVfX3VwZGF0ZVByb3BzLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgcm9vdFByb3BzOiByZW5kZXJlclJvb3RQcm9wc1xuICAgICAgfVxuICAgICkpO1xuICB9LFxuICB7IGNvbXBvbmVudDogXCJDcmVhdGVPcmdhbml6YXRpb25cIiwgcmVuZGVyV2hpbGVMb2FkaW5nOiB0cnVlIH1cbik7XG52YXIgT3JnYW5pemF0aW9uU3dpdGNoZXJDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7XG4gIG1vdW50OiAoKSA9PiB7XG4gIH0sXG4gIHVubW91bnQ6ICgpID0+IHtcbiAgfSxcbiAgdXBkYXRlUHJvcHM6ICgpID0+IHtcbiAgfVxufSk7XG52YXIgX09yZ2FuaXphdGlvblN3aXRjaGVyID0gd2l0aENsZXJrKFxuICAoe1xuICAgIGNsZXJrLFxuICAgIGNvbXBvbmVudCxcbiAgICBmYWxsYmFjayxcbiAgICAuLi5wcm9wc1xuICB9KSA9PiB7XG4gICAgY29uc3QgbW91bnRpbmdTdGF0dXMgPSB1c2VXYWl0Rm9yQ29tcG9uZW50TW91bnQoY29tcG9uZW50KTtcbiAgICBjb25zdCBzaG91bGRTaG93RmFsbGJhY2sgPSBtb3VudGluZ1N0YXR1cyA9PT0gXCJyZW5kZXJpbmdcIiB8fCAhY2xlcmsubG9hZGVkO1xuICAgIGNvbnN0IHJlbmRlcmVyUm9vdFByb3BzID0ge1xuICAgICAgLi4uc2hvdWxkU2hvd0ZhbGxiYWNrICYmIGZhbGxiYWNrICYmIHsgc3R5bGU6IHsgZGlzcGxheTogXCJub25lXCIgfSB9XG4gICAgfTtcbiAgICBjb25zdCB7IGN1c3RvbVBhZ2VzLCBjdXN0b21QYWdlc1BvcnRhbHMgfSA9IHVzZU9yZ2FuaXphdGlvblByb2ZpbGVDdXN0b21QYWdlcyhwcm9wcy5jaGlsZHJlbiwge1xuICAgICAgYWxsb3dGb3JBbnlDaGlsZHJlbjogISFwcm9wcy5fX2V4cGVyaW1lbnRhbF9hc1Byb3ZpZGVyXG4gICAgfSk7XG4gICAgY29uc3Qgb3JnYW5pemF0aW9uUHJvZmlsZVByb3BzID0gT2JqZWN0LmFzc2lnbihwcm9wcy5vcmdhbml6YXRpb25Qcm9maWxlUHJvcHMgfHwge30sIHsgY3VzdG9tUGFnZXMgfSk7XG4gICAgY29uc3Qgc2FuaXRpemVkQ2hpbGRyZW4gPSB1c2VTYW5pdGl6ZWRDaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG4gICAgY29uc3QgcGFzc2FibGVQcm9wcyA9IHtcbiAgICAgIG1vdW50OiBjbGVyay5tb3VudE9yZ2FuaXphdGlvblN3aXRjaGVyLFxuICAgICAgdW5tb3VudDogY2xlcmsudW5tb3VudE9yZ2FuaXphdGlvblN3aXRjaGVyLFxuICAgICAgdXBkYXRlUHJvcHM6IGNsZXJrLl9fdW5zdGFibGVfX3VwZGF0ZVByb3BzLFxuICAgICAgcHJvcHM6IHsgLi4ucHJvcHMsIG9yZ2FuaXphdGlvblByb2ZpbGVQcm9wcyB9LFxuICAgICAgcm9vdFByb3BzOiByZW5kZXJlclJvb3RQcm9wcyxcbiAgICAgIGNvbXBvbmVudFxuICAgIH07XG4gICAgY2xlcmsuX19leHBlcmltZW50YWxfcHJlZmV0Y2hPcmdhbml6YXRpb25Td2l0Y2hlcigpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoT3JnYW5pemF0aW9uU3dpdGNoZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBwYXNzYWJsZVByb3BzIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChSZWFjdDcuRnJhZ21lbnQsIG51bGwsIHNob3VsZFNob3dGYWxsYmFjayAmJiBmYWxsYmFjaywgY2xlcmsubG9hZGVkICYmIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChcbiAgICAgIENsZXJrSG9zdFJlbmRlcmVyLFxuICAgICAge1xuICAgICAgICAuLi5wYXNzYWJsZVByb3BzLFxuICAgICAgICBoaWRlUm9vdEh0bWxFbGVtZW50OiAhIXByb3BzLl9fZXhwZXJpbWVudGFsX2FzUHJvdmlkZXJcbiAgICAgIH0sXG4gICAgICBwcm9wcy5fX2V4cGVyaW1lbnRhbF9hc1Byb3ZpZGVyID8gc2FuaXRpemVkQ2hpbGRyZW4gOiBudWxsLFxuICAgICAgLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KEN1c3RvbVBvcnRhbHNSZW5kZXJlciwgeyBjdXN0b21QYWdlc1BvcnRhbHMgfSlcbiAgICApKSk7XG4gIH0sXG4gIHsgY29tcG9uZW50OiBcIk9yZ2FuaXphdGlvblN3aXRjaGVyXCIsIHJlbmRlcldoaWxlTG9hZGluZzogdHJ1ZSB9XG4pO1xuZnVuY3Rpb24gT3JnYW5pemF0aW9uU3dpdGNoZXJPdXRsZXQob3V0bGV0UHJvcHMpIHtcbiAgY29uc3QgcHJvdmlkZXJQcm9wcyA9IHVzZUNvbnRleHQoT3JnYW5pemF0aW9uU3dpdGNoZXJDb250ZXh0KTtcbiAgY29uc3QgcG9ydGFsUHJvcHMgPSB7XG4gICAgLi4ucHJvdmlkZXJQcm9wcyxcbiAgICBwcm9wczoge1xuICAgICAgLi4ucHJvdmlkZXJQcm9wcy5wcm9wcyxcbiAgICAgIC4uLm91dGxldFByb3BzXG4gICAgfVxuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KENsZXJrSG9zdFJlbmRlcmVyLCB7IC4uLnBvcnRhbFByb3BzIH0pO1xufVxudmFyIE9yZ2FuaXphdGlvblN3aXRjaGVyID0gT2JqZWN0LmFzc2lnbihfT3JnYW5pemF0aW9uU3dpdGNoZXIsIHtcbiAgT3JnYW5pemF0aW9uUHJvZmlsZVBhZ2UsXG4gIE9yZ2FuaXphdGlvblByb2ZpbGVMaW5rLFxuICBfX2V4cGVyaW1lbnRhbF9PdXRsZXQ6IE9yZ2FuaXphdGlvblN3aXRjaGVyT3V0bGV0XG59KTtcbnZhciBPcmdhbml6YXRpb25MaXN0ID0gd2l0aENsZXJrKFxuICAoeyBjbGVyaywgY29tcG9uZW50LCBmYWxsYmFjaywgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IG1vdW50aW5nU3RhdHVzID0gdXNlV2FpdEZvckNvbXBvbmVudE1vdW50KGNvbXBvbmVudCk7XG4gICAgY29uc3Qgc2hvdWxkU2hvd0ZhbGxiYWNrID0gbW91bnRpbmdTdGF0dXMgPT09IFwicmVuZGVyaW5nXCIgfHwgIWNsZXJrLmxvYWRlZDtcbiAgICBjb25zdCByZW5kZXJlclJvb3RQcm9wcyA9IHtcbiAgICAgIC4uLnNob3VsZFNob3dGYWxsYmFjayAmJiBmYWxsYmFjayAmJiB7IHN0eWxlOiB7IGRpc3BsYXk6IFwibm9uZVwiIH0gfVxuICAgIH07XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChSZWFjdDcuRnJhZ21lbnQsIG51bGwsIHNob3VsZFNob3dGYWxsYmFjayAmJiBmYWxsYmFjaywgY2xlcmsubG9hZGVkICYmIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChcbiAgICAgIENsZXJrSG9zdFJlbmRlcmVyLFxuICAgICAge1xuICAgICAgICBjb21wb25lbnQsXG4gICAgICAgIG1vdW50OiBjbGVyay5tb3VudE9yZ2FuaXphdGlvbkxpc3QsXG4gICAgICAgIHVubW91bnQ6IGNsZXJrLnVubW91bnRPcmdhbml6YXRpb25MaXN0LFxuICAgICAgICB1cGRhdGVQcm9wczogY2xlcmsuX191bnN0YWJsZV9fdXBkYXRlUHJvcHMsXG4gICAgICAgIHByb3BzLFxuICAgICAgICByb290UHJvcHM6IHJlbmRlcmVyUm9vdFByb3BzXG4gICAgICB9XG4gICAgKSk7XG4gIH0sXG4gIHsgY29tcG9uZW50OiBcIk9yZ2FuaXphdGlvbkxpc3RcIiwgcmVuZGVyV2hpbGVMb2FkaW5nOiB0cnVlIH1cbik7XG52YXIgR29vZ2xlT25lVGFwID0gd2l0aENsZXJrKFxuICAoeyBjbGVyaywgY29tcG9uZW50LCBmYWxsYmFjaywgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IG1vdW50aW5nU3RhdHVzID0gdXNlV2FpdEZvckNvbXBvbmVudE1vdW50KGNvbXBvbmVudCk7XG4gICAgY29uc3Qgc2hvdWxkU2hvd0ZhbGxiYWNrID0gbW91bnRpbmdTdGF0dXMgPT09IFwicmVuZGVyaW5nXCIgfHwgIWNsZXJrLmxvYWRlZDtcbiAgICBjb25zdCByZW5kZXJlclJvb3RQcm9wcyA9IHtcbiAgICAgIC4uLnNob3VsZFNob3dGYWxsYmFjayAmJiBmYWxsYmFjayAmJiB7IHN0eWxlOiB7IGRpc3BsYXk6IFwibm9uZVwiIH0gfVxuICAgIH07XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChSZWFjdDcuRnJhZ21lbnQsIG51bGwsIHNob3VsZFNob3dGYWxsYmFjayAmJiBmYWxsYmFjaywgY2xlcmsubG9hZGVkICYmIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChcbiAgICAgIENsZXJrSG9zdFJlbmRlcmVyLFxuICAgICAge1xuICAgICAgICBjb21wb25lbnQsXG4gICAgICAgIG9wZW46IGNsZXJrLm9wZW5Hb29nbGVPbmVUYXAsXG4gICAgICAgIGNsb3NlOiBjbGVyay5jbG9zZUdvb2dsZU9uZVRhcCxcbiAgICAgICAgdXBkYXRlUHJvcHM6IGNsZXJrLl9fdW5zdGFibGVfX3VwZGF0ZVByb3BzLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgcm9vdFByb3BzOiByZW5kZXJlclJvb3RQcm9wc1xuICAgICAgfVxuICAgICkpO1xuICB9LFxuICB7IGNvbXBvbmVudDogXCJHb29nbGVPbmVUYXBcIiwgcmVuZGVyV2hpbGVMb2FkaW5nOiB0cnVlIH1cbik7XG52YXIgV2FpdGxpc3QgPSB3aXRoQ2xlcmsoXG4gICh7IGNsZXJrLCBjb21wb25lbnQsIGZhbGxiYWNrLCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgY29uc3QgbW91bnRpbmdTdGF0dXMgPSB1c2VXYWl0Rm9yQ29tcG9uZW50TW91bnQoY29tcG9uZW50KTtcbiAgICBjb25zdCBzaG91bGRTaG93RmFsbGJhY2sgPSBtb3VudGluZ1N0YXR1cyA9PT0gXCJyZW5kZXJpbmdcIiB8fCAhY2xlcmsubG9hZGVkO1xuICAgIGNvbnN0IHJlbmRlcmVyUm9vdFByb3BzID0ge1xuICAgICAgLi4uc2hvdWxkU2hvd0ZhbGxiYWNrICYmIGZhbGxiYWNrICYmIHsgc3R5bGU6IHsgZGlzcGxheTogXCJub25lXCIgfSB9XG4gICAgfTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFJlYWN0Ny5GcmFnbWVudCwgbnVsbCwgc2hvdWxkU2hvd0ZhbGxiYWNrICYmIGZhbGxiYWNrLCBjbGVyay5sb2FkZWQgJiYgLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFxuICAgICAgQ2xlcmtIb3N0UmVuZGVyZXIsXG4gICAgICB7XG4gICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgbW91bnQ6IGNsZXJrLm1vdW50V2FpdGxpc3QsXG4gICAgICAgIHVubW91bnQ6IGNsZXJrLnVubW91bnRXYWl0bGlzdCxcbiAgICAgICAgdXBkYXRlUHJvcHM6IGNsZXJrLl9fdW5zdGFibGVfX3VwZGF0ZVByb3BzLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgcm9vdFByb3BzOiByZW5kZXJlclJvb3RQcm9wc1xuICAgICAgfVxuICAgICkpO1xuICB9LFxuICB7IGNvbXBvbmVudDogXCJXYWl0bGlzdFwiLCByZW5kZXJXaGlsZUxvYWRpbmc6IHRydWUgfVxuKTtcbnZhciBQcmljaW5nVGFibGUgPSB3aXRoQ2xlcmsoXG4gICh7IGNsZXJrLCBjb21wb25lbnQsIGZhbGxiYWNrLCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgY29uc3QgbW91bnRpbmdTdGF0dXMgPSB1c2VXYWl0Rm9yQ29tcG9uZW50TW91bnQoY29tcG9uZW50LCB7XG4gICAgICAvLyBUaGlzIGF0dHJpYnV0ZSBpcyBhZGRlZCB0byB0aGUgUHJpY2luZ1RhYmxlIHJvb3QgZWxlbWVudCBhZnRlciB3ZSd2ZSBzdWNjZXNzZnVsbHkgZmV0Y2hlZCB0aGUgcGxhbnMgYXN5bmNocm9ub3VzbHkuXG4gICAgICBzZWxlY3RvcjogJ1tkYXRhLWNvbXBvbmVudC1zdGF0dXM9XCJyZWFkeVwiXSdcbiAgICB9KTtcbiAgICBjb25zdCBzaG91bGRTaG93RmFsbGJhY2sgPSBtb3VudGluZ1N0YXR1cyA9PT0gXCJyZW5kZXJpbmdcIiB8fCAhY2xlcmsubG9hZGVkO1xuICAgIGNvbnN0IHJlbmRlcmVyUm9vdFByb3BzID0ge1xuICAgICAgLi4uc2hvdWxkU2hvd0ZhbGxiYWNrICYmIGZhbGxiYWNrICYmIHsgc3R5bGU6IHsgZGlzcGxheTogXCJub25lXCIgfSB9XG4gICAgfTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFJlYWN0Ny5GcmFnbWVudCwgbnVsbCwgc2hvdWxkU2hvd0ZhbGxiYWNrICYmIGZhbGxiYWNrLCBjbGVyay5sb2FkZWQgJiYgLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFxuICAgICAgQ2xlcmtIb3N0UmVuZGVyZXIsXG4gICAgICB7XG4gICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgbW91bnQ6IGNsZXJrLm1vdW50UHJpY2luZ1RhYmxlLFxuICAgICAgICB1bm1vdW50OiBjbGVyay51bm1vdW50UHJpY2luZ1RhYmxlLFxuICAgICAgICB1cGRhdGVQcm9wczogY2xlcmsuX191bnN0YWJsZV9fdXBkYXRlUHJvcHMsXG4gICAgICAgIHByb3BzLFxuICAgICAgICByb290UHJvcHM6IHJlbmRlcmVyUm9vdFByb3BzXG4gICAgICB9XG4gICAgKSk7XG4gIH0sXG4gIHsgY29tcG9uZW50OiBcIlByaWNpbmdUYWJsZVwiLCByZW5kZXJXaGlsZUxvYWRpbmc6IHRydWUgfVxuKTtcbnZhciBBUElLZXlzID0gd2l0aENsZXJrKFxuICAoeyBjbGVyaywgY29tcG9uZW50LCBmYWxsYmFjaywgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IG1vdW50aW5nU3RhdHVzID0gdXNlV2FpdEZvckNvbXBvbmVudE1vdW50KGNvbXBvbmVudCk7XG4gICAgY29uc3Qgc2hvdWxkU2hvd0ZhbGxiYWNrID0gbW91bnRpbmdTdGF0dXMgPT09IFwicmVuZGVyaW5nXCIgfHwgIWNsZXJrLmxvYWRlZDtcbiAgICBjb25zdCByZW5kZXJlclJvb3RQcm9wcyA9IHtcbiAgICAgIC4uLnNob3VsZFNob3dGYWxsYmFjayAmJiBmYWxsYmFjayAmJiB7IHN0eWxlOiB7IGRpc3BsYXk6IFwibm9uZVwiIH0gfVxuICAgIH07XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChSZWFjdDcuRnJhZ21lbnQsIG51bGwsIHNob3VsZFNob3dGYWxsYmFjayAmJiBmYWxsYmFjaywgY2xlcmsubG9hZGVkICYmIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChcbiAgICAgIENsZXJrSG9zdFJlbmRlcmVyLFxuICAgICAge1xuICAgICAgICBjb21wb25lbnQsXG4gICAgICAgIG1vdW50OiBjbGVyay5tb3VudEFwaUtleXMsXG4gICAgICAgIHVubW91bnQ6IGNsZXJrLnVubW91bnRBcGlLZXlzLFxuICAgICAgICB1cGRhdGVQcm9wczogY2xlcmsuX191bnN0YWJsZV9fdXBkYXRlUHJvcHMsXG4gICAgICAgIHByb3BzLFxuICAgICAgICByb290UHJvcHM6IHJlbmRlcmVyUm9vdFByb3BzXG4gICAgICB9XG4gICAgKSk7XG4gIH0sXG4gIHsgY29tcG9uZW50OiBcIkFwaUtleXNcIiwgcmVuZGVyV2hpbGVMb2FkaW5nOiB0cnVlIH1cbik7XG52YXIgVXNlckF2YXRhciA9IHdpdGhDbGVyayhcbiAgKHsgY2xlcmssIGNvbXBvbmVudCwgZmFsbGJhY2ssIC4uLnByb3BzIH0pID0+IHtcbiAgICBjb25zdCBtb3VudGluZ1N0YXR1cyA9IHVzZVdhaXRGb3JDb21wb25lbnRNb3VudChjb21wb25lbnQpO1xuICAgIGNvbnN0IHNob3VsZFNob3dGYWxsYmFjayA9IG1vdW50aW5nU3RhdHVzID09PSBcInJlbmRlcmluZ1wiIHx8ICFjbGVyay5sb2FkZWQ7XG4gICAgY29uc3QgcmVuZGVyZXJSb290UHJvcHMgPSB7XG4gICAgICAuLi5zaG91bGRTaG93RmFsbGJhY2sgJiYgZmFsbGJhY2sgJiYgeyBzdHlsZTogeyBkaXNwbGF5OiBcIm5vbmVcIiB9IH1cbiAgICB9O1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoUmVhY3Q3LkZyYWdtZW50LCBudWxsLCBzaG91bGRTaG93RmFsbGJhY2sgJiYgZmFsbGJhY2ssIGNsZXJrLmxvYWRlZCAmJiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBDbGVya0hvc3RSZW5kZXJlcixcbiAgICAgIHtcbiAgICAgICAgY29tcG9uZW50LFxuICAgICAgICBtb3VudDogY2xlcmsubW91bnRVc2VyQXZhdGFyLFxuICAgICAgICB1bm1vdW50OiBjbGVyay51bm1vdW50VXNlckF2YXRhcixcbiAgICAgICAgdXBkYXRlUHJvcHM6IGNsZXJrLl9fdW5zdGFibGVfX3VwZGF0ZVByb3BzLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgcm9vdFByb3BzOiByZW5kZXJlclJvb3RQcm9wc1xuICAgICAgfVxuICAgICkpO1xuICB9LFxuICB7IGNvbXBvbmVudDogXCJVc2VyQXZhdGFyXCIsIHJlbmRlcldoaWxlTG9hZGluZzogdHJ1ZSB9XG4pO1xudmFyIFRhc2tDaG9vc2VPcmdhbml6YXRpb24gPSB3aXRoQ2xlcmsoXG4gICh7IGNsZXJrLCBjb21wb25lbnQsIGZhbGxiYWNrLCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgY29uc3QgbW91bnRpbmdTdGF0dXMgPSB1c2VXYWl0Rm9yQ29tcG9uZW50TW91bnQoY29tcG9uZW50KTtcbiAgICBjb25zdCBzaG91bGRTaG93RmFsbGJhY2sgPSBtb3VudGluZ1N0YXR1cyA9PT0gXCJyZW5kZXJpbmdcIiB8fCAhY2xlcmsubG9hZGVkO1xuICAgIGNvbnN0IHJlbmRlcmVyUm9vdFByb3BzID0ge1xuICAgICAgLi4uc2hvdWxkU2hvd0ZhbGxiYWNrICYmIGZhbGxiYWNrICYmIHsgc3R5bGU6IHsgZGlzcGxheTogXCJub25lXCIgfSB9XG4gICAgfTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFJlYWN0Ny5GcmFnbWVudCwgbnVsbCwgc2hvdWxkU2hvd0ZhbGxiYWNrICYmIGZhbGxiYWNrLCBjbGVyay5sb2FkZWQgJiYgLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFxuICAgICAgQ2xlcmtIb3N0UmVuZGVyZXIsXG4gICAgICB7XG4gICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgbW91bnQ6IGNsZXJrLm1vdW50VGFza0Nob29zZU9yZ2FuaXphdGlvbixcbiAgICAgICAgdW5tb3VudDogY2xlcmsudW5tb3VudFRhc2tDaG9vc2VPcmdhbml6YXRpb24sXG4gICAgICAgIHVwZGF0ZVByb3BzOiBjbGVyay5fX3Vuc3RhYmxlX191cGRhdGVQcm9wcyxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHJvb3RQcm9wczogcmVuZGVyZXJSb290UHJvcHNcbiAgICAgIH1cbiAgICApKTtcbiAgfSxcbiAgeyBjb21wb25lbnQ6IFwiVGFza0Nob29zZU9yZ2FuaXphdGlvblwiLCByZW5kZXJXaGlsZUxvYWRpbmc6IHRydWUgfVxuKTtcblxuZXhwb3J0IHtcbiAgYXNzZXJ0U2luZ2xlQ2hpbGQsXG4gIG5vcm1hbGl6ZVdpdGhEZWZhdWx0VmFsdWUsXG4gIHNhZmVFeGVjdXRlLFxuICBpc0NvbnN0cnVjdG9yLFxuICB3aXRoTWF4QWxsb3dlZEluc3RhbmNlc0d1YXJkLFxuICBTaWduSW4sXG4gIFNpZ25VcCxcbiAgVXNlclByb2ZpbGUsXG4gIFVzZXJCdXR0b24sXG4gIE9yZ2FuaXphdGlvblByb2ZpbGUsXG4gIENyZWF0ZU9yZ2FuaXphdGlvbixcbiAgT3JnYW5pemF0aW9uU3dpdGNoZXIsXG4gIE9yZ2FuaXphdGlvbkxpc3QsXG4gIEdvb2dsZU9uZVRhcCxcbiAgV2FpdGxpc3QsXG4gIFByaWNpbmdUYWJsZSxcbiAgQVBJS2V5cyxcbiAgVXNlckF2YXRhcixcbiAgVGFza0Nob29zZU9yZ2FuaXphdGlvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLVNPSzc1WlVLLm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/chunk-SOK75ZUK.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/chunk-XIVXL4LQ.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@clerk/clerk-react/dist/chunk-XIVXL4LQ.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthContext: () => (/* binding */ AuthContext),\n/* harmony export */   IsomorphicClerkContext: () => (/* binding */ IsomorphicClerkContext),\n/* harmony export */   __experimental_CheckoutProvider: () => (/* reexport safe */ _clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.__experimental_CheckoutProvider),\n/* harmony export */   __experimental_PaymentElement: () => (/* reexport safe */ _clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.__experimental_PaymentElement),\n/* harmony export */   __experimental_PaymentElementProvider: () => (/* reexport safe */ _clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.__experimental_PaymentElementProvider),\n/* harmony export */   __experimental_useCheckout: () => (/* reexport safe */ _clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.__experimental_useCheckout),\n/* harmony export */   __experimental_usePaymentElement: () => (/* reexport safe */ _clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.__experimental_usePaymentElement),\n/* harmony export */   customLinkWrongProps: () => (/* binding */ customLinkWrongProps),\n/* harmony export */   customMenuItemsIgnoredComponent: () => (/* binding */ customMenuItemsIgnoredComponent),\n/* harmony export */   customPageWrongProps: () => (/* binding */ customPageWrongProps),\n/* harmony export */   customPagesIgnoredComponent: () => (/* binding */ customPagesIgnoredComponent),\n/* harmony export */   errorThrower: () => (/* binding */ errorThrower),\n/* harmony export */   incompatibleRoutingWithPathProvidedError: () => (/* binding */ incompatibleRoutingWithPathProvidedError),\n/* harmony export */   multipleChildrenInButtonComponent: () => (/* binding */ multipleChildrenInButtonComponent),\n/* harmony export */   multipleClerkProvidersError: () => (/* binding */ multipleClerkProvidersError),\n/* harmony export */   noPathProvidedError: () => (/* binding */ noPathProvidedError),\n/* harmony export */   organizationProfileLinkRenderedError: () => (/* binding */ organizationProfileLinkRenderedError),\n/* harmony export */   organizationProfilePageRenderedError: () => (/* binding */ organizationProfilePageRenderedError),\n/* harmony export */   setErrorThrowerOptions: () => (/* binding */ setErrorThrowerOptions),\n/* harmony export */   unsupportedNonBrowserDomainOrProxyUrlFunction: () => (/* binding */ unsupportedNonBrowserDomainOrProxyUrlFunction),\n/* harmony export */   useAssertWrappedByClerkProvider: () => (/* binding */ useAssertWrappedByClerkProvider),\n/* harmony export */   useAuth: () => (/* binding */ useAuth),\n/* harmony export */   useClerk: () => (/* reexport safe */ _clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.useClerk),\n/* harmony export */   useDerivedAuth: () => (/* binding */ useDerivedAuth),\n/* harmony export */   useEmailLink: () => (/* binding */ useEmailLink),\n/* harmony export */   useIsomorphicClerkContext: () => (/* binding */ useIsomorphicClerkContext),\n/* harmony export */   useOrganization: () => (/* reexport safe */ _clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.useOrganization),\n/* harmony export */   useOrganizationList: () => (/* reexport safe */ _clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.useOrganizationList),\n/* harmony export */   useReverification: () => (/* reexport safe */ _clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.useReverification),\n/* harmony export */   useSession: () => (/* reexport safe */ _clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.useSession),\n/* harmony export */   useSessionList: () => (/* reexport safe */ _clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.useSessionList),\n/* harmony export */   useSignIn: () => (/* binding */ useSignIn),\n/* harmony export */   useSignUp: () => (/* binding */ useSignUp),\n/* harmony export */   useUser: () => (/* reexport safe */ _clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.useUser),\n/* harmony export */   userButtonIgnoredComponent: () => (/* binding */ userButtonIgnoredComponent),\n/* harmony export */   userButtonMenuActionRenderedError: () => (/* binding */ userButtonMenuActionRenderedError),\n/* harmony export */   userButtonMenuItemLinkWrongProps: () => (/* binding */ userButtonMenuItemLinkWrongProps),\n/* harmony export */   userButtonMenuItemsActionWrongsProps: () => (/* binding */ userButtonMenuItemsActionWrongsProps),\n/* harmony export */   userButtonMenuItemsRenderedError: () => (/* binding */ userButtonMenuItemsRenderedError),\n/* harmony export */   userButtonMenuLinkRenderedError: () => (/* binding */ userButtonMenuLinkRenderedError),\n/* harmony export */   userProfileLinkRenderedError: () => (/* binding */ userProfileLinkRenderedError),\n/* harmony export */   userProfilePageRenderedError: () => (/* binding */ userProfilePageRenderedError),\n/* harmony export */   withClerk: () => (/* binding */ withClerk)\n/* harmony export */ });\n/* harmony import */ var _clerk_shared_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @clerk/shared/error */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/error.mjs\");\n/* harmony import */ var _clerk_shared_authorization__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @clerk/shared/authorization */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/authorization.mjs\");\n/* harmony import */ var _clerk_shared_telemetry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @clerk/shared/telemetry */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/telemetry.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @clerk/shared/react */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/react/index.mjs\");\n// src/errors/errorThrower.ts\n\nvar errorThrower = (0,_clerk_shared_error__WEBPACK_IMPORTED_MODULE_0__.buildErrorThrower)({ packageName: \"@clerk/clerk-react\" });\nfunction setErrorThrowerOptions(options) {\n  errorThrower.setMessages(options).setPackageName(options);\n}\n\n// src/hooks/useAuth.ts\n\n\n\n\n// src/contexts/AuthContext.ts\n\nvar [AuthContext, useAuthContext] = (0,_clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.createContextAndHook)(\"AuthContext\");\n\n// src/contexts/IsomorphicClerkContext.tsx\n\nvar IsomorphicClerkContext = _clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.ClerkInstanceContext;\nvar useIsomorphicClerkContext = _clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.useClerkInstanceContext;\n\n// src/errors/messages.ts\nvar multipleClerkProvidersError = \"You've added multiple <ClerkProvider> components in your React component tree. Wrap your components in a single <ClerkProvider>.\";\nvar multipleChildrenInButtonComponent = (name) => `You've passed multiple children components to <${name}/>. You can only pass a single child component or text.`;\nvar invalidStateError = \"Invalid state. Feel free to submit a bug or reach out to support here: https://clerk.com/support\";\nvar unsupportedNonBrowserDomainOrProxyUrlFunction = \"Unsupported usage of isSatellite, domain or proxyUrl. The usage of isSatellite, domain or proxyUrl as function is not supported in non-browser environments.\";\nvar userProfilePageRenderedError = \"<UserProfile.Page /> component needs to be a direct child of `<UserProfile />` or `<UserButton />`.\";\nvar userProfileLinkRenderedError = \"<UserProfile.Link /> component needs to be a direct child of `<UserProfile />` or `<UserButton />`.\";\nvar organizationProfilePageRenderedError = \"<OrganizationProfile.Page /> component needs to be a direct child of `<OrganizationProfile />` or `<OrganizationSwitcher />`.\";\nvar organizationProfileLinkRenderedError = \"<OrganizationProfile.Link /> component needs to be a direct child of `<OrganizationProfile />` or `<OrganizationSwitcher />`.\";\nvar customPagesIgnoredComponent = (componentName) => `<${componentName} /> can only accept <${componentName}.Page /> and <${componentName}.Link /> as its children. Any other provided component will be ignored. Additionally, please ensure that the component is rendered in a client component.`;\nvar customPageWrongProps = (componentName) => `Missing props. <${componentName}.Page /> component requires the following props: url, label, labelIcon, alongside with children to be rendered inside the page.`;\nvar customLinkWrongProps = (componentName) => `Missing props. <${componentName}.Link /> component requires the following props: url, label and labelIcon.`;\nvar noPathProvidedError = (componentName) => `The <${componentName}/> component uses path-based routing by default unless a different routing strategy is provided using the \\`routing\\` prop. When path-based routing is used, you need to provide the path where the component is mounted on by using the \\`path\\` prop. Example: <${componentName} path={'/my-path'} />`;\nvar incompatibleRoutingWithPathProvidedError = (componentName) => `The \\`path\\` prop will only be respected when the Clerk component uses path-based routing. To resolve this error, pass \\`routing='path'\\` to the <${componentName}/> component, or drop the \\`path\\` prop to switch to hash-based routing. For more details please refer to our docs: https://clerk.com/docs`;\nvar userButtonIgnoredComponent = `<UserButton /> can only accept <UserButton.UserProfilePage />, <UserButton.UserProfileLink /> and <UserButton.MenuItems /> as its children. Any other provided component will be ignored. Additionally, please ensure that the component is rendered in a client component.`;\nvar customMenuItemsIgnoredComponent = \"<UserButton.MenuItems /> component can only accept <UserButton.Action /> and <UserButton.Link /> as its children. Any other provided component will be ignored. Additionally, please ensure that the component is rendered in a client component.\";\nvar userButtonMenuItemsRenderedError = \"<UserButton.MenuItems /> component needs to be a direct child of `<UserButton />`.\";\nvar userButtonMenuActionRenderedError = \"<UserButton.Action /> component needs to be a direct child of `<UserButton.MenuItems />`.\";\nvar userButtonMenuLinkRenderedError = \"<UserButton.Link /> component needs to be a direct child of `<UserButton.MenuItems />`.\";\nvar userButtonMenuItemLinkWrongProps = \"Missing props. <UserButton.Link /> component requires the following props: href, label and labelIcon.\";\nvar userButtonMenuItemsActionWrongsProps = \"Missing props. <UserButton.Action /> component requires the following props: label.\";\n\n// src/hooks/useAssertWrappedByClerkProvider.ts\n\nvar useAssertWrappedByClerkProvider = (source) => {\n  (0,_clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.useAssertWrappedByClerkProvider)(() => {\n    errorThrower.throwMissingClerkProviderError({ source });\n  });\n};\n\n// src/hooks/utils.ts\nvar clerkLoaded = (isomorphicClerk) => {\n  return new Promise((resolve) => {\n    const handler = (status) => {\n      if ([\"ready\", \"degraded\"].includes(status)) {\n        resolve();\n        isomorphicClerk.off(\"status\", handler);\n      }\n    };\n    isomorphicClerk.on(\"status\", handler, { notify: true });\n  });\n};\nvar createGetToken = (isomorphicClerk) => {\n  return async (options) => {\n    await clerkLoaded(isomorphicClerk);\n    if (!isomorphicClerk.session) {\n      return null;\n    }\n    return isomorphicClerk.session.getToken(options);\n  };\n};\nvar createSignOut = (isomorphicClerk) => {\n  return async (...args) => {\n    await clerkLoaded(isomorphicClerk);\n    return isomorphicClerk.signOut(...args);\n  };\n};\n\n// src/hooks/useAuth.ts\nvar useAuth = (initialAuthStateOrOptions = {}) => {\n  var _a;\n  useAssertWrappedByClerkProvider(\"useAuth\");\n  const { treatPendingAsSignedOut, ...rest } = initialAuthStateOrOptions != null ? initialAuthStateOrOptions : {};\n  const initialAuthState = rest;\n  const authContextFromHook = useAuthContext();\n  let authContext = authContextFromHook;\n  if (authContext.sessionId === void 0 && authContext.userId === void 0) {\n    authContext = initialAuthState != null ? initialAuthState : {};\n  }\n  const isomorphicClerk = useIsomorphicClerkContext();\n  const getToken = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(createGetToken(isomorphicClerk), [isomorphicClerk]);\n  const signOut = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(createSignOut(isomorphicClerk), [isomorphicClerk]);\n  (_a = isomorphicClerk.telemetry) == null ? void 0 : _a.record((0,_clerk_shared_telemetry__WEBPACK_IMPORTED_MODULE_2__.eventMethodCalled)(\"useAuth\", { treatPendingAsSignedOut }));\n  return useDerivedAuth(\n    {\n      ...authContext,\n      getToken,\n      signOut\n    },\n    {\n      treatPendingAsSignedOut\n    }\n  );\n};\nfunction useDerivedAuth(authObject, { treatPendingAsSignedOut = true } = {}) {\n  const { userId, orgId, orgRole, has, signOut, getToken, orgPermissions, factorVerificationAge, sessionClaims } = authObject != null ? authObject : {};\n  const derivedHas = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    (params) => {\n      if (has) {\n        return has(params);\n      }\n      return (0,_clerk_shared_authorization__WEBPACK_IMPORTED_MODULE_1__.createCheckAuthorization)({\n        userId,\n        orgId,\n        orgRole,\n        orgPermissions,\n        factorVerificationAge,\n        features: (sessionClaims == null ? void 0 : sessionClaims.fea) || \"\",\n        plans: (sessionClaims == null ? void 0 : sessionClaims.pla) || \"\"\n      })(params);\n    },\n    [has, userId, orgId, orgRole, orgPermissions, factorVerificationAge]\n  );\n  const payload = (0,_clerk_shared_authorization__WEBPACK_IMPORTED_MODULE_1__.resolveAuthState)({\n    authObject: {\n      ...authObject,\n      getToken,\n      signOut,\n      has: derivedHas\n    },\n    options: {\n      treatPendingAsSignedOut\n    }\n  });\n  if (!payload) {\n    return errorThrower.throw(invalidStateError);\n  }\n  return payload;\n}\n\n// src/hooks/useEmailLink.ts\n\nfunction useEmailLink(resource) {\n  const { startEmailLinkFlow, cancelEmailLinkFlow } = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(() => resource.createEmailLinkFlow(), [resource]);\n  react__WEBPACK_IMPORTED_MODULE_3__.useEffect(() => {\n    return cancelEmailLinkFlow;\n  }, []);\n  return {\n    startEmailLinkFlow,\n    cancelEmailLinkFlow\n  };\n}\n\n// src/hooks/useSignIn.ts\n\n\nvar useSignIn = () => {\n  var _a;\n  useAssertWrappedByClerkProvider(\"useSignIn\");\n  const isomorphicClerk = useIsomorphicClerkContext();\n  const client = (0,_clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.useClientContext)();\n  (_a = isomorphicClerk.telemetry) == null ? void 0 : _a.record((0,_clerk_shared_telemetry__WEBPACK_IMPORTED_MODULE_2__.eventMethodCalled)(\"useSignIn\"));\n  if (!client) {\n    return { isLoaded: false, signIn: void 0, setActive: void 0 };\n  }\n  return {\n    isLoaded: true,\n    signIn: client.signIn,\n    setActive: isomorphicClerk.setActive\n  };\n};\n\n// src/hooks/useSignUp.ts\n\n\nvar useSignUp = () => {\n  var _a;\n  useAssertWrappedByClerkProvider(\"useSignUp\");\n  const isomorphicClerk = useIsomorphicClerkContext();\n  const client = (0,_clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.useClientContext)();\n  (_a = isomorphicClerk.telemetry) == null ? void 0 : _a.record((0,_clerk_shared_telemetry__WEBPACK_IMPORTED_MODULE_2__.eventMethodCalled)(\"useSignUp\"));\n  if (!client) {\n    return { isLoaded: false, signUp: void 0, setActive: void 0 };\n  }\n  return {\n    isLoaded: true,\n    signUp: client.signUp,\n    setActive: isomorphicClerk.setActive\n  };\n};\n\n// src/hooks/index.ts\n\n\n// src/components/withClerk.tsx\n\nvar withClerk = (Component, displayNameOrOptions) => {\n  const passedDisplayedName = typeof displayNameOrOptions === \"string\" ? displayNameOrOptions : displayNameOrOptions == null ? void 0 : displayNameOrOptions.component;\n  const displayName = passedDisplayedName || Component.displayName || Component.name || \"Component\";\n  Component.displayName = displayName;\n  const options = typeof displayNameOrOptions === \"string\" ? void 0 : displayNameOrOptions;\n  const HOC = (props) => {\n    useAssertWrappedByClerkProvider(displayName || \"withClerk\");\n    const clerk = useIsomorphicClerkContext();\n    if (!clerk.loaded && !(options == null ? void 0 : options.renderWhileLoading)) {\n      return null;\n    }\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_3__.createElement(\n      Component,\n      {\n        ...props,\n        component: displayName,\n        clerk\n      }\n    );\n  };\n  HOC.displayName = `withClerk(${displayName})`;\n  return HOC;\n};\n\n\n//# sourceMappingURL=chunk-XIVXL4LQ.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvY2xlcmstcmVhY3QvZGlzdC9jaHVuay1YSVZYTDRMUS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDd0Q7QUFDeEQsbUJBQW1CLHNFQUFpQixHQUFHLG1DQUFtQztBQUMxRTtBQUNBO0FBQ0E7O0FBRUE7QUFDeUY7QUFDN0I7QUFDeEI7O0FBRXBDO0FBQzJEO0FBQzNELG9DQUFvQyx5RUFBb0I7O0FBRXhEO0FBQ29GO0FBQ3BGLDZCQUE2QixxRUFBb0I7QUFDakQsZ0NBQWdDLHdFQUF1Qjs7QUFFdkQ7QUFDQTtBQUNBLG9HQUFvRyxLQUFLO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxlQUFlLHNCQUFzQixjQUFjLGdCQUFnQixjQUFjO0FBQzFJLGlFQUFpRSxjQUFjO0FBQy9FLGlFQUFpRSxjQUFjO0FBQy9FLHFEQUFxRCxjQUFjLG9RQUFvUSxlQUFlLE1BQU0sWUFBWTtBQUN4Vyx1TkFBdU4sY0FBYztBQUNyTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMrRztBQUMvRztBQUNBLEVBQUUsb0ZBQXFDO0FBQ3ZDLGtEQUFrRCxRQUFRO0FBQzFELEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsY0FBYztBQUMxRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLFVBQVUsbUNBQW1DO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFXO0FBQzlCLGtCQUFrQixrREFBVztBQUM3QixnRUFBZ0UsMEVBQWlCLGNBQWMseUJBQXlCO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpQ0FBaUMsSUFBSTtBQUMzRSxVQUFVLHVHQUF1RztBQUNqSCxxQkFBcUIsa0RBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFGQUF3QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtCQUFrQiw2RUFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMwQjtBQUMxQjtBQUNBLFVBQVUsMENBQTBDLEVBQUUsMENBQWE7QUFDbkUsRUFBRSw0Q0FBZTtBQUNqQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3VEO0FBQzJCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFFQUFnQjtBQUNqQyxnRUFBZ0UsMEVBQWtCO0FBQ2xGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzRFO0FBQ007QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUVBQWlCO0FBQ2xDLGdFQUFnRSwwRUFBa0I7QUFDbEY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFjNkI7O0FBRTdCO0FBQzJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsWUFBWTtBQUM3QztBQUNBOztBQThDRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvQGNsZXJrL2NsZXJrLXJlYWN0L2Rpc3QvY2h1bmstWElWWEw0TFEubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9lcnJvcnMvZXJyb3JUaHJvd2VyLnRzXG5pbXBvcnQgeyBidWlsZEVycm9yVGhyb3dlciB9IGZyb20gXCJAY2xlcmsvc2hhcmVkL2Vycm9yXCI7XG52YXIgZXJyb3JUaHJvd2VyID0gYnVpbGRFcnJvclRocm93ZXIoeyBwYWNrYWdlTmFtZTogXCJAY2xlcmsvY2xlcmstcmVhY3RcIiB9KTtcbmZ1bmN0aW9uIHNldEVycm9yVGhyb3dlck9wdGlvbnMob3B0aW9ucykge1xuICBlcnJvclRocm93ZXIuc2V0TWVzc2FnZXMob3B0aW9ucykuc2V0UGFja2FnZU5hbWUob3B0aW9ucyk7XG59XG5cbi8vIHNyYy9ob29rcy91c2VBdXRoLnRzXG5pbXBvcnQgeyBjcmVhdGVDaGVja0F1dGhvcml6YXRpb24sIHJlc29sdmVBdXRoU3RhdGUgfSBmcm9tIFwiQGNsZXJrL3NoYXJlZC9hdXRob3JpemF0aW9uXCI7XG5pbXBvcnQgeyBldmVudE1ldGhvZENhbGxlZCB9IGZyb20gXCJAY2xlcmsvc2hhcmVkL3RlbGVtZXRyeVwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2NvbnRleHRzL0F1dGhDb250ZXh0LnRzXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0QW5kSG9vayB9IGZyb20gXCJAY2xlcmsvc2hhcmVkL3JlYWN0XCI7XG52YXIgW0F1dGhDb250ZXh0LCB1c2VBdXRoQ29udGV4dF0gPSBjcmVhdGVDb250ZXh0QW5kSG9vayhcIkF1dGhDb250ZXh0XCIpO1xuXG4vLyBzcmMvY29udGV4dHMvSXNvbW9ycGhpY0NsZXJrQ29udGV4dC50c3hcbmltcG9ydCB7IENsZXJrSW5zdGFuY2VDb250ZXh0LCB1c2VDbGVya0luc3RhbmNlQ29udGV4dCB9IGZyb20gXCJAY2xlcmsvc2hhcmVkL3JlYWN0XCI7XG52YXIgSXNvbW9ycGhpY0NsZXJrQ29udGV4dCA9IENsZXJrSW5zdGFuY2VDb250ZXh0O1xudmFyIHVzZUlzb21vcnBoaWNDbGVya0NvbnRleHQgPSB1c2VDbGVya0luc3RhbmNlQ29udGV4dDtcblxuLy8gc3JjL2Vycm9ycy9tZXNzYWdlcy50c1xudmFyIG11bHRpcGxlQ2xlcmtQcm92aWRlcnNFcnJvciA9IFwiWW91J3ZlIGFkZGVkIG11bHRpcGxlIDxDbGVya1Byb3ZpZGVyPiBjb21wb25lbnRzIGluIHlvdXIgUmVhY3QgY29tcG9uZW50IHRyZWUuIFdyYXAgeW91ciBjb21wb25lbnRzIGluIGEgc2luZ2xlIDxDbGVya1Byb3ZpZGVyPi5cIjtcbnZhciBtdWx0aXBsZUNoaWxkcmVuSW5CdXR0b25Db21wb25lbnQgPSAobmFtZSkgPT4gYFlvdSd2ZSBwYXNzZWQgbXVsdGlwbGUgY2hpbGRyZW4gY29tcG9uZW50cyB0byA8JHtuYW1lfS8+LiBZb3UgY2FuIG9ubHkgcGFzcyBhIHNpbmdsZSBjaGlsZCBjb21wb25lbnQgb3IgdGV4dC5gO1xudmFyIGludmFsaWRTdGF0ZUVycm9yID0gXCJJbnZhbGlkIHN0YXRlLiBGZWVsIGZyZWUgdG8gc3VibWl0IGEgYnVnIG9yIHJlYWNoIG91dCB0byBzdXBwb3J0IGhlcmU6IGh0dHBzOi8vY2xlcmsuY29tL3N1cHBvcnRcIjtcbnZhciB1bnN1cHBvcnRlZE5vbkJyb3dzZXJEb21haW5PclByb3h5VXJsRnVuY3Rpb24gPSBcIlVuc3VwcG9ydGVkIHVzYWdlIG9mIGlzU2F0ZWxsaXRlLCBkb21haW4gb3IgcHJveHlVcmwuIFRoZSB1c2FnZSBvZiBpc1NhdGVsbGl0ZSwgZG9tYWluIG9yIHByb3h5VXJsIGFzIGZ1bmN0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzLlwiO1xudmFyIHVzZXJQcm9maWxlUGFnZVJlbmRlcmVkRXJyb3IgPSBcIjxVc2VyUHJvZmlsZS5QYWdlIC8+IGNvbXBvbmVudCBuZWVkcyB0byBiZSBhIGRpcmVjdCBjaGlsZCBvZiBgPFVzZXJQcm9maWxlIC8+YCBvciBgPFVzZXJCdXR0b24gLz5gLlwiO1xudmFyIHVzZXJQcm9maWxlTGlua1JlbmRlcmVkRXJyb3IgPSBcIjxVc2VyUHJvZmlsZS5MaW5rIC8+IGNvbXBvbmVudCBuZWVkcyB0byBiZSBhIGRpcmVjdCBjaGlsZCBvZiBgPFVzZXJQcm9maWxlIC8+YCBvciBgPFVzZXJCdXR0b24gLz5gLlwiO1xudmFyIG9yZ2FuaXphdGlvblByb2ZpbGVQYWdlUmVuZGVyZWRFcnJvciA9IFwiPE9yZ2FuaXphdGlvblByb2ZpbGUuUGFnZSAvPiBjb21wb25lbnQgbmVlZHMgdG8gYmUgYSBkaXJlY3QgY2hpbGQgb2YgYDxPcmdhbml6YXRpb25Qcm9maWxlIC8+YCBvciBgPE9yZ2FuaXphdGlvblN3aXRjaGVyIC8+YC5cIjtcbnZhciBvcmdhbml6YXRpb25Qcm9maWxlTGlua1JlbmRlcmVkRXJyb3IgPSBcIjxPcmdhbml6YXRpb25Qcm9maWxlLkxpbmsgLz4gY29tcG9uZW50IG5lZWRzIHRvIGJlIGEgZGlyZWN0IGNoaWxkIG9mIGA8T3JnYW5pemF0aW9uUHJvZmlsZSAvPmAgb3IgYDxPcmdhbml6YXRpb25Td2l0Y2hlciAvPmAuXCI7XG52YXIgY3VzdG9tUGFnZXNJZ25vcmVkQ29tcG9uZW50ID0gKGNvbXBvbmVudE5hbWUpID0+IGA8JHtjb21wb25lbnROYW1lfSAvPiBjYW4gb25seSBhY2NlcHQgPCR7Y29tcG9uZW50TmFtZX0uUGFnZSAvPiBhbmQgPCR7Y29tcG9uZW50TmFtZX0uTGluayAvPiBhcyBpdHMgY2hpbGRyZW4uIEFueSBvdGhlciBwcm92aWRlZCBjb21wb25lbnQgd2lsbCBiZSBpZ25vcmVkLiBBZGRpdGlvbmFsbHksIHBsZWFzZSBlbnN1cmUgdGhhdCB0aGUgY29tcG9uZW50IGlzIHJlbmRlcmVkIGluIGEgY2xpZW50IGNvbXBvbmVudC5gO1xudmFyIGN1c3RvbVBhZ2VXcm9uZ1Byb3BzID0gKGNvbXBvbmVudE5hbWUpID0+IGBNaXNzaW5nIHByb3BzLiA8JHtjb21wb25lbnROYW1lfS5QYWdlIC8+IGNvbXBvbmVudCByZXF1aXJlcyB0aGUgZm9sbG93aW5nIHByb3BzOiB1cmwsIGxhYmVsLCBsYWJlbEljb24sIGFsb25nc2lkZSB3aXRoIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgcGFnZS5gO1xudmFyIGN1c3RvbUxpbmtXcm9uZ1Byb3BzID0gKGNvbXBvbmVudE5hbWUpID0+IGBNaXNzaW5nIHByb3BzLiA8JHtjb21wb25lbnROYW1lfS5MaW5rIC8+IGNvbXBvbmVudCByZXF1aXJlcyB0aGUgZm9sbG93aW5nIHByb3BzOiB1cmwsIGxhYmVsIGFuZCBsYWJlbEljb24uYDtcbnZhciBub1BhdGhQcm92aWRlZEVycm9yID0gKGNvbXBvbmVudE5hbWUpID0+IGBUaGUgPCR7Y29tcG9uZW50TmFtZX0vPiBjb21wb25lbnQgdXNlcyBwYXRoLWJhc2VkIHJvdXRpbmcgYnkgZGVmYXVsdCB1bmxlc3MgYSBkaWZmZXJlbnQgcm91dGluZyBzdHJhdGVneSBpcyBwcm92aWRlZCB1c2luZyB0aGUgXFxgcm91dGluZ1xcYCBwcm9wLiBXaGVuIHBhdGgtYmFzZWQgcm91dGluZyBpcyB1c2VkLCB5b3UgbmVlZCB0byBwcm92aWRlIHRoZSBwYXRoIHdoZXJlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCBvbiBieSB1c2luZyB0aGUgXFxgcGF0aFxcYCBwcm9wLiBFeGFtcGxlOiA8JHtjb21wb25lbnROYW1lfSBwYXRoPXsnL215LXBhdGgnfSAvPmA7XG52YXIgaW5jb21wYXRpYmxlUm91dGluZ1dpdGhQYXRoUHJvdmlkZWRFcnJvciA9IChjb21wb25lbnROYW1lKSA9PiBgVGhlIFxcYHBhdGhcXGAgcHJvcCB3aWxsIG9ubHkgYmUgcmVzcGVjdGVkIHdoZW4gdGhlIENsZXJrIGNvbXBvbmVudCB1c2VzIHBhdGgtYmFzZWQgcm91dGluZy4gVG8gcmVzb2x2ZSB0aGlzIGVycm9yLCBwYXNzIFxcYHJvdXRpbmc9J3BhdGgnXFxgIHRvIHRoZSA8JHtjb21wb25lbnROYW1lfS8+IGNvbXBvbmVudCwgb3IgZHJvcCB0aGUgXFxgcGF0aFxcYCBwcm9wIHRvIHN3aXRjaCB0byBoYXNoLWJhc2VkIHJvdXRpbmcuIEZvciBtb3JlIGRldGFpbHMgcGxlYXNlIHJlZmVyIHRvIG91ciBkb2NzOiBodHRwczovL2NsZXJrLmNvbS9kb2NzYDtcbnZhciB1c2VyQnV0dG9uSWdub3JlZENvbXBvbmVudCA9IGA8VXNlckJ1dHRvbiAvPiBjYW4gb25seSBhY2NlcHQgPFVzZXJCdXR0b24uVXNlclByb2ZpbGVQYWdlIC8+LCA8VXNlckJ1dHRvbi5Vc2VyUHJvZmlsZUxpbmsgLz4gYW5kIDxVc2VyQnV0dG9uLk1lbnVJdGVtcyAvPiBhcyBpdHMgY2hpbGRyZW4uIEFueSBvdGhlciBwcm92aWRlZCBjb21wb25lbnQgd2lsbCBiZSBpZ25vcmVkLiBBZGRpdGlvbmFsbHksIHBsZWFzZSBlbnN1cmUgdGhhdCB0aGUgY29tcG9uZW50IGlzIHJlbmRlcmVkIGluIGEgY2xpZW50IGNvbXBvbmVudC5gO1xudmFyIGN1c3RvbU1lbnVJdGVtc0lnbm9yZWRDb21wb25lbnQgPSBcIjxVc2VyQnV0dG9uLk1lbnVJdGVtcyAvPiBjb21wb25lbnQgY2FuIG9ubHkgYWNjZXB0IDxVc2VyQnV0dG9uLkFjdGlvbiAvPiBhbmQgPFVzZXJCdXR0b24uTGluayAvPiBhcyBpdHMgY2hpbGRyZW4uIEFueSBvdGhlciBwcm92aWRlZCBjb21wb25lbnQgd2lsbCBiZSBpZ25vcmVkLiBBZGRpdGlvbmFsbHksIHBsZWFzZSBlbnN1cmUgdGhhdCB0aGUgY29tcG9uZW50IGlzIHJlbmRlcmVkIGluIGEgY2xpZW50IGNvbXBvbmVudC5cIjtcbnZhciB1c2VyQnV0dG9uTWVudUl0ZW1zUmVuZGVyZWRFcnJvciA9IFwiPFVzZXJCdXR0b24uTWVudUl0ZW1zIC8+IGNvbXBvbmVudCBuZWVkcyB0byBiZSBhIGRpcmVjdCBjaGlsZCBvZiBgPFVzZXJCdXR0b24gLz5gLlwiO1xudmFyIHVzZXJCdXR0b25NZW51QWN0aW9uUmVuZGVyZWRFcnJvciA9IFwiPFVzZXJCdXR0b24uQWN0aW9uIC8+IGNvbXBvbmVudCBuZWVkcyB0byBiZSBhIGRpcmVjdCBjaGlsZCBvZiBgPFVzZXJCdXR0b24uTWVudUl0ZW1zIC8+YC5cIjtcbnZhciB1c2VyQnV0dG9uTWVudUxpbmtSZW5kZXJlZEVycm9yID0gXCI8VXNlckJ1dHRvbi5MaW5rIC8+IGNvbXBvbmVudCBuZWVkcyB0byBiZSBhIGRpcmVjdCBjaGlsZCBvZiBgPFVzZXJCdXR0b24uTWVudUl0ZW1zIC8+YC5cIjtcbnZhciB1c2VyQnV0dG9uTWVudUl0ZW1MaW5rV3JvbmdQcm9wcyA9IFwiTWlzc2luZyBwcm9wcy4gPFVzZXJCdXR0b24uTGluayAvPiBjb21wb25lbnQgcmVxdWlyZXMgdGhlIGZvbGxvd2luZyBwcm9wczogaHJlZiwgbGFiZWwgYW5kIGxhYmVsSWNvbi5cIjtcbnZhciB1c2VyQnV0dG9uTWVudUl0ZW1zQWN0aW9uV3JvbmdzUHJvcHMgPSBcIk1pc3NpbmcgcHJvcHMuIDxVc2VyQnV0dG9uLkFjdGlvbiAvPiBjb21wb25lbnQgcmVxdWlyZXMgdGhlIGZvbGxvd2luZyBwcm9wczogbGFiZWwuXCI7XG5cbi8vIHNyYy9ob29rcy91c2VBc3NlcnRXcmFwcGVkQnlDbGVya1Byb3ZpZGVyLnRzXG5pbXBvcnQgeyB1c2VBc3NlcnRXcmFwcGVkQnlDbGVya1Byb3ZpZGVyIGFzIHVzZVNoYXJlZEFzc2VydFdyYXBwZWRCeUNsZXJrUHJvdmlkZXIgfSBmcm9tIFwiQGNsZXJrL3NoYXJlZC9yZWFjdFwiO1xudmFyIHVzZUFzc2VydFdyYXBwZWRCeUNsZXJrUHJvdmlkZXIgPSAoc291cmNlKSA9PiB7XG4gIHVzZVNoYXJlZEFzc2VydFdyYXBwZWRCeUNsZXJrUHJvdmlkZXIoKCkgPT4ge1xuICAgIGVycm9yVGhyb3dlci50aHJvd01pc3NpbmdDbGVya1Byb3ZpZGVyRXJyb3IoeyBzb3VyY2UgfSk7XG4gIH0pO1xufTtcblxuLy8gc3JjL2hvb2tzL3V0aWxzLnRzXG52YXIgY2xlcmtMb2FkZWQgPSAoaXNvbW9ycGhpY0NsZXJrKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZXIgPSAoc3RhdHVzKSA9PiB7XG4gICAgICBpZiAoW1wicmVhZHlcIiwgXCJkZWdyYWRlZFwiXS5pbmNsdWRlcyhzdGF0dXMpKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgaXNvbW9ycGhpY0NsZXJrLm9mZihcInN0YXR1c1wiLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlzb21vcnBoaWNDbGVyay5vbihcInN0YXR1c1wiLCBoYW5kbGVyLCB7IG5vdGlmeTogdHJ1ZSB9KTtcbiAgfSk7XG59O1xudmFyIGNyZWF0ZUdldFRva2VuID0gKGlzb21vcnBoaWNDbGVyaykgPT4ge1xuICByZXR1cm4gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICBhd2FpdCBjbGVya0xvYWRlZChpc29tb3JwaGljQ2xlcmspO1xuICAgIGlmICghaXNvbW9ycGhpY0NsZXJrLnNlc3Npb24pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaXNvbW9ycGhpY0NsZXJrLnNlc3Npb24uZ2V0VG9rZW4ob3B0aW9ucyk7XG4gIH07XG59O1xudmFyIGNyZWF0ZVNpZ25PdXQgPSAoaXNvbW9ycGhpY0NsZXJrKSA9PiB7XG4gIHJldHVybiBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgIGF3YWl0IGNsZXJrTG9hZGVkKGlzb21vcnBoaWNDbGVyayk7XG4gICAgcmV0dXJuIGlzb21vcnBoaWNDbGVyay5zaWduT3V0KC4uLmFyZ3MpO1xuICB9O1xufTtcblxuLy8gc3JjL2hvb2tzL3VzZUF1dGgudHNcbnZhciB1c2VBdXRoID0gKGluaXRpYWxBdXRoU3RhdGVPck9wdGlvbnMgPSB7fSkgPT4ge1xuICB2YXIgX2E7XG4gIHVzZUFzc2VydFdyYXBwZWRCeUNsZXJrUHJvdmlkZXIoXCJ1c2VBdXRoXCIpO1xuICBjb25zdCB7IHRyZWF0UGVuZGluZ0FzU2lnbmVkT3V0LCAuLi5yZXN0IH0gPSBpbml0aWFsQXV0aFN0YXRlT3JPcHRpb25zICE9IG51bGwgPyBpbml0aWFsQXV0aFN0YXRlT3JPcHRpb25zIDoge307XG4gIGNvbnN0IGluaXRpYWxBdXRoU3RhdGUgPSByZXN0O1xuICBjb25zdCBhdXRoQ29udGV4dEZyb21Ib29rID0gdXNlQXV0aENvbnRleHQoKTtcbiAgbGV0IGF1dGhDb250ZXh0ID0gYXV0aENvbnRleHRGcm9tSG9vaztcbiAgaWYgKGF1dGhDb250ZXh0LnNlc3Npb25JZCA9PT0gdm9pZCAwICYmIGF1dGhDb250ZXh0LnVzZXJJZCA9PT0gdm9pZCAwKSB7XG4gICAgYXV0aENvbnRleHQgPSBpbml0aWFsQXV0aFN0YXRlICE9IG51bGwgPyBpbml0aWFsQXV0aFN0YXRlIDoge307XG4gIH1cbiAgY29uc3QgaXNvbW9ycGhpY0NsZXJrID0gdXNlSXNvbW9ycGhpY0NsZXJrQ29udGV4dCgpO1xuICBjb25zdCBnZXRUb2tlbiA9IHVzZUNhbGxiYWNrKGNyZWF0ZUdldFRva2VuKGlzb21vcnBoaWNDbGVyayksIFtpc29tb3JwaGljQ2xlcmtdKTtcbiAgY29uc3Qgc2lnbk91dCA9IHVzZUNhbGxiYWNrKGNyZWF0ZVNpZ25PdXQoaXNvbW9ycGhpY0NsZXJrKSwgW2lzb21vcnBoaWNDbGVya10pO1xuICAoX2EgPSBpc29tb3JwaGljQ2xlcmsudGVsZW1ldHJ5KSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVjb3JkKGV2ZW50TWV0aG9kQ2FsbGVkKFwidXNlQXV0aFwiLCB7IHRyZWF0UGVuZGluZ0FzU2lnbmVkT3V0IH0pKTtcbiAgcmV0dXJuIHVzZURlcml2ZWRBdXRoKFxuICAgIHtcbiAgICAgIC4uLmF1dGhDb250ZXh0LFxuICAgICAgZ2V0VG9rZW4sXG4gICAgICBzaWduT3V0XG4gICAgfSxcbiAgICB7XG4gICAgICB0cmVhdFBlbmRpbmdBc1NpZ25lZE91dFxuICAgIH1cbiAgKTtcbn07XG5mdW5jdGlvbiB1c2VEZXJpdmVkQXV0aChhdXRoT2JqZWN0LCB7IHRyZWF0UGVuZGluZ0FzU2lnbmVkT3V0ID0gdHJ1ZSB9ID0ge30pIHtcbiAgY29uc3QgeyB1c2VySWQsIG9yZ0lkLCBvcmdSb2xlLCBoYXMsIHNpZ25PdXQsIGdldFRva2VuLCBvcmdQZXJtaXNzaW9ucywgZmFjdG9yVmVyaWZpY2F0aW9uQWdlLCBzZXNzaW9uQ2xhaW1zIH0gPSBhdXRoT2JqZWN0ICE9IG51bGwgPyBhdXRoT2JqZWN0IDoge307XG4gIGNvbnN0IGRlcml2ZWRIYXMgPSB1c2VDYWxsYmFjayhcbiAgICAocGFyYW1zKSA9PiB7XG4gICAgICBpZiAoaGFzKSB7XG4gICAgICAgIHJldHVybiBoYXMocGFyYW1zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVDaGVja0F1dGhvcml6YXRpb24oe1xuICAgICAgICB1c2VySWQsXG4gICAgICAgIG9yZ0lkLFxuICAgICAgICBvcmdSb2xlLFxuICAgICAgICBvcmdQZXJtaXNzaW9ucyxcbiAgICAgICAgZmFjdG9yVmVyaWZpY2F0aW9uQWdlLFxuICAgICAgICBmZWF0dXJlczogKHNlc3Npb25DbGFpbXMgPT0gbnVsbCA/IHZvaWQgMCA6IHNlc3Npb25DbGFpbXMuZmVhKSB8fCBcIlwiLFxuICAgICAgICBwbGFuczogKHNlc3Npb25DbGFpbXMgPT0gbnVsbCA/IHZvaWQgMCA6IHNlc3Npb25DbGFpbXMucGxhKSB8fCBcIlwiXG4gICAgICB9KShwYXJhbXMpO1xuICAgIH0sXG4gICAgW2hhcywgdXNlcklkLCBvcmdJZCwgb3JnUm9sZSwgb3JnUGVybWlzc2lvbnMsIGZhY3RvclZlcmlmaWNhdGlvbkFnZV1cbiAgKTtcbiAgY29uc3QgcGF5bG9hZCA9IHJlc29sdmVBdXRoU3RhdGUoe1xuICAgIGF1dGhPYmplY3Q6IHtcbiAgICAgIC4uLmF1dGhPYmplY3QsXG4gICAgICBnZXRUb2tlbixcbiAgICAgIHNpZ25PdXQsXG4gICAgICBoYXM6IGRlcml2ZWRIYXNcbiAgICB9LFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHRyZWF0UGVuZGluZ0FzU2lnbmVkT3V0XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGVycm9yVGhyb3dlci50aHJvdyhpbnZhbGlkU3RhdGVFcnJvcik7XG4gIH1cbiAgcmV0dXJuIHBheWxvYWQ7XG59XG5cbi8vIHNyYy9ob29rcy91c2VFbWFpbExpbmsudHNcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZUVtYWlsTGluayhyZXNvdXJjZSkge1xuICBjb25zdCB7IHN0YXJ0RW1haWxMaW5rRmxvdywgY2FuY2VsRW1haWxMaW5rRmxvdyB9ID0gUmVhY3QudXNlTWVtbygoKSA9PiByZXNvdXJjZS5jcmVhdGVFbWFpbExpbmtGbG93KCksIFtyZXNvdXJjZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBjYW5jZWxFbWFpbExpbmtGbG93O1xuICB9LCBbXSk7XG4gIHJldHVybiB7XG4gICAgc3RhcnRFbWFpbExpbmtGbG93LFxuICAgIGNhbmNlbEVtYWlsTGlua0Zsb3dcbiAgfTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZVNpZ25Jbi50c1xuaW1wb3J0IHsgdXNlQ2xpZW50Q29udGV4dCB9IGZyb20gXCJAY2xlcmsvc2hhcmVkL3JlYWN0XCI7XG5pbXBvcnQgeyBldmVudE1ldGhvZENhbGxlZCBhcyBldmVudE1ldGhvZENhbGxlZDIgfSBmcm9tIFwiQGNsZXJrL3NoYXJlZC90ZWxlbWV0cnlcIjtcbnZhciB1c2VTaWduSW4gPSAoKSA9PiB7XG4gIHZhciBfYTtcbiAgdXNlQXNzZXJ0V3JhcHBlZEJ5Q2xlcmtQcm92aWRlcihcInVzZVNpZ25JblwiKTtcbiAgY29uc3QgaXNvbW9ycGhpY0NsZXJrID0gdXNlSXNvbW9ycGhpY0NsZXJrQ29udGV4dCgpO1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnRDb250ZXh0KCk7XG4gIChfYSA9IGlzb21vcnBoaWNDbGVyay50ZWxlbWV0cnkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZWNvcmQoZXZlbnRNZXRob2RDYWxsZWQyKFwidXNlU2lnbkluXCIpKTtcbiAgaWYgKCFjbGllbnQpIHtcbiAgICByZXR1cm4geyBpc0xvYWRlZDogZmFsc2UsIHNpZ25Jbjogdm9pZCAwLCBzZXRBY3RpdmU6IHZvaWQgMCB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNMb2FkZWQ6IHRydWUsXG4gICAgc2lnbkluOiBjbGllbnQuc2lnbkluLFxuICAgIHNldEFjdGl2ZTogaXNvbW9ycGhpY0NsZXJrLnNldEFjdGl2ZVxuICB9O1xufTtcblxuLy8gc3JjL2hvb2tzL3VzZVNpZ25VcC50c1xuaW1wb3J0IHsgdXNlQ2xpZW50Q29udGV4dCBhcyB1c2VDbGllbnRDb250ZXh0MiB9IGZyb20gXCJAY2xlcmsvc2hhcmVkL3JlYWN0XCI7XG5pbXBvcnQgeyBldmVudE1ldGhvZENhbGxlZCBhcyBldmVudE1ldGhvZENhbGxlZDMgfSBmcm9tIFwiQGNsZXJrL3NoYXJlZC90ZWxlbWV0cnlcIjtcbnZhciB1c2VTaWduVXAgPSAoKSA9PiB7XG4gIHZhciBfYTtcbiAgdXNlQXNzZXJ0V3JhcHBlZEJ5Q2xlcmtQcm92aWRlcihcInVzZVNpZ25VcFwiKTtcbiAgY29uc3QgaXNvbW9ycGhpY0NsZXJrID0gdXNlSXNvbW9ycGhpY0NsZXJrQ29udGV4dCgpO1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnRDb250ZXh0MigpO1xuICAoX2EgPSBpc29tb3JwaGljQ2xlcmsudGVsZW1ldHJ5KSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVjb3JkKGV2ZW50TWV0aG9kQ2FsbGVkMyhcInVzZVNpZ25VcFwiKSk7XG4gIGlmICghY2xpZW50KSB7XG4gICAgcmV0dXJuIHsgaXNMb2FkZWQ6IGZhbHNlLCBzaWduVXA6IHZvaWQgMCwgc2V0QWN0aXZlOiB2b2lkIDAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlzTG9hZGVkOiB0cnVlLFxuICAgIHNpZ25VcDogY2xpZW50LnNpZ25VcCxcbiAgICBzZXRBY3RpdmU6IGlzb21vcnBoaWNDbGVyay5zZXRBY3RpdmVcbiAgfTtcbn07XG5cbi8vIHNyYy9ob29rcy9pbmRleC50c1xuaW1wb3J0IHtcbiAgdXNlQ2xlcmssXG4gIHVzZU9yZ2FuaXphdGlvbixcbiAgdXNlT3JnYW5pemF0aW9uTGlzdCxcbiAgdXNlU2Vzc2lvbkxpc3QsXG4gIHVzZVVzZXIsXG4gIHVzZVNlc3Npb24sXG4gIHVzZVJldmVyaWZpY2F0aW9uLFxuICBfX2V4cGVyaW1lbnRhbF91c2VDaGVja291dCxcbiAgX19leHBlcmltZW50YWxfQ2hlY2tvdXRQcm92aWRlcixcbiAgX19leHBlcmltZW50YWxfdXNlUGF5bWVudEVsZW1lbnQsXG4gIF9fZXhwZXJpbWVudGFsX1BheW1lbnRFbGVtZW50UHJvdmlkZXIsXG4gIF9fZXhwZXJpbWVudGFsX1BheW1lbnRFbGVtZW50XG59IGZyb20gXCJAY2xlcmsvc2hhcmVkL3JlYWN0XCI7XG5cbi8vIHNyYy9jb21wb25lbnRzL3dpdGhDbGVyay50c3hcbmltcG9ydCBSZWFjdDIgZnJvbSBcInJlYWN0XCI7XG52YXIgd2l0aENsZXJrID0gKENvbXBvbmVudCwgZGlzcGxheU5hbWVPck9wdGlvbnMpID0+IHtcbiAgY29uc3QgcGFzc2VkRGlzcGxheWVkTmFtZSA9IHR5cGVvZiBkaXNwbGF5TmFtZU9yT3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/IGRpc3BsYXlOYW1lT3JPcHRpb25zIDogZGlzcGxheU5hbWVPck9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGRpc3BsYXlOYW1lT3JPcHRpb25zLmNvbXBvbmVudDtcbiAgY29uc3QgZGlzcGxheU5hbWUgPSBwYXNzZWREaXNwbGF5ZWROYW1lIHx8IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCBcIkNvbXBvbmVudFwiO1xuICBDb21wb25lbnQuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBkaXNwbGF5TmFtZU9yT3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/IHZvaWQgMCA6IGRpc3BsYXlOYW1lT3JPcHRpb25zO1xuICBjb25zdCBIT0MgPSAocHJvcHMpID0+IHtcbiAgICB1c2VBc3NlcnRXcmFwcGVkQnlDbGVya1Byb3ZpZGVyKGRpc3BsYXlOYW1lIHx8IFwid2l0aENsZXJrXCIpO1xuICAgIGNvbnN0IGNsZXJrID0gdXNlSXNvbW9ycGhpY0NsZXJrQ29udGV4dCgpO1xuICAgIGlmICghY2xlcmsubG9hZGVkICYmICEob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5yZW5kZXJXaGlsZUxvYWRpbmcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIGNvbXBvbmVudDogZGlzcGxheU5hbWUsXG4gICAgICAgIGNsZXJrXG4gICAgICB9XG4gICAgKTtcbiAgfTtcbiAgSE9DLmRpc3BsYXlOYW1lID0gYHdpdGhDbGVyaygke2Rpc3BsYXlOYW1lfSlgO1xuICByZXR1cm4gSE9DO1xufTtcblxuZXhwb3J0IHtcbiAgZXJyb3JUaHJvd2VyLFxuICBzZXRFcnJvclRocm93ZXJPcHRpb25zLFxuICBtdWx0aXBsZUNsZXJrUHJvdmlkZXJzRXJyb3IsXG4gIG11bHRpcGxlQ2hpbGRyZW5JbkJ1dHRvbkNvbXBvbmVudCxcbiAgdW5zdXBwb3J0ZWROb25Ccm93c2VyRG9tYWluT3JQcm94eVVybEZ1bmN0aW9uLFxuICB1c2VyUHJvZmlsZVBhZ2VSZW5kZXJlZEVycm9yLFxuICB1c2VyUHJvZmlsZUxpbmtSZW5kZXJlZEVycm9yLFxuICBvcmdhbml6YXRpb25Qcm9maWxlUGFnZVJlbmRlcmVkRXJyb3IsXG4gIG9yZ2FuaXphdGlvblByb2ZpbGVMaW5rUmVuZGVyZWRFcnJvcixcbiAgY3VzdG9tUGFnZXNJZ25vcmVkQ29tcG9uZW50LFxuICBjdXN0b21QYWdlV3JvbmdQcm9wcyxcbiAgY3VzdG9tTGlua1dyb25nUHJvcHMsXG4gIG5vUGF0aFByb3ZpZGVkRXJyb3IsXG4gIGluY29tcGF0aWJsZVJvdXRpbmdXaXRoUGF0aFByb3ZpZGVkRXJyb3IsXG4gIHVzZXJCdXR0b25JZ25vcmVkQ29tcG9uZW50LFxuICBjdXN0b21NZW51SXRlbXNJZ25vcmVkQ29tcG9uZW50LFxuICB1c2VyQnV0dG9uTWVudUl0ZW1zUmVuZGVyZWRFcnJvcixcbiAgdXNlckJ1dHRvbk1lbnVBY3Rpb25SZW5kZXJlZEVycm9yLFxuICB1c2VyQnV0dG9uTWVudUxpbmtSZW5kZXJlZEVycm9yLFxuICB1c2VyQnV0dG9uTWVudUl0ZW1MaW5rV3JvbmdQcm9wcyxcbiAgdXNlckJ1dHRvbk1lbnVJdGVtc0FjdGlvbldyb25nc1Byb3BzLFxuICBJc29tb3JwaGljQ2xlcmtDb250ZXh0LFxuICB1c2VJc29tb3JwaGljQ2xlcmtDb250ZXh0LFxuICB1c2VBc3NlcnRXcmFwcGVkQnlDbGVya1Byb3ZpZGVyLFxuICB3aXRoQ2xlcmssXG4gIEF1dGhDb250ZXh0LFxuICB1c2VBdXRoLFxuICB1c2VEZXJpdmVkQXV0aCxcbiAgdXNlRW1haWxMaW5rLFxuICB1c2VTaWduSW4sXG4gIHVzZVNpZ25VcCxcbiAgdXNlQ2xlcmssXG4gIHVzZU9yZ2FuaXphdGlvbixcbiAgdXNlT3JnYW5pemF0aW9uTGlzdCxcbiAgdXNlU2Vzc2lvbkxpc3QsXG4gIHVzZVVzZXIsXG4gIHVzZVNlc3Npb24sXG4gIHVzZVJldmVyaWZpY2F0aW9uLFxuICBfX2V4cGVyaW1lbnRhbF91c2VDaGVja291dCxcbiAgX19leHBlcmltZW50YWxfQ2hlY2tvdXRQcm92aWRlcixcbiAgX19leHBlcmltZW50YWxfdXNlUGF5bWVudEVsZW1lbnQsXG4gIF9fZXhwZXJpbWVudGFsX1BheW1lbnRFbGVtZW50UHJvdmlkZXIsXG4gIF9fZXhwZXJpbWVudGFsX1BheW1lbnRFbGVtZW50XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstWElWWEw0TFEubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/chunk-XIVXL4LQ.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@clerk/clerk-react/dist/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIKeys: () => (/* reexport safe */ _chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.APIKeys),\n/* harmony export */   AuthenticateWithRedirectCallback: () => (/* reexport safe */ _chunk_JPAFWK3P_mjs__WEBPACK_IMPORTED_MODULE_0__.AuthenticateWithRedirectCallback),\n/* harmony export */   ClerkDegraded: () => (/* reexport safe */ _chunk_JPAFWK3P_mjs__WEBPACK_IMPORTED_MODULE_0__.ClerkDegraded),\n/* harmony export */   ClerkFailed: () => (/* reexport safe */ _chunk_JPAFWK3P_mjs__WEBPACK_IMPORTED_MODULE_0__.ClerkFailed),\n/* harmony export */   ClerkLoaded: () => (/* reexport safe */ _chunk_JPAFWK3P_mjs__WEBPACK_IMPORTED_MODULE_0__.ClerkLoaded),\n/* harmony export */   ClerkLoading: () => (/* reexport safe */ _chunk_JPAFWK3P_mjs__WEBPACK_IMPORTED_MODULE_0__.ClerkLoading),\n/* harmony export */   ClerkProvider: () => (/* binding */ ClerkProvider),\n/* harmony export */   CreateOrganization: () => (/* reexport safe */ _chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.CreateOrganization),\n/* harmony export */   GoogleOneTap: () => (/* reexport safe */ _chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.GoogleOneTap),\n/* harmony export */   OrganizationList: () => (/* reexport safe */ _chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.OrganizationList),\n/* harmony export */   OrganizationProfile: () => (/* reexport safe */ _chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.OrganizationProfile),\n/* harmony export */   OrganizationSwitcher: () => (/* reexport safe */ _chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.OrganizationSwitcher),\n/* harmony export */   PricingTable: () => (/* reexport safe */ _chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.PricingTable),\n/* harmony export */   Protect: () => (/* reexport safe */ _chunk_JPAFWK3P_mjs__WEBPACK_IMPORTED_MODULE_0__.Protect),\n/* harmony export */   RedirectToCreateOrganization: () => (/* reexport safe */ _chunk_JPAFWK3P_mjs__WEBPACK_IMPORTED_MODULE_0__.RedirectToCreateOrganization),\n/* harmony export */   RedirectToOrganizationProfile: () => (/* reexport safe */ _chunk_JPAFWK3P_mjs__WEBPACK_IMPORTED_MODULE_0__.RedirectToOrganizationProfile),\n/* harmony export */   RedirectToSignIn: () => (/* reexport safe */ _chunk_JPAFWK3P_mjs__WEBPACK_IMPORTED_MODULE_0__.RedirectToSignIn),\n/* harmony export */   RedirectToSignUp: () => (/* reexport safe */ _chunk_JPAFWK3P_mjs__WEBPACK_IMPORTED_MODULE_0__.RedirectToSignUp),\n/* harmony export */   RedirectToTasks: () => (/* reexport safe */ _chunk_JPAFWK3P_mjs__WEBPACK_IMPORTED_MODULE_0__.RedirectToTasks),\n/* harmony export */   RedirectToUserProfile: () => (/* reexport safe */ _chunk_JPAFWK3P_mjs__WEBPACK_IMPORTED_MODULE_0__.RedirectToUserProfile),\n/* harmony export */   SignIn: () => (/* reexport safe */ _chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.SignIn),\n/* harmony export */   SignInButton: () => (/* binding */ SignInButton),\n/* harmony export */   SignInWithMetamaskButton: () => (/* binding */ SignInWithMetamaskButton),\n/* harmony export */   SignOutButton: () => (/* binding */ SignOutButton),\n/* harmony export */   SignUp: () => (/* reexport safe */ _chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.SignUp),\n/* harmony export */   SignUpButton: () => (/* binding */ SignUpButton),\n/* harmony export */   SignedIn: () => (/* reexport safe */ _chunk_JPAFWK3P_mjs__WEBPACK_IMPORTED_MODULE_0__.SignedIn),\n/* harmony export */   SignedOut: () => (/* reexport safe */ _chunk_JPAFWK3P_mjs__WEBPACK_IMPORTED_MODULE_0__.SignedOut),\n/* harmony export */   TaskChooseOrganization: () => (/* reexport safe */ _chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.TaskChooseOrganization),\n/* harmony export */   UserAvatar: () => (/* reexport safe */ _chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.UserAvatar),\n/* harmony export */   UserButton: () => (/* reexport safe */ _chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.UserButton),\n/* harmony export */   UserProfile: () => (/* reexport safe */ _chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.UserProfile),\n/* harmony export */   Waitlist: () => (/* reexport safe */ _chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.Waitlist),\n/* harmony export */   __experimental_CheckoutProvider: () => (/* reexport safe */ _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.__experimental_CheckoutProvider),\n/* harmony export */   __experimental_PaymentElement: () => (/* reexport safe */ _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.__experimental_PaymentElement),\n/* harmony export */   __experimental_PaymentElementProvider: () => (/* reexport safe */ _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.__experimental_PaymentElementProvider),\n/* harmony export */   __experimental_useCheckout: () => (/* reexport safe */ _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.__experimental_useCheckout),\n/* harmony export */   __experimental_usePaymentElement: () => (/* reexport safe */ _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.__experimental_usePaymentElement),\n/* harmony export */   useAuth: () => (/* reexport safe */ _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.useAuth),\n/* harmony export */   useClerk: () => (/* reexport safe */ _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.useClerk),\n/* harmony export */   useEmailLink: () => (/* reexport safe */ _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.useEmailLink),\n/* harmony export */   useOrganization: () => (/* reexport safe */ _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.useOrganization),\n/* harmony export */   useOrganizationList: () => (/* reexport safe */ _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.useOrganizationList),\n/* harmony export */   useReverification: () => (/* reexport safe */ _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.useReverification),\n/* harmony export */   useSession: () => (/* reexport safe */ _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.useSession),\n/* harmony export */   useSessionList: () => (/* reexport safe */ _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.useSessionList),\n/* harmony export */   useSignIn: () => (/* reexport safe */ _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.useSignIn),\n/* harmony export */   useSignUp: () => (/* reexport safe */ _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.useSignUp),\n/* harmony export */   useUser: () => (/* reexport safe */ _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.useUser)\n/* harmony export */ });\n/* harmony import */ var _chunk_JPAFWK3P_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-JPAFWK3P.mjs */ \"(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/chunk-JPAFWK3P.mjs\");\n/* harmony import */ var _chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-SOK75ZUK.mjs */ \"(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/chunk-SOK75ZUK.mjs\");\n/* harmony import */ var _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-XIVXL4LQ.mjs */ \"(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/chunk-XIVXL4LQ.mjs\");\n/* harmony import */ var _chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk-OANWQR3B.mjs */ \"(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/chunk-OANWQR3B.mjs\");\n/* harmony import */ var _clerk_shared_loadClerkJsScript__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @clerk/shared/loadClerkJsScript */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/loadClerkJsScript.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _clerk_shared_keys__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @clerk/shared/keys */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/keys.mjs\");\n/* harmony import */ var _clerk_shared_deriveState__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @clerk/shared/deriveState */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/deriveState.mjs\");\n/* harmony import */ var _clerk_shared_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @clerk/shared/react */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/react/index.mjs\");\n/* harmony import */ var _clerk_shared_browser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @clerk/shared/browser */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/browser.mjs\");\n/* harmony import */ var _clerk_shared_clerkEventBus__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @clerk/shared/clerkEventBus */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/clerkEventBus.mjs\");\n/* harmony import */ var _clerk_shared_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @clerk/shared/utils */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/utils/index.mjs\");\n\n\n\n\n\n// src/polyfills.ts\nif (typeof window !== \"undefined\" && !window.global) {\n  window.global = typeof global === \"undefined\" ? window : global;\n}\n\n// src/index.ts\n\n\n// src/components/SignInButton.tsx\n\nvar SignInButton = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.withClerk)(\n  ({ clerk, children, ...props }) => {\n    const {\n      signUpFallbackRedirectUrl,\n      forceRedirectUrl,\n      fallbackRedirectUrl,\n      signUpForceRedirectUrl,\n      mode,\n      initialValues,\n      withSignUp,\n      oauthFlow,\n      ...rest\n    } = props;\n    children = (0,_chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.normalizeWithDefaultValue)(children, \"Sign in\");\n    const child = (0,_chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.assertSingleChild)(children)(\"SignInButton\");\n    const clickHandler = () => {\n      const opts = {\n        forceRedirectUrl,\n        fallbackRedirectUrl,\n        signUpFallbackRedirectUrl,\n        signUpForceRedirectUrl,\n        initialValues,\n        withSignUp,\n        oauthFlow\n      };\n      if (mode === \"modal\") {\n        return clerk.openSignIn({ ...opts, appearance: props.appearance });\n      }\n      return clerk.redirectToSignIn({\n        ...opts,\n        signInFallbackRedirectUrl: fallbackRedirectUrl,\n        signInForceRedirectUrl: forceRedirectUrl\n      });\n    };\n    const wrappedChildClickHandler = async (e) => {\n      if (child && typeof child === \"object\" && \"props\" in child) {\n        await (0,_chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.safeExecute)(child.props.onClick)(e);\n      }\n      return clickHandler();\n    };\n    const childProps = { ...rest, onClick: wrappedChildClickHandler };\n    return react__WEBPACK_IMPORTED_MODULE_5__.cloneElement(child, childProps);\n  },\n  { component: \"SignInButton\", renderWhileLoading: true }\n);\n\n// src/components/SignInWithMetamaskButton.tsx\n\nvar SignInWithMetamaskButton = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.withClerk)(\n  ({ clerk, children, ...props }) => {\n    const { redirectUrl, ...rest } = props;\n    children = (0,_chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.normalizeWithDefaultValue)(children, \"Sign in with Metamask\");\n    const child = (0,_chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.assertSingleChild)(children)(\"SignInWithMetamaskButton\");\n    const clickHandler = async () => {\n      async function authenticate() {\n        await clerk.authenticateWithMetamask({ redirectUrl: redirectUrl || void 0 });\n      }\n      void authenticate();\n    };\n    const wrappedChildClickHandler = async (e) => {\n      await (0,_chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.safeExecute)(child.props.onClick)(e);\n      return clickHandler();\n    };\n    const childProps = { ...rest, onClick: wrappedChildClickHandler };\n    return react__WEBPACK_IMPORTED_MODULE_5__.cloneElement(child, childProps);\n  },\n  { component: \"SignInWithMetamask\", renderWhileLoading: true }\n);\n\n// src/components/SignOutButton.tsx\n\nvar SignOutButton = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.withClerk)(\n  ({ clerk, children, ...props }) => {\n    const { redirectUrl = \"/\", signOutOptions, ...rest } = props;\n    children = (0,_chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.normalizeWithDefaultValue)(children, \"Sign out\");\n    const child = (0,_chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.assertSingleChild)(children)(\"SignOutButton\");\n    const clickHandler = () => clerk.signOut({ redirectUrl, ...signOutOptions });\n    const wrappedChildClickHandler = async (e) => {\n      await (0,_chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.safeExecute)(child.props.onClick)(e);\n      return clickHandler();\n    };\n    const childProps = { ...rest, onClick: wrappedChildClickHandler };\n    return react__WEBPACK_IMPORTED_MODULE_5__.cloneElement(child, childProps);\n  },\n  { component: \"SignOutButton\", renderWhileLoading: true }\n);\n\n// src/components/SignUpButton.tsx\n\nvar SignUpButton = (0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.withClerk)(\n  ({ clerk, children, ...props }) => {\n    const {\n      fallbackRedirectUrl,\n      forceRedirectUrl,\n      signInFallbackRedirectUrl,\n      signInForceRedirectUrl,\n      mode,\n      initialValues,\n      oauthFlow,\n      ...rest\n    } = props;\n    children = (0,_chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.normalizeWithDefaultValue)(children, \"Sign up\");\n    const child = (0,_chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.assertSingleChild)(children)(\"SignUpButton\");\n    const clickHandler = () => {\n      const opts = {\n        fallbackRedirectUrl,\n        forceRedirectUrl,\n        signInFallbackRedirectUrl,\n        signInForceRedirectUrl,\n        initialValues,\n        oauthFlow\n      };\n      if (mode === \"modal\") {\n        return clerk.openSignUp({\n          ...opts,\n          appearance: props.appearance,\n          unsafeMetadata: props.unsafeMetadata\n        });\n      }\n      return clerk.redirectToSignUp({\n        ...opts,\n        signUpFallbackRedirectUrl: fallbackRedirectUrl,\n        signUpForceRedirectUrl: forceRedirectUrl\n      });\n    };\n    const wrappedChildClickHandler = async (e) => {\n      if (child && typeof child === \"object\" && \"props\" in child) {\n        await (0,_chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.safeExecute)(child.props.onClick)(e);\n      }\n      return clickHandler();\n    };\n    const childProps = { ...rest, onClick: wrappedChildClickHandler };\n    return react__WEBPACK_IMPORTED_MODULE_5__.cloneElement(child, childProps);\n  },\n  { component: \"SignUpButton\", renderWhileLoading: true }\n);\n\n// src/contexts/ClerkProvider.tsx\n\n\n\n// src/contexts/ClerkContextProvider.tsx\n\n\n\n\n// src/isomorphicClerk.ts\n\n\n\n\n\n// src/stateProxy.ts\n\nvar defaultErrors = () => ({\n  fields: {\n    firstName: null,\n    lastName: null,\n    emailAddress: null,\n    identifier: null,\n    phoneNumber: null,\n    password: null,\n    username: null,\n    code: null,\n    captcha: null,\n    legalAccepted: null\n  },\n  raw: null,\n  global: null\n});\nvar StateProxy = class {\n  constructor(isomorphicClerk) {\n    this.isomorphicClerk = isomorphicClerk;\n    this.signInSignalProxy = this.buildSignInProxy();\n    this.signUpSignalProxy = this.buildSignUpProxy();\n  }\n  signInSignal() {\n    return this.signInSignalProxy;\n  }\n  signUpSignal() {\n    return this.signUpSignalProxy;\n  }\n  buildSignInProxy() {\n    const gateProperty = this.gateProperty.bind(this);\n    const target = () => this.client.signIn.__internal_future;\n    return {\n      errors: defaultErrors(),\n      fetchStatus: \"idle\",\n      signIn: {\n        status: \"needs_identifier\",\n        availableStrategies: [],\n        isTransferable: false,\n        get id() {\n          return gateProperty(target, \"id\", void 0);\n        },\n        get supportedFirstFactors() {\n          return gateProperty(target, \"supportedFirstFactors\", []);\n        },\n        get supportedSecondFactors() {\n          return gateProperty(target, \"supportedSecondFactors\", []);\n        },\n        get secondFactorVerification() {\n          return gateProperty(target, \"secondFactorVerification\", {\n            status: null,\n            error: null,\n            expireAt: null,\n            externalVerificationRedirectURL: null,\n            nonce: null,\n            attempts: null,\n            message: null,\n            strategy: null,\n            verifiedAtClient: null,\n            verifiedFromTheSameClient: () => false,\n            __internal_toSnapshot: () => {\n              throw new Error(\"__internal_toSnapshot called before Clerk is loaded\");\n            },\n            pathRoot: \"\",\n            reload: () => {\n              throw new Error(\"__internal_toSnapshot called before Clerk is loaded\");\n            }\n          });\n        },\n        get identifier() {\n          return gateProperty(target, \"identifier\", null);\n        },\n        get createdSessionId() {\n          return gateProperty(target, \"createdSessionId\", null);\n        },\n        get userData() {\n          return gateProperty(target, \"userData\", {});\n        },\n        get firstFactorVerification() {\n          return gateProperty(target, \"firstFactorVerification\", {\n            status: null,\n            error: null,\n            expireAt: null,\n            externalVerificationRedirectURL: null,\n            nonce: null,\n            attempts: null,\n            message: null,\n            strategy: null,\n            verifiedAtClient: null,\n            verifiedFromTheSameClient: () => false,\n            __internal_toSnapshot: () => {\n              throw new Error(\"__internal_toSnapshot called before Clerk is loaded\");\n            },\n            pathRoot: \"\",\n            reload: () => {\n              throw new Error(\"__internal_toSnapshot called before Clerk is loaded\");\n            }\n          });\n        },\n        create: this.gateMethod(target, \"create\"),\n        password: this.gateMethod(target, \"password\"),\n        sso: this.gateMethod(target, \"sso\"),\n        finalize: this.gateMethod(target, \"finalize\"),\n        emailCode: this.wrapMethods(() => target().emailCode, [\"sendCode\", \"verifyCode\"]),\n        emailLink: this.wrapStruct(\n          () => target().emailLink,\n          [\"sendLink\", \"waitForVerification\"],\n          [\"verification\"],\n          { verification: null }\n        ),\n        resetPasswordEmailCode: this.wrapMethods(() => target().resetPasswordEmailCode, [\n          \"sendCode\",\n          \"verifyCode\",\n          \"submitPassword\"\n        ]),\n        phoneCode: this.wrapMethods(() => target().phoneCode, [\"sendCode\", \"verifyCode\"]),\n        mfa: this.wrapMethods(() => target().mfa, [\n          \"sendPhoneCode\",\n          \"verifyPhoneCode\",\n          \"verifyTOTP\",\n          \"verifyBackupCode\"\n        ]),\n        ticket: this.gateMethod(target, \"ticket\"),\n        passkey: this.gateMethod(target, \"passkey\"),\n        web3: this.gateMethod(target, \"web3\")\n      }\n    };\n  }\n  buildSignUpProxy() {\n    const gateProperty = this.gateProperty.bind(this);\n    const gateMethod = this.gateMethod.bind(this);\n    const wrapMethods = this.wrapMethods.bind(this);\n    const target = () => this.client.signUp.__internal_future;\n    return {\n      errors: defaultErrors(),\n      fetchStatus: \"idle\",\n      signUp: {\n        get id() {\n          return gateProperty(target, \"id\", void 0);\n        },\n        get requiredFields() {\n          return gateProperty(target, \"requiredFields\", []);\n        },\n        get optionalFields() {\n          return gateProperty(target, \"optionalFields\", []);\n        },\n        get missingFields() {\n          return gateProperty(target, \"missingFields\", []);\n        },\n        get username() {\n          return gateProperty(target, \"username\", null);\n        },\n        get firstName() {\n          return gateProperty(target, \"firstName\", null);\n        },\n        get lastName() {\n          return gateProperty(target, \"lastName\", null);\n        },\n        get emailAddress() {\n          return gateProperty(target, \"emailAddress\", null);\n        },\n        get phoneNumber() {\n          return gateProperty(target, \"phoneNumber\", null);\n        },\n        get web3Wallet() {\n          return gateProperty(target, \"web3Wallet\", null);\n        },\n        get hasPassword() {\n          return gateProperty(target, \"hasPassword\", false);\n        },\n        get unsafeMetadata() {\n          return gateProperty(target, \"unsafeMetadata\", {});\n        },\n        get createdSessionId() {\n          return gateProperty(target, \"createdSessionId\", null);\n        },\n        get createdUserId() {\n          return gateProperty(target, \"createdUserId\", null);\n        },\n        get abandonAt() {\n          return gateProperty(target, \"abandonAt\", null);\n        },\n        get legalAcceptedAt() {\n          return gateProperty(target, \"legalAcceptedAt\", null);\n        },\n        get locale() {\n          return gateProperty(target, \"locale\", null);\n        },\n        get status() {\n          return gateProperty(target, \"status\", \"missing_requirements\");\n        },\n        get unverifiedFields() {\n          return gateProperty(target, \"unverifiedFields\", []);\n        },\n        get isTransferable() {\n          return gateProperty(target, \"isTransferable\", false);\n        },\n        create: gateMethod(target, \"create\"),\n        update: gateMethod(target, \"update\"),\n        sso: gateMethod(target, \"sso\"),\n        password: gateMethod(target, \"password\"),\n        ticket: gateMethod(target, \"ticket\"),\n        web3: gateMethod(target, \"web3\"),\n        finalize: gateMethod(target, \"finalize\"),\n        verifications: wrapMethods(() => target().verifications, [\n          \"sendEmailCode\",\n          \"verifyEmailCode\",\n          \"sendPhoneCode\",\n          \"verifyPhoneCode\"\n        ])\n      }\n    };\n  }\n  __internal_effect(_) {\n    throw new Error(\"__internal_effect called before Clerk is loaded\");\n  }\n  __internal_computed(_) {\n    throw new Error(\"__internal_computed called before Clerk is loaded\");\n  }\n  get client() {\n    const c = this.isomorphicClerk.client;\n    if (!c) {\n      throw new Error(\"Clerk client not ready\");\n    }\n    return c;\n  }\n  gateProperty(getTarget, key, defaultValue) {\n    return (() => {\n      if (!(0,_clerk_shared_browser__WEBPACK_IMPORTED_MODULE_9__.inBrowser)() || !this.isomorphicClerk.loaded) {\n        return defaultValue;\n      }\n      const t = getTarget();\n      return t[key];\n    })();\n  }\n  gateMethod(getTarget, key) {\n    return async (...args) => {\n      if (!(0,_clerk_shared_browser__WEBPACK_IMPORTED_MODULE_9__.inBrowser)()) {\n        return _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.errorThrower.throw(`Attempted to call a method (${key}) that is not supported on the server.`);\n      }\n      if (!this.isomorphicClerk.loaded) {\n        await new Promise((resolve) => this.isomorphicClerk.addOnLoaded(resolve));\n      }\n      const t = getTarget();\n      return t[key].apply(t, args);\n    };\n  }\n  wrapMethods(getTarget, keys) {\n    return Object.fromEntries(keys.map((k) => [k, this.gateMethod(getTarget, k)]));\n  }\n  wrapStruct(getTarget, methods, getters, fallbacks) {\n    const out = {};\n    for (const m of methods) {\n      out[m] = this.gateMethod(getTarget, m);\n    }\n    for (const g of getters) {\n      Object.defineProperty(out, g, {\n        get: () => this.gateProperty(getTarget, g, fallbacks[g]),\n        enumerable: true\n      });\n    }\n    return out;\n  }\n};\n\n// src/isomorphicClerk.ts\nif (typeof globalThis.__BUILD_DISABLE_RHC__ === \"undefined\") {\n  globalThis.__BUILD_DISABLE_RHC__ = false;\n}\nvar SDK_METADATA = {\n  name: \"@clerk/clerk-react\",\n  version: \"5.53.3\",\n  environment: \"development\"\n};\nvar _status, _domain, _proxyUrl, _publishableKey, _eventBus, _stateProxy, _instance, _IsomorphicClerk_instances, waitForClerkJS_fn;\nvar _IsomorphicClerk = class _IsomorphicClerk {\n  constructor(options) {\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateAdd)(this, _IsomorphicClerk_instances);\n    this.clerkjs = null;\n    this.preopenOneTap = null;\n    this.preopenUserVerification = null;\n    this.preopenSignIn = null;\n    this.preopenCheckout = null;\n    this.preopenPlanDetails = null;\n    this.preopenSubscriptionDetails = null;\n    this.preopenSignUp = null;\n    this.preopenUserProfile = null;\n    this.preopenOrganizationProfile = null;\n    this.preopenCreateOrganization = null;\n    this.preOpenWaitlist = null;\n    this.premountSignInNodes = /* @__PURE__ */ new Map();\n    this.premountSignUpNodes = /* @__PURE__ */ new Map();\n    this.premountUserAvatarNodes = /* @__PURE__ */ new Map();\n    this.premountUserProfileNodes = /* @__PURE__ */ new Map();\n    this.premountUserButtonNodes = /* @__PURE__ */ new Map();\n    this.premountOrganizationProfileNodes = /* @__PURE__ */ new Map();\n    this.premountCreateOrganizationNodes = /* @__PURE__ */ new Map();\n    this.premountOrganizationSwitcherNodes = /* @__PURE__ */ new Map();\n    this.premountOrganizationListNodes = /* @__PURE__ */ new Map();\n    this.premountMethodCalls = /* @__PURE__ */ new Map();\n    this.premountWaitlistNodes = /* @__PURE__ */ new Map();\n    this.premountPricingTableNodes = /* @__PURE__ */ new Map();\n    this.premountApiKeysNodes = /* @__PURE__ */ new Map();\n    this.premountOAuthConsentNodes = /* @__PURE__ */ new Map();\n    this.premountTaskChooseOrganizationNodes = /* @__PURE__ */ new Map();\n    // A separate Map of `addListener` method calls to handle multiple listeners.\n    this.premountAddListenerCalls = /* @__PURE__ */ new Map();\n    this.loadedListeners = [];\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateAdd)(this, _status, \"loading\");\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateAdd)(this, _domain);\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateAdd)(this, _proxyUrl);\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateAdd)(this, _publishableKey);\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateAdd)(this, _eventBus, (0,_clerk_shared_clerkEventBus__WEBPACK_IMPORTED_MODULE_10__.createClerkEventBus)());\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateAdd)(this, _stateProxy);\n    this.buildSignInUrl = (opts) => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildSignInUrl(opts)) || \"\";\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildSignInUrl\", callback);\n      }\n    };\n    this.buildSignUpUrl = (opts) => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildSignUpUrl(opts)) || \"\";\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildSignUpUrl\", callback);\n      }\n    };\n    this.buildAfterSignInUrl = (...args) => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildAfterSignInUrl(...args)) || \"\";\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildAfterSignInUrl\", callback);\n      }\n    };\n    this.buildAfterSignUpUrl = (...args) => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildAfterSignUpUrl(...args)) || \"\";\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildAfterSignUpUrl\", callback);\n      }\n    };\n    this.buildAfterSignOutUrl = () => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildAfterSignOutUrl()) || \"\";\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildAfterSignOutUrl\", callback);\n      }\n    };\n    this.buildNewSubscriptionRedirectUrl = () => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildNewSubscriptionRedirectUrl()) || \"\";\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildNewSubscriptionRedirectUrl\", callback);\n      }\n    };\n    this.buildAfterMultiSessionSingleSignOutUrl = () => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildAfterMultiSessionSingleSignOutUrl()) || \"\";\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildAfterMultiSessionSingleSignOutUrl\", callback);\n      }\n    };\n    this.buildUserProfileUrl = () => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildUserProfileUrl()) || \"\";\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildUserProfileUrl\", callback);\n      }\n    };\n    this.buildCreateOrganizationUrl = () => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildCreateOrganizationUrl()) || \"\";\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildCreateOrganizationUrl\", callback);\n      }\n    };\n    this.buildOrganizationProfileUrl = () => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildOrganizationProfileUrl()) || \"\";\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildOrganizationProfileUrl\", callback);\n      }\n    };\n    this.buildWaitlistUrl = () => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildWaitlistUrl()) || \"\";\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildWaitlistUrl\", callback);\n      }\n    };\n    this.buildTasksUrl = () => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildTasksUrl()) || \"\";\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildTasksUrl\", callback);\n      }\n    };\n    this.buildUrlWithAuth = (to) => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildUrlWithAuth(to)) || \"\";\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildUrlWithAuth\", callback);\n      }\n    };\n    this.handleUnauthenticated = async () => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.handleUnauthenticated();\n      };\n      if (this.clerkjs && this.loaded) {\n        void callback();\n      } else {\n        this.premountMethodCalls.set(\"handleUnauthenticated\", callback);\n      }\n    };\n    this.on = (...args) => {\n      var _a;\n      if ((_a = this.clerkjs) == null ? void 0 : _a.on) {\n        return this.clerkjs.on(...args);\n      } else {\n        (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _eventBus).on(...args);\n      }\n    };\n    this.off = (...args) => {\n      var _a;\n      if ((_a = this.clerkjs) == null ? void 0 : _a.off) {\n        return this.clerkjs.off(...args);\n      } else {\n        (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _eventBus).off(...args);\n      }\n    };\n    /**\n     * @deprecated Please use `addStatusListener`. This api will be removed in the next major.\n     */\n    this.addOnLoaded = (cb) => {\n      this.loadedListeners.push(cb);\n      if (this.loaded) {\n        this.emitLoaded();\n      }\n    };\n    /**\n     * @deprecated Please use `__internal_setStatus`. This api will be removed in the next major.\n     */\n    this.emitLoaded = () => {\n      this.loadedListeners.forEach((cb) => cb());\n      this.loadedListeners = [];\n    };\n    this.beforeLoad = (clerkjs) => {\n      if (!clerkjs) {\n        throw new Error(\"Failed to hydrate latest Clerk JS\");\n      }\n    };\n    this.hydrateClerkJS = (clerkjs) => {\n      var _a;\n      if (!clerkjs) {\n        throw new Error(\"Failed to hydrate latest Clerk JS\");\n      }\n      this.clerkjs = clerkjs;\n      this.premountMethodCalls.forEach((cb) => cb());\n      this.premountAddListenerCalls.forEach((listenerHandlers, listener) => {\n        listenerHandlers.nativeUnsubscribe = clerkjs.addListener(listener);\n      });\n      (_a = (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _eventBus).internal.retrieveListeners(\"status\")) == null ? void 0 : _a.forEach((listener) => {\n        this.on(\"status\", listener, { notify: true });\n      });\n      if (this.preopenSignIn !== null) {\n        clerkjs.openSignIn(this.preopenSignIn);\n      }\n      if (this.preopenCheckout !== null) {\n        clerkjs.__internal_openCheckout(this.preopenCheckout);\n      }\n      if (this.preopenPlanDetails !== null) {\n        clerkjs.__internal_openPlanDetails(this.preopenPlanDetails);\n      }\n      if (this.preopenSubscriptionDetails !== null) {\n        clerkjs.__internal_openSubscriptionDetails(this.preopenSubscriptionDetails);\n      }\n      if (this.preopenSignUp !== null) {\n        clerkjs.openSignUp(this.preopenSignUp);\n      }\n      if (this.preopenUserProfile !== null) {\n        clerkjs.openUserProfile(this.preopenUserProfile);\n      }\n      if (this.preopenUserVerification !== null) {\n        clerkjs.__internal_openReverification(this.preopenUserVerification);\n      }\n      if (this.preopenOneTap !== null) {\n        clerkjs.openGoogleOneTap(this.preopenOneTap);\n      }\n      if (this.preopenOrganizationProfile !== null) {\n        clerkjs.openOrganizationProfile(this.preopenOrganizationProfile);\n      }\n      if (this.preopenCreateOrganization !== null) {\n        clerkjs.openCreateOrganization(this.preopenCreateOrganization);\n      }\n      if (this.preOpenWaitlist !== null) {\n        clerkjs.openWaitlist(this.preOpenWaitlist);\n      }\n      this.premountSignInNodes.forEach((props, node) => {\n        clerkjs.mountSignIn(node, props);\n      });\n      this.premountSignUpNodes.forEach((props, node) => {\n        clerkjs.mountSignUp(node, props);\n      });\n      this.premountUserProfileNodes.forEach((props, node) => {\n        clerkjs.mountUserProfile(node, props);\n      });\n      this.premountUserAvatarNodes.forEach((props, node) => {\n        clerkjs.mountUserAvatar(node, props);\n      });\n      this.premountUserButtonNodes.forEach((props, node) => {\n        clerkjs.mountUserButton(node, props);\n      });\n      this.premountOrganizationListNodes.forEach((props, node) => {\n        clerkjs.mountOrganizationList(node, props);\n      });\n      this.premountWaitlistNodes.forEach((props, node) => {\n        clerkjs.mountWaitlist(node, props);\n      });\n      this.premountPricingTableNodes.forEach((props, node) => {\n        clerkjs.mountPricingTable(node, props);\n      });\n      this.premountApiKeysNodes.forEach((props, node) => {\n        clerkjs.mountApiKeys(node, props);\n      });\n      this.premountOAuthConsentNodes.forEach((props, node) => {\n        clerkjs.__internal_mountOAuthConsent(node, props);\n      });\n      this.premountTaskChooseOrganizationNodes.forEach((props, node) => {\n        clerkjs.mountTaskChooseOrganization(node, props);\n      });\n      if (typeof this.clerkjs.status === \"undefined\") {\n        (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _eventBus).emit(_clerk_shared_clerkEventBus__WEBPACK_IMPORTED_MODULE_10__.clerkEvents.Status, \"ready\");\n      }\n      this.emitLoaded();\n      return this.clerkjs;\n    };\n    this.__experimental_checkout = (...args) => {\n      var _a;\n      return (_a = this.clerkjs) == null ? void 0 : _a.__experimental_checkout(...args);\n    };\n    // TODO @userland-errors:\n    this.__unstable__updateProps = async (props) => {\n      const clerkjs = await (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateMethod)(this, _IsomorphicClerk_instances, waitForClerkJS_fn).call(this);\n      if (clerkjs && \"__unstable__updateProps\" in clerkjs) {\n        return clerkjs.__unstable__updateProps(props);\n      }\n    };\n    /**\n     * `setActive` can be used to set the active session and/or organization.\n     */\n    this.setActive = (params) => {\n      if (this.clerkjs) {\n        return this.clerkjs.setActive(params);\n      } else {\n        return Promise.reject();\n      }\n    };\n    this.openSignIn = (props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.openSignIn(props);\n      } else {\n        this.preopenSignIn = props;\n      }\n    };\n    this.closeSignIn = () => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.closeSignIn();\n      } else {\n        this.preopenSignIn = null;\n      }\n    };\n    this.__internal_openCheckout = (props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.__internal_openCheckout(props);\n      } else {\n        this.preopenCheckout = props;\n      }\n    };\n    this.__internal_closeCheckout = () => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.__internal_closeCheckout();\n      } else {\n        this.preopenCheckout = null;\n      }\n    };\n    this.__internal_openPlanDetails = (props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.__internal_openPlanDetails(props);\n      } else {\n        this.preopenPlanDetails = props;\n      }\n    };\n    this.__internal_closePlanDetails = () => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.__internal_closePlanDetails();\n      } else {\n        this.preopenPlanDetails = null;\n      }\n    };\n    this.__internal_openSubscriptionDetails = (props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.__internal_openSubscriptionDetails(props);\n      } else {\n        this.preopenSubscriptionDetails = props != null ? props : null;\n      }\n    };\n    this.__internal_closeSubscriptionDetails = () => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.__internal_closeSubscriptionDetails();\n      } else {\n        this.preopenSubscriptionDetails = null;\n      }\n    };\n    this.__internal_openReverification = (props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.__internal_openReverification(props);\n      } else {\n        this.preopenUserVerification = props;\n      }\n    };\n    this.__internal_closeReverification = () => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.__internal_closeReverification();\n      } else {\n        this.preopenUserVerification = null;\n      }\n    };\n    this.openGoogleOneTap = (props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.openGoogleOneTap(props);\n      } else {\n        this.preopenOneTap = props;\n      }\n    };\n    this.closeGoogleOneTap = () => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.closeGoogleOneTap();\n      } else {\n        this.preopenOneTap = null;\n      }\n    };\n    this.openUserProfile = (props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.openUserProfile(props);\n      } else {\n        this.preopenUserProfile = props;\n      }\n    };\n    this.closeUserProfile = () => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.closeUserProfile();\n      } else {\n        this.preopenUserProfile = null;\n      }\n    };\n    this.openOrganizationProfile = (props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.openOrganizationProfile(props);\n      } else {\n        this.preopenOrganizationProfile = props;\n      }\n    };\n    this.closeOrganizationProfile = () => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.closeOrganizationProfile();\n      } else {\n        this.preopenOrganizationProfile = null;\n      }\n    };\n    this.openCreateOrganization = (props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.openCreateOrganization(props);\n      } else {\n        this.preopenCreateOrganization = props;\n      }\n    };\n    this.closeCreateOrganization = () => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.closeCreateOrganization();\n      } else {\n        this.preopenCreateOrganization = null;\n      }\n    };\n    this.openWaitlist = (props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.openWaitlist(props);\n      } else {\n        this.preOpenWaitlist = props;\n      }\n    };\n    this.closeWaitlist = () => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.closeWaitlist();\n      } else {\n        this.preOpenWaitlist = null;\n      }\n    };\n    this.openSignUp = (props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.openSignUp(props);\n      } else {\n        this.preopenSignUp = props;\n      }\n    };\n    this.closeSignUp = () => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.closeSignUp();\n      } else {\n        this.preopenSignUp = null;\n      }\n    };\n    this.mountSignIn = (node, props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.mountSignIn(node, props);\n      } else {\n        this.premountSignInNodes.set(node, props);\n      }\n    };\n    this.unmountSignIn = (node) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.unmountSignIn(node);\n      } else {\n        this.premountSignInNodes.delete(node);\n      }\n    };\n    this.mountSignUp = (node, props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.mountSignUp(node, props);\n      } else {\n        this.premountSignUpNodes.set(node, props);\n      }\n    };\n    this.unmountSignUp = (node) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.unmountSignUp(node);\n      } else {\n        this.premountSignUpNodes.delete(node);\n      }\n    };\n    this.mountUserAvatar = (node, props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.mountUserAvatar(node, props);\n      } else {\n        this.premountUserAvatarNodes.set(node, props);\n      }\n    };\n    this.unmountUserAvatar = (node) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.unmountUserAvatar(node);\n      } else {\n        this.premountUserAvatarNodes.delete(node);\n      }\n    };\n    this.mountUserProfile = (node, props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.mountUserProfile(node, props);\n      } else {\n        this.premountUserProfileNodes.set(node, props);\n      }\n    };\n    this.unmountUserProfile = (node) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.unmountUserProfile(node);\n      } else {\n        this.premountUserProfileNodes.delete(node);\n      }\n    };\n    this.mountOrganizationProfile = (node, props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.mountOrganizationProfile(node, props);\n      } else {\n        this.premountOrganizationProfileNodes.set(node, props);\n      }\n    };\n    this.unmountOrganizationProfile = (node) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.unmountOrganizationProfile(node);\n      } else {\n        this.premountOrganizationProfileNodes.delete(node);\n      }\n    };\n    this.mountCreateOrganization = (node, props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.mountCreateOrganization(node, props);\n      } else {\n        this.premountCreateOrganizationNodes.set(node, props);\n      }\n    };\n    this.unmountCreateOrganization = (node) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.unmountCreateOrganization(node);\n      } else {\n        this.premountCreateOrganizationNodes.delete(node);\n      }\n    };\n    this.mountOrganizationSwitcher = (node, props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.mountOrganizationSwitcher(node, props);\n      } else {\n        this.premountOrganizationSwitcherNodes.set(node, props);\n      }\n    };\n    this.unmountOrganizationSwitcher = (node) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.unmountOrganizationSwitcher(node);\n      } else {\n        this.premountOrganizationSwitcherNodes.delete(node);\n      }\n    };\n    this.__experimental_prefetchOrganizationSwitcher = () => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.__experimental_prefetchOrganizationSwitcher();\n      };\n      if (this.clerkjs && this.loaded) {\n        void callback();\n      } else {\n        this.premountMethodCalls.set(\"__experimental_prefetchOrganizationSwitcher\", callback);\n      }\n    };\n    this.mountOrganizationList = (node, props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.mountOrganizationList(node, props);\n      } else {\n        this.premountOrganizationListNodes.set(node, props);\n      }\n    };\n    this.unmountOrganizationList = (node) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.unmountOrganizationList(node);\n      } else {\n        this.premountOrganizationListNodes.delete(node);\n      }\n    };\n    this.mountUserButton = (node, userButtonProps) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.mountUserButton(node, userButtonProps);\n      } else {\n        this.premountUserButtonNodes.set(node, userButtonProps);\n      }\n    };\n    this.unmountUserButton = (node) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.unmountUserButton(node);\n      } else {\n        this.premountUserButtonNodes.delete(node);\n      }\n    };\n    this.mountWaitlist = (node, props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.mountWaitlist(node, props);\n      } else {\n        this.premountWaitlistNodes.set(node, props);\n      }\n    };\n    this.unmountWaitlist = (node) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.unmountWaitlist(node);\n      } else {\n        this.premountWaitlistNodes.delete(node);\n      }\n    };\n    this.mountPricingTable = (node, props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.mountPricingTable(node, props);\n      } else {\n        this.premountPricingTableNodes.set(node, props);\n      }\n    };\n    this.unmountPricingTable = (node) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.unmountPricingTable(node);\n      } else {\n        this.premountPricingTableNodes.delete(node);\n      }\n    };\n    this.mountApiKeys = (node, props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.mountApiKeys(node, props);\n      } else {\n        this.premountApiKeysNodes.set(node, props);\n      }\n    };\n    this.unmountApiKeys = (node) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.unmountApiKeys(node);\n      } else {\n        this.premountApiKeysNodes.delete(node);\n      }\n    };\n    this.__internal_mountOAuthConsent = (node, props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.__internal_mountOAuthConsent(node, props);\n      } else {\n        this.premountOAuthConsentNodes.set(node, props);\n      }\n    };\n    this.__internal_unmountOAuthConsent = (node) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.__internal_unmountOAuthConsent(node);\n      } else {\n        this.premountOAuthConsentNodes.delete(node);\n      }\n    };\n    this.mountTaskChooseOrganization = (node, props) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.mountTaskChooseOrganization(node, props);\n      } else {\n        this.premountTaskChooseOrganizationNodes.set(node, props);\n      }\n    };\n    this.unmountTaskChooseOrganization = (node) => {\n      if (this.clerkjs && this.loaded) {\n        this.clerkjs.unmountTaskChooseOrganization(node);\n      } else {\n        this.premountTaskChooseOrganizationNodes.delete(node);\n      }\n    };\n    this.addListener = (listener) => {\n      if (this.clerkjs) {\n        return this.clerkjs.addListener(listener);\n      } else {\n        const unsubscribe = () => {\n          var _a;\n          const listenerHandlers = this.premountAddListenerCalls.get(listener);\n          if (listenerHandlers) {\n            (_a = listenerHandlers.nativeUnsubscribe) == null ? void 0 : _a.call(listenerHandlers);\n            this.premountAddListenerCalls.delete(listener);\n          }\n        };\n        this.premountAddListenerCalls.set(listener, { unsubscribe, nativeUnsubscribe: void 0 });\n        return unsubscribe;\n      }\n    };\n    this.navigate = (to) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.navigate(to);\n      };\n      if (this.clerkjs && this.loaded) {\n        void callback();\n      } else {\n        this.premountMethodCalls.set(\"navigate\", callback);\n      }\n    };\n    this.redirectWithAuth = async (...args) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.redirectWithAuth(...args);\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"redirectWithAuth\", callback);\n        return;\n      }\n    };\n    this.redirectToSignIn = async (opts) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.redirectToSignIn(opts);\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"redirectToSignIn\", callback);\n        return;\n      }\n    };\n    this.redirectToSignUp = async (opts) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.redirectToSignUp(opts);\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"redirectToSignUp\", callback);\n        return;\n      }\n    };\n    this.redirectToUserProfile = async () => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.redirectToUserProfile();\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"redirectToUserProfile\", callback);\n        return;\n      }\n    };\n    this.redirectToAfterSignUp = () => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.redirectToAfterSignUp();\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"redirectToAfterSignUp\", callback);\n      }\n    };\n    this.redirectToAfterSignIn = () => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.redirectToAfterSignIn();\n      };\n      if (this.clerkjs && this.loaded) {\n        callback();\n      } else {\n        this.premountMethodCalls.set(\"redirectToAfterSignIn\", callback);\n      }\n    };\n    this.redirectToAfterSignOut = () => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.redirectToAfterSignOut();\n      };\n      if (this.clerkjs && this.loaded) {\n        callback();\n      } else {\n        this.premountMethodCalls.set(\"redirectToAfterSignOut\", callback);\n      }\n    };\n    this.redirectToOrganizationProfile = async () => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.redirectToOrganizationProfile();\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"redirectToOrganizationProfile\", callback);\n        return;\n      }\n    };\n    this.redirectToCreateOrganization = async () => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.redirectToCreateOrganization();\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"redirectToCreateOrganization\", callback);\n        return;\n      }\n    };\n    this.redirectToWaitlist = async () => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.redirectToWaitlist();\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"redirectToWaitlist\", callback);\n        return;\n      }\n    };\n    this.redirectToTasks = async (opts) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.redirectToTasks(opts);\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"redirectToTasks\", callback);\n        return;\n      }\n    };\n    this.handleRedirectCallback = async (params) => {\n      var _a;\n      const callback = () => {\n        var _a2;\n        return (_a2 = this.clerkjs) == null ? void 0 : _a2.handleRedirectCallback(params);\n      };\n      if (this.clerkjs && this.loaded) {\n        void ((_a = callback()) == null ? void 0 : _a.catch(() => {\n        }));\n      } else {\n        this.premountMethodCalls.set(\"handleRedirectCallback\", callback);\n      }\n    };\n    this.handleGoogleOneTapCallback = async (signInOrUp, params) => {\n      var _a;\n      const callback = () => {\n        var _a2;\n        return (_a2 = this.clerkjs) == null ? void 0 : _a2.handleGoogleOneTapCallback(signInOrUp, params);\n      };\n      if (this.clerkjs && this.loaded) {\n        void ((_a = callback()) == null ? void 0 : _a.catch(() => {\n        }));\n      } else {\n        this.premountMethodCalls.set(\"handleGoogleOneTapCallback\", callback);\n      }\n    };\n    this.handleEmailLinkVerification = async (params) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.handleEmailLinkVerification(params);\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"handleEmailLinkVerification\", callback);\n      }\n    };\n    this.authenticateWithMetamask = async (params) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.authenticateWithMetamask(params);\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"authenticateWithMetamask\", callback);\n      }\n    };\n    this.authenticateWithCoinbaseWallet = async (params) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.authenticateWithCoinbaseWallet(params);\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"authenticateWithCoinbaseWallet\", callback);\n      }\n    };\n    this.authenticateWithBase = async (params) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.authenticateWithBase(params);\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"authenticateWithBase\", callback);\n      }\n    };\n    this.authenticateWithOKXWallet = async (params) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.authenticateWithOKXWallet(params);\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"authenticateWithOKXWallet\", callback);\n      }\n    };\n    this.authenticateWithWeb3 = async (params) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.authenticateWithWeb3(params);\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"authenticateWithWeb3\", callback);\n      }\n    };\n    this.authenticateWithGoogleOneTap = async (params) => {\n      const clerkjs = await (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateMethod)(this, _IsomorphicClerk_instances, waitForClerkJS_fn).call(this);\n      return clerkjs.authenticateWithGoogleOneTap(params);\n    };\n    this.__internal_loadStripeJs = async () => {\n      const clerkjs = await (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateMethod)(this, _IsomorphicClerk_instances, waitForClerkJS_fn).call(this);\n      return clerkjs.__internal_loadStripeJs();\n    };\n    this.createOrganization = async (params) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.createOrganization(params);\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"createOrganization\", callback);\n      }\n    };\n    this.getOrganization = async (organizationId) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.getOrganization(organizationId);\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"getOrganization\", callback);\n      }\n    };\n    this.joinWaitlist = async (params) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.joinWaitlist(params);\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"joinWaitlist\", callback);\n      }\n    };\n    this.signOut = async (...args) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.signOut(...args);\n      };\n      if (this.clerkjs && this.loaded) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"signOut\", callback);\n      }\n    };\n    const { Clerk = null, publishableKey } = options || {};\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateSet)(this, _publishableKey, publishableKey);\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateSet)(this, _proxyUrl, options == null ? void 0 : options.proxyUrl);\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateSet)(this, _domain, options == null ? void 0 : options.domain);\n    this.options = options;\n    this.Clerk = Clerk;\n    this.mode = (0,_clerk_shared_browser__WEBPACK_IMPORTED_MODULE_9__.inBrowser)() ? \"browser\" : \"server\";\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateSet)(this, _stateProxy, new StateProxy(this));\n    if (!this.options.sdkMetadata) {\n      this.options.sdkMetadata = SDK_METADATA;\n    }\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _eventBus).emit(_clerk_shared_clerkEventBus__WEBPACK_IMPORTED_MODULE_10__.clerkEvents.Status, \"loading\");\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _eventBus).prioritizedOn(_clerk_shared_clerkEventBus__WEBPACK_IMPORTED_MODULE_10__.clerkEvents.Status, (status) => (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateSet)(this, _status, status));\n    if ((0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _publishableKey)) {\n      void this.loadClerkJS();\n    }\n  }\n  get publishableKey() {\n    return (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _publishableKey);\n  }\n  get loaded() {\n    var _a;\n    return ((_a = this.clerkjs) == null ? void 0 : _a.loaded) || false;\n  }\n  get status() {\n    var _a;\n    if (!this.clerkjs) {\n      return (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _status);\n    }\n    return ((_a = this.clerkjs) == null ? void 0 : _a.status) || /**\n     * Support older clerk-js versions.\n     * If clerk-js is available but `.status` is missing it we need to fallback to `.loaded`.\n     * Since \"degraded\" an \"error\" did not exist before,\n     * map \"loaded\" to \"ready\" and \"not loaded\" to \"loading\".\n     */\n    (this.clerkjs.loaded ? \"ready\" : \"loading\");\n  }\n  static getOrCreateInstance(options) {\n    if (!(0,_clerk_shared_browser__WEBPACK_IMPORTED_MODULE_9__.inBrowser)() || !(0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _instance) || options.Clerk && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _instance).Clerk !== options.Clerk || // Allow hot swapping PKs on the client\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _instance).publishableKey !== options.publishableKey) {\n      (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateSet)(this, _instance, new _IsomorphicClerk(options));\n    }\n    return (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _instance);\n  }\n  static clearInstance() {\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateSet)(this, _instance, null);\n  }\n  get domain() {\n    if (typeof window !== \"undefined\" && window.location) {\n      return (0,_clerk_shared_utils__WEBPACK_IMPORTED_MODULE_11__.handleValueOrFn)((0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _domain), new URL(window.location.href), \"\");\n    }\n    if (typeof (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _domain) === \"function\") {\n      return _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.errorThrower.throw(_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.unsupportedNonBrowserDomainOrProxyUrlFunction);\n    }\n    return (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _domain) || \"\";\n  }\n  get proxyUrl() {\n    if (typeof window !== \"undefined\" && window.location) {\n      return (0,_clerk_shared_utils__WEBPACK_IMPORTED_MODULE_11__.handleValueOrFn)((0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _proxyUrl), new URL(window.location.href), \"\");\n    }\n    if (typeof (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _proxyUrl) === \"function\") {\n      return _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.errorThrower.throw(_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.unsupportedNonBrowserDomainOrProxyUrlFunction);\n    }\n    return (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _proxyUrl) || \"\";\n  }\n  /**\n   * Accesses private options from the `Clerk` instance and defaults to\n   * `IsomorphicClerk` options when in SSR context.\n   *  @internal\n   */\n  __internal_getOption(key) {\n    var _a, _b;\n    return ((_a = this.clerkjs) == null ? void 0 : _a.__internal_getOption) ? (_b = this.clerkjs) == null ? void 0 : _b.__internal_getOption(key) : this.options[key];\n  }\n  get sdkMetadata() {\n    var _a;\n    return ((_a = this.clerkjs) == null ? void 0 : _a.sdkMetadata) || this.options.sdkMetadata || void 0;\n  }\n  get instanceType() {\n    var _a;\n    return (_a = this.clerkjs) == null ? void 0 : _a.instanceType;\n  }\n  get frontendApi() {\n    var _a;\n    return ((_a = this.clerkjs) == null ? void 0 : _a.frontendApi) || \"\";\n  }\n  get isStandardBrowser() {\n    var _a;\n    return ((_a = this.clerkjs) == null ? void 0 : _a.isStandardBrowser) || this.options.standardBrowser || false;\n  }\n  get isSatellite() {\n    if (typeof window !== \"undefined\" && window.location) {\n      return (0,_clerk_shared_utils__WEBPACK_IMPORTED_MODULE_11__.handleValueOrFn)(this.options.isSatellite, new URL(window.location.href), false);\n    }\n    if (typeof this.options.isSatellite === \"function\") {\n      return _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.errorThrower.throw(_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.unsupportedNonBrowserDomainOrProxyUrlFunction);\n    }\n    return false;\n  }\n  async loadClerkJS() {\n    var _a;\n    if (this.mode !== \"browser\" || this.loaded) {\n      return;\n    }\n    if (typeof window !== \"undefined\") {\n      window.__clerk_publishable_key = (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _publishableKey);\n      window.__clerk_proxy_url = this.proxyUrl;\n      window.__clerk_domain = this.domain;\n    }\n    try {\n      if (this.Clerk) {\n        let c;\n        if ((0,_chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.isConstructor)(this.Clerk)) {\n          c = new this.Clerk((0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _publishableKey), {\n            proxyUrl: this.proxyUrl,\n            domain: this.domain\n          });\n          this.beforeLoad(c);\n          await c.load(this.options);\n        } else {\n          c = this.Clerk;\n          if (!c.loaded) {\n            this.beforeLoad(c);\n            await c.load(this.options);\n          }\n        }\n        global.Clerk = c;\n      } else if (!__BUILD_DISABLE_RHC__) {\n        if (!global.Clerk) {\n          await (0,_clerk_shared_loadClerkJsScript__WEBPACK_IMPORTED_MODULE_4__.loadClerkJsScript)({\n            ...this.options,\n            publishableKey: (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _publishableKey),\n            proxyUrl: this.proxyUrl,\n            domain: this.domain,\n            nonce: this.options.nonce\n          });\n        }\n        if (!global.Clerk) {\n          throw new Error(\"Failed to download latest ClerkJS. Contact support@clerk.com.\");\n        }\n        this.beforeLoad(global.Clerk);\n        await global.Clerk.load(this.options);\n      }\n      if ((_a = global.Clerk) == null ? void 0 : _a.loaded) {\n        return this.hydrateClerkJS(global.Clerk);\n      }\n      return;\n    } catch (err) {\n      const error = err;\n      (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _eventBus).emit(_clerk_shared_clerkEventBus__WEBPACK_IMPORTED_MODULE_10__.clerkEvents.Status, \"error\");\n      console.error(error.stack || error.message || error);\n      return;\n    }\n  }\n  get version() {\n    var _a;\n    return (_a = this.clerkjs) == null ? void 0 : _a.version;\n  }\n  get client() {\n    if (this.clerkjs) {\n      return this.clerkjs.client;\n    } else {\n      return void 0;\n    }\n  }\n  get session() {\n    if (this.clerkjs) {\n      return this.clerkjs.session;\n    } else {\n      return void 0;\n    }\n  }\n  get user() {\n    if (this.clerkjs) {\n      return this.clerkjs.user;\n    } else {\n      return void 0;\n    }\n  }\n  get organization() {\n    if (this.clerkjs) {\n      return this.clerkjs.organization;\n    } else {\n      return void 0;\n    }\n  }\n  get telemetry() {\n    if (this.clerkjs) {\n      return this.clerkjs.telemetry;\n    } else {\n      return void 0;\n    }\n  }\n  get __unstable__environment() {\n    if (this.clerkjs) {\n      return this.clerkjs.__unstable__environment;\n    } else {\n      return void 0;\n    }\n  }\n  get isSignedIn() {\n    if (this.clerkjs) {\n      return this.clerkjs.isSignedIn;\n    } else {\n      return false;\n    }\n  }\n  get billing() {\n    var _a;\n    return (_a = this.clerkjs) == null ? void 0 : _a.billing;\n  }\n  get __internal_state() {\n    return this.loaded && this.clerkjs ? this.clerkjs.__internal_state : (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateGet)(this, _stateProxy);\n  }\n  get apiKeys() {\n    var _a;\n    return (_a = this.clerkjs) == null ? void 0 : _a.apiKeys;\n  }\n  __unstable__setEnvironment(...args) {\n    if (this.clerkjs && \"__unstable__setEnvironment\" in this.clerkjs) {\n      this.clerkjs.__unstable__setEnvironment(args);\n    } else {\n      return void 0;\n    }\n  }\n};\n_status = new WeakMap();\n_domain = new WeakMap();\n_proxyUrl = new WeakMap();\n_publishableKey = new WeakMap();\n_eventBus = new WeakMap();\n_stateProxy = new WeakMap();\n_instance = new WeakMap();\n_IsomorphicClerk_instances = new WeakSet();\nwaitForClerkJS_fn = function() {\n  return new Promise((resolve) => {\n    this.addOnLoaded(() => resolve(this.clerkjs));\n  });\n};\n(0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_3__.__privateAdd)(_IsomorphicClerk, _instance);\nvar IsomorphicClerk = _IsomorphicClerk;\n\n// src/contexts/ClerkContextProvider.tsx\nfunction ClerkContextProvider(props) {\n  const { isomorphicClerkOptions, initialState, children } = props;\n  const { isomorphicClerk: clerk, clerkStatus } = useLoadedIsomorphicClerk(isomorphicClerkOptions);\n  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_5__.useState({\n    client: clerk.client,\n    session: clerk.session,\n    user: clerk.user,\n    organization: clerk.organization\n  });\n  react__WEBPACK_IMPORTED_MODULE_5__.useEffect(() => {\n    return clerk.addListener((e) => setState({ ...e }));\n  }, []);\n  const derivedState = (0,_clerk_shared_deriveState__WEBPACK_IMPORTED_MODULE_7__.deriveState)(clerk.loaded, state, initialState);\n  const clerkCtx = react__WEBPACK_IMPORTED_MODULE_5__.useMemo(\n    () => ({ value: clerk }),\n    [\n      // Only update the clerk reference on status change\n      clerkStatus\n    ]\n  );\n  const clientCtx = react__WEBPACK_IMPORTED_MODULE_5__.useMemo(() => ({ value: state.client }), [state.client]);\n  const {\n    sessionId,\n    sessionStatus,\n    sessionClaims,\n    session,\n    userId,\n    user,\n    orgId,\n    actor,\n    organization,\n    orgRole,\n    orgSlug,\n    orgPermissions,\n    factorVerificationAge\n  } = derivedState;\n  const authCtx = react__WEBPACK_IMPORTED_MODULE_5__.useMemo(() => {\n    const value = {\n      sessionId,\n      sessionStatus,\n      sessionClaims,\n      userId,\n      actor,\n      orgId,\n      orgRole,\n      orgSlug,\n      orgPermissions,\n      factorVerificationAge\n    };\n    return { value };\n  }, [sessionId, sessionStatus, userId, actor, orgId, orgRole, orgSlug, factorVerificationAge, sessionClaims == null ? void 0 : sessionClaims.__raw]);\n  const sessionCtx = react__WEBPACK_IMPORTED_MODULE_5__.useMemo(() => ({ value: session }), [sessionId, session]);\n  const userCtx = react__WEBPACK_IMPORTED_MODULE_5__.useMemo(() => ({ value: user }), [userId, user]);\n  const organizationCtx = react__WEBPACK_IMPORTED_MODULE_5__.useMemo(() => {\n    const value = {\n      organization\n    };\n    return { value };\n  }, [orgId, organization]);\n  return (\n    // @ts-expect-error value passed is of type IsomorphicClerk where the context expects LoadedClerk\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.IsomorphicClerkContext.Provider, { value: clerkCtx }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(_clerk_shared_react__WEBPACK_IMPORTED_MODULE_8__.ClientContext.Provider, { value: clientCtx }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(_clerk_shared_react__WEBPACK_IMPORTED_MODULE_8__.SessionContext.Provider, { value: sessionCtx }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(_clerk_shared_react__WEBPACK_IMPORTED_MODULE_8__.OrganizationProvider, { ...organizationCtx.value }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.AuthContext.Provider, { value: authCtx }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(_clerk_shared_react__WEBPACK_IMPORTED_MODULE_8__.UserContext.Provider, { value: userCtx }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(\n      _clerk_shared_react__WEBPACK_IMPORTED_MODULE_8__.__experimental_CheckoutProvider,\n      {\n        value: void 0\n      },\n      children\n    )))))))\n  );\n}\nvar useLoadedIsomorphicClerk = (options) => {\n  const isomorphicClerkRef = react__WEBPACK_IMPORTED_MODULE_5__.useRef(IsomorphicClerk.getOrCreateInstance(options));\n  const [clerkStatus, setClerkStatus] = react__WEBPACK_IMPORTED_MODULE_5__.useState(isomorphicClerkRef.current.status);\n  react__WEBPACK_IMPORTED_MODULE_5__.useEffect(() => {\n    void isomorphicClerkRef.current.__unstable__updateProps({ appearance: options.appearance });\n  }, [options.appearance]);\n  react__WEBPACK_IMPORTED_MODULE_5__.useEffect(() => {\n    void isomorphicClerkRef.current.__unstable__updateProps({ options });\n  }, [options.localization]);\n  react__WEBPACK_IMPORTED_MODULE_5__.useEffect(() => {\n    isomorphicClerkRef.current.on(\"status\", setClerkStatus);\n    return () => {\n      if (isomorphicClerkRef.current) {\n        isomorphicClerkRef.current.off(\"status\", setClerkStatus);\n      }\n      IsomorphicClerk.clearInstance();\n    };\n  }, []);\n  return { isomorphicClerk: isomorphicClerkRef.current, clerkStatus };\n};\n\n// src/contexts/ClerkProvider.tsx\nfunction ClerkProviderBase(props) {\n  const { initialState, children, __internal_bypassMissingPublishableKey, ...restIsomorphicClerkOptions } = props;\n  const { publishableKey = \"\", Clerk: userInitialisedClerk } = restIsomorphicClerkOptions;\n  if (!userInitialisedClerk && !__internal_bypassMissingPublishableKey) {\n    if (!publishableKey) {\n      _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.errorThrower.throwMissingPublishableKeyError();\n    } else if (publishableKey && !(0,_clerk_shared_keys__WEBPACK_IMPORTED_MODULE_6__.isPublishableKey)(publishableKey)) {\n      _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.errorThrower.throwInvalidPublishableKeyError({ key: publishableKey });\n    }\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(\n    ClerkContextProvider,\n    {\n      initialState,\n      isomorphicClerkOptions: restIsomorphicClerkOptions\n    },\n    children\n  );\n}\nvar ClerkProvider = (0,_chunk_SOK75ZUK_mjs__WEBPACK_IMPORTED_MODULE_1__.withMaxAllowedInstancesGuard)(ClerkProviderBase, \"ClerkProvider\", _chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.multipleClerkProvidersError);\nClerkProvider.displayName = \"ClerkProvider\";\n\n// src/index.ts\n(0,_chunk_XIVXL4LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.setErrorThrowerOptions)({ packageName: \"@clerk/clerk-react\" });\n(0,_clerk_shared_loadClerkJsScript__WEBPACK_IMPORTED_MODULE_4__.setClerkJsLoadingErrorPackageName)(\"@clerk/clerk-react\");\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvY2xlcmstcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWU4QjtBQXFCQTtBQXlCQTtBQU1BOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNvRjs7QUFFcEY7QUFDMEI7QUFDMUIsbUJBQW1CLDhEQUFTO0FBQzVCLEtBQUssMkJBQTJCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGVBQWUsOEVBQXlCO0FBQ3hDLGtCQUFrQixzRUFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1Q0FBdUM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdFQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixXQUFXLCtDQUFrQjtBQUM3QixHQUFHO0FBQ0gsSUFBSTtBQUNKOztBQUVBO0FBQzJCO0FBQzNCLCtCQUErQiw4REFBUztBQUN4QyxLQUFLLDJCQUEyQjtBQUNoQyxZQUFZLHVCQUF1QjtBQUNuQyxlQUFlLDhFQUF5QjtBQUN4QyxrQkFBa0Isc0VBQWlCO0FBQ25DO0FBQ0E7QUFDQSwrQ0FBK0Msb0NBQW9DO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRUFBVztBQUN2QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLFdBQVcsK0NBQW1CO0FBQzlCLEdBQUc7QUFDSCxJQUFJO0FBQ0o7O0FBRUE7QUFDMkI7QUFDM0Isb0JBQW9CLDhEQUFTO0FBQzdCLEtBQUssMkJBQTJCO0FBQ2hDLFlBQVksNkNBQTZDO0FBQ3pELGVBQWUsOEVBQXlCO0FBQ3hDLGtCQUFrQixzRUFBaUI7QUFDbkMsK0NBQStDLGdDQUFnQztBQUMvRTtBQUNBLFlBQVksZ0VBQVc7QUFDdkI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixXQUFXLCtDQUFtQjtBQUM5QixHQUFHO0FBQ0gsSUFBSTtBQUNKOztBQUVBO0FBQzJCO0FBQzNCLG1CQUFtQiw4REFBUztBQUM1QixLQUFLLDJCQUEyQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZUFBZSw4RUFBeUI7QUFDeEMsa0JBQWtCLHNFQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnRUFBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsV0FBVywrQ0FBbUI7QUFDOUIsR0FBRztBQUNILElBQUk7QUFDSjs7QUFFQTtBQUNzRDtBQUMzQjs7QUFFM0I7QUFDd0Q7QUFPM0I7QUFDRjs7QUFFM0I7QUFDZ0U7QUFDZTtBQUNYO0FBQ2Q7O0FBRXREO0FBQ2tEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0RBQW9EO0FBQ3BELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwwREFBMEQ7QUFDMUQsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0VBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnRUFBUztBQUNwQixlQUFlLDZEQUFZLHNDQUFzQyxJQUFJO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRUFBWTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlFQUFZO0FBQ2hCLElBQUksaUVBQVk7QUFDaEIsSUFBSSxpRUFBWTtBQUNoQixJQUFJLGlFQUFZO0FBQ2hCLElBQUksaUVBQVksa0JBQWtCLGlGQUFtQjtBQUNyRCxJQUFJLGlFQUFZO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLFFBQVEsaUVBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLFFBQVEsaUVBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxZQUFZLGlFQUFZO0FBQ3hCLHNDQUFzQyxjQUFjO0FBQ3BELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxRQUFRLGlFQUFZLHVCQUF1QixxRUFBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvRUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHdDQUF3QztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFD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QjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLFVBQVUsZ0dBQWdHO0FBQzFHLFVBQVUsbURBQW1EO0FBQzdEO0FBQ0E7QUFDQSxNQUFNLDZEQUFZO0FBQ2xCLE1BQU0sNEJBQTRCLG9FQUFnQjtBQUNsRCxNQUFNLDZEQUFZLG1DQUFtQyxxQkFBcUI7QUFDMUU7QUFDQTtBQUNBLHlCQUF5QixnREFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlGQUE0QixxQ0FBcUMsNEVBQTJCO0FBQ2hIOztBQUVBO0FBQ0EsMkVBQXNCLEdBQUcsbUNBQW1DO0FBQzVELGtHQUFpQztBQW1EL0I7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2lzaGFxYmVsbG8vV2Vic2l0ZS9oYXZlbnJpZGVfZnVsbF9hcHAvbm9kZV9tb2R1bGVzL0BjbGVyay9jbGVyay1yZWFjdC9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBdXRoZW50aWNhdGVXaXRoUmVkaXJlY3RDYWxsYmFjayxcbiAgQ2xlcmtEZWdyYWRlZCxcbiAgQ2xlcmtGYWlsZWQsXG4gIENsZXJrTG9hZGVkLFxuICBDbGVya0xvYWRpbmcsXG4gIFByb3RlY3QsXG4gIFJlZGlyZWN0VG9DcmVhdGVPcmdhbml6YXRpb24sXG4gIFJlZGlyZWN0VG9Pcmdhbml6YXRpb25Qcm9maWxlLFxuICBSZWRpcmVjdFRvU2lnbkluLFxuICBSZWRpcmVjdFRvU2lnblVwLFxuICBSZWRpcmVjdFRvVGFza3MsXG4gIFJlZGlyZWN0VG9Vc2VyUHJvZmlsZSxcbiAgU2lnbmVkSW4sXG4gIFNpZ25lZE91dFxufSBmcm9tIFwiLi9jaHVuay1KUEFGV0szUC5tanNcIjtcbmltcG9ydCB7XG4gIEFQSUtleXMsXG4gIENyZWF0ZU9yZ2FuaXphdGlvbixcbiAgR29vZ2xlT25lVGFwLFxuICBPcmdhbml6YXRpb25MaXN0LFxuICBPcmdhbml6YXRpb25Qcm9maWxlLFxuICBPcmdhbml6YXRpb25Td2l0Y2hlcixcbiAgUHJpY2luZ1RhYmxlLFxuICBTaWduSW4sXG4gIFNpZ25VcCxcbiAgVGFza0Nob29zZU9yZ2FuaXphdGlvbixcbiAgVXNlckF2YXRhcixcbiAgVXNlckJ1dHRvbixcbiAgVXNlclByb2ZpbGUsXG4gIFdhaXRsaXN0LFxuICBhc3NlcnRTaW5nbGVDaGlsZCxcbiAgaXNDb25zdHJ1Y3RvcixcbiAgbm9ybWFsaXplV2l0aERlZmF1bHRWYWx1ZSxcbiAgc2FmZUV4ZWN1dGUsXG4gIHdpdGhNYXhBbGxvd2VkSW5zdGFuY2VzR3VhcmRcbn0gZnJvbSBcIi4vY2h1bmstU09LNzVaVUsubWpzXCI7XG5pbXBvcnQge1xuICBBdXRoQ29udGV4dCxcbiAgSXNvbW9ycGhpY0NsZXJrQ29udGV4dCxcbiAgX19leHBlcmltZW50YWxfQ2hlY2tvdXRQcm92aWRlcixcbiAgX19leHBlcmltZW50YWxfUGF5bWVudEVsZW1lbnQsXG4gIF9fZXhwZXJpbWVudGFsX1BheW1lbnRFbGVtZW50UHJvdmlkZXIsXG4gIF9fZXhwZXJpbWVudGFsX3VzZUNoZWNrb3V0LFxuICBfX2V4cGVyaW1lbnRhbF91c2VQYXltZW50RWxlbWVudCxcbiAgZXJyb3JUaHJvd2VyLFxuICBtdWx0aXBsZUNsZXJrUHJvdmlkZXJzRXJyb3IsXG4gIHNldEVycm9yVGhyb3dlck9wdGlvbnMsXG4gIHVuc3VwcG9ydGVkTm9uQnJvd3NlckRvbWFpbk9yUHJveHlVcmxGdW5jdGlvbixcbiAgdXNlQXV0aCxcbiAgdXNlQ2xlcmssXG4gIHVzZUVtYWlsTGluayxcbiAgdXNlT3JnYW5pemF0aW9uLFxuICB1c2VPcmdhbml6YXRpb25MaXN0LFxuICB1c2VSZXZlcmlmaWNhdGlvbixcbiAgdXNlU2Vzc2lvbixcbiAgdXNlU2Vzc2lvbkxpc3QsXG4gIHVzZVNpZ25JbixcbiAgdXNlU2lnblVwLFxuICB1c2VVc2VyLFxuICB3aXRoQ2xlcmtcbn0gZnJvbSBcIi4vY2h1bmstWElWWEw0TFEubWpzXCI7XG5pbXBvcnQge1xuICBfX3ByaXZhdGVBZGQsXG4gIF9fcHJpdmF0ZUdldCxcbiAgX19wcml2YXRlTWV0aG9kLFxuICBfX3ByaXZhdGVTZXRcbn0gZnJvbSBcIi4vY2h1bmstT0FOV1FSM0IubWpzXCI7XG5cbi8vIHNyYy9wb2x5ZmlsbHMudHNcbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmICF3aW5kb3cuZ2xvYmFsKSB7XG4gIHdpbmRvdy5nbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogZ2xvYmFsO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IHNldENsZXJrSnNMb2FkaW5nRXJyb3JQYWNrYWdlTmFtZSB9IGZyb20gXCJAY2xlcmsvc2hhcmVkL2xvYWRDbGVya0pzU2NyaXB0XCI7XG5cbi8vIHNyYy9jb21wb25lbnRzL1NpZ25JbkJ1dHRvbi50c3hcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbnZhciBTaWduSW5CdXR0b24gPSB3aXRoQ2xlcmsoXG4gICh7IGNsZXJrLCBjaGlsZHJlbiwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHNpZ25VcEZhbGxiYWNrUmVkaXJlY3RVcmwsXG4gICAgICBmb3JjZVJlZGlyZWN0VXJsLFxuICAgICAgZmFsbGJhY2tSZWRpcmVjdFVybCxcbiAgICAgIHNpZ25VcEZvcmNlUmVkaXJlY3RVcmwsXG4gICAgICBtb2RlLFxuICAgICAgaW5pdGlhbFZhbHVlcyxcbiAgICAgIHdpdGhTaWduVXAsXG4gICAgICBvYXV0aEZsb3csXG4gICAgICAuLi5yZXN0XG4gICAgfSA9IHByb3BzO1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplV2l0aERlZmF1bHRWYWx1ZShjaGlsZHJlbiwgXCJTaWduIGluXCIpO1xuICAgIGNvbnN0IGNoaWxkID0gYXNzZXJ0U2luZ2xlQ2hpbGQoY2hpbGRyZW4pKFwiU2lnbkluQnV0dG9uXCIpO1xuICAgIGNvbnN0IGNsaWNrSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIGZvcmNlUmVkaXJlY3RVcmwsXG4gICAgICAgIGZhbGxiYWNrUmVkaXJlY3RVcmwsXG4gICAgICAgIHNpZ25VcEZhbGxiYWNrUmVkaXJlY3RVcmwsXG4gICAgICAgIHNpZ25VcEZvcmNlUmVkaXJlY3RVcmwsXG4gICAgICAgIGluaXRpYWxWYWx1ZXMsXG4gICAgICAgIHdpdGhTaWduVXAsXG4gICAgICAgIG9hdXRoRmxvd1xuICAgICAgfTtcbiAgICAgIGlmIChtb2RlID09PSBcIm1vZGFsXCIpIHtcbiAgICAgICAgcmV0dXJuIGNsZXJrLm9wZW5TaWduSW4oeyAuLi5vcHRzLCBhcHBlYXJhbmNlOiBwcm9wcy5hcHBlYXJhbmNlIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsZXJrLnJlZGlyZWN0VG9TaWduSW4oe1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBzaWduSW5GYWxsYmFja1JlZGlyZWN0VXJsOiBmYWxsYmFja1JlZGlyZWN0VXJsLFxuICAgICAgICBzaWduSW5Gb3JjZVJlZGlyZWN0VXJsOiBmb3JjZVJlZGlyZWN0VXJsXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHdyYXBwZWRDaGlsZENsaWNrSGFuZGxlciA9IGFzeW5jIChlKSA9PiB7XG4gICAgICBpZiAoY2hpbGQgJiYgdHlwZW9mIGNoaWxkID09PSBcIm9iamVjdFwiICYmIFwicHJvcHNcIiBpbiBjaGlsZCkge1xuICAgICAgICBhd2FpdCBzYWZlRXhlY3V0ZShjaGlsZC5wcm9wcy5vbkNsaWNrKShlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbGlja0hhbmRsZXIoKTtcbiAgICB9O1xuICAgIGNvbnN0IGNoaWxkUHJvcHMgPSB7IC4uLnJlc3QsIG9uQ2xpY2s6IHdyYXBwZWRDaGlsZENsaWNrSGFuZGxlciB9O1xuICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIGNoaWxkUHJvcHMpO1xuICB9LFxuICB7IGNvbXBvbmVudDogXCJTaWduSW5CdXR0b25cIiwgcmVuZGVyV2hpbGVMb2FkaW5nOiB0cnVlIH1cbik7XG5cbi8vIHNyYy9jb21wb25lbnRzL1NpZ25JbldpdGhNZXRhbWFza0J1dHRvbi50c3hcbmltcG9ydCBSZWFjdDIgZnJvbSBcInJlYWN0XCI7XG52YXIgU2lnbkluV2l0aE1ldGFtYXNrQnV0dG9uID0gd2l0aENsZXJrKFxuICAoeyBjbGVyaywgY2hpbGRyZW4sIC4uLnByb3BzIH0pID0+IHtcbiAgICBjb25zdCB7IHJlZGlyZWN0VXJsLCAuLi5yZXN0IH0gPSBwcm9wcztcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZVdpdGhEZWZhdWx0VmFsdWUoY2hpbGRyZW4sIFwiU2lnbiBpbiB3aXRoIE1ldGFtYXNrXCIpO1xuICAgIGNvbnN0IGNoaWxkID0gYXNzZXJ0U2luZ2xlQ2hpbGQoY2hpbGRyZW4pKFwiU2lnbkluV2l0aE1ldGFtYXNrQnV0dG9uXCIpO1xuICAgIGNvbnN0IGNsaWNrSGFuZGxlciA9IGFzeW5jICgpID0+IHtcbiAgICAgIGFzeW5jIGZ1bmN0aW9uIGF1dGhlbnRpY2F0ZSgpIHtcbiAgICAgICAgYXdhaXQgY2xlcmsuYXV0aGVudGljYXRlV2l0aE1ldGFtYXNrKHsgcmVkaXJlY3RVcmw6IHJlZGlyZWN0VXJsIHx8IHZvaWQgMCB9KTtcbiAgICAgIH1cbiAgICAgIHZvaWQgYXV0aGVudGljYXRlKCk7XG4gICAgfTtcbiAgICBjb25zdCB3cmFwcGVkQ2hpbGRDbGlja0hhbmRsZXIgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgYXdhaXQgc2FmZUV4ZWN1dGUoY2hpbGQucHJvcHMub25DbGljaykoZSk7XG4gICAgICByZXR1cm4gY2xpY2tIYW5kbGVyKCk7XG4gICAgfTtcbiAgICBjb25zdCBjaGlsZFByb3BzID0geyAuLi5yZXN0LCBvbkNsaWNrOiB3cmFwcGVkQ2hpbGRDbGlja0hhbmRsZXIgfTtcbiAgICByZXR1cm4gUmVhY3QyLmNsb25lRWxlbWVudChjaGlsZCwgY2hpbGRQcm9wcyk7XG4gIH0sXG4gIHsgY29tcG9uZW50OiBcIlNpZ25JbldpdGhNZXRhbWFza1wiLCByZW5kZXJXaGlsZUxvYWRpbmc6IHRydWUgfVxuKTtcblxuLy8gc3JjL2NvbXBvbmVudHMvU2lnbk91dEJ1dHRvbi50c3hcbmltcG9ydCBSZWFjdDMgZnJvbSBcInJlYWN0XCI7XG52YXIgU2lnbk91dEJ1dHRvbiA9IHdpdGhDbGVyayhcbiAgKHsgY2xlcmssIGNoaWxkcmVuLCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgY29uc3QgeyByZWRpcmVjdFVybCA9IFwiL1wiLCBzaWduT3V0T3B0aW9ucywgLi4ucmVzdCB9ID0gcHJvcHM7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVXaXRoRGVmYXVsdFZhbHVlKGNoaWxkcmVuLCBcIlNpZ24gb3V0XCIpO1xuICAgIGNvbnN0IGNoaWxkID0gYXNzZXJ0U2luZ2xlQ2hpbGQoY2hpbGRyZW4pKFwiU2lnbk91dEJ1dHRvblwiKTtcbiAgICBjb25zdCBjbGlja0hhbmRsZXIgPSAoKSA9PiBjbGVyay5zaWduT3V0KHsgcmVkaXJlY3RVcmwsIC4uLnNpZ25PdXRPcHRpb25zIH0pO1xuICAgIGNvbnN0IHdyYXBwZWRDaGlsZENsaWNrSGFuZGxlciA9IGFzeW5jIChlKSA9PiB7XG4gICAgICBhd2FpdCBzYWZlRXhlY3V0ZShjaGlsZC5wcm9wcy5vbkNsaWNrKShlKTtcbiAgICAgIHJldHVybiBjbGlja0hhbmRsZXIoKTtcbiAgICB9O1xuICAgIGNvbnN0IGNoaWxkUHJvcHMgPSB7IC4uLnJlc3QsIG9uQ2xpY2s6IHdyYXBwZWRDaGlsZENsaWNrSGFuZGxlciB9O1xuICAgIHJldHVybiBSZWFjdDMuY2xvbmVFbGVtZW50KGNoaWxkLCBjaGlsZFByb3BzKTtcbiAgfSxcbiAgeyBjb21wb25lbnQ6IFwiU2lnbk91dEJ1dHRvblwiLCByZW5kZXJXaGlsZUxvYWRpbmc6IHRydWUgfVxuKTtcblxuLy8gc3JjL2NvbXBvbmVudHMvU2lnblVwQnV0dG9uLnRzeFxuaW1wb3J0IFJlYWN0NCBmcm9tIFwicmVhY3RcIjtcbnZhciBTaWduVXBCdXR0b24gPSB3aXRoQ2xlcmsoXG4gICh7IGNsZXJrLCBjaGlsZHJlbiwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGZhbGxiYWNrUmVkaXJlY3RVcmwsXG4gICAgICBmb3JjZVJlZGlyZWN0VXJsLFxuICAgICAgc2lnbkluRmFsbGJhY2tSZWRpcmVjdFVybCxcbiAgICAgIHNpZ25JbkZvcmNlUmVkaXJlY3RVcmwsXG4gICAgICBtb2RlLFxuICAgICAgaW5pdGlhbFZhbHVlcyxcbiAgICAgIG9hdXRoRmxvdyxcbiAgICAgIC4uLnJlc3RcbiAgICB9ID0gcHJvcHM7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVXaXRoRGVmYXVsdFZhbHVlKGNoaWxkcmVuLCBcIlNpZ24gdXBcIik7XG4gICAgY29uc3QgY2hpbGQgPSBhc3NlcnRTaW5nbGVDaGlsZChjaGlsZHJlbikoXCJTaWduVXBCdXR0b25cIik7XG4gICAgY29uc3QgY2xpY2tIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgZmFsbGJhY2tSZWRpcmVjdFVybCxcbiAgICAgICAgZm9yY2VSZWRpcmVjdFVybCxcbiAgICAgICAgc2lnbkluRmFsbGJhY2tSZWRpcmVjdFVybCxcbiAgICAgICAgc2lnbkluRm9yY2VSZWRpcmVjdFVybCxcbiAgICAgICAgaW5pdGlhbFZhbHVlcyxcbiAgICAgICAgb2F1dGhGbG93XG4gICAgICB9O1xuICAgICAgaWYgKG1vZGUgPT09IFwibW9kYWxcIikge1xuICAgICAgICByZXR1cm4gY2xlcmsub3BlblNpZ25VcCh7XG4gICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICBhcHBlYXJhbmNlOiBwcm9wcy5hcHBlYXJhbmNlLFxuICAgICAgICAgIHVuc2FmZU1ldGFkYXRhOiBwcm9wcy51bnNhZmVNZXRhZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbGVyay5yZWRpcmVjdFRvU2lnblVwKHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgc2lnblVwRmFsbGJhY2tSZWRpcmVjdFVybDogZmFsbGJhY2tSZWRpcmVjdFVybCxcbiAgICAgICAgc2lnblVwRm9yY2VSZWRpcmVjdFVybDogZm9yY2VSZWRpcmVjdFVybFxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCB3cmFwcGVkQ2hpbGRDbGlja0hhbmRsZXIgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgaWYgKGNoaWxkICYmIHR5cGVvZiBjaGlsZCA9PT0gXCJvYmplY3RcIiAmJiBcInByb3BzXCIgaW4gY2hpbGQpIHtcbiAgICAgICAgYXdhaXQgc2FmZUV4ZWN1dGUoY2hpbGQucHJvcHMub25DbGljaykoZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xpY2tIYW5kbGVyKCk7XG4gICAgfTtcbiAgICBjb25zdCBjaGlsZFByb3BzID0geyAuLi5yZXN0LCBvbkNsaWNrOiB3cmFwcGVkQ2hpbGRDbGlja0hhbmRsZXIgfTtcbiAgICByZXR1cm4gUmVhY3Q0LmNsb25lRWxlbWVudChjaGlsZCwgY2hpbGRQcm9wcyk7XG4gIH0sXG4gIHsgY29tcG9uZW50OiBcIlNpZ25VcEJ1dHRvblwiLCByZW5kZXJXaGlsZUxvYWRpbmc6IHRydWUgfVxuKTtcblxuLy8gc3JjL2NvbnRleHRzL0NsZXJrUHJvdmlkZXIudHN4XG5pbXBvcnQgeyBpc1B1Ymxpc2hhYmxlS2V5IH0gZnJvbSBcIkBjbGVyay9zaGFyZWQva2V5c1wiO1xuaW1wb3J0IFJlYWN0NiBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2NvbnRleHRzL0NsZXJrQ29udGV4dFByb3ZpZGVyLnRzeFxuaW1wb3J0IHsgZGVyaXZlU3RhdGUgfSBmcm9tIFwiQGNsZXJrL3NoYXJlZC9kZXJpdmVTdGF0ZVwiO1xuaW1wb3J0IHtcbiAgX19leHBlcmltZW50YWxfQ2hlY2tvdXRQcm92aWRlciBhcyBDaGVja291dFByb3ZpZGVyLFxuICBDbGllbnRDb250ZXh0LFxuICBPcmdhbml6YXRpb25Qcm92aWRlcixcbiAgU2Vzc2lvbkNvbnRleHQsXG4gIFVzZXJDb250ZXh0XG59IGZyb20gXCJAY2xlcmsvc2hhcmVkL3JlYWN0XCI7XG5pbXBvcnQgUmVhY3Q1IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvaXNvbW9ycGhpY0NsZXJrLnRzXG5pbXBvcnQgeyBpbkJyb3dzZXIgYXMgaW5Ccm93c2VyMiB9IGZyb20gXCJAY2xlcmsvc2hhcmVkL2Jyb3dzZXJcIjtcbmltcG9ydCB7IGNsZXJrRXZlbnRzLCBjcmVhdGVDbGVya0V2ZW50QnVzIH0gZnJvbSBcIkBjbGVyay9zaGFyZWQvY2xlcmtFdmVudEJ1c1wiO1xuaW1wb3J0IHsgbG9hZENsZXJrSnNTY3JpcHQgfSBmcm9tIFwiQGNsZXJrL3NoYXJlZC9sb2FkQ2xlcmtKc1NjcmlwdFwiO1xuaW1wb3J0IHsgaGFuZGxlVmFsdWVPckZuIH0gZnJvbSBcIkBjbGVyay9zaGFyZWQvdXRpbHNcIjtcblxuLy8gc3JjL3N0YXRlUHJveHkudHNcbmltcG9ydCB7IGluQnJvd3NlciB9IGZyb20gXCJAY2xlcmsvc2hhcmVkL2Jyb3dzZXJcIjtcbnZhciBkZWZhdWx0RXJyb3JzID0gKCkgPT4gKHtcbiAgZmllbGRzOiB7XG4gICAgZmlyc3ROYW1lOiBudWxsLFxuICAgIGxhc3ROYW1lOiBudWxsLFxuICAgIGVtYWlsQWRkcmVzczogbnVsbCxcbiAgICBpZGVudGlmaWVyOiBudWxsLFxuICAgIHBob25lTnVtYmVyOiBudWxsLFxuICAgIHBhc3N3b3JkOiBudWxsLFxuICAgIHVzZXJuYW1lOiBudWxsLFxuICAgIGNvZGU6IG51bGwsXG4gICAgY2FwdGNoYTogbnVsbCxcbiAgICBsZWdhbEFjY2VwdGVkOiBudWxsXG4gIH0sXG4gIHJhdzogbnVsbCxcbiAgZ2xvYmFsOiBudWxsXG59KTtcbnZhciBTdGF0ZVByb3h5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihpc29tb3JwaGljQ2xlcmspIHtcbiAgICB0aGlzLmlzb21vcnBoaWNDbGVyayA9IGlzb21vcnBoaWNDbGVyaztcbiAgICB0aGlzLnNpZ25JblNpZ25hbFByb3h5ID0gdGhpcy5idWlsZFNpZ25JblByb3h5KCk7XG4gICAgdGhpcy5zaWduVXBTaWduYWxQcm94eSA9IHRoaXMuYnVpbGRTaWduVXBQcm94eSgpO1xuICB9XG4gIHNpZ25JblNpZ25hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zaWduSW5TaWduYWxQcm94eTtcbiAgfVxuICBzaWduVXBTaWduYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2lnblVwU2lnbmFsUHJveHk7XG4gIH1cbiAgYnVpbGRTaWduSW5Qcm94eSgpIHtcbiAgICBjb25zdCBnYXRlUHJvcGVydHkgPSB0aGlzLmdhdGVQcm9wZXJ0eS5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHRhcmdldCA9ICgpID0+IHRoaXMuY2xpZW50LnNpZ25Jbi5fX2ludGVybmFsX2Z1dHVyZTtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3JzOiBkZWZhdWx0RXJyb3JzKCksXG4gICAgICBmZXRjaFN0YXR1czogXCJpZGxlXCIsXG4gICAgICBzaWduSW46IHtcbiAgICAgICAgc3RhdHVzOiBcIm5lZWRzX2lkZW50aWZpZXJcIixcbiAgICAgICAgYXZhaWxhYmxlU3RyYXRlZ2llczogW10sXG4gICAgICAgIGlzVHJhbnNmZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0IGlkKCkge1xuICAgICAgICAgIHJldHVybiBnYXRlUHJvcGVydHkodGFyZ2V0LCBcImlkXCIsIHZvaWQgMCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBzdXBwb3J0ZWRGaXJzdEZhY3RvcnMoKSB7XG4gICAgICAgICAgcmV0dXJuIGdhdGVQcm9wZXJ0eSh0YXJnZXQsIFwic3VwcG9ydGVkRmlyc3RGYWN0b3JzXCIsIFtdKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHN1cHBvcnRlZFNlY29uZEZhY3RvcnMoKSB7XG4gICAgICAgICAgcmV0dXJuIGdhdGVQcm9wZXJ0eSh0YXJnZXQsIFwic3VwcG9ydGVkU2Vjb25kRmFjdG9yc1wiLCBbXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBzZWNvbmRGYWN0b3JWZXJpZmljYXRpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGdhdGVQcm9wZXJ0eSh0YXJnZXQsIFwic2Vjb25kRmFjdG9yVmVyaWZpY2F0aW9uXCIsIHtcbiAgICAgICAgICAgIHN0YXR1czogbnVsbCxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgZXhwaXJlQXQ6IG51bGwsXG4gICAgICAgICAgICBleHRlcm5hbFZlcmlmaWNhdGlvblJlZGlyZWN0VVJMOiBudWxsLFxuICAgICAgICAgICAgbm9uY2U6IG51bGwsXG4gICAgICAgICAgICBhdHRlbXB0czogbnVsbCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG51bGwsXG4gICAgICAgICAgICBzdHJhdGVneTogbnVsbCxcbiAgICAgICAgICAgIHZlcmlmaWVkQXRDbGllbnQ6IG51bGwsXG4gICAgICAgICAgICB2ZXJpZmllZEZyb21UaGVTYW1lQ2xpZW50OiAoKSA9PiBmYWxzZSxcbiAgICAgICAgICAgIF9faW50ZXJuYWxfdG9TbmFwc2hvdDogKCkgPT4ge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfX2ludGVybmFsX3RvU25hcHNob3QgY2FsbGVkIGJlZm9yZSBDbGVyayBpcyBsb2FkZWRcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0aFJvb3Q6IFwiXCIsXG4gICAgICAgICAgICByZWxvYWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX19pbnRlcm5hbF90b1NuYXBzaG90IGNhbGxlZCBiZWZvcmUgQ2xlcmsgaXMgbG9hZGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICAgICAgICByZXR1cm4gZ2F0ZVByb3BlcnR5KHRhcmdldCwgXCJpZGVudGlmaWVyXCIsIG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY3JlYXRlZFNlc3Npb25JZCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2F0ZVByb3BlcnR5KHRhcmdldCwgXCJjcmVhdGVkU2Vzc2lvbklkXCIsIG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgdXNlckRhdGEoKSB7XG4gICAgICAgICAgcmV0dXJuIGdhdGVQcm9wZXJ0eSh0YXJnZXQsIFwidXNlckRhdGFcIiwge30pO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgZmlyc3RGYWN0b3JWZXJpZmljYXRpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGdhdGVQcm9wZXJ0eSh0YXJnZXQsIFwiZmlyc3RGYWN0b3JWZXJpZmljYXRpb25cIiwge1xuICAgICAgICAgICAgc3RhdHVzOiBudWxsLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICBleHBpcmVBdDogbnVsbCxcbiAgICAgICAgICAgIGV4dGVybmFsVmVyaWZpY2F0aW9uUmVkaXJlY3RVUkw6IG51bGwsXG4gICAgICAgICAgICBub25jZTogbnVsbCxcbiAgICAgICAgICAgIGF0dGVtcHRzOiBudWxsLFxuICAgICAgICAgICAgbWVzc2FnZTogbnVsbCxcbiAgICAgICAgICAgIHN0cmF0ZWd5OiBudWxsLFxuICAgICAgICAgICAgdmVyaWZpZWRBdENsaWVudDogbnVsbCxcbiAgICAgICAgICAgIHZlcmlmaWVkRnJvbVRoZVNhbWVDbGllbnQ6ICgpID0+IGZhbHNlLFxuICAgICAgICAgICAgX19pbnRlcm5hbF90b1NuYXBzaG90OiAoKSA9PiB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIl9faW50ZXJuYWxfdG9TbmFwc2hvdCBjYWxsZWQgYmVmb3JlIENsZXJrIGlzIGxvYWRlZFwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoUm9vdDogXCJcIixcbiAgICAgICAgICAgIHJlbG9hZDogKCkgPT4ge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfX2ludGVybmFsX3RvU25hcHNob3QgY2FsbGVkIGJlZm9yZSBDbGVyayBpcyBsb2FkZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZTogdGhpcy5nYXRlTWV0aG9kKHRhcmdldCwgXCJjcmVhdGVcIiksXG4gICAgICAgIHBhc3N3b3JkOiB0aGlzLmdhdGVNZXRob2QodGFyZ2V0LCBcInBhc3N3b3JkXCIpLFxuICAgICAgICBzc286IHRoaXMuZ2F0ZU1ldGhvZCh0YXJnZXQsIFwic3NvXCIpLFxuICAgICAgICBmaW5hbGl6ZTogdGhpcy5nYXRlTWV0aG9kKHRhcmdldCwgXCJmaW5hbGl6ZVwiKSxcbiAgICAgICAgZW1haWxDb2RlOiB0aGlzLndyYXBNZXRob2RzKCgpID0+IHRhcmdldCgpLmVtYWlsQ29kZSwgW1wic2VuZENvZGVcIiwgXCJ2ZXJpZnlDb2RlXCJdKSxcbiAgICAgICAgZW1haWxMaW5rOiB0aGlzLndyYXBTdHJ1Y3QoXG4gICAgICAgICAgKCkgPT4gdGFyZ2V0KCkuZW1haWxMaW5rLFxuICAgICAgICAgIFtcInNlbmRMaW5rXCIsIFwid2FpdEZvclZlcmlmaWNhdGlvblwiXSxcbiAgICAgICAgICBbXCJ2ZXJpZmljYXRpb25cIl0sXG4gICAgICAgICAgeyB2ZXJpZmljYXRpb246IG51bGwgfVxuICAgICAgICApLFxuICAgICAgICByZXNldFBhc3N3b3JkRW1haWxDb2RlOiB0aGlzLndyYXBNZXRob2RzKCgpID0+IHRhcmdldCgpLnJlc2V0UGFzc3dvcmRFbWFpbENvZGUsIFtcbiAgICAgICAgICBcInNlbmRDb2RlXCIsXG4gICAgICAgICAgXCJ2ZXJpZnlDb2RlXCIsXG4gICAgICAgICAgXCJzdWJtaXRQYXNzd29yZFwiXG4gICAgICAgIF0pLFxuICAgICAgICBwaG9uZUNvZGU6IHRoaXMud3JhcE1ldGhvZHMoKCkgPT4gdGFyZ2V0KCkucGhvbmVDb2RlLCBbXCJzZW5kQ29kZVwiLCBcInZlcmlmeUNvZGVcIl0pLFxuICAgICAgICBtZmE6IHRoaXMud3JhcE1ldGhvZHMoKCkgPT4gdGFyZ2V0KCkubWZhLCBbXG4gICAgICAgICAgXCJzZW5kUGhvbmVDb2RlXCIsXG4gICAgICAgICAgXCJ2ZXJpZnlQaG9uZUNvZGVcIixcbiAgICAgICAgICBcInZlcmlmeVRPVFBcIixcbiAgICAgICAgICBcInZlcmlmeUJhY2t1cENvZGVcIlxuICAgICAgICBdKSxcbiAgICAgICAgdGlja2V0OiB0aGlzLmdhdGVNZXRob2QodGFyZ2V0LCBcInRpY2tldFwiKSxcbiAgICAgICAgcGFzc2tleTogdGhpcy5nYXRlTWV0aG9kKHRhcmdldCwgXCJwYXNza2V5XCIpLFxuICAgICAgICB3ZWIzOiB0aGlzLmdhdGVNZXRob2QodGFyZ2V0LCBcIndlYjNcIilcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGJ1aWxkU2lnblVwUHJveHkoKSB7XG4gICAgY29uc3QgZ2F0ZVByb3BlcnR5ID0gdGhpcy5nYXRlUHJvcGVydHkuYmluZCh0aGlzKTtcbiAgICBjb25zdCBnYXRlTWV0aG9kID0gdGhpcy5nYXRlTWV0aG9kLmJpbmQodGhpcyk7XG4gICAgY29uc3Qgd3JhcE1ldGhvZHMgPSB0aGlzLndyYXBNZXRob2RzLmJpbmQodGhpcyk7XG4gICAgY29uc3QgdGFyZ2V0ID0gKCkgPT4gdGhpcy5jbGllbnQuc2lnblVwLl9faW50ZXJuYWxfZnV0dXJlO1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcnM6IGRlZmF1bHRFcnJvcnMoKSxcbiAgICAgIGZldGNoU3RhdHVzOiBcImlkbGVcIixcbiAgICAgIHNpZ25VcDoge1xuICAgICAgICBnZXQgaWQoKSB7XG4gICAgICAgICAgcmV0dXJuIGdhdGVQcm9wZXJ0eSh0YXJnZXQsIFwiaWRcIiwgdm9pZCAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHJlcXVpcmVkRmllbGRzKCkge1xuICAgICAgICAgIHJldHVybiBnYXRlUHJvcGVydHkodGFyZ2V0LCBcInJlcXVpcmVkRmllbGRzXCIsIFtdKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IG9wdGlvbmFsRmllbGRzKCkge1xuICAgICAgICAgIHJldHVybiBnYXRlUHJvcGVydHkodGFyZ2V0LCBcIm9wdGlvbmFsRmllbGRzXCIsIFtdKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IG1pc3NpbmdGaWVsZHMoKSB7XG4gICAgICAgICAgcmV0dXJuIGdhdGVQcm9wZXJ0eSh0YXJnZXQsIFwibWlzc2luZ0ZpZWxkc1wiLCBbXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCB1c2VybmFtZSgpIHtcbiAgICAgICAgICByZXR1cm4gZ2F0ZVByb3BlcnR5KHRhcmdldCwgXCJ1c2VybmFtZVwiLCBudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGZpcnN0TmFtZSgpIHtcbiAgICAgICAgICByZXR1cm4gZ2F0ZVByb3BlcnR5KHRhcmdldCwgXCJmaXJzdE5hbWVcIiwgbnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBsYXN0TmFtZSgpIHtcbiAgICAgICAgICByZXR1cm4gZ2F0ZVByb3BlcnR5KHRhcmdldCwgXCJsYXN0TmFtZVwiLCBudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGVtYWlsQWRkcmVzcygpIHtcbiAgICAgICAgICByZXR1cm4gZ2F0ZVByb3BlcnR5KHRhcmdldCwgXCJlbWFpbEFkZHJlc3NcIiwgbnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBwaG9uZU51bWJlcigpIHtcbiAgICAgICAgICByZXR1cm4gZ2F0ZVByb3BlcnR5KHRhcmdldCwgXCJwaG9uZU51bWJlclwiLCBudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHdlYjNXYWxsZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIGdhdGVQcm9wZXJ0eSh0YXJnZXQsIFwid2ViM1dhbGxldFwiLCBudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGhhc1Bhc3N3b3JkKCkge1xuICAgICAgICAgIHJldHVybiBnYXRlUHJvcGVydHkodGFyZ2V0LCBcImhhc1Bhc3N3b3JkXCIsIGZhbHNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHVuc2FmZU1ldGFkYXRhKCkge1xuICAgICAgICAgIHJldHVybiBnYXRlUHJvcGVydHkodGFyZ2V0LCBcInVuc2FmZU1ldGFkYXRhXCIsIHt9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNyZWF0ZWRTZXNzaW9uSWQoKSB7XG4gICAgICAgICAgcmV0dXJuIGdhdGVQcm9wZXJ0eSh0YXJnZXQsIFwiY3JlYXRlZFNlc3Npb25JZFwiLCBudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNyZWF0ZWRVc2VySWQoKSB7XG4gICAgICAgICAgcmV0dXJuIGdhdGVQcm9wZXJ0eSh0YXJnZXQsIFwiY3JlYXRlZFVzZXJJZFwiLCBudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGFiYW5kb25BdCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2F0ZVByb3BlcnR5KHRhcmdldCwgXCJhYmFuZG9uQXRcIiwgbnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBsZWdhbEFjY2VwdGVkQXQoKSB7XG4gICAgICAgICAgcmV0dXJuIGdhdGVQcm9wZXJ0eSh0YXJnZXQsIFwibGVnYWxBY2NlcHRlZEF0XCIsIG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgbG9jYWxlKCkge1xuICAgICAgICAgIHJldHVybiBnYXRlUHJvcGVydHkodGFyZ2V0LCBcImxvY2FsZVwiLCBudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHN0YXR1cygpIHtcbiAgICAgICAgICByZXR1cm4gZ2F0ZVByb3BlcnR5KHRhcmdldCwgXCJzdGF0dXNcIiwgXCJtaXNzaW5nX3JlcXVpcmVtZW50c1wiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHVudmVyaWZpZWRGaWVsZHMoKSB7XG4gICAgICAgICAgcmV0dXJuIGdhdGVQcm9wZXJ0eSh0YXJnZXQsIFwidW52ZXJpZmllZEZpZWxkc1wiLCBbXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBpc1RyYW5zZmVyYWJsZSgpIHtcbiAgICAgICAgICByZXR1cm4gZ2F0ZVByb3BlcnR5KHRhcmdldCwgXCJpc1RyYW5zZmVyYWJsZVwiLCBmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZTogZ2F0ZU1ldGhvZCh0YXJnZXQsIFwiY3JlYXRlXCIpLFxuICAgICAgICB1cGRhdGU6IGdhdGVNZXRob2QodGFyZ2V0LCBcInVwZGF0ZVwiKSxcbiAgICAgICAgc3NvOiBnYXRlTWV0aG9kKHRhcmdldCwgXCJzc29cIiksXG4gICAgICAgIHBhc3N3b3JkOiBnYXRlTWV0aG9kKHRhcmdldCwgXCJwYXNzd29yZFwiKSxcbiAgICAgICAgdGlja2V0OiBnYXRlTWV0aG9kKHRhcmdldCwgXCJ0aWNrZXRcIiksXG4gICAgICAgIHdlYjM6IGdhdGVNZXRob2QodGFyZ2V0LCBcIndlYjNcIiksXG4gICAgICAgIGZpbmFsaXplOiBnYXRlTWV0aG9kKHRhcmdldCwgXCJmaW5hbGl6ZVwiKSxcbiAgICAgICAgdmVyaWZpY2F0aW9uczogd3JhcE1ldGhvZHMoKCkgPT4gdGFyZ2V0KCkudmVyaWZpY2F0aW9ucywgW1xuICAgICAgICAgIFwic2VuZEVtYWlsQ29kZVwiLFxuICAgICAgICAgIFwidmVyaWZ5RW1haWxDb2RlXCIsXG4gICAgICAgICAgXCJzZW5kUGhvbmVDb2RlXCIsXG4gICAgICAgICAgXCJ2ZXJpZnlQaG9uZUNvZGVcIlxuICAgICAgICBdKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgX19pbnRlcm5hbF9lZmZlY3QoXykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIl9faW50ZXJuYWxfZWZmZWN0IGNhbGxlZCBiZWZvcmUgQ2xlcmsgaXMgbG9hZGVkXCIpO1xuICB9XG4gIF9faW50ZXJuYWxfY29tcHV0ZWQoXykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIl9faW50ZXJuYWxfY29tcHV0ZWQgY2FsbGVkIGJlZm9yZSBDbGVyayBpcyBsb2FkZWRcIik7XG4gIH1cbiAgZ2V0IGNsaWVudCgpIHtcbiAgICBjb25zdCBjID0gdGhpcy5pc29tb3JwaGljQ2xlcmsuY2xpZW50O1xuICAgIGlmICghYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2xlcmsgY2xpZW50IG5vdCByZWFkeVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG4gIH1cbiAgZ2F0ZVByb3BlcnR5KGdldFRhcmdldCwga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICByZXR1cm4gKCgpID0+IHtcbiAgICAgIGlmICghaW5Ccm93c2VyKCkgfHwgIXRoaXMuaXNvbW9ycGhpY0NsZXJrLmxvYWRlZCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdCA9IGdldFRhcmdldCgpO1xuICAgICAgcmV0dXJuIHRba2V5XTtcbiAgICB9KSgpO1xuICB9XG4gIGdhdGVNZXRob2QoZ2V0VGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGlmICghaW5Ccm93c2VyKCkpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yVGhyb3dlci50aHJvdyhgQXR0ZW1wdGVkIHRvIGNhbGwgYSBtZXRob2QgKCR7a2V5fSkgdGhhdCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoZSBzZXJ2ZXIuYCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaXNvbW9ycGhpY0NsZXJrLmxvYWRlZCkge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gdGhpcy5pc29tb3JwaGljQ2xlcmsuYWRkT25Mb2FkZWQocmVzb2x2ZSkpO1xuICAgICAgfVxuICAgICAgY29uc3QgdCA9IGdldFRhcmdldCgpO1xuICAgICAgcmV0dXJuIHRba2V5XS5hcHBseSh0LCBhcmdzKTtcbiAgICB9O1xuICB9XG4gIHdyYXBNZXRob2RzKGdldFRhcmdldCwga2V5cykge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoa2V5cy5tYXAoKGspID0+IFtrLCB0aGlzLmdhdGVNZXRob2QoZ2V0VGFyZ2V0LCBrKV0pKTtcbiAgfVxuICB3cmFwU3RydWN0KGdldFRhcmdldCwgbWV0aG9kcywgZ2V0dGVycywgZmFsbGJhY2tzKSB7XG4gICAgY29uc3Qgb3V0ID0ge307XG4gICAgZm9yIChjb25zdCBtIG9mIG1ldGhvZHMpIHtcbiAgICAgIG91dFttXSA9IHRoaXMuZ2F0ZU1ldGhvZChnZXRUYXJnZXQsIG0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGcgb2YgZ2V0dGVycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG91dCwgZywge1xuICAgICAgICBnZXQ6ICgpID0+IHRoaXMuZ2F0ZVByb3BlcnR5KGdldFRhcmdldCwgZywgZmFsbGJhY2tzW2ddKSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbn07XG5cbi8vIHNyYy9pc29tb3JwaGljQ2xlcmsudHNcbmlmICh0eXBlb2YgZ2xvYmFsVGhpcy5fX0JVSUxEX0RJU0FCTEVfUkhDX18gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgZ2xvYmFsVGhpcy5fX0JVSUxEX0RJU0FCTEVfUkhDX18gPSBmYWxzZTtcbn1cbnZhciBTREtfTUVUQURBVEEgPSB7XG4gIG5hbWU6IFwiQGNsZXJrL2NsZXJrLXJlYWN0XCIsXG4gIHZlcnNpb246IFwiNS41My4zXCIsXG4gIGVudmlyb25tZW50OiBwcm9jZXNzLmVudi5OT0RFX0VOVlxufTtcbnZhciBfc3RhdHVzLCBfZG9tYWluLCBfcHJveHlVcmwsIF9wdWJsaXNoYWJsZUtleSwgX2V2ZW50QnVzLCBfc3RhdGVQcm94eSwgX2luc3RhbmNlLCBfSXNvbW9ycGhpY0NsZXJrX2luc3RhbmNlcywgd2FpdEZvckNsZXJrSlNfZm47XG52YXIgX0lzb21vcnBoaWNDbGVyayA9IGNsYXNzIF9Jc29tb3JwaGljQ2xlcmsge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9Jc29tb3JwaGljQ2xlcmtfaW5zdGFuY2VzKTtcbiAgICB0aGlzLmNsZXJranMgPSBudWxsO1xuICAgIHRoaXMucHJlb3Blbk9uZVRhcCA9IG51bGw7XG4gICAgdGhpcy5wcmVvcGVuVXNlclZlcmlmaWNhdGlvbiA9IG51bGw7XG4gICAgdGhpcy5wcmVvcGVuU2lnbkluID0gbnVsbDtcbiAgICB0aGlzLnByZW9wZW5DaGVja291dCA9IG51bGw7XG4gICAgdGhpcy5wcmVvcGVuUGxhbkRldGFpbHMgPSBudWxsO1xuICAgIHRoaXMucHJlb3BlblN1YnNjcmlwdGlvbkRldGFpbHMgPSBudWxsO1xuICAgIHRoaXMucHJlb3BlblNpZ25VcCA9IG51bGw7XG4gICAgdGhpcy5wcmVvcGVuVXNlclByb2ZpbGUgPSBudWxsO1xuICAgIHRoaXMucHJlb3Blbk9yZ2FuaXphdGlvblByb2ZpbGUgPSBudWxsO1xuICAgIHRoaXMucHJlb3BlbkNyZWF0ZU9yZ2FuaXphdGlvbiA9IG51bGw7XG4gICAgdGhpcy5wcmVPcGVuV2FpdGxpc3QgPSBudWxsO1xuICAgIHRoaXMucHJlbW91bnRTaWduSW5Ob2RlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5wcmVtb3VudFNpZ25VcE5vZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnByZW1vdW50VXNlckF2YXRhck5vZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnByZW1vdW50VXNlclByb2ZpbGVOb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5wcmVtb3VudFVzZXJCdXR0b25Ob2RlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5wcmVtb3VudE9yZ2FuaXphdGlvblByb2ZpbGVOb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5wcmVtb3VudENyZWF0ZU9yZ2FuaXphdGlvbk5vZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnByZW1vdW50T3JnYW5pemF0aW9uU3dpdGNoZXJOb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5wcmVtb3VudE9yZ2FuaXphdGlvbkxpc3ROb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnByZW1vdW50V2FpdGxpc3ROb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5wcmVtb3VudFByaWNpbmdUYWJsZU5vZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnByZW1vdW50QXBpS2V5c05vZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnByZW1vdW50T0F1dGhDb25zZW50Tm9kZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMucHJlbW91bnRUYXNrQ2hvb3NlT3JnYW5pemF0aW9uTm9kZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIC8vIEEgc2VwYXJhdGUgTWFwIG9mIGBhZGRMaXN0ZW5lcmAgbWV0aG9kIGNhbGxzIHRvIGhhbmRsZSBtdWx0aXBsZSBsaXN0ZW5lcnMuXG4gICAgdGhpcy5wcmVtb3VudEFkZExpc3RlbmVyQ2FsbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMubG9hZGVkTGlzdGVuZXJzID0gW107XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9zdGF0dXMsIFwibG9hZGluZ1wiKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2RvbWFpbik7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9wcm94eVVybCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9wdWJsaXNoYWJsZUtleSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9ldmVudEJ1cywgY3JlYXRlQ2xlcmtFdmVudEJ1cygpKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3N0YXRlUHJveHkpO1xuICAgIHRoaXMuYnVpbGRTaWduSW5VcmwgPSAob3B0cykgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5idWlsZFNpZ25JblVybChvcHRzKSkgfHwgXCJcIjtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcImJ1aWxkU2lnbkluVXJsXCIsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYnVpbGRTaWduVXBVcmwgPSAob3B0cykgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5idWlsZFNpZ25VcFVybChvcHRzKSkgfHwgXCJcIjtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcImJ1aWxkU2lnblVwVXJsXCIsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYnVpbGRBZnRlclNpZ25JblVybCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmJ1aWxkQWZ0ZXJTaWduSW5VcmwoLi4uYXJncykpIHx8IFwiXCI7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJidWlsZEFmdGVyU2lnbkluVXJsXCIsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYnVpbGRBZnRlclNpZ25VcFVybCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmJ1aWxkQWZ0ZXJTaWduVXBVcmwoLi4uYXJncykpIHx8IFwiXCI7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJidWlsZEFmdGVyU2lnblVwVXJsXCIsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYnVpbGRBZnRlclNpZ25PdXRVcmwgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmJ1aWxkQWZ0ZXJTaWduT3V0VXJsKCkpIHx8IFwiXCI7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJidWlsZEFmdGVyU2lnbk91dFVybFwiLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmJ1aWxkTmV3U3Vic2NyaXB0aW9uUmVkaXJlY3RVcmwgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmJ1aWxkTmV3U3Vic2NyaXB0aW9uUmVkaXJlY3RVcmwoKSkgfHwgXCJcIjtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcImJ1aWxkTmV3U3Vic2NyaXB0aW9uUmVkaXJlY3RVcmxcIiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5idWlsZEFmdGVyTXVsdGlTZXNzaW9uU2luZ2xlU2lnbk91dFVybCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYnVpbGRBZnRlck11bHRpU2Vzc2lvblNpbmdsZVNpZ25PdXRVcmwoKSkgfHwgXCJcIjtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcImJ1aWxkQWZ0ZXJNdWx0aVNlc3Npb25TaW5nbGVTaWduT3V0VXJsXCIsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYnVpbGRVc2VyUHJvZmlsZVVybCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYnVpbGRVc2VyUHJvZmlsZVVybCgpKSB8fCBcIlwiO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50TWV0aG9kQ2FsbHMuc2V0KFwiYnVpbGRVc2VyUHJvZmlsZVVybFwiLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmJ1aWxkQ3JlYXRlT3JnYW5pemF0aW9uVXJsID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5idWlsZENyZWF0ZU9yZ2FuaXphdGlvblVybCgpKSB8fCBcIlwiO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50TWV0aG9kQ2FsbHMuc2V0KFwiYnVpbGRDcmVhdGVPcmdhbml6YXRpb25VcmxcIiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5idWlsZE9yZ2FuaXphdGlvblByb2ZpbGVVcmwgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmJ1aWxkT3JnYW5pemF0aW9uUHJvZmlsZVVybCgpKSB8fCBcIlwiO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50TWV0aG9kQ2FsbHMuc2V0KFwiYnVpbGRPcmdhbml6YXRpb25Qcm9maWxlVXJsXCIsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYnVpbGRXYWl0bGlzdFVybCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYnVpbGRXYWl0bGlzdFVybCgpKSB8fCBcIlwiO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50TWV0aG9kQ2FsbHMuc2V0KFwiYnVpbGRXYWl0bGlzdFVybFwiLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmJ1aWxkVGFza3NVcmwgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmJ1aWxkVGFza3NVcmwoKSkgfHwgXCJcIjtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcImJ1aWxkVGFza3NVcmxcIiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5idWlsZFVybFdpdGhBdXRoID0gKHRvKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmJ1aWxkVXJsV2l0aEF1dGgodG8pKSB8fCBcIlwiO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50TWV0aG9kQ2FsbHMuc2V0KFwiYnVpbGRVcmxXaXRoQXV0aFwiLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVVuYXV0aGVudGljYXRlZCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5oYW5kbGVVbmF1dGhlbnRpY2F0ZWQoKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHZvaWQgY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJoYW5kbGVVbmF1dGhlbnRpY2F0ZWRcIiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vbiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2Eub24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xlcmtqcy5vbiguLi5hcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfZXZlbnRCdXMpLm9uKC4uLmFyZ3MpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vZmYgPSAoLi4uYXJncykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm9mZikge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGVya2pzLm9mZiguLi5hcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfZXZlbnRCdXMpLm9mZiguLi5hcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYGFkZFN0YXR1c0xpc3RlbmVyYC4gVGhpcyBhcGkgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yLlxuICAgICAqL1xuICAgIHRoaXMuYWRkT25Mb2FkZWQgPSAoY2IpID0+IHtcbiAgICAgIHRoaXMubG9hZGVkTGlzdGVuZXJzLnB1c2goY2IpO1xuICAgICAgaWYgKHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHRoaXMuZW1pdExvYWRlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBgX19pbnRlcm5hbF9zZXRTdGF0dXNgLiBUaGlzIGFwaSB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IuXG4gICAgICovXG4gICAgdGhpcy5lbWl0TG9hZGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5sb2FkZWRMaXN0ZW5lcnMuZm9yRWFjaCgoY2IpID0+IGNiKCkpO1xuICAgICAgdGhpcy5sb2FkZWRMaXN0ZW5lcnMgPSBbXTtcbiAgICB9O1xuICAgIHRoaXMuYmVmb3JlTG9hZCA9IChjbGVya2pzKSA9PiB7XG4gICAgICBpZiAoIWNsZXJranMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGh5ZHJhdGUgbGF0ZXN0IENsZXJrIEpTXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oeWRyYXRlQ2xlcmtKUyA9IChjbGVya2pzKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIWNsZXJranMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGh5ZHJhdGUgbGF0ZXN0IENsZXJrIEpTXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGVya2pzID0gY2xlcmtqcztcbiAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgICB0aGlzLnByZW1vdW50QWRkTGlzdGVuZXJDYWxscy5mb3JFYWNoKChsaXN0ZW5lckhhbmRsZXJzLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgICBsaXN0ZW5lckhhbmRsZXJzLm5hdGl2ZVVuc3Vic2NyaWJlID0gY2xlcmtqcy5hZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB9KTtcbiAgICAgIChfYSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfZXZlbnRCdXMpLmludGVybmFsLnJldHJpZXZlTGlzdGVuZXJzKFwic3RhdHVzXCIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgICAgdGhpcy5vbihcInN0YXR1c1wiLCBsaXN0ZW5lciwgeyBub3RpZnk6IHRydWUgfSk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnByZW9wZW5TaWduSW4gIT09IG51bGwpIHtcbiAgICAgICAgY2xlcmtqcy5vcGVuU2lnbkluKHRoaXMucHJlb3BlblNpZ25Jbik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcmVvcGVuQ2hlY2tvdXQgIT09IG51bGwpIHtcbiAgICAgICAgY2xlcmtqcy5fX2ludGVybmFsX29wZW5DaGVja291dCh0aGlzLnByZW9wZW5DaGVja291dCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcmVvcGVuUGxhbkRldGFpbHMgIT09IG51bGwpIHtcbiAgICAgICAgY2xlcmtqcy5fX2ludGVybmFsX29wZW5QbGFuRGV0YWlscyh0aGlzLnByZW9wZW5QbGFuRGV0YWlscyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcmVvcGVuU3Vic2NyaXB0aW9uRGV0YWlscyAhPT0gbnVsbCkge1xuICAgICAgICBjbGVya2pzLl9faW50ZXJuYWxfb3BlblN1YnNjcmlwdGlvbkRldGFpbHModGhpcy5wcmVvcGVuU3Vic2NyaXB0aW9uRGV0YWlscyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcmVvcGVuU2lnblVwICE9PSBudWxsKSB7XG4gICAgICAgIGNsZXJranMub3BlblNpZ25VcCh0aGlzLnByZW9wZW5TaWduVXApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJlb3BlblVzZXJQcm9maWxlICE9PSBudWxsKSB7XG4gICAgICAgIGNsZXJranMub3BlblVzZXJQcm9maWxlKHRoaXMucHJlb3BlblVzZXJQcm9maWxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnByZW9wZW5Vc2VyVmVyaWZpY2F0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIGNsZXJranMuX19pbnRlcm5hbF9vcGVuUmV2ZXJpZmljYXRpb24odGhpcy5wcmVvcGVuVXNlclZlcmlmaWNhdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcmVvcGVuT25lVGFwICE9PSBudWxsKSB7XG4gICAgICAgIGNsZXJranMub3Blbkdvb2dsZU9uZVRhcCh0aGlzLnByZW9wZW5PbmVUYXApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJlb3Blbk9yZ2FuaXphdGlvblByb2ZpbGUgIT09IG51bGwpIHtcbiAgICAgICAgY2xlcmtqcy5vcGVuT3JnYW5pemF0aW9uUHJvZmlsZSh0aGlzLnByZW9wZW5Pcmdhbml6YXRpb25Qcm9maWxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnByZW9wZW5DcmVhdGVPcmdhbml6YXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgY2xlcmtqcy5vcGVuQ3JlYXRlT3JnYW5pemF0aW9uKHRoaXMucHJlb3BlbkNyZWF0ZU9yZ2FuaXphdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcmVPcGVuV2FpdGxpc3QgIT09IG51bGwpIHtcbiAgICAgICAgY2xlcmtqcy5vcGVuV2FpdGxpc3QodGhpcy5wcmVPcGVuV2FpdGxpc3QpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmVtb3VudFNpZ25Jbk5vZGVzLmZvckVhY2goKHByb3BzLCBub2RlKSA9PiB7XG4gICAgICAgIGNsZXJranMubW91bnRTaWduSW4obm9kZSwgcHJvcHMpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnByZW1vdW50U2lnblVwTm9kZXMuZm9yRWFjaCgocHJvcHMsIG5vZGUpID0+IHtcbiAgICAgICAgY2xlcmtqcy5tb3VudFNpZ25VcChub2RlLCBwcm9wcyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJlbW91bnRVc2VyUHJvZmlsZU5vZGVzLmZvckVhY2goKHByb3BzLCBub2RlKSA9PiB7XG4gICAgICAgIGNsZXJranMubW91bnRVc2VyUHJvZmlsZShub2RlLCBwcm9wcyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJlbW91bnRVc2VyQXZhdGFyTm9kZXMuZm9yRWFjaCgocHJvcHMsIG5vZGUpID0+IHtcbiAgICAgICAgY2xlcmtqcy5tb3VudFVzZXJBdmF0YXIobm9kZSwgcHJvcHMpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnByZW1vdW50VXNlckJ1dHRvbk5vZGVzLmZvckVhY2goKHByb3BzLCBub2RlKSA9PiB7XG4gICAgICAgIGNsZXJranMubW91bnRVc2VyQnV0dG9uKG5vZGUsIHByb3BzKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcmVtb3VudE9yZ2FuaXphdGlvbkxpc3ROb2Rlcy5mb3JFYWNoKChwcm9wcywgbm9kZSkgPT4ge1xuICAgICAgICBjbGVya2pzLm1vdW50T3JnYW5pemF0aW9uTGlzdChub2RlLCBwcm9wcyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJlbW91bnRXYWl0bGlzdE5vZGVzLmZvckVhY2goKHByb3BzLCBub2RlKSA9PiB7XG4gICAgICAgIGNsZXJranMubW91bnRXYWl0bGlzdChub2RlLCBwcm9wcyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJlbW91bnRQcmljaW5nVGFibGVOb2Rlcy5mb3JFYWNoKChwcm9wcywgbm9kZSkgPT4ge1xuICAgICAgICBjbGVya2pzLm1vdW50UHJpY2luZ1RhYmxlKG5vZGUsIHByb3BzKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcmVtb3VudEFwaUtleXNOb2Rlcy5mb3JFYWNoKChwcm9wcywgbm9kZSkgPT4ge1xuICAgICAgICBjbGVya2pzLm1vdW50QXBpS2V5cyhub2RlLCBwcm9wcyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJlbW91bnRPQXV0aENvbnNlbnROb2Rlcy5mb3JFYWNoKChwcm9wcywgbm9kZSkgPT4ge1xuICAgICAgICBjbGVya2pzLl9faW50ZXJuYWxfbW91bnRPQXV0aENvbnNlbnQobm9kZSwgcHJvcHMpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnByZW1vdW50VGFza0Nob29zZU9yZ2FuaXphdGlvbk5vZGVzLmZvckVhY2goKHByb3BzLCBub2RlKSA9PiB7XG4gICAgICAgIGNsZXJranMubW91bnRUYXNrQ2hvb3NlT3JnYW5pemF0aW9uKG5vZGUsIHByb3BzKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLmNsZXJranMuc3RhdHVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfZXZlbnRCdXMpLmVtaXQoY2xlcmtFdmVudHMuU3RhdHVzLCBcInJlYWR5XCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0TG9hZGVkKCk7XG4gICAgICByZXR1cm4gdGhpcy5jbGVya2pzO1xuICAgIH07XG4gICAgdGhpcy5fX2V4cGVyaW1lbnRhbF9jaGVja291dCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuX19leHBlcmltZW50YWxfY2hlY2tvdXQoLi4uYXJncyk7XG4gICAgfTtcbiAgICAvLyBUT0RPIEB1c2VybGFuZC1lcnJvcnM6XG4gICAgdGhpcy5fX3Vuc3RhYmxlX191cGRhdGVQcm9wcyA9IGFzeW5jIChwcm9wcykgPT4ge1xuICAgICAgY29uc3QgY2xlcmtqcyA9IGF3YWl0IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfSXNvbW9ycGhpY0NsZXJrX2luc3RhbmNlcywgd2FpdEZvckNsZXJrSlNfZm4pLmNhbGwodGhpcyk7XG4gICAgICBpZiAoY2xlcmtqcyAmJiBcIl9fdW5zdGFibGVfX3VwZGF0ZVByb3BzXCIgaW4gY2xlcmtqcykge1xuICAgICAgICByZXR1cm4gY2xlcmtqcy5fX3Vuc3RhYmxlX191cGRhdGVQcm9wcyhwcm9wcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBgc2V0QWN0aXZlYCBjYW4gYmUgdXNlZCB0byBzZXQgdGhlIGFjdGl2ZSBzZXNzaW9uIGFuZC9vciBvcmdhbml6YXRpb24uXG4gICAgICovXG4gICAgdGhpcy5zZXRBY3RpdmUgPSAocGFyYW1zKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsZXJranMuc2V0QWN0aXZlKHBhcmFtcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub3BlblNpZ25JbiA9IChwcm9wcykgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICB0aGlzLmNsZXJranMub3BlblNpZ25Jbihwcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW9wZW5TaWduSW4gPSBwcm9wcztcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuY2xvc2VTaWduSW4gPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy5jbG9zZVNpZ25JbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVvcGVuU2lnbkluID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX19pbnRlcm5hbF9vcGVuQ2hlY2tvdXQgPSAocHJvcHMpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgdGhpcy5jbGVya2pzLl9faW50ZXJuYWxfb3BlbkNoZWNrb3V0KHByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlb3BlbkNoZWNrb3V0ID0gcHJvcHM7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9faW50ZXJuYWxfY2xvc2VDaGVja291dCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgdGhpcy5jbGVya2pzLl9faW50ZXJuYWxfY2xvc2VDaGVja291dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVvcGVuQ2hlY2tvdXQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fX2ludGVybmFsX29wZW5QbGFuRGV0YWlscyA9IChwcm9wcykgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICB0aGlzLmNsZXJranMuX19pbnRlcm5hbF9vcGVuUGxhbkRldGFpbHMocHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVvcGVuUGxhbkRldGFpbHMgPSBwcm9wcztcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX19pbnRlcm5hbF9jbG9zZVBsYW5EZXRhaWxzID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICB0aGlzLmNsZXJranMuX19pbnRlcm5hbF9jbG9zZVBsYW5EZXRhaWxzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW9wZW5QbGFuRGV0YWlscyA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9faW50ZXJuYWxfb3BlblN1YnNjcmlwdGlvbkRldGFpbHMgPSAocHJvcHMpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgdGhpcy5jbGVya2pzLl9faW50ZXJuYWxfb3BlblN1YnNjcmlwdGlvbkRldGFpbHMocHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVvcGVuU3Vic2NyaXB0aW9uRGV0YWlscyA9IHByb3BzICE9IG51bGwgPyBwcm9wcyA6IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9faW50ZXJuYWxfY2xvc2VTdWJzY3JpcHRpb25EZXRhaWxzID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICB0aGlzLmNsZXJranMuX19pbnRlcm5hbF9jbG9zZVN1YnNjcmlwdGlvbkRldGFpbHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlb3BlblN1YnNjcmlwdGlvbkRldGFpbHMgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fX2ludGVybmFsX29wZW5SZXZlcmlmaWNhdGlvbiA9IChwcm9wcykgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICB0aGlzLmNsZXJranMuX19pbnRlcm5hbF9vcGVuUmV2ZXJpZmljYXRpb24ocHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVvcGVuVXNlclZlcmlmaWNhdGlvbiA9IHByb3BzO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fX2ludGVybmFsX2Nsb3NlUmV2ZXJpZmljYXRpb24gPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy5fX2ludGVybmFsX2Nsb3NlUmV2ZXJpZmljYXRpb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlb3BlblVzZXJWZXJpZmljYXRpb24gPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vcGVuR29vZ2xlT25lVGFwID0gKHByb3BzKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy5vcGVuR29vZ2xlT25lVGFwKHByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlb3Blbk9uZVRhcCA9IHByb3BzO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5jbG9zZUdvb2dsZU9uZVRhcCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgdGhpcy5jbGVya2pzLmNsb3NlR29vZ2xlT25lVGFwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW9wZW5PbmVUYXAgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vcGVuVXNlclByb2ZpbGUgPSAocHJvcHMpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgdGhpcy5jbGVya2pzLm9wZW5Vc2VyUHJvZmlsZShwcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW9wZW5Vc2VyUHJvZmlsZSA9IHByb3BzO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5jbG9zZVVzZXJQcm9maWxlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICB0aGlzLmNsZXJranMuY2xvc2VVc2VyUHJvZmlsZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVvcGVuVXNlclByb2ZpbGUgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vcGVuT3JnYW5pemF0aW9uUHJvZmlsZSA9IChwcm9wcykgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICB0aGlzLmNsZXJranMub3Blbk9yZ2FuaXphdGlvblByb2ZpbGUocHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVvcGVuT3JnYW5pemF0aW9uUHJvZmlsZSA9IHByb3BzO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5jbG9zZU9yZ2FuaXphdGlvblByb2ZpbGUgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy5jbG9zZU9yZ2FuaXphdGlvblByb2ZpbGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlb3Blbk9yZ2FuaXphdGlvblByb2ZpbGUgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vcGVuQ3JlYXRlT3JnYW5pemF0aW9uID0gKHByb3BzKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy5vcGVuQ3JlYXRlT3JnYW5pemF0aW9uKHByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlb3BlbkNyZWF0ZU9yZ2FuaXphdGlvbiA9IHByb3BzO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5jbG9zZUNyZWF0ZU9yZ2FuaXphdGlvbiA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgdGhpcy5jbGVya2pzLmNsb3NlQ3JlYXRlT3JnYW5pemF0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW9wZW5DcmVhdGVPcmdhbml6YXRpb24gPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vcGVuV2FpdGxpc3QgPSAocHJvcHMpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgdGhpcy5jbGVya2pzLm9wZW5XYWl0bGlzdChwcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZU9wZW5XYWl0bGlzdCA9IHByb3BzO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5jbG9zZVdhaXRsaXN0ID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICB0aGlzLmNsZXJranMuY2xvc2VXYWl0bGlzdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVPcGVuV2FpdGxpc3QgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vcGVuU2lnblVwID0gKHByb3BzKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy5vcGVuU2lnblVwKHByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlb3BlblNpZ25VcCA9IHByb3BzO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5jbG9zZVNpZ25VcCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgdGhpcy5jbGVya2pzLmNsb3NlU2lnblVwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW9wZW5TaWduVXAgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5tb3VudFNpZ25JbiA9IChub2RlLCBwcm9wcykgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICB0aGlzLmNsZXJranMubW91bnRTaWduSW4obm9kZSwgcHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudFNpZ25Jbk5vZGVzLnNldChub2RlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnVubW91bnRTaWduSW4gPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICB0aGlzLmNsZXJranMudW5tb3VudFNpZ25Jbihub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRTaWduSW5Ob2Rlcy5kZWxldGUobm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm1vdW50U2lnblVwID0gKG5vZGUsIHByb3BzKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy5tb3VudFNpZ25VcChub2RlLCBwcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50U2lnblVwTm9kZXMuc2V0KG5vZGUsIHByb3BzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMudW5tb3VudFNpZ25VcCA9IChub2RlKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy51bm1vdW50U2lnblVwKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudFNpZ25VcE5vZGVzLmRlbGV0ZShub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubW91bnRVc2VyQXZhdGFyID0gKG5vZGUsIHByb3BzKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy5tb3VudFVzZXJBdmF0YXIobm9kZSwgcHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudFVzZXJBdmF0YXJOb2Rlcy5zZXQobm9kZSwgcHJvcHMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy51bm1vdW50VXNlckF2YXRhciA9IChub2RlKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy51bm1vdW50VXNlckF2YXRhcihub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRVc2VyQXZhdGFyTm9kZXMuZGVsZXRlKG5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5tb3VudFVzZXJQcm9maWxlID0gKG5vZGUsIHByb3BzKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy5tb3VudFVzZXJQcm9maWxlKG5vZGUsIHByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRVc2VyUHJvZmlsZU5vZGVzLnNldChub2RlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnVubW91bnRVc2VyUHJvZmlsZSA9IChub2RlKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy51bm1vdW50VXNlclByb2ZpbGUobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50VXNlclByb2ZpbGVOb2Rlcy5kZWxldGUobm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm1vdW50T3JnYW5pemF0aW9uUHJvZmlsZSA9IChub2RlLCBwcm9wcykgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICB0aGlzLmNsZXJranMubW91bnRPcmdhbml6YXRpb25Qcm9maWxlKG5vZGUsIHByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRPcmdhbml6YXRpb25Qcm9maWxlTm9kZXMuc2V0KG5vZGUsIHByb3BzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMudW5tb3VudE9yZ2FuaXphdGlvblByb2ZpbGUgPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICB0aGlzLmNsZXJranMudW5tb3VudE9yZ2FuaXphdGlvblByb2ZpbGUobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50T3JnYW5pemF0aW9uUHJvZmlsZU5vZGVzLmRlbGV0ZShub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubW91bnRDcmVhdGVPcmdhbml6YXRpb24gPSAobm9kZSwgcHJvcHMpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgdGhpcy5jbGVya2pzLm1vdW50Q3JlYXRlT3JnYW5pemF0aW9uKG5vZGUsIHByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRDcmVhdGVPcmdhbml6YXRpb25Ob2Rlcy5zZXQobm9kZSwgcHJvcHMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy51bm1vdW50Q3JlYXRlT3JnYW5pemF0aW9uID0gKG5vZGUpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgdGhpcy5jbGVya2pzLnVubW91bnRDcmVhdGVPcmdhbml6YXRpb24obm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50Q3JlYXRlT3JnYW5pemF0aW9uTm9kZXMuZGVsZXRlKG5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5tb3VudE9yZ2FuaXphdGlvblN3aXRjaGVyID0gKG5vZGUsIHByb3BzKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy5tb3VudE9yZ2FuaXphdGlvblN3aXRjaGVyKG5vZGUsIHByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRPcmdhbml6YXRpb25Td2l0Y2hlck5vZGVzLnNldChub2RlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnVubW91bnRPcmdhbml6YXRpb25Td2l0Y2hlciA9IChub2RlKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy51bm1vdW50T3JnYW5pemF0aW9uU3dpdGNoZXIobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50T3JnYW5pemF0aW9uU3dpdGNoZXJOb2Rlcy5kZWxldGUobm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9fZXhwZXJpbWVudGFsX3ByZWZldGNoT3JnYW5pemF0aW9uU3dpdGNoZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuX19leHBlcmltZW50YWxfcHJlZmV0Y2hPcmdhbml6YXRpb25Td2l0Y2hlcigpO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgdm9pZCBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcIl9fZXhwZXJpbWVudGFsX3ByZWZldGNoT3JnYW5pemF0aW9uU3dpdGNoZXJcIiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5tb3VudE9yZ2FuaXphdGlvbkxpc3QgPSAobm9kZSwgcHJvcHMpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgdGhpcy5jbGVya2pzLm1vdW50T3JnYW5pemF0aW9uTGlzdChub2RlLCBwcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50T3JnYW5pemF0aW9uTGlzdE5vZGVzLnNldChub2RlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnVubW91bnRPcmdhbml6YXRpb25MaXN0ID0gKG5vZGUpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgdGhpcy5jbGVya2pzLnVubW91bnRPcmdhbml6YXRpb25MaXN0KG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE9yZ2FuaXphdGlvbkxpc3ROb2Rlcy5kZWxldGUobm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm1vdW50VXNlckJ1dHRvbiA9IChub2RlLCB1c2VyQnV0dG9uUHJvcHMpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgdGhpcy5jbGVya2pzLm1vdW50VXNlckJ1dHRvbihub2RlLCB1c2VyQnV0dG9uUHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudFVzZXJCdXR0b25Ob2Rlcy5zZXQobm9kZSwgdXNlckJ1dHRvblByb3BzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMudW5tb3VudFVzZXJCdXR0b24gPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICB0aGlzLmNsZXJranMudW5tb3VudFVzZXJCdXR0b24obm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50VXNlckJ1dHRvbk5vZGVzLmRlbGV0ZShub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubW91bnRXYWl0bGlzdCA9IChub2RlLCBwcm9wcykgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICB0aGlzLmNsZXJranMubW91bnRXYWl0bGlzdChub2RlLCBwcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50V2FpdGxpc3ROb2Rlcy5zZXQobm9kZSwgcHJvcHMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy51bm1vdW50V2FpdGxpc3QgPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICB0aGlzLmNsZXJranMudW5tb3VudFdhaXRsaXN0KG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudFdhaXRsaXN0Tm9kZXMuZGVsZXRlKG5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5tb3VudFByaWNpbmdUYWJsZSA9IChub2RlLCBwcm9wcykgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICB0aGlzLmNsZXJranMubW91bnRQcmljaW5nVGFibGUobm9kZSwgcHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudFByaWNpbmdUYWJsZU5vZGVzLnNldChub2RlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnVubW91bnRQcmljaW5nVGFibGUgPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICB0aGlzLmNsZXJranMudW5tb3VudFByaWNpbmdUYWJsZShub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRQcmljaW5nVGFibGVOb2Rlcy5kZWxldGUobm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm1vdW50QXBpS2V5cyA9IChub2RlLCBwcm9wcykgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICB0aGlzLmNsZXJranMubW91bnRBcGlLZXlzKG5vZGUsIHByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRBcGlLZXlzTm9kZXMuc2V0KG5vZGUsIHByb3BzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMudW5tb3VudEFwaUtleXMgPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICB0aGlzLmNsZXJranMudW5tb3VudEFwaUtleXMobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50QXBpS2V5c05vZGVzLmRlbGV0ZShub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX19pbnRlcm5hbF9tb3VudE9BdXRoQ29uc2VudCA9IChub2RlLCBwcm9wcykgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICB0aGlzLmNsZXJranMuX19pbnRlcm5hbF9tb3VudE9BdXRoQ29uc2VudChub2RlLCBwcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50T0F1dGhDb25zZW50Tm9kZXMuc2V0KG5vZGUsIHByb3BzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX19pbnRlcm5hbF91bm1vdW50T0F1dGhDb25zZW50ID0gKG5vZGUpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgdGhpcy5jbGVya2pzLl9faW50ZXJuYWxfdW5tb3VudE9BdXRoQ29uc2VudChub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRPQXV0aENvbnNlbnROb2Rlcy5kZWxldGUobm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm1vdW50VGFza0Nob29zZU9yZ2FuaXphdGlvbiA9IChub2RlLCBwcm9wcykgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICB0aGlzLmNsZXJranMubW91bnRUYXNrQ2hvb3NlT3JnYW5pemF0aW9uKG5vZGUsIHByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRUYXNrQ2hvb3NlT3JnYW5pemF0aW9uTm9kZXMuc2V0KG5vZGUsIHByb3BzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMudW5tb3VudFRhc2tDaG9vc2VPcmdhbml6YXRpb24gPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICB0aGlzLmNsZXJranMudW5tb3VudFRhc2tDaG9vc2VPcmdhbml6YXRpb24obm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50VGFza0Nob29zZU9yZ2FuaXphdGlvbk5vZGVzLmRlbGV0ZShub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWRkTGlzdGVuZXIgPSAobGlzdGVuZXIpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xlcmtqcy5hZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9ICgpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgY29uc3QgbGlzdGVuZXJIYW5kbGVycyA9IHRoaXMucHJlbW91bnRBZGRMaXN0ZW5lckNhbGxzLmdldChsaXN0ZW5lcik7XG4gICAgICAgICAgaWYgKGxpc3RlbmVySGFuZGxlcnMpIHtcbiAgICAgICAgICAgIChfYSA9IGxpc3RlbmVySGFuZGxlcnMubmF0aXZlVW5zdWJzY3JpYmUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGxpc3RlbmVySGFuZGxlcnMpO1xuICAgICAgICAgICAgdGhpcy5wcmVtb3VudEFkZExpc3RlbmVyQ2FsbHMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJlbW91bnRBZGRMaXN0ZW5lckNhbGxzLnNldChsaXN0ZW5lciwgeyB1bnN1YnNjcmliZSwgbmF0aXZlVW5zdWJzY3JpYmU6IHZvaWQgMCB9KTtcbiAgICAgICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5uYXZpZ2F0ZSA9ICh0bykgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm5hdmlnYXRlKHRvKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHZvaWQgY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJuYXZpZ2F0ZVwiLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlZGlyZWN0V2l0aEF1dGggPSBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlZGlyZWN0V2l0aEF1dGgoLi4uYXJncyk7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJyZWRpcmVjdFdpdGhBdXRoXCIsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yZWRpcmVjdFRvU2lnbkluID0gYXN5bmMgKG9wdHMpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvU2lnbkluKG9wdHMpO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50TWV0aG9kQ2FsbHMuc2V0KFwicmVkaXJlY3RUb1NpZ25JblwiLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVkaXJlY3RUb1NpZ25VcCA9IGFzeW5jIChvcHRzKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVkaXJlY3RUb1NpZ25VcChvcHRzKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcInJlZGlyZWN0VG9TaWduVXBcIiwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlZGlyZWN0VG9Vc2VyUHJvZmlsZSA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvVXNlclByb2ZpbGUoKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcInJlZGlyZWN0VG9Vc2VyUHJvZmlsZVwiLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVkaXJlY3RUb0FmdGVyU2lnblVwID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlZGlyZWN0VG9BZnRlclNpZ25VcCgpO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50TWV0aG9kQ2FsbHMuc2V0KFwicmVkaXJlY3RUb0FmdGVyU2lnblVwXCIsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVkaXJlY3RUb0FmdGVyU2lnbkluID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlZGlyZWN0VG9BZnRlclNpZ25JbigpO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJyZWRpcmVjdFRvQWZ0ZXJTaWduSW5cIiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yZWRpcmVjdFRvQWZ0ZXJTaWduT3V0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlZGlyZWN0VG9BZnRlclNpZ25PdXQoKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50TWV0aG9kQ2FsbHMuc2V0KFwicmVkaXJlY3RUb0FmdGVyU2lnbk91dFwiLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlZGlyZWN0VG9Pcmdhbml6YXRpb25Qcm9maWxlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlZGlyZWN0VG9Pcmdhbml6YXRpb25Qcm9maWxlKCk7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJyZWRpcmVjdFRvT3JnYW5pemF0aW9uUHJvZmlsZVwiLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVkaXJlY3RUb0NyZWF0ZU9yZ2FuaXphdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvQ3JlYXRlT3JnYW5pemF0aW9uKCk7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJyZWRpcmVjdFRvQ3JlYXRlT3JnYW5pemF0aW9uXCIsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yZWRpcmVjdFRvV2FpdGxpc3QgPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVkaXJlY3RUb1dhaXRsaXN0KCk7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJyZWRpcmVjdFRvV2FpdGxpc3RcIiwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlZGlyZWN0VG9UYXNrcyA9IGFzeW5jIChvcHRzKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVkaXJlY3RUb1Rhc2tzKG9wdHMpO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50TWV0aG9kQ2FsbHMuc2V0KFwicmVkaXJlY3RUb1Rhc2tzXCIsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVSZWRpcmVjdENhbGxiYWNrID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiAoX2EyID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmhhbmRsZVJlZGlyZWN0Q2FsbGJhY2socGFyYW1zKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHZvaWQgKChfYSA9IGNhbGxiYWNrKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYXRjaCgoKSA9PiB7XG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJoYW5kbGVSZWRpcmVjdENhbGxiYWNrXCIsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlR29vZ2xlT25lVGFwQ2FsbGJhY2sgPSBhc3luYyAoc2lnbkluT3JVcCwgcGFyYW1zKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgcmV0dXJuIChfYTIgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaGFuZGxlR29vZ2xlT25lVGFwQ2FsbGJhY2soc2lnbkluT3JVcCwgcGFyYW1zKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHZvaWQgKChfYSA9IGNhbGxiYWNrKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYXRjaCgoKSA9PiB7XG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJoYW5kbGVHb29nbGVPbmVUYXBDYWxsYmFja1wiLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUVtYWlsTGlua1ZlcmlmaWNhdGlvbiA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5oYW5kbGVFbWFpbExpbmtWZXJpZmljYXRpb24ocGFyYW1zKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcImhhbmRsZUVtYWlsTGlua1ZlcmlmaWNhdGlvblwiLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmF1dGhlbnRpY2F0ZVdpdGhNZXRhbWFzayA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5hdXRoZW50aWNhdGVXaXRoTWV0YW1hc2socGFyYW1zKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcImF1dGhlbnRpY2F0ZVdpdGhNZXRhbWFza1wiLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmF1dGhlbnRpY2F0ZVdpdGhDb2luYmFzZVdhbGxldCA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5hdXRoZW50aWNhdGVXaXRoQ29pbmJhc2VXYWxsZXQocGFyYW1zKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcImF1dGhlbnRpY2F0ZVdpdGhDb2luYmFzZVdhbGxldFwiLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmF1dGhlbnRpY2F0ZVdpdGhCYXNlID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmF1dGhlbnRpY2F0ZVdpdGhCYXNlKHBhcmFtcyk7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJhdXRoZW50aWNhdGVXaXRoQmFzZVwiLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmF1dGhlbnRpY2F0ZVdpdGhPS1hXYWxsZXQgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYXV0aGVudGljYXRlV2l0aE9LWFdhbGxldChwYXJhbXMpO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50TWV0aG9kQ2FsbHMuc2V0KFwiYXV0aGVudGljYXRlV2l0aE9LWFdhbGxldFwiLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmF1dGhlbnRpY2F0ZVdpdGhXZWIzID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmF1dGhlbnRpY2F0ZVdpdGhXZWIzKHBhcmFtcyk7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJhdXRoZW50aWNhdGVXaXRoV2ViM1wiLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmF1dGhlbnRpY2F0ZVdpdGhHb29nbGVPbmVUYXAgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICBjb25zdCBjbGVya2pzID0gYXdhaXQgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9Jc29tb3JwaGljQ2xlcmtfaW5zdGFuY2VzLCB3YWl0Rm9yQ2xlcmtKU19mbikuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybiBjbGVya2pzLmF1dGhlbnRpY2F0ZVdpdGhHb29nbGVPbmVUYXAocGFyYW1zKTtcbiAgICB9O1xuICAgIHRoaXMuX19pbnRlcm5hbF9sb2FkU3RyaXBlSnMgPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjbGVya2pzID0gYXdhaXQgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9Jc29tb3JwaGljQ2xlcmtfaW5zdGFuY2VzLCB3YWl0Rm9yQ2xlcmtKU19mbikuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybiBjbGVya2pzLl9faW50ZXJuYWxfbG9hZFN0cmlwZUpzKCk7XG4gICAgfTtcbiAgICB0aGlzLmNyZWF0ZU9yZ2FuaXphdGlvbiA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jcmVhdGVPcmdhbml6YXRpb24ocGFyYW1zKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcImNyZWF0ZU9yZ2FuaXphdGlvblwiLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdldE9yZ2FuaXphdGlvbiA9IGFzeW5jIChvcmdhbml6YXRpb25JZCkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmdldE9yZ2FuaXphdGlvbihvcmdhbml6YXRpb25JZCk7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJnZXRPcmdhbml6YXRpb25cIiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5qb2luV2FpdGxpc3QgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2Euam9pbldhaXRsaXN0KHBhcmFtcyk7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiB0aGlzLmxvYWRlZCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJqb2luV2FpdGxpc3RcIiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zaWduT3V0ID0gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zaWduT3V0KC4uLmFyZ3MpO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50TWV0aG9kQ2FsbHMuc2V0KFwic2lnbk91dFwiLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB7IENsZXJrID0gbnVsbCwgcHVibGlzaGFibGVLZXkgfSA9IG9wdGlvbnMgfHwge307XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9wdWJsaXNoYWJsZUtleSwgcHVibGlzaGFibGVLZXkpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfcHJveHlVcmwsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucHJveHlVcmwpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZG9tYWluLCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRvbWFpbik7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLkNsZXJrID0gQ2xlcms7XG4gICAgdGhpcy5tb2RlID0gaW5Ccm93c2VyMigpID8gXCJicm93c2VyXCIgOiBcInNlcnZlclwiO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfc3RhdGVQcm94eSwgbmV3IFN0YXRlUHJveHkodGhpcykpO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnNka01ldGFkYXRhKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuc2RrTWV0YWRhdGEgPSBTREtfTUVUQURBVEE7XG4gICAgfVxuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfZXZlbnRCdXMpLmVtaXQoY2xlcmtFdmVudHMuU3RhdHVzLCBcImxvYWRpbmdcIik7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9ldmVudEJ1cykucHJpb3JpdGl6ZWRPbihjbGVya0V2ZW50cy5TdGF0dXMsIChzdGF0dXMpID0+IF9fcHJpdmF0ZVNldCh0aGlzLCBfc3RhdHVzLCBzdGF0dXMpKTtcbiAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9wdWJsaXNoYWJsZUtleSkpIHtcbiAgICAgIHZvaWQgdGhpcy5sb2FkQ2xlcmtKUygpO1xuICAgIH1cbiAgfVxuICBnZXQgcHVibGlzaGFibGVLZXkoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfcHVibGlzaGFibGVLZXkpO1xuICB9XG4gIGdldCBsb2FkZWQoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EubG9hZGVkKSB8fCBmYWxzZTtcbiAgfVxuICBnZXQgc3RhdHVzKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXRoaXMuY2xlcmtqcykge1xuICAgICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfc3RhdHVzKTtcbiAgICB9XG4gICAgcmV0dXJuICgoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zdGF0dXMpIHx8IC8qKlxuICAgICAqIFN1cHBvcnQgb2xkZXIgY2xlcmstanMgdmVyc2lvbnMuXG4gICAgICogSWYgY2xlcmstanMgaXMgYXZhaWxhYmxlIGJ1dCBgLnN0YXR1c2AgaXMgbWlzc2luZyBpdCB3ZSBuZWVkIHRvIGZhbGxiYWNrIHRvIGAubG9hZGVkYC5cbiAgICAgKiBTaW5jZSBcImRlZ3JhZGVkXCIgYW4gXCJlcnJvclwiIGRpZCBub3QgZXhpc3QgYmVmb3JlLFxuICAgICAqIG1hcCBcImxvYWRlZFwiIHRvIFwicmVhZHlcIiBhbmQgXCJub3QgbG9hZGVkXCIgdG8gXCJsb2FkaW5nXCIuXG4gICAgICovXG4gICAgKHRoaXMuY2xlcmtqcy5sb2FkZWQgPyBcInJlYWR5XCIgOiBcImxvYWRpbmdcIik7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2Uob3B0aW9ucykge1xuICAgIGlmICghaW5Ccm93c2VyMigpIHx8ICFfX3ByaXZhdGVHZXQodGhpcywgX2luc3RhbmNlKSB8fCBvcHRpb25zLkNsZXJrICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5zdGFuY2UpLkNsZXJrICE9PSBvcHRpb25zLkNsZXJrIHx8IC8vIEFsbG93IGhvdCBzd2FwcGluZyBQS3Mgb24gdGhlIGNsaWVudFxuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5zdGFuY2UpLnB1Ymxpc2hhYmxlS2V5ICE9PSBvcHRpb25zLnB1Ymxpc2hhYmxlS2V5KSB7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2luc3RhbmNlLCBuZXcgX0lzb21vcnBoaWNDbGVyayhvcHRpb25zKSk7XG4gICAgfVxuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2luc3RhbmNlKTtcbiAgfVxuICBzdGF0aWMgY2xlYXJJbnN0YW5jZSgpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2luc3RhbmNlLCBudWxsKTtcbiAgfVxuICBnZXQgZG9tYWluKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhhbmRsZVZhbHVlT3JGbihfX3ByaXZhdGVHZXQodGhpcywgX2RvbWFpbiksIG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpLCBcIlwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBfX3ByaXZhdGVHZXQodGhpcywgX2RvbWFpbikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGVycm9yVGhyb3dlci50aHJvdyh1bnN1cHBvcnRlZE5vbkJyb3dzZXJEb21haW5PclByb3h5VXJsRnVuY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9kb21haW4pIHx8IFwiXCI7XG4gIH1cbiAgZ2V0IHByb3h5VXJsKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhhbmRsZVZhbHVlT3JGbihfX3ByaXZhdGVHZXQodGhpcywgX3Byb3h5VXJsKSwgbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZiksIFwiXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIF9fcHJpdmF0ZUdldCh0aGlzLCBfcHJveHlVcmwpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBlcnJvclRocm93ZXIudGhyb3codW5zdXBwb3J0ZWROb25Ccm93c2VyRG9tYWluT3JQcm94eVVybEZ1bmN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfcHJveHlVcmwpIHx8IFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIEFjY2Vzc2VzIHByaXZhdGUgb3B0aW9ucyBmcm9tIHRoZSBgQ2xlcmtgIGluc3RhbmNlIGFuZCBkZWZhdWx0cyB0b1xuICAgKiBgSXNvbW9ycGhpY0NsZXJrYCBvcHRpb25zIHdoZW4gaW4gU1NSIGNvbnRleHQuXG4gICAqICBAaW50ZXJuYWxcbiAgICovXG4gIF9faW50ZXJuYWxfZ2V0T3B0aW9uKGtleSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuICgoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5fX2ludGVybmFsX2dldE9wdGlvbikgPyAoX2IgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5fX2ludGVybmFsX2dldE9wdGlvbihrZXkpIDogdGhpcy5vcHRpb25zW2tleV07XG4gIH1cbiAgZ2V0IHNka01ldGFkYXRhKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNka01ldGFkYXRhKSB8fCB0aGlzLm9wdGlvbnMuc2RrTWV0YWRhdGEgfHwgdm9pZCAwO1xuICB9XG4gIGdldCBpbnN0YW5jZVR5cGUoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pbnN0YW5jZVR5cGU7XG4gIH1cbiAgZ2V0IGZyb250ZW5kQXBpKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZyb250ZW5kQXBpKSB8fCBcIlwiO1xuICB9XG4gIGdldCBpc1N0YW5kYXJkQnJvd3NlcigpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pc1N0YW5kYXJkQnJvd3NlcikgfHwgdGhpcy5vcHRpb25zLnN0YW5kYXJkQnJvd3NlciB8fCBmYWxzZTtcbiAgfVxuICBnZXQgaXNTYXRlbGxpdGUoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gaGFuZGxlVmFsdWVPckZuKHRoaXMub3B0aW9ucy5pc1NhdGVsbGl0ZSwgbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZiksIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuaXNTYXRlbGxpdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGVycm9yVGhyb3dlci50aHJvdyh1bnN1cHBvcnRlZE5vbkJyb3dzZXJEb21haW5PclByb3h5VXJsRnVuY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgbG9hZENsZXJrSlMoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0aGlzLm1vZGUgIT09IFwiYnJvd3NlclwiIHx8IHRoaXMubG9hZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB3aW5kb3cuX19jbGVya19wdWJsaXNoYWJsZV9rZXkgPSBfX3ByaXZhdGVHZXQodGhpcywgX3B1Ymxpc2hhYmxlS2V5KTtcbiAgICAgIHdpbmRvdy5fX2NsZXJrX3Byb3h5X3VybCA9IHRoaXMucHJveHlVcmw7XG4gICAgICB3aW5kb3cuX19jbGVya19kb21haW4gPSB0aGlzLmRvbWFpbjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLkNsZXJrKSB7XG4gICAgICAgIGxldCBjO1xuICAgICAgICBpZiAoaXNDb25zdHJ1Y3Rvcih0aGlzLkNsZXJrKSkge1xuICAgICAgICAgIGMgPSBuZXcgdGhpcy5DbGVyayhfX3ByaXZhdGVHZXQodGhpcywgX3B1Ymxpc2hhYmxlS2V5KSwge1xuICAgICAgICAgICAgcHJveHlVcmw6IHRoaXMucHJveHlVcmwsXG4gICAgICAgICAgICBkb21haW46IHRoaXMuZG9tYWluXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5iZWZvcmVMb2FkKGMpO1xuICAgICAgICAgIGF3YWl0IGMubG9hZCh0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGMgPSB0aGlzLkNsZXJrO1xuICAgICAgICAgIGlmICghYy5sb2FkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYmVmb3JlTG9hZChjKTtcbiAgICAgICAgICAgIGF3YWl0IGMubG9hZCh0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnbG9iYWwuQ2xlcmsgPSBjO1xuICAgICAgfSBlbHNlIGlmICghX19CVUlMRF9ESVNBQkxFX1JIQ19fKSB7XG4gICAgICAgIGlmICghZ2xvYmFsLkNsZXJrKSB7XG4gICAgICAgICAgYXdhaXQgbG9hZENsZXJrSnNTY3JpcHQoe1xuICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgcHVibGlzaGFibGVLZXk6IF9fcHJpdmF0ZUdldCh0aGlzLCBfcHVibGlzaGFibGVLZXkpLFxuICAgICAgICAgICAgcHJveHlVcmw6IHRoaXMucHJveHlVcmwsXG4gICAgICAgICAgICBkb21haW46IHRoaXMuZG9tYWluLFxuICAgICAgICAgICAgbm9uY2U6IHRoaXMub3B0aW9ucy5ub25jZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZ2xvYmFsLkNsZXJrKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRvd25sb2FkIGxhdGVzdCBDbGVya0pTLiBDb250YWN0IHN1cHBvcnRAY2xlcmsuY29tLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJlZm9yZUxvYWQoZ2xvYmFsLkNsZXJrKTtcbiAgICAgICAgYXdhaXQgZ2xvYmFsLkNsZXJrLmxvYWQodGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICgoX2EgPSBnbG9iYWwuQ2xlcmspID09IG51bGwgPyB2b2lkIDAgOiBfYS5sb2FkZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHlkcmF0ZUNsZXJrSlMoZ2xvYmFsLkNsZXJrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gZXJyO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9ldmVudEJ1cykuZW1pdChjbGVya0V2ZW50cy5TdGF0dXMsIFwiZXJyb3JcIik7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yLnN0YWNrIHx8IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBnZXQgdmVyc2lvbigpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnZlcnNpb247XG4gIH1cbiAgZ2V0IGNsaWVudCgpIHtcbiAgICBpZiAodGhpcy5jbGVya2pzKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbGVya2pzLmNsaWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgZ2V0IHNlc3Npb24oKSB7XG4gICAgaWYgKHRoaXMuY2xlcmtqcykge1xuICAgICAgcmV0dXJuIHRoaXMuY2xlcmtqcy5zZXNzaW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBnZXQgdXNlcigpIHtcbiAgICBpZiAodGhpcy5jbGVya2pzKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbGVya2pzLnVzZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGdldCBvcmdhbml6YXRpb24oKSB7XG4gICAgaWYgKHRoaXMuY2xlcmtqcykge1xuICAgICAgcmV0dXJuIHRoaXMuY2xlcmtqcy5vcmdhbml6YXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGdldCB0ZWxlbWV0cnkoKSB7XG4gICAgaWYgKHRoaXMuY2xlcmtqcykge1xuICAgICAgcmV0dXJuIHRoaXMuY2xlcmtqcy50ZWxlbWV0cnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGdldCBfX3Vuc3RhYmxlX19lbnZpcm9ubWVudCgpIHtcbiAgICBpZiAodGhpcy5jbGVya2pzKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbGVya2pzLl9fdW5zdGFibGVfX2Vudmlyb25tZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBnZXQgaXNTaWduZWRJbigpIHtcbiAgICBpZiAodGhpcy5jbGVya2pzKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbGVya2pzLmlzU2lnbmVkSW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZ2V0IGJpbGxpbmcoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5iaWxsaW5nO1xuICB9XG4gIGdldCBfX2ludGVybmFsX3N0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLmxvYWRlZCAmJiB0aGlzLmNsZXJranMgPyB0aGlzLmNsZXJranMuX19pbnRlcm5hbF9zdGF0ZSA6IF9fcHJpdmF0ZUdldCh0aGlzLCBfc3RhdGVQcm94eSk7XG4gIH1cbiAgZ2V0IGFwaUtleXMoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5hcGlLZXlzO1xuICB9XG4gIF9fdW5zdGFibGVfX3NldEVudmlyb25tZW50KC4uLmFyZ3MpIHtcbiAgICBpZiAodGhpcy5jbGVya2pzICYmIFwiX191bnN0YWJsZV9fc2V0RW52aXJvbm1lbnRcIiBpbiB0aGlzLmNsZXJranMpIHtcbiAgICAgIHRoaXMuY2xlcmtqcy5fX3Vuc3RhYmxlX19zZXRFbnZpcm9ubWVudChhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbn07XG5fc3RhdHVzID0gbmV3IFdlYWtNYXAoKTtcbl9kb21haW4gPSBuZXcgV2Vha01hcCgpO1xuX3Byb3h5VXJsID0gbmV3IFdlYWtNYXAoKTtcbl9wdWJsaXNoYWJsZUtleSA9IG5ldyBXZWFrTWFwKCk7XG5fZXZlbnRCdXMgPSBuZXcgV2Vha01hcCgpO1xuX3N0YXRlUHJveHkgPSBuZXcgV2Vha01hcCgpO1xuX2luc3RhbmNlID0gbmV3IFdlYWtNYXAoKTtcbl9Jc29tb3JwaGljQ2xlcmtfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKTtcbndhaXRGb3JDbGVya0pTX2ZuID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHRoaXMuYWRkT25Mb2FkZWQoKCkgPT4gcmVzb2x2ZSh0aGlzLmNsZXJranMpKTtcbiAgfSk7XG59O1xuX19wcml2YXRlQWRkKF9Jc29tb3JwaGljQ2xlcmssIF9pbnN0YW5jZSk7XG52YXIgSXNvbW9ycGhpY0NsZXJrID0gX0lzb21vcnBoaWNDbGVyaztcblxuLy8gc3JjL2NvbnRleHRzL0NsZXJrQ29udGV4dFByb3ZpZGVyLnRzeFxuZnVuY3Rpb24gQ2xlcmtDb250ZXh0UHJvdmlkZXIocHJvcHMpIHtcbiAgY29uc3QgeyBpc29tb3JwaGljQ2xlcmtPcHRpb25zLCBpbml0aWFsU3RhdGUsIGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgY29uc3QgeyBpc29tb3JwaGljQ2xlcms6IGNsZXJrLCBjbGVya1N0YXR1cyB9ID0gdXNlTG9hZGVkSXNvbW9ycGhpY0NsZXJrKGlzb21vcnBoaWNDbGVya09wdGlvbnMpO1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0NS51c2VTdGF0ZSh7XG4gICAgY2xpZW50OiBjbGVyay5jbGllbnQsXG4gICAgc2Vzc2lvbjogY2xlcmsuc2Vzc2lvbixcbiAgICB1c2VyOiBjbGVyay51c2VyLFxuICAgIG9yZ2FuaXphdGlvbjogY2xlcmsub3JnYW5pemF0aW9uXG4gIH0pO1xuICBSZWFjdDUudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gY2xlcmsuYWRkTGlzdGVuZXIoKGUpID0+IHNldFN0YXRlKHsgLi4uZSB9KSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgZGVyaXZlZFN0YXRlID0gZGVyaXZlU3RhdGUoY2xlcmsubG9hZGVkLCBzdGF0ZSwgaW5pdGlhbFN0YXRlKTtcbiAgY29uc3QgY2xlcmtDdHggPSBSZWFjdDUudXNlTWVtbyhcbiAgICAoKSA9PiAoeyB2YWx1ZTogY2xlcmsgfSksXG4gICAgW1xuICAgICAgLy8gT25seSB1cGRhdGUgdGhlIGNsZXJrIHJlZmVyZW5jZSBvbiBzdGF0dXMgY2hhbmdlXG4gICAgICBjbGVya1N0YXR1c1xuICAgIF1cbiAgKTtcbiAgY29uc3QgY2xpZW50Q3R4ID0gUmVhY3Q1LnVzZU1lbW8oKCkgPT4gKHsgdmFsdWU6IHN0YXRlLmNsaWVudCB9KSwgW3N0YXRlLmNsaWVudF0pO1xuICBjb25zdCB7XG4gICAgc2Vzc2lvbklkLFxuICAgIHNlc3Npb25TdGF0dXMsXG4gICAgc2Vzc2lvbkNsYWltcyxcbiAgICBzZXNzaW9uLFxuICAgIHVzZXJJZCxcbiAgICB1c2VyLFxuICAgIG9yZ0lkLFxuICAgIGFjdG9yLFxuICAgIG9yZ2FuaXphdGlvbixcbiAgICBvcmdSb2xlLFxuICAgIG9yZ1NsdWcsXG4gICAgb3JnUGVybWlzc2lvbnMsXG4gICAgZmFjdG9yVmVyaWZpY2F0aW9uQWdlXG4gIH0gPSBkZXJpdmVkU3RhdGU7XG4gIGNvbnN0IGF1dGhDdHggPSBSZWFjdDUudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSB7XG4gICAgICBzZXNzaW9uSWQsXG4gICAgICBzZXNzaW9uU3RhdHVzLFxuICAgICAgc2Vzc2lvbkNsYWltcyxcbiAgICAgIHVzZXJJZCxcbiAgICAgIGFjdG9yLFxuICAgICAgb3JnSWQsXG4gICAgICBvcmdSb2xlLFxuICAgICAgb3JnU2x1ZyxcbiAgICAgIG9yZ1Blcm1pc3Npb25zLFxuICAgICAgZmFjdG9yVmVyaWZpY2F0aW9uQWdlXG4gICAgfTtcbiAgICByZXR1cm4geyB2YWx1ZSB9O1xuICB9LCBbc2Vzc2lvbklkLCBzZXNzaW9uU3RhdHVzLCB1c2VySWQsIGFjdG9yLCBvcmdJZCwgb3JnUm9sZSwgb3JnU2x1ZywgZmFjdG9yVmVyaWZpY2F0aW9uQWdlLCBzZXNzaW9uQ2xhaW1zID09IG51bGwgPyB2b2lkIDAgOiBzZXNzaW9uQ2xhaW1zLl9fcmF3XSk7XG4gIGNvbnN0IHNlc3Npb25DdHggPSBSZWFjdDUudXNlTWVtbygoKSA9PiAoeyB2YWx1ZTogc2Vzc2lvbiB9KSwgW3Nlc3Npb25JZCwgc2Vzc2lvbl0pO1xuICBjb25zdCB1c2VyQ3R4ID0gUmVhY3Q1LnVzZU1lbW8oKCkgPT4gKHsgdmFsdWU6IHVzZXIgfSksIFt1c2VySWQsIHVzZXJdKTtcbiAgY29uc3Qgb3JnYW5pemF0aW9uQ3R4ID0gUmVhY3Q1LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0ge1xuICAgICAgb3JnYW5pemF0aW9uXG4gICAgfTtcbiAgICByZXR1cm4geyB2YWx1ZSB9O1xuICB9LCBbb3JnSWQsIG9yZ2FuaXphdGlvbl0pO1xuICByZXR1cm4gKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdmFsdWUgcGFzc2VkIGlzIG9mIHR5cGUgSXNvbW9ycGhpY0NsZXJrIHdoZXJlIHRoZSBjb250ZXh0IGV4cGVjdHMgTG9hZGVkQ2xlcmtcbiAgICAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoSXNvbW9ycGhpY0NsZXJrQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY2xlcmtDdHggfSwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KENsaWVudENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNsaWVudEN0eCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoU2Vzc2lvbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHNlc3Npb25DdHggfSwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KE9yZ2FuaXphdGlvblByb3ZpZGVyLCB7IC4uLm9yZ2FuaXphdGlvbkN0eC52YWx1ZSB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoQXV0aENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGF1dGhDdHggfSwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFVzZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB1c2VyQ3R4IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcbiAgICAgIENoZWNrb3V0UHJvdmlkZXIsXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlblxuICAgICkpKSkpKSlcbiAgKTtcbn1cbnZhciB1c2VMb2FkZWRJc29tb3JwaGljQ2xlcmsgPSAob3B0aW9ucykgPT4ge1xuICBjb25zdCBpc29tb3JwaGljQ2xlcmtSZWYgPSBSZWFjdDUudXNlUmVmKElzb21vcnBoaWNDbGVyay5nZXRPckNyZWF0ZUluc3RhbmNlKG9wdGlvbnMpKTtcbiAgY29uc3QgW2NsZXJrU3RhdHVzLCBzZXRDbGVya1N0YXR1c10gPSBSZWFjdDUudXNlU3RhdGUoaXNvbW9ycGhpY0NsZXJrUmVmLmN1cnJlbnQuc3RhdHVzKTtcbiAgUmVhY3Q1LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdm9pZCBpc29tb3JwaGljQ2xlcmtSZWYuY3VycmVudC5fX3Vuc3RhYmxlX191cGRhdGVQcm9wcyh7IGFwcGVhcmFuY2U6IG9wdGlvbnMuYXBwZWFyYW5jZSB9KTtcbiAgfSwgW29wdGlvbnMuYXBwZWFyYW5jZV0pO1xuICBSZWFjdDUudXNlRWZmZWN0KCgpID0+IHtcbiAgICB2b2lkIGlzb21vcnBoaWNDbGVya1JlZi5jdXJyZW50Ll9fdW5zdGFibGVfX3VwZGF0ZVByb3BzKHsgb3B0aW9ucyB9KTtcbiAgfSwgW29wdGlvbnMubG9jYWxpemF0aW9uXSk7XG4gIFJlYWN0NS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlzb21vcnBoaWNDbGVya1JlZi5jdXJyZW50Lm9uKFwic3RhdHVzXCIsIHNldENsZXJrU3RhdHVzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGlzb21vcnBoaWNDbGVya1JlZi5jdXJyZW50KSB7XG4gICAgICAgIGlzb21vcnBoaWNDbGVya1JlZi5jdXJyZW50Lm9mZihcInN0YXR1c1wiLCBzZXRDbGVya1N0YXR1cyk7XG4gICAgICB9XG4gICAgICBJc29tb3JwaGljQ2xlcmsuY2xlYXJJbnN0YW5jZSgpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHsgaXNvbW9ycGhpY0NsZXJrOiBpc29tb3JwaGljQ2xlcmtSZWYuY3VycmVudCwgY2xlcmtTdGF0dXMgfTtcbn07XG5cbi8vIHNyYy9jb250ZXh0cy9DbGVya1Byb3ZpZGVyLnRzeFxuZnVuY3Rpb24gQ2xlcmtQcm92aWRlckJhc2UocHJvcHMpIHtcbiAgY29uc3QgeyBpbml0aWFsU3RhdGUsIGNoaWxkcmVuLCBfX2ludGVybmFsX2J5cGFzc01pc3NpbmdQdWJsaXNoYWJsZUtleSwgLi4ucmVzdElzb21vcnBoaWNDbGVya09wdGlvbnMgfSA9IHByb3BzO1xuICBjb25zdCB7IHB1Ymxpc2hhYmxlS2V5ID0gXCJcIiwgQ2xlcms6IHVzZXJJbml0aWFsaXNlZENsZXJrIH0gPSByZXN0SXNvbW9ycGhpY0NsZXJrT3B0aW9ucztcbiAgaWYgKCF1c2VySW5pdGlhbGlzZWRDbGVyayAmJiAhX19pbnRlcm5hbF9ieXBhc3NNaXNzaW5nUHVibGlzaGFibGVLZXkpIHtcbiAgICBpZiAoIXB1Ymxpc2hhYmxlS2V5KSB7XG4gICAgICBlcnJvclRocm93ZXIudGhyb3dNaXNzaW5nUHVibGlzaGFibGVLZXlFcnJvcigpO1xuICAgIH0gZWxzZSBpZiAocHVibGlzaGFibGVLZXkgJiYgIWlzUHVibGlzaGFibGVLZXkocHVibGlzaGFibGVLZXkpKSB7XG4gICAgICBlcnJvclRocm93ZXIudGhyb3dJbnZhbGlkUHVibGlzaGFibGVLZXlFcnJvcih7IGtleTogcHVibGlzaGFibGVLZXkgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q2LmNyZWF0ZUVsZW1lbnQoXG4gICAgQ2xlcmtDb250ZXh0UHJvdmlkZXIsXG4gICAge1xuICAgICAgaW5pdGlhbFN0YXRlLFxuICAgICAgaXNvbW9ycGhpY0NsZXJrT3B0aW9uczogcmVzdElzb21vcnBoaWNDbGVya09wdGlvbnNcbiAgICB9LFxuICAgIGNoaWxkcmVuXG4gICk7XG59XG52YXIgQ2xlcmtQcm92aWRlciA9IHdpdGhNYXhBbGxvd2VkSW5zdGFuY2VzR3VhcmQoQ2xlcmtQcm92aWRlckJhc2UsIFwiQ2xlcmtQcm92aWRlclwiLCBtdWx0aXBsZUNsZXJrUHJvdmlkZXJzRXJyb3IpO1xuQ2xlcmtQcm92aWRlci5kaXNwbGF5TmFtZSA9IFwiQ2xlcmtQcm92aWRlclwiO1xuXG4vLyBzcmMvaW5kZXgudHNcbnNldEVycm9yVGhyb3dlck9wdGlvbnMoeyBwYWNrYWdlTmFtZTogXCJAY2xlcmsvY2xlcmstcmVhY3RcIiB9KTtcbnNldENsZXJrSnNMb2FkaW5nRXJyb3JQYWNrYWdlTmFtZShcIkBjbGVyay9jbGVyay1yZWFjdFwiKTtcbmV4cG9ydCB7XG4gIEFQSUtleXMsXG4gIEF1dGhlbnRpY2F0ZVdpdGhSZWRpcmVjdENhbGxiYWNrLFxuICBDbGVya0RlZ3JhZGVkLFxuICBDbGVya0ZhaWxlZCxcbiAgQ2xlcmtMb2FkZWQsXG4gIENsZXJrTG9hZGluZyxcbiAgQ2xlcmtQcm92aWRlcixcbiAgQ3JlYXRlT3JnYW5pemF0aW9uLFxuICBHb29nbGVPbmVUYXAsXG4gIE9yZ2FuaXphdGlvbkxpc3QsXG4gIE9yZ2FuaXphdGlvblByb2ZpbGUsXG4gIE9yZ2FuaXphdGlvblN3aXRjaGVyLFxuICBQcmljaW5nVGFibGUsXG4gIFByb3RlY3QsXG4gIFJlZGlyZWN0VG9DcmVhdGVPcmdhbml6YXRpb24sXG4gIFJlZGlyZWN0VG9Pcmdhbml6YXRpb25Qcm9maWxlLFxuICBSZWRpcmVjdFRvU2lnbkluLFxuICBSZWRpcmVjdFRvU2lnblVwLFxuICBSZWRpcmVjdFRvVGFza3MsXG4gIFJlZGlyZWN0VG9Vc2VyUHJvZmlsZSxcbiAgU2lnbkluLFxuICBTaWduSW5CdXR0b24sXG4gIFNpZ25JbldpdGhNZXRhbWFza0J1dHRvbixcbiAgU2lnbk91dEJ1dHRvbixcbiAgU2lnblVwLFxuICBTaWduVXBCdXR0b24sXG4gIFNpZ25lZEluLFxuICBTaWduZWRPdXQsXG4gIFRhc2tDaG9vc2VPcmdhbml6YXRpb24sXG4gIFVzZXJBdmF0YXIsXG4gIFVzZXJCdXR0b24sXG4gIFVzZXJQcm9maWxlLFxuICBXYWl0bGlzdCxcbiAgX19leHBlcmltZW50YWxfQ2hlY2tvdXRQcm92aWRlcixcbiAgX19leHBlcmltZW50YWxfUGF5bWVudEVsZW1lbnQsXG4gIF9fZXhwZXJpbWVudGFsX1BheW1lbnRFbGVtZW50UHJvdmlkZXIsXG4gIF9fZXhwZXJpbWVudGFsX3VzZUNoZWNrb3V0LFxuICBfX2V4cGVyaW1lbnRhbF91c2VQYXltZW50RWxlbWVudCxcbiAgdXNlQXV0aCxcbiAgdXNlQ2xlcmssXG4gIHVzZUVtYWlsTGluayxcbiAgdXNlT3JnYW5pemF0aW9uLFxuICB1c2VPcmdhbml6YXRpb25MaXN0LFxuICB1c2VSZXZlcmlmaWNhdGlvbixcbiAgdXNlU2Vzc2lvbixcbiAgdXNlU2Vzc2lvbkxpc3QsXG4gIHVzZVNpZ25JbixcbiAgdXNlU2lnblVwLFxuICB1c2VVc2VyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/authorization.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/authorization.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCheckAuthorization: () => (/* reexport safe */ _chunk_3CN5LOSN_mjs__WEBPACK_IMPORTED_MODULE_0__.createCheckAuthorization),\n/* harmony export */   resolveAuthState: () => (/* reexport safe */ _chunk_3CN5LOSN_mjs__WEBPACK_IMPORTED_MODULE_0__.resolveAuthState),\n/* harmony export */   splitByScope: () => (/* reexport safe */ _chunk_3CN5LOSN_mjs__WEBPACK_IMPORTED_MODULE_0__.splitByScope),\n/* harmony export */   validateReverificationConfig: () => (/* reexport safe */ _chunk_3CN5LOSN_mjs__WEBPACK_IMPORTED_MODULE_0__.validateReverificationConfig)\n/* harmony export */ });\n/* harmony import */ var _chunk_3CN5LOSN_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-3CN5LOSN.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-3CN5LOSN.mjs\");\n/* harmony import */ var _chunk_IEP6GGEX_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-IEP6GGEX.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IEP6GGEX.mjs\");\n\n\n\n//# sourceMappingURL=authorization.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvYXV0aG9yaXphdGlvbi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBSzhCO0FBQ0E7QUFNNUI7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2lzaGFxYmVsbG8vV2Vic2l0ZS9oYXZlbnJpZGVfZnVsbF9hcHAvbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9hdXRob3JpemF0aW9uLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBjcmVhdGVDaGVja0F1dGhvcml6YXRpb24sXG4gIHJlc29sdmVBdXRoU3RhdGUsXG4gIHNwbGl0QnlTY29wZSxcbiAgdmFsaWRhdGVSZXZlcmlmaWNhdGlvbkNvbmZpZ1xufSBmcm9tIFwiLi9jaHVuay0zQ041TE9TTi5tanNcIjtcbmltcG9ydCBcIi4vY2h1bmstSUVQNkdHRVgubWpzXCI7XG5leHBvcnQge1xuICBjcmVhdGVDaGVja0F1dGhvcml6YXRpb24sXG4gIHJlc29sdmVBdXRoU3RhdGUsXG4gIHNwbGl0QnlTY29wZSxcbiAgdmFsaWRhdGVSZXZlcmlmaWNhdGlvbkNvbmZpZ1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGhvcml6YXRpb24ubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/authorization.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/browser.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/browser.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   inBrowser: () => (/* reexport safe */ _chunk_JKSAJ6AV_mjs__WEBPACK_IMPORTED_MODULE_0__.inBrowser),\n/* harmony export */   isBrowserOnline: () => (/* reexport safe */ _chunk_JKSAJ6AV_mjs__WEBPACK_IMPORTED_MODULE_0__.isBrowserOnline),\n/* harmony export */   isValidBrowser: () => (/* reexport safe */ _chunk_JKSAJ6AV_mjs__WEBPACK_IMPORTED_MODULE_0__.isValidBrowser),\n/* harmony export */   isValidBrowserOnline: () => (/* reexport safe */ _chunk_JKSAJ6AV_mjs__WEBPACK_IMPORTED_MODULE_0__.isValidBrowserOnline),\n/* harmony export */   userAgentIsRobot: () => (/* reexport safe */ _chunk_JKSAJ6AV_mjs__WEBPACK_IMPORTED_MODULE_0__.userAgentIsRobot)\n/* harmony export */ });\n/* harmony import */ var _chunk_JKSAJ6AV_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-JKSAJ6AV.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-JKSAJ6AV.mjs\");\n/* harmony import */ var _chunk_IEP6GGEX_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-IEP6GGEX.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IEP6GGEX.mjs\");\n\n\n\n//# sourceMappingURL=browser.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvYnJvd3Nlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQU04QjtBQUNBO0FBTzVCO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvYnJvd3Nlci5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgaW5Ccm93c2VyLFxuICBpc0Jyb3dzZXJPbmxpbmUsXG4gIGlzVmFsaWRCcm93c2VyLFxuICBpc1ZhbGlkQnJvd3Nlck9ubGluZSxcbiAgdXNlckFnZW50SXNSb2JvdFxufSBmcm9tIFwiLi9jaHVuay1KS1NBSjZBVi5tanNcIjtcbmltcG9ydCBcIi4vY2h1bmstSUVQNkdHRVgubWpzXCI7XG5leHBvcnQge1xuICBpbkJyb3dzZXIsXG4gIGlzQnJvd3Nlck9ubGluZSxcbiAgaXNWYWxpZEJyb3dzZXIsXG4gIGlzVmFsaWRCcm93c2VyT25saW5lLFxuICB1c2VyQWdlbnRJc1JvYm90XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlci5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/browser.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-3CN5LOSN.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-3CN5LOSN.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCheckAuthorization: () => (/* binding */ createCheckAuthorization),\n/* harmony export */   resolveAuthState: () => (/* binding */ resolveAuthState),\n/* harmony export */   splitByScope: () => (/* binding */ splitByScope),\n/* harmony export */   validateReverificationConfig: () => (/* binding */ validateReverificationConfig)\n/* harmony export */ });\n// src/authorization.ts\nvar TYPES_TO_OBJECTS = {\n  strict_mfa: {\n    afterMinutes: 10,\n    level: \"multi_factor\"\n  },\n  strict: {\n    afterMinutes: 10,\n    level: \"second_factor\"\n  },\n  moderate: {\n    afterMinutes: 60,\n    level: \"second_factor\"\n  },\n  lax: {\n    afterMinutes: 1440,\n    level: \"second_factor\"\n  }\n};\nvar ALLOWED_LEVELS = /* @__PURE__ */ new Set([\"first_factor\", \"second_factor\", \"multi_factor\"]);\nvar ALLOWED_TYPES = /* @__PURE__ */ new Set([\"strict_mfa\", \"strict\", \"moderate\", \"lax\"]);\nvar isValidMaxAge = (maxAge) => typeof maxAge === \"number\" && maxAge > 0;\nvar isValidLevel = (level) => ALLOWED_LEVELS.has(level);\nvar isValidVerificationType = (type) => ALLOWED_TYPES.has(type);\nvar prefixWithOrg = (value) => value.replace(/^(org:)*/, \"org:\");\nvar checkOrgAuthorization = (params, options) => {\n  const { orgId, orgRole, orgPermissions } = options;\n  if (!params.role && !params.permission) {\n    return null;\n  }\n  if (!orgId || !orgRole || !orgPermissions) {\n    return null;\n  }\n  if (params.permission) {\n    return orgPermissions.includes(prefixWithOrg(params.permission));\n  }\n  if (params.role) {\n    return prefixWithOrg(orgRole) === prefixWithOrg(params.role);\n  }\n  return null;\n};\nvar checkForFeatureOrPlan = (claim, featureOrPlan) => {\n  const { org: orgFeatures, user: userFeatures } = splitByScope(claim);\n  const [scope, _id] = featureOrPlan.split(\":\");\n  const id = _id || scope;\n  if (scope === \"org\") {\n    return orgFeatures.includes(id);\n  } else if (scope === \"user\") {\n    return userFeatures.includes(id);\n  } else {\n    return [...orgFeatures, ...userFeatures].includes(id);\n  }\n};\nvar checkBillingAuthorization = (params, options) => {\n  const { features, plans } = options;\n  if (params.feature && features) {\n    return checkForFeatureOrPlan(features, params.feature);\n  }\n  if (params.plan && plans) {\n    return checkForFeatureOrPlan(plans, params.plan);\n  }\n  return null;\n};\nvar splitByScope = (fea) => {\n  const features = fea ? fea.split(\",\").map((f) => f.trim()) : [];\n  return {\n    org: features.filter((f) => f.split(\":\")[0].includes(\"o\")).map((f) => f.split(\":\")[1]),\n    user: features.filter((f) => f.split(\":\")[0].includes(\"u\")).map((f) => f.split(\":\")[1])\n  };\n};\nvar validateReverificationConfig = (config) => {\n  if (!config) {\n    return false;\n  }\n  const convertConfigToObject = (config2) => {\n    if (typeof config2 === \"string\") {\n      return TYPES_TO_OBJECTS[config2];\n    }\n    return config2;\n  };\n  const isValidStringValue = typeof config === \"string\" && isValidVerificationType(config);\n  const isValidObjectValue = typeof config === \"object\" && isValidLevel(config.level) && isValidMaxAge(config.afterMinutes);\n  if (isValidStringValue || isValidObjectValue) {\n    return convertConfigToObject.bind(null, config);\n  }\n  return false;\n};\nvar checkReverificationAuthorization = (params, { factorVerificationAge }) => {\n  if (!params.reverification || !factorVerificationAge) {\n    return null;\n  }\n  const isValidReverification = validateReverificationConfig(params.reverification);\n  if (!isValidReverification) {\n    return null;\n  }\n  const { level, afterMinutes } = isValidReverification();\n  const [factor1Age, factor2Age] = factorVerificationAge;\n  const isValidFactor1 = factor1Age !== -1 ? afterMinutes > factor1Age : null;\n  const isValidFactor2 = factor2Age !== -1 ? afterMinutes > factor2Age : null;\n  switch (level) {\n    case \"first_factor\":\n      return isValidFactor1;\n    case \"second_factor\":\n      return factor2Age !== -1 ? isValidFactor2 : isValidFactor1;\n    case \"multi_factor\":\n      return factor2Age === -1 ? isValidFactor1 : isValidFactor1 && isValidFactor2;\n  }\n};\nvar createCheckAuthorization = (options) => {\n  return (params) => {\n    if (!options.userId) {\n      return false;\n    }\n    const billingAuthorization = checkBillingAuthorization(params, options);\n    const orgAuthorization = checkOrgAuthorization(params, options);\n    const reverificationAuthorization = checkReverificationAuthorization(params, options);\n    if ([billingAuthorization || orgAuthorization, reverificationAuthorization].some((a) => a === null)) {\n      return [billingAuthorization || orgAuthorization, reverificationAuthorization].some((a) => a === true);\n    }\n    return [billingAuthorization || orgAuthorization, reverificationAuthorization].every((a) => a === true);\n  };\n};\nvar resolveAuthState = ({\n  authObject: {\n    sessionId,\n    sessionStatus,\n    userId,\n    actor,\n    orgId,\n    orgRole,\n    orgSlug,\n    signOut,\n    getToken,\n    has,\n    sessionClaims\n  },\n  options: { treatPendingAsSignedOut = true }\n}) => {\n  if (sessionId === void 0 && userId === void 0) {\n    return {\n      isLoaded: false,\n      isSignedIn: void 0,\n      sessionId,\n      sessionClaims: void 0,\n      userId,\n      actor: void 0,\n      orgId: void 0,\n      orgRole: void 0,\n      orgSlug: void 0,\n      has: void 0,\n      signOut,\n      getToken\n    };\n  }\n  if (sessionId === null && userId === null) {\n    return {\n      isLoaded: true,\n      isSignedIn: false,\n      sessionId,\n      userId,\n      sessionClaims: null,\n      actor: null,\n      orgId: null,\n      orgRole: null,\n      orgSlug: null,\n      has: () => false,\n      signOut,\n      getToken\n    };\n  }\n  if (treatPendingAsSignedOut && sessionStatus === \"pending\") {\n    return {\n      isLoaded: true,\n      isSignedIn: false,\n      sessionId: null,\n      userId: null,\n      sessionClaims: null,\n      actor: null,\n      orgId: null,\n      orgRole: null,\n      orgSlug: null,\n      has: () => false,\n      signOut,\n      getToken\n    };\n  }\n  if (!!sessionId && !!sessionClaims && !!userId && !!orgId && !!orgRole) {\n    return {\n      isLoaded: true,\n      isSignedIn: true,\n      sessionId,\n      sessionClaims,\n      userId,\n      actor: actor || null,\n      orgId,\n      orgRole,\n      orgSlug: orgSlug || null,\n      has,\n      signOut,\n      getToken\n    };\n  }\n  if (!!sessionId && !!sessionClaims && !!userId && !orgId) {\n    return {\n      isLoaded: true,\n      isSignedIn: true,\n      sessionId,\n      sessionClaims,\n      userId,\n      actor: actor || null,\n      orgId: null,\n      orgRole: null,\n      orgSlug: null,\n      has,\n      signOut,\n      getToken\n    };\n  }\n};\n\n\n//# sourceMappingURL=chunk-3CN5LOSN.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstM0NONUxPU04ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQ0FBaUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1Q0FBdUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHVCQUF1QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0JBQXNCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxhQUFhO0FBQ2IsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFPRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2NodW5rLTNDTjVMT1NOLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvYXV0aG9yaXphdGlvbi50c1xudmFyIFRZUEVTX1RPX09CSkVDVFMgPSB7XG4gIHN0cmljdF9tZmE6IHtcbiAgICBhZnRlck1pbnV0ZXM6IDEwLFxuICAgIGxldmVsOiBcIm11bHRpX2ZhY3RvclwiXG4gIH0sXG4gIHN0cmljdDoge1xuICAgIGFmdGVyTWludXRlczogMTAsXG4gICAgbGV2ZWw6IFwic2Vjb25kX2ZhY3RvclwiXG4gIH0sXG4gIG1vZGVyYXRlOiB7XG4gICAgYWZ0ZXJNaW51dGVzOiA2MCxcbiAgICBsZXZlbDogXCJzZWNvbmRfZmFjdG9yXCJcbiAgfSxcbiAgbGF4OiB7XG4gICAgYWZ0ZXJNaW51dGVzOiAxNDQwLFxuICAgIGxldmVsOiBcInNlY29uZF9mYWN0b3JcIlxuICB9XG59O1xudmFyIEFMTE9XRURfTEVWRUxTID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiZmlyc3RfZmFjdG9yXCIsIFwic2Vjb25kX2ZhY3RvclwiLCBcIm11bHRpX2ZhY3RvclwiXSk7XG52YXIgQUxMT1dFRF9UWVBFUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInN0cmljdF9tZmFcIiwgXCJzdHJpY3RcIiwgXCJtb2RlcmF0ZVwiLCBcImxheFwiXSk7XG52YXIgaXNWYWxpZE1heEFnZSA9IChtYXhBZ2UpID0+IHR5cGVvZiBtYXhBZ2UgPT09IFwibnVtYmVyXCIgJiYgbWF4QWdlID4gMDtcbnZhciBpc1ZhbGlkTGV2ZWwgPSAobGV2ZWwpID0+IEFMTE9XRURfTEVWRUxTLmhhcyhsZXZlbCk7XG52YXIgaXNWYWxpZFZlcmlmaWNhdGlvblR5cGUgPSAodHlwZSkgPT4gQUxMT1dFRF9UWVBFUy5oYXModHlwZSk7XG52YXIgcHJlZml4V2l0aE9yZyA9ICh2YWx1ZSkgPT4gdmFsdWUucmVwbGFjZSgvXihvcmc6KSovLCBcIm9yZzpcIik7XG52YXIgY2hlY2tPcmdBdXRob3JpemF0aW9uID0gKHBhcmFtcywgb3B0aW9ucykgPT4ge1xuICBjb25zdCB7IG9yZ0lkLCBvcmdSb2xlLCBvcmdQZXJtaXNzaW9ucyB9ID0gb3B0aW9ucztcbiAgaWYgKCFwYXJhbXMucm9sZSAmJiAhcGFyYW1zLnBlcm1pc3Npb24pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIW9yZ0lkIHx8ICFvcmdSb2xlIHx8ICFvcmdQZXJtaXNzaW9ucykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwYXJhbXMucGVybWlzc2lvbikge1xuICAgIHJldHVybiBvcmdQZXJtaXNzaW9ucy5pbmNsdWRlcyhwcmVmaXhXaXRoT3JnKHBhcmFtcy5wZXJtaXNzaW9uKSk7XG4gIH1cbiAgaWYgKHBhcmFtcy5yb2xlKSB7XG4gICAgcmV0dXJuIHByZWZpeFdpdGhPcmcob3JnUm9sZSkgPT09IHByZWZpeFdpdGhPcmcocGFyYW1zLnJvbGUpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbnZhciBjaGVja0ZvckZlYXR1cmVPclBsYW4gPSAoY2xhaW0sIGZlYXR1cmVPclBsYW4pID0+IHtcbiAgY29uc3QgeyBvcmc6IG9yZ0ZlYXR1cmVzLCB1c2VyOiB1c2VyRmVhdHVyZXMgfSA9IHNwbGl0QnlTY29wZShjbGFpbSk7XG4gIGNvbnN0IFtzY29wZSwgX2lkXSA9IGZlYXR1cmVPclBsYW4uc3BsaXQoXCI6XCIpO1xuICBjb25zdCBpZCA9IF9pZCB8fCBzY29wZTtcbiAgaWYgKHNjb3BlID09PSBcIm9yZ1wiKSB7XG4gICAgcmV0dXJuIG9yZ0ZlYXR1cmVzLmluY2x1ZGVzKGlkKTtcbiAgfSBlbHNlIGlmIChzY29wZSA9PT0gXCJ1c2VyXCIpIHtcbiAgICByZXR1cm4gdXNlckZlYXR1cmVzLmluY2x1ZGVzKGlkKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gWy4uLm9yZ0ZlYXR1cmVzLCAuLi51c2VyRmVhdHVyZXNdLmluY2x1ZGVzKGlkKTtcbiAgfVxufTtcbnZhciBjaGVja0JpbGxpbmdBdXRob3JpemF0aW9uID0gKHBhcmFtcywgb3B0aW9ucykgPT4ge1xuICBjb25zdCB7IGZlYXR1cmVzLCBwbGFucyB9ID0gb3B0aW9ucztcbiAgaWYgKHBhcmFtcy5mZWF0dXJlICYmIGZlYXR1cmVzKSB7XG4gICAgcmV0dXJuIGNoZWNrRm9yRmVhdHVyZU9yUGxhbihmZWF0dXJlcywgcGFyYW1zLmZlYXR1cmUpO1xuICB9XG4gIGlmIChwYXJhbXMucGxhbiAmJiBwbGFucykge1xuICAgIHJldHVybiBjaGVja0ZvckZlYXR1cmVPclBsYW4ocGxhbnMsIHBhcmFtcy5wbGFuKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG52YXIgc3BsaXRCeVNjb3BlID0gKGZlYSkgPT4ge1xuICBjb25zdCBmZWF0dXJlcyA9IGZlYSA/IGZlYS5zcGxpdChcIixcIikubWFwKChmKSA9PiBmLnRyaW0oKSkgOiBbXTtcbiAgcmV0dXJuIHtcbiAgICBvcmc6IGZlYXR1cmVzLmZpbHRlcigoZikgPT4gZi5zcGxpdChcIjpcIilbMF0uaW5jbHVkZXMoXCJvXCIpKS5tYXAoKGYpID0+IGYuc3BsaXQoXCI6XCIpWzFdKSxcbiAgICB1c2VyOiBmZWF0dXJlcy5maWx0ZXIoKGYpID0+IGYuc3BsaXQoXCI6XCIpWzBdLmluY2x1ZGVzKFwidVwiKSkubWFwKChmKSA9PiBmLnNwbGl0KFwiOlwiKVsxXSlcbiAgfTtcbn07XG52YXIgdmFsaWRhdGVSZXZlcmlmaWNhdGlvbkNvbmZpZyA9IChjb25maWcpID0+IHtcbiAgaWYgKCFjb25maWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgY29udmVydENvbmZpZ1RvT2JqZWN0ID0gKGNvbmZpZzIpID0+IHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZzIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBUWVBFU19UT19PQkpFQ1RTW2NvbmZpZzJdO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnMjtcbiAgfTtcbiAgY29uc3QgaXNWYWxpZFN0cmluZ1ZhbHVlID0gdHlwZW9mIGNvbmZpZyA9PT0gXCJzdHJpbmdcIiAmJiBpc1ZhbGlkVmVyaWZpY2F0aW9uVHlwZShjb25maWcpO1xuICBjb25zdCBpc1ZhbGlkT2JqZWN0VmFsdWUgPSB0eXBlb2YgY29uZmlnID09PSBcIm9iamVjdFwiICYmIGlzVmFsaWRMZXZlbChjb25maWcubGV2ZWwpICYmIGlzVmFsaWRNYXhBZ2UoY29uZmlnLmFmdGVyTWludXRlcyk7XG4gIGlmIChpc1ZhbGlkU3RyaW5nVmFsdWUgfHwgaXNWYWxpZE9iamVjdFZhbHVlKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRDb25maWdUb09iamVjdC5iaW5kKG51bGwsIGNvbmZpZyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBjaGVja1JldmVyaWZpY2F0aW9uQXV0aG9yaXphdGlvbiA9IChwYXJhbXMsIHsgZmFjdG9yVmVyaWZpY2F0aW9uQWdlIH0pID0+IHtcbiAgaWYgKCFwYXJhbXMucmV2ZXJpZmljYXRpb24gfHwgIWZhY3RvclZlcmlmaWNhdGlvbkFnZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGlzVmFsaWRSZXZlcmlmaWNhdGlvbiA9IHZhbGlkYXRlUmV2ZXJpZmljYXRpb25Db25maWcocGFyYW1zLnJldmVyaWZpY2F0aW9uKTtcbiAgaWYgKCFpc1ZhbGlkUmV2ZXJpZmljYXRpb24pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB7IGxldmVsLCBhZnRlck1pbnV0ZXMgfSA9IGlzVmFsaWRSZXZlcmlmaWNhdGlvbigpO1xuICBjb25zdCBbZmFjdG9yMUFnZSwgZmFjdG9yMkFnZV0gPSBmYWN0b3JWZXJpZmljYXRpb25BZ2U7XG4gIGNvbnN0IGlzVmFsaWRGYWN0b3IxID0gZmFjdG9yMUFnZSAhPT0gLTEgPyBhZnRlck1pbnV0ZXMgPiBmYWN0b3IxQWdlIDogbnVsbDtcbiAgY29uc3QgaXNWYWxpZEZhY3RvcjIgPSBmYWN0b3IyQWdlICE9PSAtMSA/IGFmdGVyTWludXRlcyA+IGZhY3RvcjJBZ2UgOiBudWxsO1xuICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgY2FzZSBcImZpcnN0X2ZhY3RvclwiOlxuICAgICAgcmV0dXJuIGlzVmFsaWRGYWN0b3IxO1xuICAgIGNhc2UgXCJzZWNvbmRfZmFjdG9yXCI6XG4gICAgICByZXR1cm4gZmFjdG9yMkFnZSAhPT0gLTEgPyBpc1ZhbGlkRmFjdG9yMiA6IGlzVmFsaWRGYWN0b3IxO1xuICAgIGNhc2UgXCJtdWx0aV9mYWN0b3JcIjpcbiAgICAgIHJldHVybiBmYWN0b3IyQWdlID09PSAtMSA/IGlzVmFsaWRGYWN0b3IxIDogaXNWYWxpZEZhY3RvcjEgJiYgaXNWYWxpZEZhY3RvcjI7XG4gIH1cbn07XG52YXIgY3JlYXRlQ2hlY2tBdXRob3JpemF0aW9uID0gKG9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIChwYXJhbXMpID0+IHtcbiAgICBpZiAoIW9wdGlvbnMudXNlcklkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGJpbGxpbmdBdXRob3JpemF0aW9uID0gY2hlY2tCaWxsaW5nQXV0aG9yaXphdGlvbihwYXJhbXMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IG9yZ0F1dGhvcml6YXRpb24gPSBjaGVja09yZ0F1dGhvcml6YXRpb24ocGFyYW1zLCBvcHRpb25zKTtcbiAgICBjb25zdCByZXZlcmlmaWNhdGlvbkF1dGhvcml6YXRpb24gPSBjaGVja1JldmVyaWZpY2F0aW9uQXV0aG9yaXphdGlvbihwYXJhbXMsIG9wdGlvbnMpO1xuICAgIGlmIChbYmlsbGluZ0F1dGhvcml6YXRpb24gfHwgb3JnQXV0aG9yaXphdGlvbiwgcmV2ZXJpZmljYXRpb25BdXRob3JpemF0aW9uXS5zb21lKChhKSA9PiBhID09PSBudWxsKSkge1xuICAgICAgcmV0dXJuIFtiaWxsaW5nQXV0aG9yaXphdGlvbiB8fCBvcmdBdXRob3JpemF0aW9uLCByZXZlcmlmaWNhdGlvbkF1dGhvcml6YXRpb25dLnNvbWUoKGEpID0+IGEgPT09IHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gW2JpbGxpbmdBdXRob3JpemF0aW9uIHx8IG9yZ0F1dGhvcml6YXRpb24sIHJldmVyaWZpY2F0aW9uQXV0aG9yaXphdGlvbl0uZXZlcnkoKGEpID0+IGEgPT09IHRydWUpO1xuICB9O1xufTtcbnZhciByZXNvbHZlQXV0aFN0YXRlID0gKHtcbiAgYXV0aE9iamVjdDoge1xuICAgIHNlc3Npb25JZCxcbiAgICBzZXNzaW9uU3RhdHVzLFxuICAgIHVzZXJJZCxcbiAgICBhY3RvcixcbiAgICBvcmdJZCxcbiAgICBvcmdSb2xlLFxuICAgIG9yZ1NsdWcsXG4gICAgc2lnbk91dCxcbiAgICBnZXRUb2tlbixcbiAgICBoYXMsXG4gICAgc2Vzc2lvbkNsYWltc1xuICB9LFxuICBvcHRpb25zOiB7IHRyZWF0UGVuZGluZ0FzU2lnbmVkT3V0ID0gdHJ1ZSB9XG59KSA9PiB7XG4gIGlmIChzZXNzaW9uSWQgPT09IHZvaWQgMCAmJiB1c2VySWQgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRlZDogZmFsc2UsXG4gICAgICBpc1NpZ25lZEluOiB2b2lkIDAsXG4gICAgICBzZXNzaW9uSWQsXG4gICAgICBzZXNzaW9uQ2xhaW1zOiB2b2lkIDAsXG4gICAgICB1c2VySWQsXG4gICAgICBhY3Rvcjogdm9pZCAwLFxuICAgICAgb3JnSWQ6IHZvaWQgMCxcbiAgICAgIG9yZ1JvbGU6IHZvaWQgMCxcbiAgICAgIG9yZ1NsdWc6IHZvaWQgMCxcbiAgICAgIGhhczogdm9pZCAwLFxuICAgICAgc2lnbk91dCxcbiAgICAgIGdldFRva2VuXG4gICAgfTtcbiAgfVxuICBpZiAoc2Vzc2lvbklkID09PSBudWxsICYmIHVzZXJJZCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRlZDogdHJ1ZSxcbiAgICAgIGlzU2lnbmVkSW46IGZhbHNlLFxuICAgICAgc2Vzc2lvbklkLFxuICAgICAgdXNlcklkLFxuICAgICAgc2Vzc2lvbkNsYWltczogbnVsbCxcbiAgICAgIGFjdG9yOiBudWxsLFxuICAgICAgb3JnSWQ6IG51bGwsXG4gICAgICBvcmdSb2xlOiBudWxsLFxuICAgICAgb3JnU2x1ZzogbnVsbCxcbiAgICAgIGhhczogKCkgPT4gZmFsc2UsXG4gICAgICBzaWduT3V0LFxuICAgICAgZ2V0VG9rZW5cbiAgICB9O1xuICB9XG4gIGlmICh0cmVhdFBlbmRpbmdBc1NpZ25lZE91dCAmJiBzZXNzaW9uU3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRlZDogdHJ1ZSxcbiAgICAgIGlzU2lnbmVkSW46IGZhbHNlLFxuICAgICAgc2Vzc2lvbklkOiBudWxsLFxuICAgICAgdXNlcklkOiBudWxsLFxuICAgICAgc2Vzc2lvbkNsYWltczogbnVsbCxcbiAgICAgIGFjdG9yOiBudWxsLFxuICAgICAgb3JnSWQ6IG51bGwsXG4gICAgICBvcmdSb2xlOiBudWxsLFxuICAgICAgb3JnU2x1ZzogbnVsbCxcbiAgICAgIGhhczogKCkgPT4gZmFsc2UsXG4gICAgICBzaWduT3V0LFxuICAgICAgZ2V0VG9rZW5cbiAgICB9O1xuICB9XG4gIGlmICghIXNlc3Npb25JZCAmJiAhIXNlc3Npb25DbGFpbXMgJiYgISF1c2VySWQgJiYgISFvcmdJZCAmJiAhIW9yZ1JvbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNMb2FkZWQ6IHRydWUsXG4gICAgICBpc1NpZ25lZEluOiB0cnVlLFxuICAgICAgc2Vzc2lvbklkLFxuICAgICAgc2Vzc2lvbkNsYWltcyxcbiAgICAgIHVzZXJJZCxcbiAgICAgIGFjdG9yOiBhY3RvciB8fCBudWxsLFxuICAgICAgb3JnSWQsXG4gICAgICBvcmdSb2xlLFxuICAgICAgb3JnU2x1Zzogb3JnU2x1ZyB8fCBudWxsLFxuICAgICAgaGFzLFxuICAgICAgc2lnbk91dCxcbiAgICAgIGdldFRva2VuXG4gICAgfTtcbiAgfVxuICBpZiAoISFzZXNzaW9uSWQgJiYgISFzZXNzaW9uQ2xhaW1zICYmICEhdXNlcklkICYmICFvcmdJZCkge1xuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRlZDogdHJ1ZSxcbiAgICAgIGlzU2lnbmVkSW46IHRydWUsXG4gICAgICBzZXNzaW9uSWQsXG4gICAgICBzZXNzaW9uQ2xhaW1zLFxuICAgICAgdXNlcklkLFxuICAgICAgYWN0b3I6IGFjdG9yIHx8IG51bGwsXG4gICAgICBvcmdJZDogbnVsbCxcbiAgICAgIG9yZ1JvbGU6IG51bGwsXG4gICAgICBvcmdTbHVnOiBudWxsLFxuICAgICAgaGFzLFxuICAgICAgc2lnbk91dCxcbiAgICAgIGdldFRva2VuXG4gICAgfTtcbiAgfVxufTtcblxuZXhwb3J0IHtcbiAgc3BsaXRCeVNjb3BlLFxuICB2YWxpZGF0ZVJldmVyaWZpY2F0aW9uQ29uZmlnLFxuICBjcmVhdGVDaGVja0F1dGhvcml6YXRpb24sXG4gIHJlc29sdmVBdXRoU3RhdGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay0zQ041TE9TTi5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-3CN5LOSN.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-3TMSNP4L.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-3TMSNP4L.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isStaging: () => (/* binding */ isStaging)\n/* harmony export */ });\n// src/utils/instance.ts\nfunction isStaging(frontendApi) {\n  return frontendApi.endsWith(\".lclstage.dev\") || frontendApi.endsWith(\".stgstage.dev\") || frontendApi.endsWith(\".clerkstage.dev\") || frontendApi.endsWith(\".accountsstage.dev\");\n}\n\n\n//# sourceMappingURL=chunk-3TMSNP4L.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstM1RNU05QNEwubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFJRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2NodW5rLTNUTVNOUDRMLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdXRpbHMvaW5zdGFuY2UudHNcbmZ1bmN0aW9uIGlzU3RhZ2luZyhmcm9udGVuZEFwaSkge1xuICByZXR1cm4gZnJvbnRlbmRBcGkuZW5kc1dpdGgoXCIubGNsc3RhZ2UuZGV2XCIpIHx8IGZyb250ZW5kQXBpLmVuZHNXaXRoKFwiLnN0Z3N0YWdlLmRldlwiKSB8fCBmcm9udGVuZEFwaS5lbmRzV2l0aChcIi5jbGVya3N0YWdlLmRldlwiKSB8fCBmcm9udGVuZEFwaS5lbmRzV2l0aChcIi5hY2NvdW50c3N0YWdlLmRldlwiKTtcbn1cblxuZXhwb3J0IHtcbiAgaXNTdGFnaW5nXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstM1RNU05QNEwubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-3TMSNP4L.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-43A5F2IE.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-43A5F2IE.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isReverificationHint: () => (/* binding */ isReverificationHint),\n/* harmony export */   reverificationError: () => (/* binding */ reverificationError),\n/* harmony export */   reverificationErrorResponse: () => (/* binding */ reverificationErrorResponse)\n/* harmony export */ });\n// src/authorization-errors.ts\nvar REVERIFICATION_REASON = \"reverification-error\";\nvar reverificationError = (missingConfig) => ({\n  clerk_error: {\n    type: \"forbidden\",\n    reason: REVERIFICATION_REASON,\n    metadata: {\n      reverification: missingConfig\n    }\n  }\n});\nvar reverificationErrorResponse = (...args) => new Response(JSON.stringify(reverificationError(...args)), {\n  status: 403\n});\nvar isReverificationHint = (result) => {\n  return result && typeof result === \"object\" && \"clerk_error\" in result && result.clerk_error?.type === \"forbidden\" && result.clerk_error?.reason === REVERIFICATION_REASON;\n};\n\n\n//# sourceMappingURL=chunk-43A5F2IE.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstNDNBNUYySUUubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQU1FO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstNDNBNUYySUUubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9hdXRob3JpemF0aW9uLWVycm9ycy50c1xudmFyIFJFVkVSSUZJQ0FUSU9OX1JFQVNPTiA9IFwicmV2ZXJpZmljYXRpb24tZXJyb3JcIjtcbnZhciByZXZlcmlmaWNhdGlvbkVycm9yID0gKG1pc3NpbmdDb25maWcpID0+ICh7XG4gIGNsZXJrX2Vycm9yOiB7XG4gICAgdHlwZTogXCJmb3JiaWRkZW5cIixcbiAgICByZWFzb246IFJFVkVSSUZJQ0FUSU9OX1JFQVNPTixcbiAgICBtZXRhZGF0YToge1xuICAgICAgcmV2ZXJpZmljYXRpb246IG1pc3NpbmdDb25maWdcbiAgICB9XG4gIH1cbn0pO1xudmFyIHJldmVyaWZpY2F0aW9uRXJyb3JSZXNwb25zZSA9ICguLi5hcmdzKSA9PiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkocmV2ZXJpZmljYXRpb25FcnJvciguLi5hcmdzKSksIHtcbiAgc3RhdHVzOiA0MDNcbn0pO1xudmFyIGlzUmV2ZXJpZmljYXRpb25IaW50ID0gKHJlc3VsdCkgPT4ge1xuICByZXR1cm4gcmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgPT09IFwib2JqZWN0XCIgJiYgXCJjbGVya19lcnJvclwiIGluIHJlc3VsdCAmJiByZXN1bHQuY2xlcmtfZXJyb3I/LnR5cGUgPT09IFwiZm9yYmlkZGVuXCIgJiYgcmVzdWx0LmNsZXJrX2Vycm9yPy5yZWFzb24gPT09IFJFVkVSSUZJQ0FUSU9OX1JFQVNPTjtcbn07XG5cbmV4cG9ydCB7XG4gIHJldmVyaWZpY2F0aW9uRXJyb3IsXG4gIHJldmVyaWZpY2F0aW9uRXJyb3JSZXNwb25zZSxcbiAgaXNSZXZlcmlmaWNhdGlvbkhpbnRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay00M0E1RjJJRS5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-43A5F2IE.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-6NDGN2IU.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-6NDGN2IU.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isHttpOrHttps: () => (/* binding */ isHttpOrHttps),\n/* harmony export */   isProxyUrlRelative: () => (/* binding */ isProxyUrlRelative),\n/* harmony export */   isValidProxyUrl: () => (/* binding */ isValidProxyUrl),\n/* harmony export */   proxyUrlToAbsoluteURL: () => (/* binding */ proxyUrlToAbsoluteURL)\n/* harmony export */ });\n// src/proxy.ts\nfunction isValidProxyUrl(key) {\n  if (!key) {\n    return true;\n  }\n  return isHttpOrHttps(key) || isProxyUrlRelative(key);\n}\nfunction isHttpOrHttps(key) {\n  return /^http(s)?:\\/\\//.test(key || \"\");\n}\nfunction isProxyUrlRelative(key) {\n  return key.startsWith(\"/\");\n}\nfunction proxyUrlToAbsoluteURL(url) {\n  if (!url) {\n    return \"\";\n  }\n  return isProxyUrlRelative(url) ? new URL(url, window.location.origin).toString() : url;\n}\n\n\n//# sourceMappingURL=chunk-6NDGN2IU.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstNk5ER04ySVUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFPRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2NodW5rLTZOREdOMklVLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcHJveHkudHNcbmZ1bmN0aW9uIGlzVmFsaWRQcm94eVVybChrZXkpIHtcbiAgaWYgKCFrZXkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gaXNIdHRwT3JIdHRwcyhrZXkpIHx8IGlzUHJveHlVcmxSZWxhdGl2ZShrZXkpO1xufVxuZnVuY3Rpb24gaXNIdHRwT3JIdHRwcyhrZXkpIHtcbiAgcmV0dXJuIC9eaHR0cChzKT86XFwvXFwvLy50ZXN0KGtleSB8fCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGlzUHJveHlVcmxSZWxhdGl2ZShrZXkpIHtcbiAgcmV0dXJuIGtleS5zdGFydHNXaXRoKFwiL1wiKTtcbn1cbmZ1bmN0aW9uIHByb3h5VXJsVG9BYnNvbHV0ZVVSTCh1cmwpIHtcbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICByZXR1cm4gaXNQcm94eVVybFJlbGF0aXZlKHVybCkgPyBuZXcgVVJMKHVybCwgd2luZG93LmxvY2F0aW9uLm9yaWdpbikudG9TdHJpbmcoKSA6IHVybDtcbn1cblxuZXhwb3J0IHtcbiAgaXNWYWxpZFByb3h5VXJsLFxuICBpc0h0dHBPckh0dHBzLFxuICBpc1Byb3h5VXJsUmVsYXRpdmUsXG4gIHByb3h5VXJsVG9BYnNvbHV0ZVVSTFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLTZOREdOMklVLm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-6NDGN2IU.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7FNX7RWY.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-7FNX7RWY.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   noop: () => (/* binding */ noop)\n/* harmony export */ });\n// src/utils/noop.ts\nvar noop = (..._args) => {\n};\n\n\n//# sourceMappingURL=chunk-7FNX7RWY.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstN0ZOWDdSV1kubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBSUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2lzaGFxYmVsbG8vV2Vic2l0ZS9oYXZlbnJpZGVfZnVsbF9hcHAvbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9jaHVuay03Rk5YN1JXWS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3V0aWxzL25vb3AudHNcbnZhciBub29wID0gKC4uLl9hcmdzKSA9PiB7XG59O1xuXG5leHBvcnQge1xuICBub29wXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstN0ZOWDdSV1kubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7FNX7RWY.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7HPDNZ3R.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-7HPDNZ3R.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isDevelopmentEnvironment: () => (/* binding */ isDevelopmentEnvironment),\n/* harmony export */   isProductionEnvironment: () => (/* binding */ isProductionEnvironment),\n/* harmony export */   isTestEnvironment: () => (/* binding */ isTestEnvironment)\n/* harmony export */ });\n// src/utils/runtimeEnvironment.ts\nvar isDevelopmentEnvironment = () => {\n  try {\n    return \"development\" === \"development\";\n  } catch {\n  }\n  return false;\n};\nvar isTestEnvironment = () => {\n  try {\n    return \"development\" === \"test\";\n  } catch {\n  }\n  return false;\n};\nvar isProductionEnvironment = () => {\n  try {\n    return \"development\" === \"production\";\n  } catch {\n  }\n  return false;\n};\n\n\n//# sourceMappingURL=chunk-7HPDNZ3R.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstN0hQRE5aM1IubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBb0I7QUFDL0IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQW9CO0FBQy9CLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFvQjtBQUMvQixJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQU1FO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstN0hQRE5aM1IubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy91dGlscy9ydW50aW1lRW52aXJvbm1lbnQudHNcbnZhciBpc0RldmVsb3BtZW50RW52aXJvbm1lbnQgPSAoKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCI7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgaXNUZXN0RW52aXJvbm1lbnQgPSAoKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIjtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBpc1Byb2R1Y3Rpb25FbnZpcm9ubWVudCA9ICgpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnQge1xuICBpc0RldmVsb3BtZW50RW52aXJvbm1lbnQsXG4gIGlzVGVzdEVudmlyb25tZW50LFxuICBpc1Byb2R1Y3Rpb25FbnZpcm9ubWVudFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLTdIUEROWjNSLm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7HPDNZ3R.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7QJ2QTJL.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-7QJ2QTJL.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDeferredPromise: () => (/* binding */ createDeferredPromise)\n/* harmony export */ });\n/* harmony import */ var _chunk_7FNX7RWY_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-7FNX7RWY.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7FNX7RWY.mjs\");\n\n\n// src/utils/createDeferredPromise.ts\nvar createDeferredPromise = () => {\n  let resolve = _chunk_7FNX7RWY_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;\n  let reject = _chunk_7FNX7RWY_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return { promise, resolve, reject };\n};\n\n\n//# sourceMappingURL=chunk-7QJ2QTJL.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstN1FKMlFUSkwubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBRThCOztBQUU5QjtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFJO0FBQ3BCLGVBQWUscURBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFdBQVc7QUFDWDs7QUFJRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2NodW5rLTdRSjJRVEpMLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBub29wXG59IGZyb20gXCIuL2NodW5rLTdGTlg3UldZLm1qc1wiO1xuXG4vLyBzcmMvdXRpbHMvY3JlYXRlRGVmZXJyZWRQcm9taXNlLnRzXG52YXIgY3JlYXRlRGVmZXJyZWRQcm9taXNlID0gKCkgPT4ge1xuICBsZXQgcmVzb2x2ZSA9IG5vb3A7XG4gIGxldCByZWplY3QgPSBub29wO1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZSA9IHJlcztcbiAgICByZWplY3QgPSByZWo7XG4gIH0pO1xuICByZXR1cm4geyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfTtcbn07XG5cbmV4cG9ydCB7XG4gIGNyZWF0ZURlZmVycmVkUHJvbWlzZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLTdRSjJRVEpMLm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7QJ2QTJL.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-ARQUL5DC.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-ARQUL5DC.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allSettled: () => (/* binding */ allSettled),\n/* harmony export */   fastDeepMergeAndKeep: () => (/* binding */ fastDeepMergeAndKeep),\n/* harmony export */   fastDeepMergeAndReplace: () => (/* binding */ fastDeepMergeAndReplace),\n/* harmony export */   logErrorInDevMode: () => (/* binding */ logErrorInDevMode)\n/* harmony export */ });\n/* harmony import */ var _chunk_7HPDNZ3R_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-7HPDNZ3R.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7HPDNZ3R.mjs\");\n\n\n// src/utils/allSettled.ts\nfunction allSettled(iterable) {\n  const promises = Array.from(iterable).map(\n    (p) => p.then(\n      (value) => ({ status: \"fulfilled\", value }),\n      (reason) => ({ status: \"rejected\", reason })\n    )\n  );\n  return Promise.all(promises);\n}\n\n// src/utils/logErrorInDevMode.ts\nvar logErrorInDevMode = (message) => {\n  if ((0,_chunk_7HPDNZ3R_mjs__WEBPACK_IMPORTED_MODULE_0__.isDevelopmentEnvironment)()) {\n    console.error(`Clerk: ${message}`);\n  }\n};\n\n// src/utils/fastDeepMerge.ts\nvar fastDeepMergeAndReplace = (source, target) => {\n  if (!source || !target) {\n    return;\n  }\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key) && source[key] !== null && typeof source[key] === `object`) {\n      if (target[key] === void 0) {\n        target[key] = new (Object.getPrototypeOf(source[key])).constructor();\n      }\n      fastDeepMergeAndReplace(source[key], target[key]);\n    } else if (Object.prototype.hasOwnProperty.call(source, key)) {\n      target[key] = source[key];\n    }\n  }\n};\nvar fastDeepMergeAndKeep = (source, target) => {\n  if (!source || !target) {\n    return;\n  }\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key) && source[key] !== null && typeof source[key] === `object`) {\n      if (target[key] === void 0) {\n        target[key] = new (Object.getPrototypeOf(source[key])).constructor();\n      }\n      fastDeepMergeAndKeep(source[key], target[key]);\n    } else if (Object.prototype.hasOwnProperty.call(source, key) && target[key] === void 0) {\n      target[key] = source[key];\n    }\n  }\n};\n\n\n//# sourceMappingURL=chunk-ARQUL5DC.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstQVJRVUw1REMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBRThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSw2RUFBd0I7QUFDOUIsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBT0U7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2lzaGFxYmVsbG8vV2Vic2l0ZS9oYXZlbnJpZGVfZnVsbF9hcHAvbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9jaHVuay1BUlFVTDVEQy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgaXNEZXZlbG9wbWVudEVudmlyb25tZW50XG59IGZyb20gXCIuL2NodW5rLTdIUEROWjNSLm1qc1wiO1xuXG4vLyBzcmMvdXRpbHMvYWxsU2V0dGxlZC50c1xuZnVuY3Rpb24gYWxsU2V0dGxlZChpdGVyYWJsZSkge1xuICBjb25zdCBwcm9taXNlcyA9IEFycmF5LmZyb20oaXRlcmFibGUpLm1hcChcbiAgICAocCkgPT4gcC50aGVuKFxuICAgICAgKHZhbHVlKSA9PiAoeyBzdGF0dXM6IFwiZnVsZmlsbGVkXCIsIHZhbHVlIH0pLFxuICAgICAgKHJlYXNvbikgPT4gKHsgc3RhdHVzOiBcInJlamVjdGVkXCIsIHJlYXNvbiB9KVxuICAgIClcbiAgKTtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn1cblxuLy8gc3JjL3V0aWxzL2xvZ0Vycm9ySW5EZXZNb2RlLnRzXG52YXIgbG9nRXJyb3JJbkRldk1vZGUgPSAobWVzc2FnZSkgPT4ge1xuICBpZiAoaXNEZXZlbG9wbWVudEVudmlyb25tZW50KCkpIHtcbiAgICBjb25zb2xlLmVycm9yKGBDbGVyazogJHttZXNzYWdlfWApO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvZmFzdERlZXBNZXJnZS50c1xudmFyIGZhc3REZWVwTWVyZ2VBbmRSZXBsYWNlID0gKHNvdXJjZSwgdGFyZ2V0KSA9PiB7XG4gIGlmICghc291cmNlIHx8ICF0YXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkgJiYgc291cmNlW2tleV0gIT09IG51bGwgJiYgdHlwZW9mIHNvdXJjZVtrZXldID09PSBgb2JqZWN0YCkge1xuICAgICAgaWYgKHRhcmdldFtrZXldID09PSB2b2lkIDApIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBuZXcgKE9iamVjdC5nZXRQcm90b3R5cGVPZihzb3VyY2Vba2V5XSkpLmNvbnN0cnVjdG9yKCk7XG4gICAgICB9XG4gICAgICBmYXN0RGVlcE1lcmdlQW5kUmVwbGFjZShzb3VyY2Vba2V5XSwgdGFyZ2V0W2tleV0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cbn07XG52YXIgZmFzdERlZXBNZXJnZUFuZEtlZXAgPSAoc291cmNlLCB0YXJnZXQpID0+IHtcbiAgaWYgKCFzb3VyY2UgfHwgIXRhcmdldCkge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSAmJiBzb3VyY2Vba2V5XSAhPT0gbnVsbCAmJiB0eXBlb2Ygc291cmNlW2tleV0gPT09IGBvYmplY3RgKSB7XG4gICAgICBpZiAodGFyZ2V0W2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IG5ldyAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZVtrZXldKSkuY29uc3RydWN0b3IoKTtcbiAgICAgIH1cbiAgICAgIGZhc3REZWVwTWVyZ2VBbmRLZWVwKHNvdXJjZVtrZXldLCB0YXJnZXRba2V5XSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpICYmIHRhcmdldFtrZXldID09PSB2b2lkIDApIHtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQge1xuICBhbGxTZXR0bGVkLFxuICBsb2dFcnJvckluRGV2TW9kZSxcbiAgZmFzdERlZXBNZXJnZUFuZFJlcGxhY2UsXG4gIGZhc3REZWVwTWVyZ2VBbmRLZWVwXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstQVJRVUw1REMubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-ARQUL5DC.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-AXHU6TXE.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-AXHU6TXE.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClerkAPIError: () => (/* binding */ ClerkAPIError),\n/* harmony export */   ClerkAPIResponseError: () => (/* binding */ ClerkAPIResponseError),\n/* harmony export */   ClerkRuntimeError: () => (/* binding */ ClerkRuntimeError),\n/* harmony export */   ClerkWebAuthnError: () => (/* binding */ ClerkWebAuthnError),\n/* harmony export */   EmailLinkError: () => (/* binding */ EmailLinkError),\n/* harmony export */   EmailLinkErrorCode: () => (/* binding */ EmailLinkErrorCode),\n/* harmony export */   EmailLinkErrorCodeStatus: () => (/* binding */ EmailLinkErrorCodeStatus),\n/* harmony export */   buildErrorThrower: () => (/* binding */ buildErrorThrower),\n/* harmony export */   errorToJSON: () => (/* binding */ errorToJSON),\n/* harmony export */   is4xxError: () => (/* binding */ is4xxError),\n/* harmony export */   isCaptchaError: () => (/* binding */ isCaptchaError),\n/* harmony export */   isClerkAPIResponseError: () => (/* binding */ isClerkAPIResponseError),\n/* harmony export */   isClerkRuntimeError: () => (/* binding */ isClerkRuntimeError2),\n/* harmony export */   isEmailLinkError: () => (/* binding */ isEmailLinkError),\n/* harmony export */   isKnownError: () => (/* binding */ isKnownError),\n/* harmony export */   isMetamaskError: () => (/* binding */ isMetamaskError),\n/* harmony export */   isNetworkError: () => (/* binding */ isNetworkError),\n/* harmony export */   isPasswordPwnedError: () => (/* binding */ isPasswordPwnedError),\n/* harmony export */   isReverificationCancelledError: () => (/* binding */ isReverificationCancelledError),\n/* harmony export */   isUnauthorizedError: () => (/* binding */ isUnauthorizedError),\n/* harmony export */   isUserLockedError: () => (/* binding */ isUserLockedError),\n/* harmony export */   parseError: () => (/* binding */ parseError),\n/* harmony export */   parseErrors: () => (/* binding */ parseErrors)\n/* harmony export */ });\n// src/errors/createErrorTypeGuard.ts\nfunction createErrorTypeGuard(ErrorClass) {\n  function typeGuard(error) {\n    const target = error ?? this;\n    if (!target) {\n      throw new TypeError(`${ErrorClass.kind || ErrorClass.name} type guard requires an error object`);\n    }\n    return target instanceof ErrorClass;\n  }\n  return typeGuard;\n}\n\n// src/errors/clerkApiError.ts\nvar ClerkAPIError = class {\n  static kind = \"ClerkApiError\";\n  code;\n  message;\n  longMessage;\n  meta;\n  constructor(json) {\n    const parsedError = this.parseJsonError(json);\n    this.code = parsedError.code;\n    this.message = parsedError.message;\n    this.longMessage = parsedError.longMessage;\n    this.meta = parsedError.meta;\n  }\n  parseJsonError(json) {\n    return {\n      code: json.code,\n      message: json.message,\n      longMessage: json.long_message,\n      meta: {\n        paramName: json.meta?.param_name,\n        sessionId: json.meta?.session_id,\n        emailAddresses: json.meta?.email_addresses,\n        identifiers: json.meta?.identifiers,\n        zxcvbn: json.meta?.zxcvbn,\n        plan: json.meta?.plan,\n        isPlanUpgradePossible: json.meta?.is_plan_upgrade_possible\n      }\n    };\n  }\n};\nvar isClerkApiError = createErrorTypeGuard(ClerkAPIError);\n\n// src/errors/parseError.ts\nfunction parseErrors(data = []) {\n  return data.length > 0 ? data.map((e) => new ClerkAPIError(e)) : [];\n}\nfunction parseError(error) {\n  return new ClerkAPIError(error);\n}\nfunction errorToJSON(error) {\n  return {\n    code: error?.code || \"\",\n    message: error?.message || \"\",\n    long_message: error?.longMessage,\n    meta: {\n      param_name: error?.meta?.paramName,\n      session_id: error?.meta?.sessionId,\n      email_addresses: error?.meta?.emailAddresses,\n      identifiers: error?.meta?.identifiers,\n      zxcvbn: error?.meta?.zxcvbn,\n      plan: error?.meta?.plan,\n      is_plan_upgrade_possible: error?.meta?.isPlanUpgradePossible\n    }\n  };\n}\n\n// src/errors/clerkError.ts\nvar __DEV__ = true;\nvar ClerkError = class _ClerkError extends Error {\n  static kind = \"ClerkError\";\n  clerkError = true;\n  code;\n  longMessage;\n  docsUrl;\n  cause;\n  get name() {\n    return this.constructor.name;\n  }\n  constructor(opts) {\n    super(new.target.formatMessage(new.target.kind, opts.message, opts.code, opts.docsUrl), { cause: opts.cause });\n    Object.setPrototypeOf(this, _ClerkError.prototype);\n    this.code = opts.code;\n    this.docsUrl = opts.docsUrl;\n    this.longMessage = opts.longMessage;\n    this.cause = opts.cause;\n  }\n  toString() {\n    return `[${this.name}]\nMessage:${this.message}`;\n  }\n  static formatMessage(name, msg, code, docsUrl) {\n    const prefix = \"Clerk:\";\n    const regex = new RegExp(prefix.replace(\" \", \"\\\\s*\"), \"i\");\n    msg = msg.replace(regex, \"\");\n    msg = `${prefix} ${msg.trim()}\n\n(code=\"${code}\")\n\n`;\n    if (__DEV__ && docsUrl) {\n      msg += `\n\nDocs: ${docsUrl}`;\n    }\n    return msg;\n  }\n};\n\n// src/errors/clerkApiResponseError.ts\nvar ClerkAPIResponseError = class _ClerkAPIResponseError extends ClerkError {\n  static kind = \"ClerkAPIResponseError\";\n  status;\n  clerkTraceId;\n  retryAfter;\n  errors;\n  constructor(message, options) {\n    const { data: errorsJson, status, clerkTraceId, retryAfter } = options;\n    super({ ...options, message, code: \"api_response_error\" });\n    Object.setPrototypeOf(this, _ClerkAPIResponseError.prototype);\n    this.status = status;\n    this.clerkTraceId = clerkTraceId;\n    this.retryAfter = retryAfter;\n    this.errors = (errorsJson || []).map((e) => new ClerkAPIError(e));\n  }\n  toString() {\n    let message = `[${this.name}]\nMessage:${this.message}\nStatus:${this.status}\nSerialized errors: ${this.errors.map(\n      (e) => JSON.stringify(e)\n    )}`;\n    if (this.clerkTraceId) {\n      message += `\nClerk Trace ID: ${this.clerkTraceId}`;\n    }\n    return message;\n  }\n  // Override formatMessage to keep it unformatted for backward compatibility\n  static formatMessage(name, msg, _, __) {\n    return msg;\n  }\n};\nvar isClerkApiResponseError = createErrorTypeGuard(ClerkAPIResponseError);\n\n// src/errors/errorThrower.ts\nvar DefaultMessages = Object.freeze({\n  InvalidProxyUrlErrorMessage: `The proxyUrl passed to Clerk is invalid. The expected value for proxyUrl is an absolute URL or a relative path with a leading '/'. (key={{url}})`,\n  InvalidPublishableKeyErrorMessage: `The publishableKey passed to Clerk is invalid. You can get your Publishable key at https://dashboard.clerk.com/last-active?path=api-keys. (key={{key}})`,\n  MissingPublishableKeyErrorMessage: `Missing publishableKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.`,\n  MissingSecretKeyErrorMessage: `Missing secretKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.`,\n  MissingClerkProvider: `{{source}} can only be used within the <ClerkProvider /> component. Learn more: https://clerk.com/docs/components/clerk-provider`\n});\nfunction buildErrorThrower({ packageName, customMessages }) {\n  let pkg = packageName;\n  function buildMessage(rawMessage, replacements) {\n    if (!replacements) {\n      return `${pkg}: ${rawMessage}`;\n    }\n    let msg = rawMessage;\n    const matches = rawMessage.matchAll(/{{([a-zA-Z0-9-_]+)}}/g);\n    for (const match of matches) {\n      const replacement = (replacements[match[1]] || \"\").toString();\n      msg = msg.replace(`{{${match[1]}}}`, replacement);\n    }\n    return `${pkg}: ${msg}`;\n  }\n  const messages = {\n    ...DefaultMessages,\n    ...customMessages\n  };\n  return {\n    setPackageName({ packageName: packageName2 }) {\n      if (typeof packageName2 === \"string\") {\n        pkg = packageName2;\n      }\n      return this;\n    },\n    setMessages({ customMessages: customMessages2 }) {\n      Object.assign(messages, customMessages2 || {});\n      return this;\n    },\n    throwInvalidPublishableKeyError(params) {\n      throw new Error(buildMessage(messages.InvalidPublishableKeyErrorMessage, params));\n    },\n    throwInvalidProxyUrl(params) {\n      throw new Error(buildMessage(messages.InvalidProxyUrlErrorMessage, params));\n    },\n    throwMissingPublishableKeyError() {\n      throw new Error(buildMessage(messages.MissingPublishableKeyErrorMessage));\n    },\n    throwMissingSecretKeyError() {\n      throw new Error(buildMessage(messages.MissingSecretKeyErrorMessage));\n    },\n    throwMissingClerkProviderError(params) {\n      throw new Error(buildMessage(messages.MissingClerkProvider, params));\n    },\n    throw(message) {\n      throw new Error(buildMessage(message));\n    }\n  };\n}\n\n// src/errors/emailLinkError.ts\nvar EmailLinkError = class _EmailLinkError extends Error {\n  code;\n  constructor(code) {\n    super(code);\n    this.code = code;\n    this.name = \"EmailLinkError\";\n    Object.setPrototypeOf(this, _EmailLinkError.prototype);\n  }\n};\nvar EmailLinkErrorCode = {\n  Expired: \"expired\",\n  Failed: \"failed\",\n  ClientMismatch: \"client_mismatch\"\n};\nvar EmailLinkErrorCodeStatus = {\n  Expired: \"expired\",\n  Failed: \"failed\",\n  ClientMismatch: \"client_mismatch\"\n};\n\n// src/errors/clerkRuntimeError.ts\nvar ClerkRuntimeError = class _ClerkRuntimeError extends ClerkError {\n  static kind = \"ClerkRuntimeError\";\n  /**\n   * @deprecated Use `clerkError` property instead. This property is maintained for backward compatibility.\n   */\n  clerkRuntimeError = true;\n  constructor(message, options) {\n    super({ ...options, message });\n    Object.setPrototypeOf(this, _ClerkRuntimeError.prototype);\n  }\n};\nvar isClerkRuntimeError = createErrorTypeGuard(ClerkRuntimeError);\n\n// src/errors/webAuthNError.ts\nvar ClerkWebAuthnError = class extends ClerkRuntimeError {\n  /**\n   * A unique code identifying the error, can be used for localization.\n   */\n  code;\n  constructor(message, { code }) {\n    super(message, { code });\n    this.code = code;\n  }\n};\n\n// src/errors/helpers.ts\nfunction isUnauthorizedError(e) {\n  const status = e?.status;\n  const code = e?.errors?.[0]?.code;\n  return code === \"authentication_invalid\" && status === 401;\n}\nfunction isCaptchaError(e) {\n  return [\"captcha_invalid\", \"captcha_not_enabled\", \"captcha_missing_token\"].includes(e.errors[0].code);\n}\nfunction is4xxError(e) {\n  const status = e?.status;\n  return !!status && status >= 400 && status < 500;\n}\nfunction isNetworkError(e) {\n  const message = (`${e.message}${e.name}` || \"\").toLowerCase().replace(/\\s+/g, \"\");\n  return message.includes(\"networkerror\");\n}\nfunction isKnownError(error) {\n  return isClerkAPIResponseError(error) || isMetamaskError(error) || isClerkRuntimeError2(error);\n}\nfunction isClerkAPIResponseError(err) {\n  return err && \"clerkError\" in err;\n}\nfunction isClerkRuntimeError2(err) {\n  return \"clerkRuntimeError\" in err;\n}\nfunction isReverificationCancelledError(err) {\n  return isClerkRuntimeError2(err) && err.code === \"reverification_cancelled\";\n}\nfunction isMetamaskError(err) {\n  return \"code\" in err && [4001, 32602, 32603].includes(err.code) && \"message\" in err;\n}\nfunction isUserLockedError(err) {\n  return isClerkAPIResponseError(err) && err.errors?.[0]?.code === \"user_locked\";\n}\nfunction isPasswordPwnedError(err) {\n  return isClerkAPIResponseError(err) && err.errors?.[0]?.code === \"form_password_pwned\";\n}\nfunction isEmailLinkError(err) {\n  return err.name === \"EmailLinkError\";\n}\n\n\n//# sourceMappingURL=chunk-AXHU6TXE.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstQVhIVTZUWEUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQ0FBb0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsbUJBQW1CO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLFVBQVUsYUFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRLEVBQUU7O0FBRXZCLFNBQVMsS0FBSzs7QUFFZDtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxRQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFxRDtBQUNqRSxZQUFZLGlEQUFpRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDLFVBQVU7QUFDVixTQUFTO0FBQ1QscUJBQXFCO0FBQ3JCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEtBQTBLLEtBQUs7QUFDL0ssdUxBQXVMLEtBQUs7QUFDNUw7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDLENBQUM7QUFDRCw2QkFBNkIsNkJBQTZCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFJLElBQUksV0FBVztBQUNuQztBQUNBO0FBQ0EsMkNBQTJDLGtCQUFrQjtBQUM3RDtBQUNBO0FBQ0EsMkJBQTJCLEVBQUUsV0FBVztBQUN4QztBQUNBLGNBQWMsSUFBSSxJQUFJLElBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQkFBa0IsaUNBQWlDO0FBQ25ELG1EQUFtRDtBQUNuRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsTUFBTTtBQUMvQixxQkFBcUIsTUFBTTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVLEVBQUUsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTBCRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2NodW5rLUFYSFU2VFhFLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZXJyb3JzL2NyZWF0ZUVycm9yVHlwZUd1YXJkLnRzXG5mdW5jdGlvbiBjcmVhdGVFcnJvclR5cGVHdWFyZChFcnJvckNsYXNzKSB7XG4gIGZ1bmN0aW9uIHR5cGVHdWFyZChlcnJvcikge1xuICAgIGNvbnN0IHRhcmdldCA9IGVycm9yID8/IHRoaXM7XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7RXJyb3JDbGFzcy5raW5kIHx8IEVycm9yQ2xhc3MubmFtZX0gdHlwZSBndWFyZCByZXF1aXJlcyBhbiBlcnJvciBvYmplY3RgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIEVycm9yQ2xhc3M7XG4gIH1cbiAgcmV0dXJuIHR5cGVHdWFyZDtcbn1cblxuLy8gc3JjL2Vycm9ycy9jbGVya0FwaUVycm9yLnRzXG52YXIgQ2xlcmtBUElFcnJvciA9IGNsYXNzIHtcbiAgc3RhdGljIGtpbmQgPSBcIkNsZXJrQXBpRXJyb3JcIjtcbiAgY29kZTtcbiAgbWVzc2FnZTtcbiAgbG9uZ01lc3NhZ2U7XG4gIG1ldGE7XG4gIGNvbnN0cnVjdG9yKGpzb24pIHtcbiAgICBjb25zdCBwYXJzZWRFcnJvciA9IHRoaXMucGFyc2VKc29uRXJyb3IoanNvbik7XG4gICAgdGhpcy5jb2RlID0gcGFyc2VkRXJyb3IuY29kZTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBwYXJzZWRFcnJvci5tZXNzYWdlO1xuICAgIHRoaXMubG9uZ01lc3NhZ2UgPSBwYXJzZWRFcnJvci5sb25nTWVzc2FnZTtcbiAgICB0aGlzLm1ldGEgPSBwYXJzZWRFcnJvci5tZXRhO1xuICB9XG4gIHBhcnNlSnNvbkVycm9yKGpzb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29kZToganNvbi5jb2RlLFxuICAgICAgbWVzc2FnZToganNvbi5tZXNzYWdlLFxuICAgICAgbG9uZ01lc3NhZ2U6IGpzb24ubG9uZ19tZXNzYWdlLFxuICAgICAgbWV0YToge1xuICAgICAgICBwYXJhbU5hbWU6IGpzb24ubWV0YT8ucGFyYW1fbmFtZSxcbiAgICAgICAgc2Vzc2lvbklkOiBqc29uLm1ldGE/LnNlc3Npb25faWQsXG4gICAgICAgIGVtYWlsQWRkcmVzc2VzOiBqc29uLm1ldGE/LmVtYWlsX2FkZHJlc3NlcyxcbiAgICAgICAgaWRlbnRpZmllcnM6IGpzb24ubWV0YT8uaWRlbnRpZmllcnMsXG4gICAgICAgIHp4Y3ZibjoganNvbi5tZXRhPy56eGN2Ym4sXG4gICAgICAgIHBsYW46IGpzb24ubWV0YT8ucGxhbixcbiAgICAgICAgaXNQbGFuVXBncmFkZVBvc3NpYmxlOiBqc29uLm1ldGE/LmlzX3BsYW5fdXBncmFkZV9wb3NzaWJsZVxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG52YXIgaXNDbGVya0FwaUVycm9yID0gY3JlYXRlRXJyb3JUeXBlR3VhcmQoQ2xlcmtBUElFcnJvcik7XG5cbi8vIHNyYy9lcnJvcnMvcGFyc2VFcnJvci50c1xuZnVuY3Rpb24gcGFyc2VFcnJvcnMoZGF0YSA9IFtdKSB7XG4gIHJldHVybiBkYXRhLmxlbmd0aCA+IDAgPyBkYXRhLm1hcCgoZSkgPT4gbmV3IENsZXJrQVBJRXJyb3IoZSkpIDogW107XG59XG5mdW5jdGlvbiBwYXJzZUVycm9yKGVycm9yKSB7XG4gIHJldHVybiBuZXcgQ2xlcmtBUElFcnJvcihlcnJvcik7XG59XG5mdW5jdGlvbiBlcnJvclRvSlNPTihlcnJvcikge1xuICByZXR1cm4ge1xuICAgIGNvZGU6IGVycm9yPy5jb2RlIHx8IFwiXCIsXG4gICAgbWVzc2FnZTogZXJyb3I/Lm1lc3NhZ2UgfHwgXCJcIixcbiAgICBsb25nX21lc3NhZ2U6IGVycm9yPy5sb25nTWVzc2FnZSxcbiAgICBtZXRhOiB7XG4gICAgICBwYXJhbV9uYW1lOiBlcnJvcj8ubWV0YT8ucGFyYW1OYW1lLFxuICAgICAgc2Vzc2lvbl9pZDogZXJyb3I/Lm1ldGE/LnNlc3Npb25JZCxcbiAgICAgIGVtYWlsX2FkZHJlc3NlczogZXJyb3I/Lm1ldGE/LmVtYWlsQWRkcmVzc2VzLFxuICAgICAgaWRlbnRpZmllcnM6IGVycm9yPy5tZXRhPy5pZGVudGlmaWVycyxcbiAgICAgIHp4Y3ZibjogZXJyb3I/Lm1ldGE/Lnp4Y3ZibixcbiAgICAgIHBsYW46IGVycm9yPy5tZXRhPy5wbGFuLFxuICAgICAgaXNfcGxhbl91cGdyYWRlX3Bvc3NpYmxlOiBlcnJvcj8ubWV0YT8uaXNQbGFuVXBncmFkZVBvc3NpYmxlXG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvZXJyb3JzL2NsZXJrRXJyb3IudHNcbnZhciBfX0RFVl9fID0gdHJ1ZTtcbnZhciBDbGVya0Vycm9yID0gY2xhc3MgX0NsZXJrRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHN0YXRpYyBraW5kID0gXCJDbGVya0Vycm9yXCI7XG4gIGNsZXJrRXJyb3IgPSB0cnVlO1xuICBjb2RlO1xuICBsb25nTWVzc2FnZTtcbiAgZG9jc1VybDtcbiAgY2F1c2U7XG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG5ldy50YXJnZXQuZm9ybWF0TWVzc2FnZShuZXcudGFyZ2V0LmtpbmQsIG9wdHMubWVzc2FnZSwgb3B0cy5jb2RlLCBvcHRzLmRvY3NVcmwpLCB7IGNhdXNlOiBvcHRzLmNhdXNlIH0pO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBfQ2xlcmtFcnJvci5wcm90b3R5cGUpO1xuICAgIHRoaXMuY29kZSA9IG9wdHMuY29kZTtcbiAgICB0aGlzLmRvY3NVcmwgPSBvcHRzLmRvY3NVcmw7XG4gICAgdGhpcy5sb25nTWVzc2FnZSA9IG9wdHMubG9uZ01lc3NhZ2U7XG4gICAgdGhpcy5jYXVzZSA9IG9wdHMuY2F1c2U7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbJHt0aGlzLm5hbWV9XVxuTWVzc2FnZToke3RoaXMubWVzc2FnZX1gO1xuICB9XG4gIHN0YXRpYyBmb3JtYXRNZXNzYWdlKG5hbWUsIG1zZywgY29kZSwgZG9jc1VybCkge1xuICAgIGNvbnN0IHByZWZpeCA9IFwiQ2xlcms6XCI7XG4gICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHByZWZpeC5yZXBsYWNlKFwiIFwiLCBcIlxcXFxzKlwiKSwgXCJpXCIpO1xuICAgIG1zZyA9IG1zZy5yZXBsYWNlKHJlZ2V4LCBcIlwiKTtcbiAgICBtc2cgPSBgJHtwcmVmaXh9ICR7bXNnLnRyaW0oKX1cblxuKGNvZGU9XCIke2NvZGV9XCIpXG5cbmA7XG4gICAgaWYgKF9fREVWX18gJiYgZG9jc1VybCkge1xuICAgICAgbXNnICs9IGBcblxuRG9jczogJHtkb2NzVXJsfWA7XG4gICAgfVxuICAgIHJldHVybiBtc2c7XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvcnMvY2xlcmtBcGlSZXNwb25zZUVycm9yLnRzXG52YXIgQ2xlcmtBUElSZXNwb25zZUVycm9yID0gY2xhc3MgX0NsZXJrQVBJUmVzcG9uc2VFcnJvciBleHRlbmRzIENsZXJrRXJyb3Ige1xuICBzdGF0aWMga2luZCA9IFwiQ2xlcmtBUElSZXNwb25zZUVycm9yXCI7XG4gIHN0YXR1cztcbiAgY2xlcmtUcmFjZUlkO1xuICByZXRyeUFmdGVyO1xuICBlcnJvcnM7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGRhdGE6IGVycm9yc0pzb24sIHN0YXR1cywgY2xlcmtUcmFjZUlkLCByZXRyeUFmdGVyIH0gPSBvcHRpb25zO1xuICAgIHN1cGVyKHsgLi4ub3B0aW9ucywgbWVzc2FnZSwgY29kZTogXCJhcGlfcmVzcG9uc2VfZXJyb3JcIiB9KTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgX0NsZXJrQVBJUmVzcG9uc2VFcnJvci5wcm90b3R5cGUpO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuY2xlcmtUcmFjZUlkID0gY2xlcmtUcmFjZUlkO1xuICAgIHRoaXMucmV0cnlBZnRlciA9IHJldHJ5QWZ0ZXI7XG4gICAgdGhpcy5lcnJvcnMgPSAoZXJyb3JzSnNvbiB8fCBbXSkubWFwKChlKSA9PiBuZXcgQ2xlcmtBUElFcnJvcihlKSk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBgWyR7dGhpcy5uYW1lfV1cbk1lc3NhZ2U6JHt0aGlzLm1lc3NhZ2V9XG5TdGF0dXM6JHt0aGlzLnN0YXR1c31cblNlcmlhbGl6ZWQgZXJyb3JzOiAke3RoaXMuZXJyb3JzLm1hcChcbiAgICAgIChlKSA9PiBKU09OLnN0cmluZ2lmeShlKVxuICAgICl9YDtcbiAgICBpZiAodGhpcy5jbGVya1RyYWNlSWQpIHtcbiAgICAgIG1lc3NhZ2UgKz0gYFxuQ2xlcmsgVHJhY2UgSUQ6ICR7dGhpcy5jbGVya1RyYWNlSWR9YDtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgLy8gT3ZlcnJpZGUgZm9ybWF0TWVzc2FnZSB0byBrZWVwIGl0IHVuZm9ybWF0dGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gIHN0YXRpYyBmb3JtYXRNZXNzYWdlKG5hbWUsIG1zZywgXywgX18pIHtcbiAgICByZXR1cm4gbXNnO1xuICB9XG59O1xudmFyIGlzQ2xlcmtBcGlSZXNwb25zZUVycm9yID0gY3JlYXRlRXJyb3JUeXBlR3VhcmQoQ2xlcmtBUElSZXNwb25zZUVycm9yKTtcblxuLy8gc3JjL2Vycm9ycy9lcnJvclRocm93ZXIudHNcbnZhciBEZWZhdWx0TWVzc2FnZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgSW52YWxpZFByb3h5VXJsRXJyb3JNZXNzYWdlOiBgVGhlIHByb3h5VXJsIHBhc3NlZCB0byBDbGVyayBpcyBpbnZhbGlkLiBUaGUgZXhwZWN0ZWQgdmFsdWUgZm9yIHByb3h5VXJsIGlzIGFuIGFic29sdXRlIFVSTCBvciBhIHJlbGF0aXZlIHBhdGggd2l0aCBhIGxlYWRpbmcgJy8nLiAoa2V5PXt7dXJsfX0pYCxcbiAgSW52YWxpZFB1Ymxpc2hhYmxlS2V5RXJyb3JNZXNzYWdlOiBgVGhlIHB1Ymxpc2hhYmxlS2V5IHBhc3NlZCB0byBDbGVyayBpcyBpbnZhbGlkLiBZb3UgY2FuIGdldCB5b3VyIFB1Ymxpc2hhYmxlIGtleSBhdCBodHRwczovL2Rhc2hib2FyZC5jbGVyay5jb20vbGFzdC1hY3RpdmU/cGF0aD1hcGkta2V5cy4gKGtleT17e2tleX19KWAsXG4gIE1pc3NpbmdQdWJsaXNoYWJsZUtleUVycm9yTWVzc2FnZTogYE1pc3NpbmcgcHVibGlzaGFibGVLZXkuIFlvdSBjYW4gZ2V0IHlvdXIga2V5IGF0IGh0dHBzOi8vZGFzaGJvYXJkLmNsZXJrLmNvbS9sYXN0LWFjdGl2ZT9wYXRoPWFwaS1rZXlzLmAsXG4gIE1pc3NpbmdTZWNyZXRLZXlFcnJvck1lc3NhZ2U6IGBNaXNzaW5nIHNlY3JldEtleS4gWW91IGNhbiBnZXQgeW91ciBrZXkgYXQgaHR0cHM6Ly9kYXNoYm9hcmQuY2xlcmsuY29tL2xhc3QtYWN0aXZlP3BhdGg9YXBpLWtleXMuYCxcbiAgTWlzc2luZ0NsZXJrUHJvdmlkZXI6IGB7e3NvdXJjZX19IGNhbiBvbmx5IGJlIHVzZWQgd2l0aGluIHRoZSA8Q2xlcmtQcm92aWRlciAvPiBjb21wb25lbnQuIExlYXJuIG1vcmU6IGh0dHBzOi8vY2xlcmsuY29tL2RvY3MvY29tcG9uZW50cy9jbGVyay1wcm92aWRlcmBcbn0pO1xuZnVuY3Rpb24gYnVpbGRFcnJvclRocm93ZXIoeyBwYWNrYWdlTmFtZSwgY3VzdG9tTWVzc2FnZXMgfSkge1xuICBsZXQgcGtnID0gcGFja2FnZU5hbWU7XG4gIGZ1bmN0aW9uIGJ1aWxkTWVzc2FnZShyYXdNZXNzYWdlLCByZXBsYWNlbWVudHMpIHtcbiAgICBpZiAoIXJlcGxhY2VtZW50cykge1xuICAgICAgcmV0dXJuIGAke3BrZ306ICR7cmF3TWVzc2FnZX1gO1xuICAgIH1cbiAgICBsZXQgbXNnID0gcmF3TWVzc2FnZTtcbiAgICBjb25zdCBtYXRjaGVzID0gcmF3TWVzc2FnZS5tYXRjaEFsbCgve3soW2EtekEtWjAtOS1fXSspfX0vZyk7XG4gICAgZm9yIChjb25zdCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudCA9IChyZXBsYWNlbWVudHNbbWF0Y2hbMV1dIHx8IFwiXCIpLnRvU3RyaW5nKCk7XG4gICAgICBtc2cgPSBtc2cucmVwbGFjZShge3ske21hdGNoWzFdfX19YCwgcmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gYCR7cGtnfTogJHttc2d9YDtcbiAgfVxuICBjb25zdCBtZXNzYWdlcyA9IHtcbiAgICAuLi5EZWZhdWx0TWVzc2FnZXMsXG4gICAgLi4uY3VzdG9tTWVzc2FnZXNcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBzZXRQYWNrYWdlTmFtZSh7IHBhY2thZ2VOYW1lOiBwYWNrYWdlTmFtZTIgfSkge1xuICAgICAgaWYgKHR5cGVvZiBwYWNrYWdlTmFtZTIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcGtnID0gcGFja2FnZU5hbWUyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzZXRNZXNzYWdlcyh7IGN1c3RvbU1lc3NhZ2VzOiBjdXN0b21NZXNzYWdlczIgfSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihtZXNzYWdlcywgY3VzdG9tTWVzc2FnZXMyIHx8IHt9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgdGhyb3dJbnZhbGlkUHVibGlzaGFibGVLZXlFcnJvcihwYXJhbXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihidWlsZE1lc3NhZ2UobWVzc2FnZXMuSW52YWxpZFB1Ymxpc2hhYmxlS2V5RXJyb3JNZXNzYWdlLCBwYXJhbXMpKTtcbiAgICB9LFxuICAgIHRocm93SW52YWxpZFByb3h5VXJsKHBhcmFtcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGJ1aWxkTWVzc2FnZShtZXNzYWdlcy5JbnZhbGlkUHJveHlVcmxFcnJvck1lc3NhZ2UsIHBhcmFtcykpO1xuICAgIH0sXG4gICAgdGhyb3dNaXNzaW5nUHVibGlzaGFibGVLZXlFcnJvcigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihidWlsZE1lc3NhZ2UobWVzc2FnZXMuTWlzc2luZ1B1Ymxpc2hhYmxlS2V5RXJyb3JNZXNzYWdlKSk7XG4gICAgfSxcbiAgICB0aHJvd01pc3NpbmdTZWNyZXRLZXlFcnJvcigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihidWlsZE1lc3NhZ2UobWVzc2FnZXMuTWlzc2luZ1NlY3JldEtleUVycm9yTWVzc2FnZSkpO1xuICAgIH0sXG4gICAgdGhyb3dNaXNzaW5nQ2xlcmtQcm92aWRlckVycm9yKHBhcmFtcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGJ1aWxkTWVzc2FnZShtZXNzYWdlcy5NaXNzaW5nQ2xlcmtQcm92aWRlciwgcGFyYW1zKSk7XG4gICAgfSxcbiAgICB0aHJvdyhtZXNzYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYnVpbGRNZXNzYWdlKG1lc3NhZ2UpKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9lcnJvcnMvZW1haWxMaW5rRXJyb3IudHNcbnZhciBFbWFpbExpbmtFcnJvciA9IGNsYXNzIF9FbWFpbExpbmtFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29kZTtcbiAgY29uc3RydWN0b3IoY29kZSkge1xuICAgIHN1cGVyKGNvZGUpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5uYW1lID0gXCJFbWFpbExpbmtFcnJvclwiO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBfRW1haWxMaW5rRXJyb3IucHJvdG90eXBlKTtcbiAgfVxufTtcbnZhciBFbWFpbExpbmtFcnJvckNvZGUgPSB7XG4gIEV4cGlyZWQ6IFwiZXhwaXJlZFwiLFxuICBGYWlsZWQ6IFwiZmFpbGVkXCIsXG4gIENsaWVudE1pc21hdGNoOiBcImNsaWVudF9taXNtYXRjaFwiXG59O1xudmFyIEVtYWlsTGlua0Vycm9yQ29kZVN0YXR1cyA9IHtcbiAgRXhwaXJlZDogXCJleHBpcmVkXCIsXG4gIEZhaWxlZDogXCJmYWlsZWRcIixcbiAgQ2xpZW50TWlzbWF0Y2g6IFwiY2xpZW50X21pc21hdGNoXCJcbn07XG5cbi8vIHNyYy9lcnJvcnMvY2xlcmtSdW50aW1lRXJyb3IudHNcbnZhciBDbGVya1J1bnRpbWVFcnJvciA9IGNsYXNzIF9DbGVya1J1bnRpbWVFcnJvciBleHRlbmRzIENsZXJrRXJyb3Ige1xuICBzdGF0aWMga2luZCA9IFwiQ2xlcmtSdW50aW1lRXJyb3JcIjtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgY2xlcmtFcnJvcmAgcHJvcGVydHkgaW5zdGVhZC4gVGhpcyBwcm9wZXJ0eSBpcyBtYWludGFpbmVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgKi9cbiAgY2xlcmtSdW50aW1lRXJyb3IgPSB0cnVlO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoeyAuLi5vcHRpb25zLCBtZXNzYWdlIH0pO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBfQ2xlcmtSdW50aW1lRXJyb3IucHJvdG90eXBlKTtcbiAgfVxufTtcbnZhciBpc0NsZXJrUnVudGltZUVycm9yID0gY3JlYXRlRXJyb3JUeXBlR3VhcmQoQ2xlcmtSdW50aW1lRXJyb3IpO1xuXG4vLyBzcmMvZXJyb3JzL3dlYkF1dGhORXJyb3IudHNcbnZhciBDbGVya1dlYkF1dGhuRXJyb3IgPSBjbGFzcyBleHRlbmRzIENsZXJrUnVudGltZUVycm9yIHtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIGNvZGUgaWRlbnRpZnlpbmcgdGhlIGVycm9yLCBjYW4gYmUgdXNlZCBmb3IgbG9jYWxpemF0aW9uLlxuICAgKi9cbiAgY29kZTtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgeyBjb2RlIH0pIHtcbiAgICBzdXBlcihtZXNzYWdlLCB7IGNvZGUgfSk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy9oZWxwZXJzLnRzXG5mdW5jdGlvbiBpc1VuYXV0aG9yaXplZEVycm9yKGUpIHtcbiAgY29uc3Qgc3RhdHVzID0gZT8uc3RhdHVzO1xuICBjb25zdCBjb2RlID0gZT8uZXJyb3JzPy5bMF0/LmNvZGU7XG4gIHJldHVybiBjb2RlID09PSBcImF1dGhlbnRpY2F0aW9uX2ludmFsaWRcIiAmJiBzdGF0dXMgPT09IDQwMTtcbn1cbmZ1bmN0aW9uIGlzQ2FwdGNoYUVycm9yKGUpIHtcbiAgcmV0dXJuIFtcImNhcHRjaGFfaW52YWxpZFwiLCBcImNhcHRjaGFfbm90X2VuYWJsZWRcIiwgXCJjYXB0Y2hhX21pc3NpbmdfdG9rZW5cIl0uaW5jbHVkZXMoZS5lcnJvcnNbMF0uY29kZSk7XG59XG5mdW5jdGlvbiBpczR4eEVycm9yKGUpIHtcbiAgY29uc3Qgc3RhdHVzID0gZT8uc3RhdHVzO1xuICByZXR1cm4gISFzdGF0dXMgJiYgc3RhdHVzID49IDQwMCAmJiBzdGF0dXMgPCA1MDA7XG59XG5mdW5jdGlvbiBpc05ldHdvcmtFcnJvcihlKSB7XG4gIGNvbnN0IG1lc3NhZ2UgPSAoYCR7ZS5tZXNzYWdlfSR7ZS5uYW1lfWAgfHwgXCJcIikudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csIFwiXCIpO1xuICByZXR1cm4gbWVzc2FnZS5pbmNsdWRlcyhcIm5ldHdvcmtlcnJvclwiKTtcbn1cbmZ1bmN0aW9uIGlzS25vd25FcnJvcihlcnJvcikge1xuICByZXR1cm4gaXNDbGVya0FQSVJlc3BvbnNlRXJyb3IoZXJyb3IpIHx8IGlzTWV0YW1hc2tFcnJvcihlcnJvcikgfHwgaXNDbGVya1J1bnRpbWVFcnJvcjIoZXJyb3IpO1xufVxuZnVuY3Rpb24gaXNDbGVya0FQSVJlc3BvbnNlRXJyb3IoZXJyKSB7XG4gIHJldHVybiBlcnIgJiYgXCJjbGVya0Vycm9yXCIgaW4gZXJyO1xufVxuZnVuY3Rpb24gaXNDbGVya1J1bnRpbWVFcnJvcjIoZXJyKSB7XG4gIHJldHVybiBcImNsZXJrUnVudGltZUVycm9yXCIgaW4gZXJyO1xufVxuZnVuY3Rpb24gaXNSZXZlcmlmaWNhdGlvbkNhbmNlbGxlZEVycm9yKGVycikge1xuICByZXR1cm4gaXNDbGVya1J1bnRpbWVFcnJvcjIoZXJyKSAmJiBlcnIuY29kZSA9PT0gXCJyZXZlcmlmaWNhdGlvbl9jYW5jZWxsZWRcIjtcbn1cbmZ1bmN0aW9uIGlzTWV0YW1hc2tFcnJvcihlcnIpIHtcbiAgcmV0dXJuIFwiY29kZVwiIGluIGVyciAmJiBbNDAwMSwgMzI2MDIsIDMyNjAzXS5pbmNsdWRlcyhlcnIuY29kZSkgJiYgXCJtZXNzYWdlXCIgaW4gZXJyO1xufVxuZnVuY3Rpb24gaXNVc2VyTG9ja2VkRXJyb3IoZXJyKSB7XG4gIHJldHVybiBpc0NsZXJrQVBJUmVzcG9uc2VFcnJvcihlcnIpICYmIGVyci5lcnJvcnM/LlswXT8uY29kZSA9PT0gXCJ1c2VyX2xvY2tlZFwiO1xufVxuZnVuY3Rpb24gaXNQYXNzd29yZFB3bmVkRXJyb3IoZXJyKSB7XG4gIHJldHVybiBpc0NsZXJrQVBJUmVzcG9uc2VFcnJvcihlcnIpICYmIGVyci5lcnJvcnM/LlswXT8uY29kZSA9PT0gXCJmb3JtX3Bhc3N3b3JkX3B3bmVkXCI7XG59XG5mdW5jdGlvbiBpc0VtYWlsTGlua0Vycm9yKGVycikge1xuICByZXR1cm4gZXJyLm5hbWUgPT09IFwiRW1haWxMaW5rRXJyb3JcIjtcbn1cblxuZXhwb3J0IHtcbiAgQ2xlcmtBUElFcnJvcixcbiAgcGFyc2VFcnJvcnMsXG4gIHBhcnNlRXJyb3IsXG4gIGVycm9yVG9KU09OLFxuICBDbGVya0FQSVJlc3BvbnNlRXJyb3IsXG4gIGJ1aWxkRXJyb3JUaHJvd2VyLFxuICBFbWFpbExpbmtFcnJvcixcbiAgRW1haWxMaW5rRXJyb3JDb2RlLFxuICBFbWFpbExpbmtFcnJvckNvZGVTdGF0dXMsXG4gIENsZXJrUnVudGltZUVycm9yLFxuICBDbGVya1dlYkF1dGhuRXJyb3IsXG4gIGlzVW5hdXRob3JpemVkRXJyb3IsXG4gIGlzQ2FwdGNoYUVycm9yLFxuICBpczR4eEVycm9yLFxuICBpc05ldHdvcmtFcnJvcixcbiAgaXNLbm93bkVycm9yLFxuICBpc0NsZXJrQVBJUmVzcG9uc2VFcnJvcixcbiAgaXNDbGVya1J1bnRpbWVFcnJvcjIgYXMgaXNDbGVya1J1bnRpbWVFcnJvcixcbiAgaXNSZXZlcmlmaWNhdGlvbkNhbmNlbGxlZEVycm9yLFxuICBpc01ldGFtYXNrRXJyb3IsXG4gIGlzVXNlckxvY2tlZEVycm9yLFxuICBpc1Bhc3N3b3JkUHduZWRFcnJvcixcbiAgaXNFbWFpbExpbmtFcnJvclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLUFYSFU2VFhFLm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-AXHU6TXE.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-CFXQSUF6.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-CFXQSUF6.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyFunctionToObj: () => (/* binding */ applyFunctionToObj),\n/* harmony export */   filterProps: () => (/* binding */ filterProps),\n/* harmony export */   removeUndefined: () => (/* binding */ removeUndefined),\n/* harmony export */   without: () => (/* binding */ without)\n/* harmony export */ });\n// src/object.ts\nvar without = (obj, ...props) => {\n  const copy = { ...obj };\n  for (const prop of props) {\n    delete copy[prop];\n  }\n  return copy;\n};\nvar removeUndefined = (obj) => {\n  return Object.entries(obj).reduce((acc, [key, value]) => {\n    if (value !== void 0 && value !== null) {\n      acc[key] = value;\n    }\n    return acc;\n  }, {});\n};\nvar applyFunctionToObj = (obj, fn) => {\n  const result = {};\n  for (const key in obj) {\n    result[key] = fn(obj[key], key);\n  }\n  return result;\n};\nvar filterProps = (obj, filter) => {\n  const result = {};\n  for (const key in obj) {\n    if (obj[key] && filter(obj[key])) {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n};\n\n\n//# sourceMappingURL=chunk-CFXQSUF6.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstQ0ZYUVNVRjYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU9FO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstQ0ZYUVNVRjYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9vYmplY3QudHNcbnZhciB3aXRob3V0ID0gKG9iaiwgLi4ucHJvcHMpID0+IHtcbiAgY29uc3QgY29weSA9IHsgLi4ub2JqIH07XG4gIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wcykge1xuICAgIGRlbGV0ZSBjb3B5W3Byb3BdO1xuICB9XG4gIHJldHVybiBjb3B5O1xufTtcbnZhciByZW1vdmVVbmRlZmluZWQgPSAob2JqKSA9PiB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhvYmopLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufTtcbnZhciBhcHBseUZ1bmN0aW9uVG9PYmogPSAob2JqLCBmbikgPT4ge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgcmVzdWx0W2tleV0gPSBmbihvYmpba2V5XSwga2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBmaWx0ZXJQcm9wcyA9IChvYmosIGZpbHRlcikgPT4ge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKG9ialtrZXldICYmIGZpbHRlcihvYmpba2V5XSkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gb2JqW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQge1xuICB3aXRob3V0LFxuICByZW1vdmVVbmRlZmluZWQsXG4gIGFwcGx5RnVuY3Rpb25Ub09iaixcbiAgZmlsdGVyUHJvcHNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1DRlhRU1VGNi5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-CFXQSUF6.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-ELKNO6YM.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-ELKNO6YM.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getMajorVersion: () => (/* binding */ getMajorVersion),\n/* harmony export */   versionSelector: () => (/* binding */ versionSelector)\n/* harmony export */ });\n// src/versionSelector.ts\nvar versionSelector = (clerkJSVersion, packageVersion = \"5.102.1\") => {\n  if (clerkJSVersion) {\n    return clerkJSVersion;\n  }\n  const prereleaseTag = getPrereleaseTag(packageVersion);\n  if (prereleaseTag) {\n    if (prereleaseTag === \"snapshot\") {\n      return \"5.102.1\";\n    }\n    return prereleaseTag;\n  }\n  return getMajorVersion(packageVersion);\n};\nvar getPrereleaseTag = (packageVersion) => packageVersion.trim().replace(/^v/, \"\").match(/-(.+?)(\\.|$)/)?.[1];\nvar getMajorVersion = (packageVersion) => packageVersion.trim().replace(/^v/, \"\").split(\".\")[0];\n\n\n//# sourceMappingURL=chunk-ELKNO6YM.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstRUxLTk82WU0ubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2lzaGFxYmVsbG8vV2Vic2l0ZS9oYXZlbnJpZGVfZnVsbF9hcHAvbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9jaHVuay1FTEtOTzZZTS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3ZlcnNpb25TZWxlY3Rvci50c1xudmFyIHZlcnNpb25TZWxlY3RvciA9IChjbGVya0pTVmVyc2lvbiwgcGFja2FnZVZlcnNpb24gPSBcIjUuMTAyLjFcIikgPT4ge1xuICBpZiAoY2xlcmtKU1ZlcnNpb24pIHtcbiAgICByZXR1cm4gY2xlcmtKU1ZlcnNpb247XG4gIH1cbiAgY29uc3QgcHJlcmVsZWFzZVRhZyA9IGdldFByZXJlbGVhc2VUYWcocGFja2FnZVZlcnNpb24pO1xuICBpZiAocHJlcmVsZWFzZVRhZykge1xuICAgIGlmIChwcmVyZWxlYXNlVGFnID09PSBcInNuYXBzaG90XCIpIHtcbiAgICAgIHJldHVybiBcIjUuMTAyLjFcIjtcbiAgICB9XG4gICAgcmV0dXJuIHByZXJlbGVhc2VUYWc7XG4gIH1cbiAgcmV0dXJuIGdldE1ham9yVmVyc2lvbihwYWNrYWdlVmVyc2lvbik7XG59O1xudmFyIGdldFByZXJlbGVhc2VUYWcgPSAocGFja2FnZVZlcnNpb24pID0+IHBhY2thZ2VWZXJzaW9uLnRyaW0oKS5yZXBsYWNlKC9edi8sIFwiXCIpLm1hdGNoKC8tKC4rPykoXFwufCQpLyk/LlsxXTtcbnZhciBnZXRNYWpvclZlcnNpb24gPSAocGFja2FnZVZlcnNpb24pID0+IHBhY2thZ2VWZXJzaW9uLnRyaW0oKS5yZXBsYWNlKC9edi8sIFwiXCIpLnNwbGl0KFwiLlwiKVswXTtcblxuZXhwb3J0IHtcbiAgdmVyc2lvblNlbGVjdG9yLFxuICBnZXRNYWpvclZlcnNpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1FTEtOTzZZTS5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-ELKNO6YM.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-GGFRMWFO.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-GGFRMWFO.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   camelToSnake: () => (/* binding */ camelToSnake),\n/* harmony export */   deepCamelToSnake: () => (/* binding */ deepCamelToSnake),\n/* harmony export */   deepSnakeToCamel: () => (/* binding */ deepSnakeToCamel),\n/* harmony export */   getNonUndefinedValues: () => (/* binding */ getNonUndefinedValues),\n/* harmony export */   isIPV4Address: () => (/* binding */ isIPV4Address),\n/* harmony export */   isTruthy: () => (/* binding */ isTruthy),\n/* harmony export */   snakeToCamel: () => (/* binding */ snakeToCamel),\n/* harmony export */   titleize: () => (/* binding */ titleize),\n/* harmony export */   toSentence: () => (/* binding */ toSentence)\n/* harmony export */ });\n// src/underscore.ts\nvar toSentence = (items) => {\n  if (items.length == 0) {\n    return \"\";\n  }\n  if (items.length == 1) {\n    return items[0];\n  }\n  let sentence = items.slice(0, -1).join(\", \");\n  sentence += `, or ${items.slice(-1)}`;\n  return sentence;\n};\nvar IP_V4_ADDRESS_REGEX = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;\nfunction isIPV4Address(str) {\n  return IP_V4_ADDRESS_REGEX.test(str || \"\");\n}\nfunction titleize(str) {\n  const s = str || \"\";\n  return s.charAt(0).toUpperCase() + s.slice(1);\n}\nfunction snakeToCamel(str) {\n  return str ? str.replace(/([-_][a-z])/g, (match) => match.toUpperCase().replace(/-|_/, \"\")) : \"\";\n}\nfunction camelToSnake(str) {\n  return str ? str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`) : \"\";\n}\nvar createDeepObjectTransformer = (transform) => {\n  const deepTransform = (obj) => {\n    if (!obj) {\n      return obj;\n    }\n    if (Array.isArray(obj)) {\n      return obj.map((el) => {\n        if (typeof el === \"object\" || Array.isArray(el)) {\n          return deepTransform(el);\n        }\n        return el;\n      });\n    }\n    const copy = { ...obj };\n    const keys = Object.keys(copy);\n    for (const oldName of keys) {\n      const newName = transform(oldName.toString());\n      if (newName !== oldName) {\n        copy[newName] = copy[oldName];\n        delete copy[oldName];\n      }\n      if (typeof copy[newName] === \"object\") {\n        copy[newName] = deepTransform(copy[newName]);\n      }\n    }\n    return copy;\n  };\n  return deepTransform;\n};\nvar deepCamelToSnake = createDeepObjectTransformer(camelToSnake);\nvar deepSnakeToCamel = createDeepObjectTransformer(snakeToCamel);\nfunction isTruthy(value) {\n  if (typeof value === `boolean`) {\n    return value;\n  }\n  if (value === void 0 || value === null) {\n    return false;\n  }\n  if (typeof value === `string`) {\n    if (value.toLowerCase() === `true`) {\n      return true;\n    }\n    if (value.toLowerCase() === `false`) {\n      return false;\n    }\n  }\n  const number = parseInt(value, 10);\n  if (isNaN(number)) {\n    return false;\n  }\n  if (number > 0) {\n    return true;\n  }\n  return false;\n}\nfunction getNonUndefinedValues(obj) {\n  return Object.entries(obj).reduce((acc, [key, value]) => {\n    if (value !== void 0) {\n      acc[key] = value;\n    }\n    return acc;\n  }, {});\n}\n\n\n//# sourceMappingURL=chunk-GGFRMWFO.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstR0dGUk1XRk8ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxxQkFBcUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDs7QUFZRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2NodW5rLUdHRlJNV0ZPLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdW5kZXJzY29yZS50c1xudmFyIHRvU2VudGVuY2UgPSAoaXRlbXMpID0+IHtcbiAgaWYgKGl0ZW1zLmxlbmd0aCA9PSAwKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgaWYgKGl0ZW1zLmxlbmd0aCA9PSAxKSB7XG4gICAgcmV0dXJuIGl0ZW1zWzBdO1xuICB9XG4gIGxldCBzZW50ZW5jZSA9IGl0ZW1zLnNsaWNlKDAsIC0xKS5qb2luKFwiLCBcIik7XG4gIHNlbnRlbmNlICs9IGAsIG9yICR7aXRlbXMuc2xpY2UoLTEpfWA7XG4gIHJldHVybiBzZW50ZW5jZTtcbn07XG52YXIgSVBfVjRfQUREUkVTU19SRUdFWCA9IC9eKDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4oMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFwuKDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPykkLztcbmZ1bmN0aW9uIGlzSVBWNEFkZHJlc3Moc3RyKSB7XG4gIHJldHVybiBJUF9WNF9BRERSRVNTX1JFR0VYLnRlc3Qoc3RyIHx8IFwiXCIpO1xufVxuZnVuY3Rpb24gdGl0bGVpemUoc3RyKSB7XG4gIGNvbnN0IHMgPSBzdHIgfHwgXCJcIjtcbiAgcmV0dXJuIHMuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzLnNsaWNlKDEpO1xufVxuZnVuY3Rpb24gc25ha2VUb0NhbWVsKHN0cikge1xuICByZXR1cm4gc3RyID8gc3RyLnJlcGxhY2UoLyhbLV9dW2Etel0pL2csIChtYXRjaCkgPT4gbWF0Y2gudG9VcHBlckNhc2UoKS5yZXBsYWNlKC8tfF8vLCBcIlwiKSkgOiBcIlwiO1xufVxuZnVuY3Rpb24gY2FtZWxUb1NuYWtlKHN0cikge1xuICByZXR1cm4gc3RyID8gc3RyLnJlcGxhY2UoL1tBLVpdL2csIChsZXR0ZXIpID0+IGBfJHtsZXR0ZXIudG9Mb3dlckNhc2UoKX1gKSA6IFwiXCI7XG59XG52YXIgY3JlYXRlRGVlcE9iamVjdFRyYW5zZm9ybWVyID0gKHRyYW5zZm9ybSkgPT4ge1xuICBjb25zdCBkZWVwVHJhbnNmb3JtID0gKG9iaikgPT4ge1xuICAgIGlmICghb2JqKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICByZXR1cm4gb2JqLm1hcCgoZWwpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbCA9PT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KGVsKSkge1xuICAgICAgICAgIHJldHVybiBkZWVwVHJhbnNmb3JtKGVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgY29weSA9IHsgLi4ub2JqIH07XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGNvcHkpO1xuICAgIGZvciAoY29uc3Qgb2xkTmFtZSBvZiBrZXlzKSB7XG4gICAgICBjb25zdCBuZXdOYW1lID0gdHJhbnNmb3JtKG9sZE5hbWUudG9TdHJpbmcoKSk7XG4gICAgICBpZiAobmV3TmFtZSAhPT0gb2xkTmFtZSkge1xuICAgICAgICBjb3B5W25ld05hbWVdID0gY29weVtvbGROYW1lXTtcbiAgICAgICAgZGVsZXRlIGNvcHlbb2xkTmFtZV07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNvcHlbbmV3TmFtZV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29weVtuZXdOYW1lXSA9IGRlZXBUcmFuc2Zvcm0oY29weVtuZXdOYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xuICB9O1xuICByZXR1cm4gZGVlcFRyYW5zZm9ybTtcbn07XG52YXIgZGVlcENhbWVsVG9TbmFrZSA9IGNyZWF0ZURlZXBPYmplY3RUcmFuc2Zvcm1lcihjYW1lbFRvU25ha2UpO1xudmFyIGRlZXBTbmFrZVRvQ2FtZWwgPSBjcmVhdGVEZWVwT2JqZWN0VHJhbnNmb3JtZXIoc25ha2VUb0NhbWVsKTtcbmZ1bmN0aW9uIGlzVHJ1dGh5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IGBib29sZWFuYCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBgc3RyaW5nYCkge1xuICAgIGlmICh2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBgdHJ1ZWApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gYGZhbHNlYCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBjb25zdCBudW1iZXIgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICBpZiAoaXNOYU4obnVtYmVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobnVtYmVyID4gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldE5vblVuZGVmaW5lZFZhbHVlcyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG9iaikucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbmV4cG9ydCB7XG4gIHRvU2VudGVuY2UsXG4gIGlzSVBWNEFkZHJlc3MsXG4gIHRpdGxlaXplLFxuICBzbmFrZVRvQ2FtZWwsXG4gIGNhbWVsVG9TbmFrZSxcbiAgZGVlcENhbWVsVG9TbmFrZSxcbiAgZGVlcFNuYWtlVG9DYW1lbCxcbiAgaXNUcnV0aHksXG4gIGdldE5vblVuZGVmaW5lZFZhbHVlc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLUdHRlJNV0ZPLm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-GGFRMWFO.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-GVKBGR5N.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-GVKBGR5N.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEventBus: () => (/* binding */ createEventBus)\n/* harmony export */ });\n// src/eventBus.ts\nvar _on = (eventToHandlersMap, latestPayloadMap, event, handler, opts) => {\n  const { notify } = opts || {};\n  let handlers = eventToHandlersMap.get(event);\n  if (!handlers) {\n    handlers = [];\n    eventToHandlersMap.set(event, handlers);\n  }\n  handlers.push(handler);\n  if (notify && latestPayloadMap.has(event)) {\n    handler(latestPayloadMap.get(event));\n  }\n};\nvar _dispatch = (eventToHandlersMap, event, payload) => (eventToHandlersMap.get(event) || []).map((h) => h(payload));\nvar _off = (eventToHandlersMap, event, handler) => {\n  const handlers = eventToHandlersMap.get(event);\n  if (handlers) {\n    if (handler) {\n      handlers.splice(handlers.indexOf(handler) >>> 0, 1);\n    } else {\n      eventToHandlersMap.set(event, []);\n    }\n  }\n};\nvar createEventBus = () => {\n  const eventToHandlersMap = /* @__PURE__ */ new Map();\n  const latestPayloadMap = /* @__PURE__ */ new Map();\n  const eventToPredispatchHandlersMap = /* @__PURE__ */ new Map();\n  const emit = (event, payload) => {\n    latestPayloadMap.set(event, payload);\n    _dispatch(eventToPredispatchHandlersMap, event, payload);\n    _dispatch(eventToHandlersMap, event, payload);\n  };\n  return {\n    // Subscribe to an event\n    on: (...args) => _on(eventToHandlersMap, latestPayloadMap, ...args),\n    // Subscribe to an event with priority\n    // Registered handlers with `prioritizedOn` will be called before handlers registered with `on`\n    prioritizedOn: (...args) => _on(eventToPredispatchHandlersMap, latestPayloadMap, ...args),\n    // Dispatch an event\n    emit,\n    // Unsubscribe from an event\n    off: (...args) => _off(eventToHandlersMap, ...args),\n    // Unsubscribe from an event with priority\n    // Unsubscribes handlers only registered with `prioritizedOn`\n    prioritizedOff: (...args) => _off(eventToPredispatchHandlersMap, ...args),\n    // Internal utilities\n    internal: {\n      retrieveListeners: (event) => eventToHandlersMap.get(event) || []\n    }\n  };\n};\n\n\n//# sourceMappingURL=chunk-GVKBGR5N.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstR1ZLQkdSNU4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2lzaGFxYmVsbG8vV2Vic2l0ZS9oYXZlbnJpZGVfZnVsbF9hcHAvbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9jaHVuay1HVktCR1I1Ti5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2V2ZW50QnVzLnRzXG52YXIgX29uID0gKGV2ZW50VG9IYW5kbGVyc01hcCwgbGF0ZXN0UGF5bG9hZE1hcCwgZXZlbnQsIGhhbmRsZXIsIG9wdHMpID0+IHtcbiAgY29uc3QgeyBub3RpZnkgfSA9IG9wdHMgfHwge307XG4gIGxldCBoYW5kbGVycyA9IGV2ZW50VG9IYW5kbGVyc01hcC5nZXQoZXZlbnQpO1xuICBpZiAoIWhhbmRsZXJzKSB7XG4gICAgaGFuZGxlcnMgPSBbXTtcbiAgICBldmVudFRvSGFuZGxlcnNNYXAuc2V0KGV2ZW50LCBoYW5kbGVycyk7XG4gIH1cbiAgaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgaWYgKG5vdGlmeSAmJiBsYXRlc3RQYXlsb2FkTWFwLmhhcyhldmVudCkpIHtcbiAgICBoYW5kbGVyKGxhdGVzdFBheWxvYWRNYXAuZ2V0KGV2ZW50KSk7XG4gIH1cbn07XG52YXIgX2Rpc3BhdGNoID0gKGV2ZW50VG9IYW5kbGVyc01hcCwgZXZlbnQsIHBheWxvYWQpID0+IChldmVudFRvSGFuZGxlcnNNYXAuZ2V0KGV2ZW50KSB8fCBbXSkubWFwKChoKSA9PiBoKHBheWxvYWQpKTtcbnZhciBfb2ZmID0gKGV2ZW50VG9IYW5kbGVyc01hcCwgZXZlbnQsIGhhbmRsZXIpID0+IHtcbiAgY29uc3QgaGFuZGxlcnMgPSBldmVudFRvSGFuZGxlcnNNYXAuZ2V0KGV2ZW50KTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXJzLnNwbGljZShoYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpID4+PiAwLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnRUb0hhbmRsZXJzTWFwLnNldChldmVudCwgW10pO1xuICAgIH1cbiAgfVxufTtcbnZhciBjcmVhdGVFdmVudEJ1cyA9ICgpID0+IHtcbiAgY29uc3QgZXZlbnRUb0hhbmRsZXJzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgbGF0ZXN0UGF5bG9hZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGV2ZW50VG9QcmVkaXNwYXRjaEhhbmRsZXJzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgZW1pdCA9IChldmVudCwgcGF5bG9hZCkgPT4ge1xuICAgIGxhdGVzdFBheWxvYWRNYXAuc2V0KGV2ZW50LCBwYXlsb2FkKTtcbiAgICBfZGlzcGF0Y2goZXZlbnRUb1ByZWRpc3BhdGNoSGFuZGxlcnNNYXAsIGV2ZW50LCBwYXlsb2FkKTtcbiAgICBfZGlzcGF0Y2goZXZlbnRUb0hhbmRsZXJzTWFwLCBldmVudCwgcGF5bG9hZCk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgLy8gU3Vic2NyaWJlIHRvIGFuIGV2ZW50XG4gICAgb246ICguLi5hcmdzKSA9PiBfb24oZXZlbnRUb0hhbmRsZXJzTWFwLCBsYXRlc3RQYXlsb2FkTWFwLCAuLi5hcmdzKSxcbiAgICAvLyBTdWJzY3JpYmUgdG8gYW4gZXZlbnQgd2l0aCBwcmlvcml0eVxuICAgIC8vIFJlZ2lzdGVyZWQgaGFuZGxlcnMgd2l0aCBgcHJpb3JpdGl6ZWRPbmAgd2lsbCBiZSBjYWxsZWQgYmVmb3JlIGhhbmRsZXJzIHJlZ2lzdGVyZWQgd2l0aCBgb25gXG4gICAgcHJpb3JpdGl6ZWRPbjogKC4uLmFyZ3MpID0+IF9vbihldmVudFRvUHJlZGlzcGF0Y2hIYW5kbGVyc01hcCwgbGF0ZXN0UGF5bG9hZE1hcCwgLi4uYXJncyksXG4gICAgLy8gRGlzcGF0Y2ggYW4gZXZlbnRcbiAgICBlbWl0LFxuICAgIC8vIFVuc3Vic2NyaWJlIGZyb20gYW4gZXZlbnRcbiAgICBvZmY6ICguLi5hcmdzKSA9PiBfb2ZmKGV2ZW50VG9IYW5kbGVyc01hcCwgLi4uYXJncyksXG4gICAgLy8gVW5zdWJzY3JpYmUgZnJvbSBhbiBldmVudCB3aXRoIHByaW9yaXR5XG4gICAgLy8gVW5zdWJzY3JpYmVzIGhhbmRsZXJzIG9ubHkgcmVnaXN0ZXJlZCB3aXRoIGBwcmlvcml0aXplZE9uYFxuICAgIHByaW9yaXRpemVkT2ZmOiAoLi4uYXJncykgPT4gX29mZihldmVudFRvUHJlZGlzcGF0Y2hIYW5kbGVyc01hcCwgLi4uYXJncyksXG4gICAgLy8gSW50ZXJuYWwgdXRpbGl0aWVzXG4gICAgaW50ZXJuYWw6IHtcbiAgICAgIHJldHJpZXZlTGlzdGVuZXJzOiAoZXZlbnQpID0+IGV2ZW50VG9IYW5kbGVyc01hcC5nZXQoZXZlbnQpIHx8IFtdXG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0IHtcbiAgY3JlYXRlRXZlbnRCdXNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1HVktCR1I1Ti5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-GVKBGR5N.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CURRENT_DEV_INSTANCE_SUFFIXES: () => (/* binding */ CURRENT_DEV_INSTANCE_SUFFIXES),\n/* harmony export */   DEV_OR_STAGING_SUFFIXES: () => (/* binding */ DEV_OR_STAGING_SUFFIXES),\n/* harmony export */   LEGACY_DEV_INSTANCE_SUFFIXES: () => (/* binding */ LEGACY_DEV_INSTANCE_SUFFIXES),\n/* harmony export */   LOCAL_API_URL: () => (/* binding */ LOCAL_API_URL),\n/* harmony export */   LOCAL_ENV_SUFFIXES: () => (/* binding */ LOCAL_ENV_SUFFIXES),\n/* harmony export */   PROD_API_URL: () => (/* binding */ PROD_API_URL),\n/* harmony export */   STAGING_API_URL: () => (/* binding */ STAGING_API_URL),\n/* harmony export */   STAGING_ENV_SUFFIXES: () => (/* binding */ STAGING_ENV_SUFFIXES),\n/* harmony export */   iconImageUrl: () => (/* binding */ iconImageUrl)\n/* harmony export */ });\n// src/constants.ts\nvar LEGACY_DEV_INSTANCE_SUFFIXES = [\".lcl.dev\", \".lclstage.dev\", \".lclclerk.com\"];\nvar CURRENT_DEV_INSTANCE_SUFFIXES = [\".accounts.dev\", \".accountsstage.dev\", \".accounts.lclclerk.com\"];\nvar DEV_OR_STAGING_SUFFIXES = [\n  \".lcl.dev\",\n  \".stg.dev\",\n  \".lclstage.dev\",\n  \".stgstage.dev\",\n  \".dev.lclclerk.com\",\n  \".stg.lclclerk.com\",\n  \".accounts.lclclerk.com\",\n  \"accountsstage.dev\",\n  \"accounts.dev\"\n];\nvar LOCAL_ENV_SUFFIXES = [\".lcl.dev\", \"lclstage.dev\", \".lclclerk.com\", \".accounts.lclclerk.com\"];\nvar STAGING_ENV_SUFFIXES = [\".accountsstage.dev\"];\nvar LOCAL_API_URL = \"https://api.lclclerk.com\";\nvar STAGING_API_URL = \"https://api.clerkstage.dev\";\nvar PROD_API_URL = \"https://api.clerk.com\";\nfunction iconImageUrl(id, format = \"svg\") {\n  return `https://img.clerk.com/static/${id}.${format}`;\n}\n\n\n//# sourceMappingURL=chunk-I6MTSTOF.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstSTZNVFNUT0YubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsR0FBRyxHQUFHLE9BQU87QUFDdEQ7O0FBWUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2lzaGFxYmVsbG8vV2Vic2l0ZS9oYXZlbnJpZGVfZnVsbF9hcHAvbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9jaHVuay1JNk1UU1RPRi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NvbnN0YW50cy50c1xudmFyIExFR0FDWV9ERVZfSU5TVEFOQ0VfU1VGRklYRVMgPSBbXCIubGNsLmRldlwiLCBcIi5sY2xzdGFnZS5kZXZcIiwgXCIubGNsY2xlcmsuY29tXCJdO1xudmFyIENVUlJFTlRfREVWX0lOU1RBTkNFX1NVRkZJWEVTID0gW1wiLmFjY291bnRzLmRldlwiLCBcIi5hY2NvdW50c3N0YWdlLmRldlwiLCBcIi5hY2NvdW50cy5sY2xjbGVyay5jb21cIl07XG52YXIgREVWX09SX1NUQUdJTkdfU1VGRklYRVMgPSBbXG4gIFwiLmxjbC5kZXZcIixcbiAgXCIuc3RnLmRldlwiLFxuICBcIi5sY2xzdGFnZS5kZXZcIixcbiAgXCIuc3Rnc3RhZ2UuZGV2XCIsXG4gIFwiLmRldi5sY2xjbGVyay5jb21cIixcbiAgXCIuc3RnLmxjbGNsZXJrLmNvbVwiLFxuICBcIi5hY2NvdW50cy5sY2xjbGVyay5jb21cIixcbiAgXCJhY2NvdW50c3N0YWdlLmRldlwiLFxuICBcImFjY291bnRzLmRldlwiXG5dO1xudmFyIExPQ0FMX0VOVl9TVUZGSVhFUyA9IFtcIi5sY2wuZGV2XCIsIFwibGNsc3RhZ2UuZGV2XCIsIFwiLmxjbGNsZXJrLmNvbVwiLCBcIi5hY2NvdW50cy5sY2xjbGVyay5jb21cIl07XG52YXIgU1RBR0lOR19FTlZfU1VGRklYRVMgPSBbXCIuYWNjb3VudHNzdGFnZS5kZXZcIl07XG52YXIgTE9DQUxfQVBJX1VSTCA9IFwiaHR0cHM6Ly9hcGkubGNsY2xlcmsuY29tXCI7XG52YXIgU1RBR0lOR19BUElfVVJMID0gXCJodHRwczovL2FwaS5jbGVya3N0YWdlLmRldlwiO1xudmFyIFBST0RfQVBJX1VSTCA9IFwiaHR0cHM6Ly9hcGkuY2xlcmsuY29tXCI7XG5mdW5jdGlvbiBpY29uSW1hZ2VVcmwoaWQsIGZvcm1hdCA9IFwic3ZnXCIpIHtcbiAgcmV0dXJuIGBodHRwczovL2ltZy5jbGVyay5jb20vc3RhdGljLyR7aWR9LiR7Zm9ybWF0fWA7XG59XG5cbmV4cG9ydCB7XG4gIExFR0FDWV9ERVZfSU5TVEFOQ0VfU1VGRklYRVMsXG4gIENVUlJFTlRfREVWX0lOU1RBTkNFX1NVRkZJWEVTLFxuICBERVZfT1JfU1RBR0lOR19TVUZGSVhFUyxcbiAgTE9DQUxfRU5WX1NVRkZJWEVTLFxuICBTVEFHSU5HX0VOVl9TVUZGSVhFUyxcbiAgTE9DQUxfQVBJX1VSTCxcbiAgU1RBR0lOR19BUElfVVJMLFxuICBQUk9EX0FQSV9VUkwsXG4gIGljb25JbWFnZVVybFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLUk2TVRTVE9GLm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IBXKDGSZ.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-IBXKDGSZ.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurrentOrganizationMembership: () => (/* binding */ getCurrentOrganizationMembership)\n/* harmony export */ });\n// src/organization.ts\nfunction getCurrentOrganizationMembership(organizationMemberships, organizationId) {\n  return organizationMemberships.find(\n    (organizationMembership) => organizationMembership.organization.id === organizationId\n  );\n}\n\n\n//# sourceMappingURL=chunk-IBXKDGSZ.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstSUJYS0RHU1oubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2lzaGFxYmVsbG8vV2Vic2l0ZS9oYXZlbnJpZGVfZnVsbF9hcHAvbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9jaHVuay1JQlhLREdTWi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL29yZ2FuaXphdGlvbi50c1xuZnVuY3Rpb24gZ2V0Q3VycmVudE9yZ2FuaXphdGlvbk1lbWJlcnNoaXAob3JnYW5pemF0aW9uTWVtYmVyc2hpcHMsIG9yZ2FuaXphdGlvbklkKSB7XG4gIHJldHVybiBvcmdhbml6YXRpb25NZW1iZXJzaGlwcy5maW5kKFxuICAgIChvcmdhbml6YXRpb25NZW1iZXJzaGlwKSA9PiBvcmdhbml6YXRpb25NZW1iZXJzaGlwLm9yZ2FuaXphdGlvbi5pZCA9PT0gb3JnYW5pemF0aW9uSWRcbiAgKTtcbn1cblxuZXhwb3J0IHtcbiAgZ2V0Q3VycmVudE9yZ2FuaXphdGlvbk1lbWJlcnNoaXBcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1JQlhLREdTWi5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IBXKDGSZ.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IEP6GGEX.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-IEP6GGEX.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __export: () => (/* binding */ __export),\n/* harmony export */   __reExport: () => (/* binding */ __reExport)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\n\n\n//# sourceMappingURL=chunk-IEP6GGEX.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstSUVQNkdHRVgubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTs7QUFLRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2NodW5rLUlFUDZHR0VYLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kLCBzZWNvbmRUYXJnZXQpID0+IChfX2NvcHlQcm9wcyh0YXJnZXQsIG1vZCwgXCJkZWZhdWx0XCIpLCBzZWNvbmRUYXJnZXQgJiYgX19jb3B5UHJvcHMoc2Vjb25kVGFyZ2V0LCBtb2QsIFwiZGVmYXVsdFwiKSk7XG5cbmV4cG9ydCB7XG4gIF9fZXhwb3J0LFxuICBfX3JlRXhwb3J0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstSUVQNkdHRVgubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IEP6GGEX.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IFTVZ2LQ.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-IFTVZ2LQ.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addClerkPrefix: () => (/* binding */ addClerkPrefix),\n/* harmony export */   cleanDoubleSlashes: () => (/* binding */ cleanDoubleSlashes),\n/* harmony export */   getClerkJsMajorVersionOrTag: () => (/* binding */ getClerkJsMajorVersionOrTag),\n/* harmony export */   getScriptUrl: () => (/* binding */ getScriptUrl),\n/* harmony export */   hasLeadingSlash: () => (/* binding */ hasLeadingSlash),\n/* harmony export */   hasTrailingSlash: () => (/* binding */ hasTrailingSlash),\n/* harmony export */   isAbsoluteUrl: () => (/* binding */ isAbsoluteUrl),\n/* harmony export */   isCurrentDevAccountPortalOrigin: () => (/* binding */ isCurrentDevAccountPortalOrigin),\n/* harmony export */   isLegacyDevAccountPortalOrigin: () => (/* binding */ isLegacyDevAccountPortalOrigin),\n/* harmony export */   isNonEmptyURL: () => (/* binding */ isNonEmptyURL),\n/* harmony export */   joinURL: () => (/* binding */ joinURL),\n/* harmony export */   parseSearchParams: () => (/* binding */ parseSearchParams),\n/* harmony export */   stripScheme: () => (/* binding */ stripScheme),\n/* harmony export */   withLeadingSlash: () => (/* binding */ withLeadingSlash),\n/* harmony export */   withTrailingSlash: () => (/* binding */ withTrailingSlash),\n/* harmony export */   withoutLeadingSlash: () => (/* binding */ withoutLeadingSlash),\n/* harmony export */   withoutTrailingSlash: () => (/* binding */ withoutTrailingSlash)\n/* harmony export */ });\n/* harmony import */ var _chunk_3TMSNP4L_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-3TMSNP4L.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-3TMSNP4L.mjs\");\n/* harmony import */ var _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-I6MTSTOF.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs\");\n\n\n\n// src/url.ts\nfunction parseSearchParams(queryString = \"\") {\n  if (queryString.startsWith(\"?\")) {\n    queryString = queryString.slice(1);\n  }\n  return new URLSearchParams(queryString);\n}\nfunction stripScheme(url = \"\") {\n  return (url || \"\").replace(/^.+:\\/\\//, \"\");\n}\nfunction addClerkPrefix(str) {\n  if (!str) {\n    return \"\";\n  }\n  let regex;\n  if (str.match(/^(clerk\\.)+\\w*$/)) {\n    regex = /(clerk\\.)*(?=clerk\\.)/;\n  } else if (str.match(/\\.clerk.accounts/)) {\n    return str;\n  } else {\n    regex = /^(clerk\\.)*/gi;\n  }\n  const stripped = str.replace(regex, \"\");\n  return `clerk.${stripped}`;\n}\nvar getClerkJsMajorVersionOrTag = (frontendApi, version) => {\n  if (!version && (0,_chunk_3TMSNP4L_mjs__WEBPACK_IMPORTED_MODULE_0__.isStaging)(frontendApi)) {\n    return \"canary\";\n  }\n  if (!version) {\n    return \"latest\";\n  }\n  return version.split(\".\")[0] || \"latest\";\n};\nvar getScriptUrl = (frontendApi, { clerkJSVersion }) => {\n  const noSchemeFrontendApi = frontendApi.replace(/http(s)?:\\/\\//, \"\");\n  const major = getClerkJsMajorVersionOrTag(frontendApi, clerkJSVersion);\n  return `https://${noSchemeFrontendApi}/npm/@clerk/clerk-js@${clerkJSVersion || major}/dist/clerk.browser.js`;\n};\nfunction isLegacyDevAccountPortalOrigin(host) {\n  return _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_1__.LEGACY_DEV_INSTANCE_SUFFIXES.some((legacyDevSuffix) => {\n    return host.startsWith(\"accounts.\") && host.endsWith(legacyDevSuffix);\n  });\n}\nfunction isCurrentDevAccountPortalOrigin(host) {\n  return _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_1__.CURRENT_DEV_INSTANCE_SUFFIXES.some((currentDevSuffix) => {\n    return host.endsWith(currentDevSuffix) && !host.endsWith(\".clerk\" + currentDevSuffix);\n  });\n}\nvar TRAILING_SLASH_RE = /\\/$|\\/\\?|\\/#/;\nfunction hasTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return input.endsWith(\"/\");\n  }\n  return TRAILING_SLASH_RE.test(input);\n}\nfunction withTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return input.endsWith(\"/\") ? input : input + \"/\";\n  }\n  if (hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  let path = input;\n  let fragment = \"\";\n  const fragmentIndex = input.indexOf(\"#\");\n  if (fragmentIndex >= 0) {\n    path = input.slice(0, fragmentIndex);\n    fragment = input.slice(fragmentIndex);\n    if (!path) {\n      return fragment;\n    }\n  }\n  const [s0, ...s] = path.split(\"?\");\n  return s0 + \"/\" + (s.length > 0 ? `?${s.join(\"?\")}` : \"\") + fragment;\n}\nfunction withoutTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || \"/\";\n  }\n  if (!hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  let path = input;\n  let fragment = \"\";\n  const fragmentIndex = input.indexOf(\"#\");\n  if (fragmentIndex >= 0) {\n    path = input.slice(0, fragmentIndex);\n    fragment = input.slice(fragmentIndex);\n  }\n  const [s0, ...s] = path.split(\"?\");\n  return (s0.slice(0, -1) || \"/\") + (s.length > 0 ? `?${s.join(\"?\")}` : \"\") + fragment;\n}\nfunction hasLeadingSlash(input = \"\") {\n  return input.startsWith(\"/\");\n}\nfunction withoutLeadingSlash(input = \"\") {\n  return (hasLeadingSlash(input) ? input.slice(1) : input) || \"/\";\n}\nfunction withLeadingSlash(input = \"\") {\n  return hasLeadingSlash(input) ? input : \"/\" + input;\n}\nfunction cleanDoubleSlashes(input = \"\") {\n  return input.split(\"://\").map((string_) => string_.replace(/\\/{2,}/g, \"/\")).join(\"://\");\n}\nfunction isNonEmptyURL(url) {\n  return url && url !== \"/\";\n}\nvar JOIN_LEADING_SLASH_RE = /^\\.?\\//;\nfunction joinURL(base, ...input) {\n  let url = base || \"\";\n  for (const segment of input.filter((url2) => isNonEmptyURL(url2))) {\n    if (url) {\n      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, \"\");\n      url = withTrailingSlash(url) + _segment;\n    } else {\n      url = segment;\n    }\n  }\n  return url;\n}\nvar ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nvar isAbsoluteUrl = (url) => ABSOLUTE_URL_REGEX.test(url);\n\n\n//# sourceMappingURL=chunk-IFTVZ2LQ.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstSUZUVloyTFEubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFOEI7QUFJQTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0Esa0JBQWtCLDhEQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQix1QkFBdUIsd0JBQXdCO0FBQ3ZGO0FBQ0E7QUFDQSxTQUFTLDZFQUE0QjtBQUNyQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsU0FBUyw4RUFBNkI7QUFDdEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxHQUFHO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBb0JFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstSUZUVloyTFEubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGlzU3RhZ2luZ1xufSBmcm9tIFwiLi9jaHVuay0zVE1TTlA0TC5tanNcIjtcbmltcG9ydCB7XG4gIENVUlJFTlRfREVWX0lOU1RBTkNFX1NVRkZJWEVTLFxuICBMRUdBQ1lfREVWX0lOU1RBTkNFX1NVRkZJWEVTXG59IGZyb20gXCIuL2NodW5rLUk2TVRTVE9GLm1qc1wiO1xuXG4vLyBzcmMvdXJsLnRzXG5mdW5jdGlvbiBwYXJzZVNlYXJjaFBhcmFtcyhxdWVyeVN0cmluZyA9IFwiXCIpIHtcbiAgaWYgKHF1ZXJ5U3RyaW5nLnN0YXJ0c1dpdGgoXCI/XCIpKSB7XG4gICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyhxdWVyeVN0cmluZyk7XG59XG5mdW5jdGlvbiBzdHJpcFNjaGVtZSh1cmwgPSBcIlwiKSB7XG4gIHJldHVybiAodXJsIHx8IFwiXCIpLnJlcGxhY2UoL14uKzpcXC9cXC8vLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGFkZENsZXJrUHJlZml4KHN0cikge1xuICBpZiAoIXN0cikge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGxldCByZWdleDtcbiAgaWYgKHN0ci5tYXRjaCgvXihjbGVya1xcLikrXFx3KiQvKSkge1xuICAgIHJlZ2V4ID0gLyhjbGVya1xcLikqKD89Y2xlcmtcXC4pLztcbiAgfSBlbHNlIGlmIChzdHIubWF0Y2goL1xcLmNsZXJrLmFjY291bnRzLykpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9IGVsc2Uge1xuICAgIHJlZ2V4ID0gL14oY2xlcmtcXC4pKi9naTtcbiAgfVxuICBjb25zdCBzdHJpcHBlZCA9IHN0ci5yZXBsYWNlKHJlZ2V4LCBcIlwiKTtcbiAgcmV0dXJuIGBjbGVyay4ke3N0cmlwcGVkfWA7XG59XG52YXIgZ2V0Q2xlcmtKc01ham9yVmVyc2lvbk9yVGFnID0gKGZyb250ZW5kQXBpLCB2ZXJzaW9uKSA9PiB7XG4gIGlmICghdmVyc2lvbiAmJiBpc1N0YWdpbmcoZnJvbnRlbmRBcGkpKSB7XG4gICAgcmV0dXJuIFwiY2FuYXJ5XCI7XG4gIH1cbiAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIFwibGF0ZXN0XCI7XG4gIH1cbiAgcmV0dXJuIHZlcnNpb24uc3BsaXQoXCIuXCIpWzBdIHx8IFwibGF0ZXN0XCI7XG59O1xudmFyIGdldFNjcmlwdFVybCA9IChmcm9udGVuZEFwaSwgeyBjbGVya0pTVmVyc2lvbiB9KSA9PiB7XG4gIGNvbnN0IG5vU2NoZW1lRnJvbnRlbmRBcGkgPSBmcm9udGVuZEFwaS5yZXBsYWNlKC9odHRwKHMpPzpcXC9cXC8vLCBcIlwiKTtcbiAgY29uc3QgbWFqb3IgPSBnZXRDbGVya0pzTWFqb3JWZXJzaW9uT3JUYWcoZnJvbnRlbmRBcGksIGNsZXJrSlNWZXJzaW9uKTtcbiAgcmV0dXJuIGBodHRwczovLyR7bm9TY2hlbWVGcm9udGVuZEFwaX0vbnBtL0BjbGVyay9jbGVyay1qc0Ake2NsZXJrSlNWZXJzaW9uIHx8IG1ham9yfS9kaXN0L2NsZXJrLmJyb3dzZXIuanNgO1xufTtcbmZ1bmN0aW9uIGlzTGVnYWN5RGV2QWNjb3VudFBvcnRhbE9yaWdpbihob3N0KSB7XG4gIHJldHVybiBMRUdBQ1lfREVWX0lOU1RBTkNFX1NVRkZJWEVTLnNvbWUoKGxlZ2FjeURldlN1ZmZpeCkgPT4ge1xuICAgIHJldHVybiBob3N0LnN0YXJ0c1dpdGgoXCJhY2NvdW50cy5cIikgJiYgaG9zdC5lbmRzV2l0aChsZWdhY3lEZXZTdWZmaXgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzQ3VycmVudERldkFjY291bnRQb3J0YWxPcmlnaW4oaG9zdCkge1xuICByZXR1cm4gQ1VSUkVOVF9ERVZfSU5TVEFOQ0VfU1VGRklYRVMuc29tZSgoY3VycmVudERldlN1ZmZpeCkgPT4ge1xuICAgIHJldHVybiBob3N0LmVuZHNXaXRoKGN1cnJlbnREZXZTdWZmaXgpICYmICFob3N0LmVuZHNXaXRoKFwiLmNsZXJrXCIgKyBjdXJyZW50RGV2U3VmZml4KTtcbiAgfSk7XG59XG52YXIgVFJBSUxJTkdfU0xBU0hfUkUgPSAvXFwvJHxcXC9cXD98XFwvIy87XG5mdW5jdGlvbiBoYXNUcmFpbGluZ1NsYXNoKGlucHV0ID0gXCJcIiwgcmVzcGVjdFF1ZXJ5QW5kRnJhZ21lbnQpIHtcbiAgaWYgKCFyZXNwZWN0UXVlcnlBbmRGcmFnbWVudCkge1xuICAgIHJldHVybiBpbnB1dC5lbmRzV2l0aChcIi9cIik7XG4gIH1cbiAgcmV0dXJuIFRSQUlMSU5HX1NMQVNIX1JFLnRlc3QoaW5wdXQpO1xufVxuZnVuY3Rpb24gd2l0aFRyYWlsaW5nU2xhc2goaW5wdXQgPSBcIlwiLCByZXNwZWN0UXVlcnlBbmRGcmFnbWVudCkge1xuICBpZiAoIXJlc3BlY3RRdWVyeUFuZEZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGlucHV0LmVuZHNXaXRoKFwiL1wiKSA/IGlucHV0IDogaW5wdXQgKyBcIi9cIjtcbiAgfVxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaChpbnB1dCwgdHJ1ZSkpIHtcbiAgICByZXR1cm4gaW5wdXQgfHwgXCIvXCI7XG4gIH1cbiAgbGV0IHBhdGggPSBpbnB1dDtcbiAgbGV0IGZyYWdtZW50ID0gXCJcIjtcbiAgY29uc3QgZnJhZ21lbnRJbmRleCA9IGlucHV0LmluZGV4T2YoXCIjXCIpO1xuICBpZiAoZnJhZ21lbnRJbmRleCA+PSAwKSB7XG4gICAgcGF0aCA9IGlucHV0LnNsaWNlKDAsIGZyYWdtZW50SW5kZXgpO1xuICAgIGZyYWdtZW50ID0gaW5wdXQuc2xpY2UoZnJhZ21lbnRJbmRleCk7XG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgfVxuICB9XG4gIGNvbnN0IFtzMCwgLi4uc10gPSBwYXRoLnNwbGl0KFwiP1wiKTtcbiAgcmV0dXJuIHMwICsgXCIvXCIgKyAocy5sZW5ndGggPiAwID8gYD8ke3Muam9pbihcIj9cIil9YCA6IFwiXCIpICsgZnJhZ21lbnQ7XG59XG5mdW5jdGlvbiB3aXRob3V0VHJhaWxpbmdTbGFzaChpbnB1dCA9IFwiXCIsIHJlc3BlY3RRdWVyeUFuZEZyYWdtZW50KSB7XG4gIGlmICghcmVzcGVjdFF1ZXJ5QW5kRnJhZ21lbnQpIHtcbiAgICByZXR1cm4gKGhhc1RyYWlsaW5nU2xhc2goaW5wdXQpID8gaW5wdXQuc2xpY2UoMCwgLTEpIDogaW5wdXQpIHx8IFwiL1wiO1xuICB9XG4gIGlmICghaGFzVHJhaWxpbmdTbGFzaChpbnB1dCwgdHJ1ZSkpIHtcbiAgICByZXR1cm4gaW5wdXQgfHwgXCIvXCI7XG4gIH1cbiAgbGV0IHBhdGggPSBpbnB1dDtcbiAgbGV0IGZyYWdtZW50ID0gXCJcIjtcbiAgY29uc3QgZnJhZ21lbnRJbmRleCA9IGlucHV0LmluZGV4T2YoXCIjXCIpO1xuICBpZiAoZnJhZ21lbnRJbmRleCA+PSAwKSB7XG4gICAgcGF0aCA9IGlucHV0LnNsaWNlKDAsIGZyYWdtZW50SW5kZXgpO1xuICAgIGZyYWdtZW50ID0gaW5wdXQuc2xpY2UoZnJhZ21lbnRJbmRleCk7XG4gIH1cbiAgY29uc3QgW3MwLCAuLi5zXSA9IHBhdGguc3BsaXQoXCI/XCIpO1xuICByZXR1cm4gKHMwLnNsaWNlKDAsIC0xKSB8fCBcIi9cIikgKyAocy5sZW5ndGggPiAwID8gYD8ke3Muam9pbihcIj9cIil9YCA6IFwiXCIpICsgZnJhZ21lbnQ7XG59XG5mdW5jdGlvbiBoYXNMZWFkaW5nU2xhc2goaW5wdXQgPSBcIlwiKSB7XG4gIHJldHVybiBpbnB1dC5zdGFydHNXaXRoKFwiL1wiKTtcbn1cbmZ1bmN0aW9uIHdpdGhvdXRMZWFkaW5nU2xhc2goaW5wdXQgPSBcIlwiKSB7XG4gIHJldHVybiAoaGFzTGVhZGluZ1NsYXNoKGlucHV0KSA/IGlucHV0LnNsaWNlKDEpIDogaW5wdXQpIHx8IFwiL1wiO1xufVxuZnVuY3Rpb24gd2l0aExlYWRpbmdTbGFzaChpbnB1dCA9IFwiXCIpIHtcbiAgcmV0dXJuIGhhc0xlYWRpbmdTbGFzaChpbnB1dCkgPyBpbnB1dCA6IFwiL1wiICsgaW5wdXQ7XG59XG5mdW5jdGlvbiBjbGVhbkRvdWJsZVNsYXNoZXMoaW5wdXQgPSBcIlwiKSB7XG4gIHJldHVybiBpbnB1dC5zcGxpdChcIjovL1wiKS5tYXAoKHN0cmluZ18pID0+IHN0cmluZ18ucmVwbGFjZSgvXFwvezIsfS9nLCBcIi9cIikpLmpvaW4oXCI6Ly9cIik7XG59XG5mdW5jdGlvbiBpc05vbkVtcHR5VVJMKHVybCkge1xuICByZXR1cm4gdXJsICYmIHVybCAhPT0gXCIvXCI7XG59XG52YXIgSk9JTl9MRUFESU5HX1NMQVNIX1JFID0gL15cXC4/XFwvLztcbmZ1bmN0aW9uIGpvaW5VUkwoYmFzZSwgLi4uaW5wdXQpIHtcbiAgbGV0IHVybCA9IGJhc2UgfHwgXCJcIjtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIGlucHV0LmZpbHRlcigodXJsMikgPT4gaXNOb25FbXB0eVVSTCh1cmwyKSkpIHtcbiAgICBpZiAodXJsKSB7XG4gICAgICBjb25zdCBfc2VnbWVudCA9IHNlZ21lbnQucmVwbGFjZShKT0lOX0xFQURJTkdfU0xBU0hfUkUsIFwiXCIpO1xuICAgICAgdXJsID0gd2l0aFRyYWlsaW5nU2xhc2godXJsKSArIF9zZWdtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICB1cmwgPSBzZWdtZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdXJsO1xufVxudmFyIEFCU09MVVRFX1VSTF9SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aXFxkK1xcLS5dKj86LztcbnZhciBpc0Fic29sdXRlVXJsID0gKHVybCkgPT4gQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QodXJsKTtcblxuZXhwb3J0IHtcbiAgcGFyc2VTZWFyY2hQYXJhbXMsXG4gIHN0cmlwU2NoZW1lLFxuICBhZGRDbGVya1ByZWZpeCxcbiAgZ2V0Q2xlcmtKc01ham9yVmVyc2lvbk9yVGFnLFxuICBnZXRTY3JpcHRVcmwsXG4gIGlzTGVnYWN5RGV2QWNjb3VudFBvcnRhbE9yaWdpbixcbiAgaXNDdXJyZW50RGV2QWNjb3VudFBvcnRhbE9yaWdpbixcbiAgaGFzVHJhaWxpbmdTbGFzaCxcbiAgd2l0aFRyYWlsaW5nU2xhc2gsXG4gIHdpdGhvdXRUcmFpbGluZ1NsYXNoLFxuICBoYXNMZWFkaW5nU2xhc2gsXG4gIHdpdGhvdXRMZWFkaW5nU2xhc2gsXG4gIHdpdGhMZWFkaW5nU2xhc2gsXG4gIGNsZWFuRG91YmxlU2xhc2hlcyxcbiAgaXNOb25FbXB0eVVSTCxcbiAgam9pblVSTCxcbiAgaXNBYnNvbHV0ZVVybFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLUlGVFZaMkxRLm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IFTVZ2LQ.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IV7BOO4U.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-IV7BOO4U.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildPublishableKey: () => (/* binding */ buildPublishableKey),\n/* harmony export */   createDevOrStagingUrlCache: () => (/* binding */ createDevOrStagingUrlCache),\n/* harmony export */   getCookieSuffix: () => (/* binding */ getCookieSuffix),\n/* harmony export */   getSuffixedCookieName: () => (/* binding */ getSuffixedCookieName),\n/* harmony export */   isDevelopmentFromPublishableKey: () => (/* binding */ isDevelopmentFromPublishableKey),\n/* harmony export */   isDevelopmentFromSecretKey: () => (/* binding */ isDevelopmentFromSecretKey),\n/* harmony export */   isProductionFromPublishableKey: () => (/* binding */ isProductionFromPublishableKey),\n/* harmony export */   isProductionFromSecretKey: () => (/* binding */ isProductionFromSecretKey),\n/* harmony export */   isPublishableKey: () => (/* binding */ isPublishableKey),\n/* harmony export */   parsePublishableKey: () => (/* binding */ parsePublishableKey)\n/* harmony export */ });\n/* harmony import */ var _chunk_TETGTEI2_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-TETGTEI2.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs\");\n/* harmony import */ var _chunk_KOH7GTJO_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-KOH7GTJO.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs\");\n/* harmony import */ var _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-I6MTSTOF.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs\");\n\n\n\n\n// src/keys.ts\nvar PUBLISHABLE_KEY_LIVE_PREFIX = \"pk_live_\";\nvar PUBLISHABLE_KEY_TEST_PREFIX = \"pk_test_\";\nvar PUBLISHABLE_FRONTEND_API_DEV_REGEX = /^(([a-z]+)-){2}([0-9]{1,2})\\.clerk\\.accounts([a-z.]*)(dev|com)$/i;\nfunction buildPublishableKey(frontendApi) {\n  const isDevKey = PUBLISHABLE_FRONTEND_API_DEV_REGEX.test(frontendApi) || frontendApi.startsWith(\"clerk.\") && _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_2__.LEGACY_DEV_INSTANCE_SUFFIXES.some((s) => frontendApi.endsWith(s));\n  const keyPrefix = isDevKey ? PUBLISHABLE_KEY_TEST_PREFIX : PUBLISHABLE_KEY_LIVE_PREFIX;\n  return `${keyPrefix}${(0,_chunk_KOH7GTJO_mjs__WEBPACK_IMPORTED_MODULE_1__.isomorphicBtoa)(`${frontendApi}$`)}`;\n}\nfunction isValidDecodedPublishableKey(decoded) {\n  if (!decoded.endsWith(\"$\")) {\n    return false;\n  }\n  const withoutTrailing = decoded.slice(0, -1);\n  if (withoutTrailing.includes(\"$\")) {\n    return false;\n  }\n  return withoutTrailing.includes(\".\");\n}\nfunction parsePublishableKey(key, options = {}) {\n  key = key || \"\";\n  if (!key || !isPublishableKey(key)) {\n    if (options.fatal && !key) {\n      throw new Error(\n        \"Publishable key is missing. Ensure that your publishable key is correctly configured. Double-check your environment configuration for your keys, or access them here: https://dashboard.clerk.com/last-active?path=api-keys\"\n      );\n    }\n    if (options.fatal && !isPublishableKey(key)) {\n      throw new Error(\"Publishable key not valid.\");\n    }\n    return null;\n  }\n  const instanceType = key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) ? \"production\" : \"development\";\n  let decodedFrontendApi;\n  try {\n    decodedFrontendApi = (0,_chunk_TETGTEI2_mjs__WEBPACK_IMPORTED_MODULE_0__.isomorphicAtob)(key.split(\"_\")[2]);\n  } catch {\n    if (options.fatal) {\n      throw new Error(\"Publishable key not valid: Failed to decode key.\");\n    }\n    return null;\n  }\n  if (!isValidDecodedPublishableKey(decodedFrontendApi)) {\n    if (options.fatal) {\n      throw new Error(\"Publishable key not valid: Decoded key has invalid format.\");\n    }\n    return null;\n  }\n  let frontendApi = decodedFrontendApi.slice(0, -1);\n  if (options.proxyUrl) {\n    frontendApi = options.proxyUrl;\n  } else if (instanceType !== \"development\" && options.domain && options.isSatellite) {\n    frontendApi = `clerk.${options.domain}`;\n  }\n  return {\n    instanceType,\n    frontendApi\n  };\n}\nfunction isPublishableKey(key = \"\") {\n  try {\n    const hasValidPrefix = key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) || key.startsWith(PUBLISHABLE_KEY_TEST_PREFIX);\n    if (!hasValidPrefix) {\n      return false;\n    }\n    const parts = key.split(\"_\");\n    if (parts.length !== 3) {\n      return false;\n    }\n    const encodedPart = parts[2];\n    if (!encodedPart) {\n      return false;\n    }\n    const decoded = (0,_chunk_TETGTEI2_mjs__WEBPACK_IMPORTED_MODULE_0__.isomorphicAtob)(encodedPart);\n    return isValidDecodedPublishableKey(decoded);\n  } catch {\n    return false;\n  }\n}\nfunction createDevOrStagingUrlCache() {\n  const devOrStagingUrlCache = /* @__PURE__ */ new Map();\n  return {\n    /**\n     * Checks if a URL is a development or staging environment.\n     *\n     * @param url - The URL to check (string or URL object).\n     * @returns `true` if the URL is a development or staging environment, `false` otherwise.\n     */\n    isDevOrStagingUrl: (url) => {\n      if (!url) {\n        return false;\n      }\n      const hostname = typeof url === \"string\" ? url : url.hostname;\n      let res = devOrStagingUrlCache.get(hostname);\n      if (res === void 0) {\n        res = _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_2__.DEV_OR_STAGING_SUFFIXES.some((s) => hostname.endsWith(s));\n        devOrStagingUrlCache.set(hostname, res);\n      }\n      return res;\n    }\n  };\n}\nfunction isDevelopmentFromPublishableKey(apiKey) {\n  return apiKey.startsWith(\"test_\") || apiKey.startsWith(\"pk_test_\");\n}\nfunction isProductionFromPublishableKey(apiKey) {\n  return apiKey.startsWith(\"live_\") || apiKey.startsWith(\"pk_live_\");\n}\nfunction isDevelopmentFromSecretKey(apiKey) {\n  return apiKey.startsWith(\"test_\") || apiKey.startsWith(\"sk_test_\");\n}\nfunction isProductionFromSecretKey(apiKey) {\n  return apiKey.startsWith(\"live_\") || apiKey.startsWith(\"sk_live_\");\n}\nasync function getCookieSuffix(publishableKey, subtle = globalThis.crypto.subtle) {\n  const data = new TextEncoder().encode(publishableKey);\n  const digest = await subtle.digest(\"sha-1\", data);\n  const stringDigest = String.fromCharCode(...new Uint8Array(digest));\n  return (0,_chunk_KOH7GTJO_mjs__WEBPACK_IMPORTED_MODULE_1__.isomorphicBtoa)(stringDigest).replace(/\\+/gi, \"-\").replace(/\\//gi, \"_\").substring(0, 8);\n}\nvar getSuffixedCookieName = (cookieName, cookieSuffix) => {\n  return `${cookieName}_${cookieSuffix}`;\n};\n\n\n//# sourceMappingURL=chunk-IV7BOO4U.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstSVY3Qk9PNFUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFOEI7QUFHQTtBQUlBOztBQUU5QjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsRUFBRSxPQUFPLElBQUk7QUFDcEU7QUFDQSwrR0FBK0csNkVBQTRCO0FBQzNJO0FBQ0EsWUFBWSxVQUFVLEVBQUUsbUVBQWMsSUFBSSxZQUFZLElBQUk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUVBQWM7QUFDdkMsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkJBQTJCLGVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtRUFBYztBQUNsQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0VBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtRUFBYztBQUN2QjtBQUNBO0FBQ0EsWUFBWSxXQUFXLEdBQUcsYUFBYTtBQUN2Qzs7QUFhRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2NodW5rLUlWN0JPTzRVLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBpc29tb3JwaGljQXRvYlxufSBmcm9tIFwiLi9jaHVuay1URVRHVEVJMi5tanNcIjtcbmltcG9ydCB7XG4gIGlzb21vcnBoaWNCdG9hXG59IGZyb20gXCIuL2NodW5rLUtPSDdHVEpPLm1qc1wiO1xuaW1wb3J0IHtcbiAgREVWX09SX1NUQUdJTkdfU1VGRklYRVMsXG4gIExFR0FDWV9ERVZfSU5TVEFOQ0VfU1VGRklYRVNcbn0gZnJvbSBcIi4vY2h1bmstSTZNVFNUT0YubWpzXCI7XG5cbi8vIHNyYy9rZXlzLnRzXG52YXIgUFVCTElTSEFCTEVfS0VZX0xJVkVfUFJFRklYID0gXCJwa19saXZlX1wiO1xudmFyIFBVQkxJU0hBQkxFX0tFWV9URVNUX1BSRUZJWCA9IFwicGtfdGVzdF9cIjtcbnZhciBQVUJMSVNIQUJMRV9GUk9OVEVORF9BUElfREVWX1JFR0VYID0gL14oKFthLXpdKyktKXsyfShbMC05XXsxLDJ9KVxcLmNsZXJrXFwuYWNjb3VudHMoW2Etei5dKikoZGV2fGNvbSkkL2k7XG5mdW5jdGlvbiBidWlsZFB1Ymxpc2hhYmxlS2V5KGZyb250ZW5kQXBpKSB7XG4gIGNvbnN0IGlzRGV2S2V5ID0gUFVCTElTSEFCTEVfRlJPTlRFTkRfQVBJX0RFVl9SRUdFWC50ZXN0KGZyb250ZW5kQXBpKSB8fCBmcm9udGVuZEFwaS5zdGFydHNXaXRoKFwiY2xlcmsuXCIpICYmIExFR0FDWV9ERVZfSU5TVEFOQ0VfU1VGRklYRVMuc29tZSgocykgPT4gZnJvbnRlbmRBcGkuZW5kc1dpdGgocykpO1xuICBjb25zdCBrZXlQcmVmaXggPSBpc0RldktleSA/IFBVQkxJU0hBQkxFX0tFWV9URVNUX1BSRUZJWCA6IFBVQkxJU0hBQkxFX0tFWV9MSVZFX1BSRUZJWDtcbiAgcmV0dXJuIGAke2tleVByZWZpeH0ke2lzb21vcnBoaWNCdG9hKGAke2Zyb250ZW5kQXBpfSRgKX1gO1xufVxuZnVuY3Rpb24gaXNWYWxpZERlY29kZWRQdWJsaXNoYWJsZUtleShkZWNvZGVkKSB7XG4gIGlmICghZGVjb2RlZC5lbmRzV2l0aChcIiRcIikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgd2l0aG91dFRyYWlsaW5nID0gZGVjb2RlZC5zbGljZSgwLCAtMSk7XG4gIGlmICh3aXRob3V0VHJhaWxpbmcuaW5jbHVkZXMoXCIkXCIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB3aXRob3V0VHJhaWxpbmcuaW5jbHVkZXMoXCIuXCIpO1xufVxuZnVuY3Rpb24gcGFyc2VQdWJsaXNoYWJsZUtleShrZXksIG9wdGlvbnMgPSB7fSkge1xuICBrZXkgPSBrZXkgfHwgXCJcIjtcbiAgaWYgKCFrZXkgfHwgIWlzUHVibGlzaGFibGVLZXkoa2V5KSkge1xuICAgIGlmIChvcHRpb25zLmZhdGFsICYmICFrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJQdWJsaXNoYWJsZSBrZXkgaXMgbWlzc2luZy4gRW5zdXJlIHRoYXQgeW91ciBwdWJsaXNoYWJsZSBrZXkgaXMgY29ycmVjdGx5IGNvbmZpZ3VyZWQuIERvdWJsZS1jaGVjayB5b3VyIGVudmlyb25tZW50IGNvbmZpZ3VyYXRpb24gZm9yIHlvdXIga2V5cywgb3IgYWNjZXNzIHRoZW0gaGVyZTogaHR0cHM6Ly9kYXNoYm9hcmQuY2xlcmsuY29tL2xhc3QtYWN0aXZlP3BhdGg9YXBpLWtleXNcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZmF0YWwgJiYgIWlzUHVibGlzaGFibGVLZXkoa2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHVibGlzaGFibGUga2V5IG5vdCB2YWxpZC5cIik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGluc3RhbmNlVHlwZSA9IGtleS5zdGFydHNXaXRoKFBVQkxJU0hBQkxFX0tFWV9MSVZFX1BSRUZJWCkgPyBcInByb2R1Y3Rpb25cIiA6IFwiZGV2ZWxvcG1lbnRcIjtcbiAgbGV0IGRlY29kZWRGcm9udGVuZEFwaTtcbiAgdHJ5IHtcbiAgICBkZWNvZGVkRnJvbnRlbmRBcGkgPSBpc29tb3JwaGljQXRvYihrZXkuc3BsaXQoXCJfXCIpWzJdKTtcbiAgfSBjYXRjaCB7XG4gICAgaWYgKG9wdGlvbnMuZmF0YWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlB1Ymxpc2hhYmxlIGtleSBub3QgdmFsaWQ6IEZhaWxlZCB0byBkZWNvZGUga2V5LlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFpc1ZhbGlkRGVjb2RlZFB1Ymxpc2hhYmxlS2V5KGRlY29kZWRGcm9udGVuZEFwaSkpIHtcbiAgICBpZiAob3B0aW9ucy5mYXRhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHVibGlzaGFibGUga2V5IG5vdCB2YWxpZDogRGVjb2RlZCBrZXkgaGFzIGludmFsaWQgZm9ybWF0LlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IGZyb250ZW5kQXBpID0gZGVjb2RlZEZyb250ZW5kQXBpLnNsaWNlKDAsIC0xKTtcbiAgaWYgKG9wdGlvbnMucHJveHlVcmwpIHtcbiAgICBmcm9udGVuZEFwaSA9IG9wdGlvbnMucHJveHlVcmw7XG4gIH0gZWxzZSBpZiAoaW5zdGFuY2VUeXBlICE9PSBcImRldmVsb3BtZW50XCIgJiYgb3B0aW9ucy5kb21haW4gJiYgb3B0aW9ucy5pc1NhdGVsbGl0ZSkge1xuICAgIGZyb250ZW5kQXBpID0gYGNsZXJrLiR7b3B0aW9ucy5kb21haW59YDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGluc3RhbmNlVHlwZSxcbiAgICBmcm9udGVuZEFwaVxuICB9O1xufVxuZnVuY3Rpb24gaXNQdWJsaXNoYWJsZUtleShrZXkgPSBcIlwiKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgaGFzVmFsaWRQcmVmaXggPSBrZXkuc3RhcnRzV2l0aChQVUJMSVNIQUJMRV9LRVlfTElWRV9QUkVGSVgpIHx8IGtleS5zdGFydHNXaXRoKFBVQkxJU0hBQkxFX0tFWV9URVNUX1BSRUZJWCk7XG4gICAgaWYgKCFoYXNWYWxpZFByZWZpeCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0cyA9IGtleS5zcGxpdChcIl9cIik7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGVkUGFydCA9IHBhcnRzWzJdO1xuICAgIGlmICghZW5jb2RlZFBhcnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlZCA9IGlzb21vcnBoaWNBdG9iKGVuY29kZWRQYXJ0KTtcbiAgICByZXR1cm4gaXNWYWxpZERlY29kZWRQdWJsaXNoYWJsZUtleShkZWNvZGVkKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVEZXZPclN0YWdpbmdVcmxDYWNoZSgpIHtcbiAgY29uc3QgZGV2T3JTdGFnaW5nVXJsQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIFVSTCBpcyBhIGRldmVsb3BtZW50IG9yIHN0YWdpbmcgZW52aXJvbm1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBjaGVjayAoc3RyaW5nIG9yIFVSTCBvYmplY3QpLlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgVVJMIGlzIGEgZGV2ZWxvcG1lbnQgb3Igc3RhZ2luZyBlbnZpcm9ubWVudCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNEZXZPclN0YWdpbmdVcmw6ICh1cmwpID0+IHtcbiAgICAgIGlmICghdXJsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhvc3RuYW1lID0gdHlwZW9mIHVybCA9PT0gXCJzdHJpbmdcIiA/IHVybCA6IHVybC5ob3N0bmFtZTtcbiAgICAgIGxldCByZXMgPSBkZXZPclN0YWdpbmdVcmxDYWNoZS5nZXQoaG9zdG5hbWUpO1xuICAgICAgaWYgKHJlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJlcyA9IERFVl9PUl9TVEFHSU5HX1NVRkZJWEVTLnNvbWUoKHMpID0+IGhvc3RuYW1lLmVuZHNXaXRoKHMpKTtcbiAgICAgICAgZGV2T3JTdGFnaW5nVXJsQ2FjaGUuc2V0KGhvc3RuYW1lLCByZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpc0RldmVsb3BtZW50RnJvbVB1Ymxpc2hhYmxlS2V5KGFwaUtleSkge1xuICByZXR1cm4gYXBpS2V5LnN0YXJ0c1dpdGgoXCJ0ZXN0X1wiKSB8fCBhcGlLZXkuc3RhcnRzV2l0aChcInBrX3Rlc3RfXCIpO1xufVxuZnVuY3Rpb24gaXNQcm9kdWN0aW9uRnJvbVB1Ymxpc2hhYmxlS2V5KGFwaUtleSkge1xuICByZXR1cm4gYXBpS2V5LnN0YXJ0c1dpdGgoXCJsaXZlX1wiKSB8fCBhcGlLZXkuc3RhcnRzV2l0aChcInBrX2xpdmVfXCIpO1xufVxuZnVuY3Rpb24gaXNEZXZlbG9wbWVudEZyb21TZWNyZXRLZXkoYXBpS2V5KSB7XG4gIHJldHVybiBhcGlLZXkuc3RhcnRzV2l0aChcInRlc3RfXCIpIHx8IGFwaUtleS5zdGFydHNXaXRoKFwic2tfdGVzdF9cIik7XG59XG5mdW5jdGlvbiBpc1Byb2R1Y3Rpb25Gcm9tU2VjcmV0S2V5KGFwaUtleSkge1xuICByZXR1cm4gYXBpS2V5LnN0YXJ0c1dpdGgoXCJsaXZlX1wiKSB8fCBhcGlLZXkuc3RhcnRzV2l0aChcInNrX2xpdmVfXCIpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0Q29va2llU3VmZml4KHB1Ymxpc2hhYmxlS2V5LCBzdWJ0bGUgPSBnbG9iYWxUaGlzLmNyeXB0by5zdWJ0bGUpIHtcbiAgY29uc3QgZGF0YSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShwdWJsaXNoYWJsZUtleSk7XG4gIGNvbnN0IGRpZ2VzdCA9IGF3YWl0IHN1YnRsZS5kaWdlc3QoXCJzaGEtMVwiLCBkYXRhKTtcbiAgY29uc3Qgc3RyaW5nRGlnZXN0ID0gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5uZXcgVWludDhBcnJheShkaWdlc3QpKTtcbiAgcmV0dXJuIGlzb21vcnBoaWNCdG9hKHN0cmluZ0RpZ2VzdCkucmVwbGFjZSgvXFwrL2dpLCBcIi1cIikucmVwbGFjZSgvXFwvL2dpLCBcIl9cIikuc3Vic3RyaW5nKDAsIDgpO1xufVxudmFyIGdldFN1ZmZpeGVkQ29va2llTmFtZSA9IChjb29raWVOYW1lLCBjb29raWVTdWZmaXgpID0+IHtcbiAgcmV0dXJuIGAke2Nvb2tpZU5hbWV9XyR7Y29va2llU3VmZml4fWA7XG59O1xuXG5leHBvcnQge1xuICBidWlsZFB1Ymxpc2hhYmxlS2V5LFxuICBwYXJzZVB1Ymxpc2hhYmxlS2V5LFxuICBpc1B1Ymxpc2hhYmxlS2V5LFxuICBjcmVhdGVEZXZPclN0YWdpbmdVcmxDYWNoZSxcbiAgaXNEZXZlbG9wbWVudEZyb21QdWJsaXNoYWJsZUtleSxcbiAgaXNQcm9kdWN0aW9uRnJvbVB1Ymxpc2hhYmxlS2V5LFxuICBpc0RldmVsb3BtZW50RnJvbVNlY3JldEtleSxcbiAgaXNQcm9kdWN0aW9uRnJvbVNlY3JldEtleSxcbiAgZ2V0Q29va2llU3VmZml4LFxuICBnZXRTdWZmaXhlZENvb2tpZU5hbWVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1JVjdCT080VS5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IV7BOO4U.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-JKSAJ6AV.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-JKSAJ6AV.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   inBrowser: () => (/* binding */ inBrowser),\n/* harmony export */   isBrowserOnline: () => (/* binding */ isBrowserOnline),\n/* harmony export */   isValidBrowser: () => (/* binding */ isValidBrowser),\n/* harmony export */   isValidBrowserOnline: () => (/* binding */ isValidBrowserOnline),\n/* harmony export */   userAgentIsRobot: () => (/* binding */ userAgentIsRobot)\n/* harmony export */ });\n// src/browser.ts\nfunction inBrowser() {\n  return typeof window !== \"undefined\";\n}\nvar botAgents = [\n  \"bot\",\n  \"spider\",\n  \"crawl\",\n  \"APIs-Google\",\n  \"AdsBot\",\n  \"Googlebot\",\n  \"mediapartners\",\n  \"Google Favicon\",\n  \"FeedFetcher\",\n  \"Google-Read-Aloud\",\n  \"DuplexWeb-Google\",\n  \"googleweblight\",\n  \"bing\",\n  \"yandex\",\n  \"baidu\",\n  \"duckduck\",\n  \"yahoo\",\n  \"ecosia\",\n  \"ia_archiver\",\n  \"facebook\",\n  \"instagram\",\n  \"pinterest\",\n  \"reddit\",\n  \"slack\",\n  \"twitter\",\n  \"whatsapp\",\n  \"youtube\",\n  \"semrush\"\n];\nvar botAgentRegex = new RegExp(botAgents.join(\"|\"), \"i\");\nfunction userAgentIsRobot(userAgent) {\n  return !userAgent ? false : botAgentRegex.test(userAgent);\n}\nfunction isValidBrowser() {\n  const navigator = inBrowser() ? window?.navigator : null;\n  if (!navigator) {\n    return false;\n  }\n  return !userAgentIsRobot(navigator?.userAgent) && !navigator?.webdriver;\n}\nfunction isBrowserOnline() {\n  const navigator = inBrowser() ? window?.navigator : null;\n  if (!navigator) {\n    return false;\n  }\n  const isNavigatorOnline = navigator?.onLine;\n  const isExperimentalConnectionOnline = navigator?.connection?.rtt !== 0 && navigator?.connection?.downlink !== 0;\n  return isExperimentalConnectionOnline && isNavigatorOnline;\n}\nfunction isValidBrowserOnline() {\n  return isBrowserOnline() && isValidBrowser();\n}\n\n\n//# sourceMappingURL=chunk-JKSAJ6AV.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstSktTQUo2QVYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVFFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstSktTQUo2QVYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9icm93c2VyLnRzXG5mdW5jdGlvbiBpbkJyb3dzZXIoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufVxudmFyIGJvdEFnZW50cyA9IFtcbiAgXCJib3RcIixcbiAgXCJzcGlkZXJcIixcbiAgXCJjcmF3bFwiLFxuICBcIkFQSXMtR29vZ2xlXCIsXG4gIFwiQWRzQm90XCIsXG4gIFwiR29vZ2xlYm90XCIsXG4gIFwibWVkaWFwYXJ0bmVyc1wiLFxuICBcIkdvb2dsZSBGYXZpY29uXCIsXG4gIFwiRmVlZEZldGNoZXJcIixcbiAgXCJHb29nbGUtUmVhZC1BbG91ZFwiLFxuICBcIkR1cGxleFdlYi1Hb29nbGVcIixcbiAgXCJnb29nbGV3ZWJsaWdodFwiLFxuICBcImJpbmdcIixcbiAgXCJ5YW5kZXhcIixcbiAgXCJiYWlkdVwiLFxuICBcImR1Y2tkdWNrXCIsXG4gIFwieWFob29cIixcbiAgXCJlY29zaWFcIixcbiAgXCJpYV9hcmNoaXZlclwiLFxuICBcImZhY2Vib29rXCIsXG4gIFwiaW5zdGFncmFtXCIsXG4gIFwicGludGVyZXN0XCIsXG4gIFwicmVkZGl0XCIsXG4gIFwic2xhY2tcIixcbiAgXCJ0d2l0dGVyXCIsXG4gIFwid2hhdHNhcHBcIixcbiAgXCJ5b3V0dWJlXCIsXG4gIFwic2VtcnVzaFwiXG5dO1xudmFyIGJvdEFnZW50UmVnZXggPSBuZXcgUmVnRXhwKGJvdEFnZW50cy5qb2luKFwifFwiKSwgXCJpXCIpO1xuZnVuY3Rpb24gdXNlckFnZW50SXNSb2JvdCh1c2VyQWdlbnQpIHtcbiAgcmV0dXJuICF1c2VyQWdlbnQgPyBmYWxzZSA6IGJvdEFnZW50UmVnZXgudGVzdCh1c2VyQWdlbnQpO1xufVxuZnVuY3Rpb24gaXNWYWxpZEJyb3dzZXIoKSB7XG4gIGNvbnN0IG5hdmlnYXRvciA9IGluQnJvd3NlcigpID8gd2luZG93Py5uYXZpZ2F0b3IgOiBudWxsO1xuICBpZiAoIW5hdmlnYXRvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gIXVzZXJBZ2VudElzUm9ib3QobmF2aWdhdG9yPy51c2VyQWdlbnQpICYmICFuYXZpZ2F0b3I/LndlYmRyaXZlcjtcbn1cbmZ1bmN0aW9uIGlzQnJvd3Nlck9ubGluZSgpIHtcbiAgY29uc3QgbmF2aWdhdG9yID0gaW5Ccm93c2VyKCkgPyB3aW5kb3c/Lm5hdmlnYXRvciA6IG51bGw7XG4gIGlmICghbmF2aWdhdG9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGlzTmF2aWdhdG9yT25saW5lID0gbmF2aWdhdG9yPy5vbkxpbmU7XG4gIGNvbnN0IGlzRXhwZXJpbWVudGFsQ29ubmVjdGlvbk9ubGluZSA9IG5hdmlnYXRvcj8uY29ubmVjdGlvbj8ucnR0ICE9PSAwICYmIG5hdmlnYXRvcj8uY29ubmVjdGlvbj8uZG93bmxpbmsgIT09IDA7XG4gIHJldHVybiBpc0V4cGVyaW1lbnRhbENvbm5lY3Rpb25PbmxpbmUgJiYgaXNOYXZpZ2F0b3JPbmxpbmU7XG59XG5mdW5jdGlvbiBpc1ZhbGlkQnJvd3Nlck9ubGluZSgpIHtcbiAgcmV0dXJuIGlzQnJvd3Nlck9ubGluZSgpICYmIGlzVmFsaWRCcm93c2VyKCk7XG59XG5cbmV4cG9ydCB7XG4gIGluQnJvd3NlcixcbiAgdXNlckFnZW50SXNSb2JvdCxcbiAgaXNWYWxpZEJyb3dzZXIsXG4gIGlzQnJvd3Nlck9ubGluZSxcbiAgaXNWYWxpZEJyb3dzZXJPbmxpbmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1KS1NBSjZBVi5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-JKSAJ6AV.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isomorphicBtoa: () => (/* binding */ isomorphicBtoa)\n/* harmony export */ });\n// src/isomorphicBtoa.ts\nvar isomorphicBtoa = (data) => {\n  if (typeof btoa !== \"undefined\" && typeof btoa === \"function\") {\n    return btoa(data);\n  } else if (typeof global !== \"undefined\" && global.Buffer) {\n    return new global.Buffer(data).toString(\"base64\");\n  }\n  return data;\n};\n\n\n//# sourceMappingURL=chunk-KOH7GTJO.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstS09IN0dUSk8ubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFJRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2NodW5rLUtPSDdHVEpPLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaXNvbW9ycGhpY0J0b2EudHNcbnZhciBpc29tb3JwaGljQnRvYSA9IChkYXRhKSA9PiB7XG4gIGlmICh0eXBlb2YgYnRvYSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGJ0b2EoZGF0YSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuQnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBnbG9iYWwuQnVmZmVyKGRhdGEpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICB9XG4gIHJldHVybiBkYXRhO1xufTtcblxuZXhwb3J0IHtcbiAgaXNvbW9ycGhpY0J0b2Fcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1LT0g3R1RKTy5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-O32JQBM6.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-O32JQBM6.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handleValueOrFn: () => (/* binding */ handleValueOrFn)\n/* harmony export */ });\n// src/utils/handleValueOrFn.ts\nfunction handleValueOrFn(value, url, defaultValue) {\n  if (typeof value === \"function\") {\n    return value(url);\n  }\n  if (typeof value !== \"undefined\") {\n    return value;\n  }\n  if (typeof defaultValue !== \"undefined\") {\n    return defaultValue;\n  }\n  return void 0;\n}\n\n\n//# sourceMappingURL=chunk-O32JQBM6.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstTzMySlFCTTYubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2NodW5rLU8zMkpRQk02Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdXRpbHMvaGFuZGxlVmFsdWVPckZuLnRzXG5mdW5jdGlvbiBoYW5kbGVWYWx1ZU9yRm4odmFsdWUsIHVybCwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB2YWx1ZSh1cmwpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBkZWZhdWx0VmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbmV4cG9ydCB7XG4gIGhhbmRsZVZhbHVlT3JGblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLU8zMkpRQk02Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-O32JQBM6.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-PL3YYI2I.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-PL3YYI2I.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   retry: () => (/* binding */ retry)\n/* harmony export */ });\n// src/retry.ts\nvar defaultOptions = {\n  initialDelay: 125,\n  maxDelayBetweenRetries: 0,\n  factor: 2,\n  shouldRetry: (_, iteration) => iteration < 5,\n  retryImmediately: false,\n  jitter: true\n};\nvar RETRY_IMMEDIATELY_DELAY = 100;\nvar sleep = async (ms) => new Promise((s) => setTimeout(s, ms));\nvar applyJitter = (delay, jitter) => {\n  return jitter ? delay * (1 + Math.random()) : delay;\n};\nvar createExponentialDelayAsyncFn = (opts) => {\n  let timesCalled = 0;\n  const calculateDelayInMs = () => {\n    const constant = opts.initialDelay;\n    const base = opts.factor;\n    let delay = constant * Math.pow(base, timesCalled);\n    delay = applyJitter(delay, opts.jitter);\n    return Math.min(opts.maxDelayBetweenRetries || delay, delay);\n  };\n  return async () => {\n    await sleep(calculateDelayInMs());\n    timesCalled++;\n  };\n};\nvar retry = async (callback, options = {}) => {\n  let iterations = 0;\n  const { shouldRetry, initialDelay, maxDelayBetweenRetries, factor, retryImmediately, jitter, onBeforeRetry } = {\n    ...defaultOptions,\n    ...options\n  };\n  const delay = createExponentialDelayAsyncFn({\n    initialDelay,\n    maxDelayBetweenRetries,\n    factor,\n    jitter\n  });\n  while (true) {\n    try {\n      return await callback();\n    } catch (e) {\n      iterations++;\n      if (!shouldRetry(e, iterations)) {\n        throw e;\n      }\n      if (onBeforeRetry) {\n        await onBeforeRetry(iterations);\n      }\n      if (retryImmediately && iterations === 1) {\n        await sleep(applyJitter(RETRY_IMMEDIATELY_DELAY, jitter));\n      } else {\n        await delay();\n      }\n    }\n  }\n};\n\n\n//# sourceMappingURL=chunk-PL3YYI2I.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstUEwzWVlJMkkubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLFVBQVUscUdBQXFHO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstUEwzWVlJMkkubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9yZXRyeS50c1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBpbml0aWFsRGVsYXk6IDEyNSxcbiAgbWF4RGVsYXlCZXR3ZWVuUmV0cmllczogMCxcbiAgZmFjdG9yOiAyLFxuICBzaG91bGRSZXRyeTogKF8sIGl0ZXJhdGlvbikgPT4gaXRlcmF0aW9uIDwgNSxcbiAgcmV0cnlJbW1lZGlhdGVseTogZmFsc2UsXG4gIGppdHRlcjogdHJ1ZVxufTtcbnZhciBSRVRSWV9JTU1FRElBVEVMWV9ERUxBWSA9IDEwMDtcbnZhciBzbGVlcCA9IGFzeW5jIChtcykgPT4gbmV3IFByb21pc2UoKHMpID0+IHNldFRpbWVvdXQocywgbXMpKTtcbnZhciBhcHBseUppdHRlciA9IChkZWxheSwgaml0dGVyKSA9PiB7XG4gIHJldHVybiBqaXR0ZXIgPyBkZWxheSAqICgxICsgTWF0aC5yYW5kb20oKSkgOiBkZWxheTtcbn07XG52YXIgY3JlYXRlRXhwb25lbnRpYWxEZWxheUFzeW5jRm4gPSAob3B0cykgPT4ge1xuICBsZXQgdGltZXNDYWxsZWQgPSAwO1xuICBjb25zdCBjYWxjdWxhdGVEZWxheUluTXMgPSAoKSA9PiB7XG4gICAgY29uc3QgY29uc3RhbnQgPSBvcHRzLmluaXRpYWxEZWxheTtcbiAgICBjb25zdCBiYXNlID0gb3B0cy5mYWN0b3I7XG4gICAgbGV0IGRlbGF5ID0gY29uc3RhbnQgKiBNYXRoLnBvdyhiYXNlLCB0aW1lc0NhbGxlZCk7XG4gICAgZGVsYXkgPSBhcHBseUppdHRlcihkZWxheSwgb3B0cy5qaXR0ZXIpO1xuICAgIHJldHVybiBNYXRoLm1pbihvcHRzLm1heERlbGF5QmV0d2VlblJldHJpZXMgfHwgZGVsYXksIGRlbGF5KTtcbiAgfTtcbiAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBzbGVlcChjYWxjdWxhdGVEZWxheUluTXMoKSk7XG4gICAgdGltZXNDYWxsZWQrKztcbiAgfTtcbn07XG52YXIgcmV0cnkgPSBhc3luYyAoY2FsbGJhY2ssIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBsZXQgaXRlcmF0aW9ucyA9IDA7XG4gIGNvbnN0IHsgc2hvdWxkUmV0cnksIGluaXRpYWxEZWxheSwgbWF4RGVsYXlCZXR3ZWVuUmV0cmllcywgZmFjdG9yLCByZXRyeUltbWVkaWF0ZWx5LCBqaXR0ZXIsIG9uQmVmb3JlUmV0cnkgfSA9IHtcbiAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGNvbnN0IGRlbGF5ID0gY3JlYXRlRXhwb25lbnRpYWxEZWxheUFzeW5jRm4oe1xuICAgIGluaXRpYWxEZWxheSxcbiAgICBtYXhEZWxheUJldHdlZW5SZXRyaWVzLFxuICAgIGZhY3RvcixcbiAgICBqaXR0ZXJcbiAgfSk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBjYWxsYmFjaygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgIGlmICghc2hvdWxkUmV0cnkoZSwgaXRlcmF0aW9ucykpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIGlmIChvbkJlZm9yZVJldHJ5KSB7XG4gICAgICAgIGF3YWl0IG9uQmVmb3JlUmV0cnkoaXRlcmF0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAocmV0cnlJbW1lZGlhdGVseSAmJiBpdGVyYXRpb25zID09PSAxKSB7XG4gICAgICAgIGF3YWl0IHNsZWVwKGFwcGx5Sml0dGVyKFJFVFJZX0lNTUVESUFURUxZX0RFTEFZLCBqaXR0ZXIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IGRlbGF5KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQge1xuICByZXRyeVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLVBMM1lZSTJJLm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-PL3YYI2I.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-RUA3ZE6A.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-RUA3ZE6A.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EVENT_SAMPLING_RATE: () => (/* binding */ EVENT_SAMPLING_RATE4),\n/* harmony export */   EVENT_THEME_USAGE: () => (/* binding */ EVENT_THEME_USAGE),\n/* harmony export */   TelemetryCollector: () => (/* binding */ TelemetryCollector),\n/* harmony export */   eventComponentMounted: () => (/* binding */ eventComponentMounted),\n/* harmony export */   eventFrameworkMetadata: () => (/* binding */ eventFrameworkMetadata),\n/* harmony export */   eventMethodCalled: () => (/* binding */ eventMethodCalled),\n/* harmony export */   eventPrebuiltComponentMounted: () => (/* binding */ eventPrebuiltComponentMounted),\n/* harmony export */   eventPrebuiltComponentOpened: () => (/* binding */ eventPrebuiltComponentOpened),\n/* harmony export */   eventThemeUsage: () => (/* binding */ eventThemeUsage)\n/* harmony export */ });\n/* harmony import */ var _chunk_GGFRMWFO_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-GGFRMWFO.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-GGFRMWFO.mjs\");\n/* harmony import */ var _chunk_IV7BOO4U_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-IV7BOO4U.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IV7BOO4U.mjs\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\n\n// src/telemetry/throttler.ts\nvar DEFAULT_CACHE_TTL_MS = 864e5;\nvar TelemetryEventThrottler = class {\n  #cache;\n  #cacheTtl = DEFAULT_CACHE_TTL_MS;\n  constructor(cache) {\n    this.#cache = cache;\n  }\n  isEventThrottled(payload) {\n    const now = Date.now();\n    const key = this.#generateKey(payload);\n    const entry = this.#cache.getItem(key);\n    if (!entry) {\n      this.#cache.setItem(key, now);\n      return false;\n    }\n    const shouldInvalidate = now - entry > this.#cacheTtl;\n    if (shouldInvalidate) {\n      this.#cache.setItem(key, now);\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Generates a consistent unique key for telemetry events by sorting payload properties.\n   * This ensures that payloads with identical content in different orders produce the same key.\n   */\n  #generateKey(event) {\n    const { sk: _sk, pk: _pk, payload, ...rest } = event;\n    const sanitizedEvent = {\n      ...payload,\n      ...rest\n    };\n    return JSON.stringify(\n      Object.keys({\n        ...payload,\n        ...rest\n      }).sort().map((key) => sanitizedEvent[key])\n    );\n  }\n};\nvar LocalStorageThrottlerCache = class {\n  #storageKey = \"clerk_telemetry_throttler\";\n  getItem(key) {\n    return this.#getCache()[key];\n  }\n  setItem(key, value) {\n    try {\n      const cache = this.#getCache();\n      cache[key] = value;\n      localStorage.setItem(this.#storageKey, JSON.stringify(cache));\n    } catch (err) {\n      const isQuotaExceededError = err instanceof DOMException && // Check error names for different browsers\n      (err.name === \"QuotaExceededError\" || err.name === \"NS_ERROR_DOM_QUOTA_REACHED\");\n      if (isQuotaExceededError && localStorage.length > 0) {\n        localStorage.removeItem(this.#storageKey);\n      }\n    }\n  }\n  removeItem(key) {\n    try {\n      const cache = this.#getCache();\n      delete cache[key];\n      localStorage.setItem(this.#storageKey, JSON.stringify(cache));\n    } catch {\n    }\n  }\n  #getCache() {\n    try {\n      const cacheString = localStorage.getItem(this.#storageKey);\n      if (!cacheString) {\n        return {};\n      }\n      return JSON.parse(cacheString);\n    } catch {\n      return {};\n    }\n  }\n  static isSupported() {\n    return typeof window !== \"undefined\" && !!window.localStorage;\n  }\n};\nvar InMemoryThrottlerCache = class {\n  #cache = /* @__PURE__ */ new Map();\n  #maxSize = 1e4;\n  // Defensive limit to prevent memory issues\n  getItem(key) {\n    if (this.#cache.size > this.#maxSize) {\n      this.#cache.clear();\n      return void 0;\n    }\n    return this.#cache.get(key);\n  }\n  setItem(key, value) {\n    this.#cache.set(key, value);\n  }\n  removeItem(key) {\n    this.#cache.delete(key);\n  }\n};\n\n// src/telemetry/collector.ts\nfunction isWindowClerkWithMetadata(clerk) {\n  return typeof clerk === \"object\" && clerk !== null && \"constructor\" in clerk && typeof clerk.constructor === \"function\";\n}\nvar VALID_LOG_LEVELS = /* @__PURE__ */ new Set([\"error\", \"warn\", \"info\", \"debug\", \"trace\"]);\nvar DEFAULT_CONFIG = {\n  samplingRate: 1,\n  maxBufferSize: 5,\n  // Production endpoint: https://clerk-telemetry.com\n  // Staging endpoint: https://staging.clerk-telemetry.com\n  // Local: http://localhost:8787\n  endpoint: \"https://clerk-telemetry.com\"\n};\nvar TelemetryCollector = class {\n  #config;\n  #eventThrottler;\n  #metadata = {};\n  #buffer = [];\n  #pendingFlush = null;\n  constructor(options) {\n    this.#config = {\n      maxBufferSize: options.maxBufferSize ?? DEFAULT_CONFIG.maxBufferSize,\n      samplingRate: options.samplingRate ?? DEFAULT_CONFIG.samplingRate,\n      perEventSampling: options.perEventSampling ?? true,\n      disabled: options.disabled ?? false,\n      debug: options.debug ?? false,\n      endpoint: DEFAULT_CONFIG.endpoint\n    };\n    if (!options.clerkVersion && typeof window === \"undefined\") {\n      this.#metadata.clerkVersion = \"\";\n    } else {\n      this.#metadata.clerkVersion = options.clerkVersion ?? \"\";\n    }\n    this.#metadata.sdk = options.sdk;\n    this.#metadata.sdkVersion = options.sdkVersion;\n    this.#metadata.publishableKey = options.publishableKey ?? \"\";\n    const parsedKey = (0,_chunk_IV7BOO4U_mjs__WEBPACK_IMPORTED_MODULE_1__.parsePublishableKey)(options.publishableKey);\n    if (parsedKey) {\n      this.#metadata.instanceType = parsedKey.instanceType;\n    }\n    if (options.secretKey) {\n      this.#metadata.secretKey = options.secretKey.substring(0, 16);\n    }\n    const cache = LocalStorageThrottlerCache.isSupported() ? new LocalStorageThrottlerCache() : new InMemoryThrottlerCache();\n    this.#eventThrottler = new TelemetryEventThrottler(cache);\n  }\n  get isEnabled() {\n    if (this.#metadata.instanceType !== \"development\") {\n      return false;\n    }\n    if (this.#config.disabled || typeof process !== \"undefined\" && process.env && (0,_chunk_GGFRMWFO_mjs__WEBPACK_IMPORTED_MODULE_0__.isTruthy)(process.env.CLERK_TELEMETRY_DISABLED)) {\n      return false;\n    }\n    if (typeof window !== \"undefined\" && !!window?.navigator?.webdriver) {\n      return false;\n    }\n    return true;\n  }\n  get isDebug() {\n    return this.#config.debug || typeof process !== \"undefined\" && process.env && (0,_chunk_GGFRMWFO_mjs__WEBPACK_IMPORTED_MODULE_0__.isTruthy)(process.env.CLERK_TELEMETRY_DEBUG);\n  }\n  record(event) {\n    try {\n      const preparedPayload = this.#preparePayload(event.event, event.payload);\n      this.#logEvent(preparedPayload.event, preparedPayload);\n      if (!this.#shouldRecord(preparedPayload, event.eventSamplingRate)) {\n        return;\n      }\n      this.#buffer.push({ kind: \"event\", value: preparedPayload });\n      this.#scheduleFlush();\n    } catch (error) {\n      console.error(\"[clerk/telemetry] Error recording telemetry event\", error);\n    }\n  }\n  /**\n   * Records a telemetry log entry if logging is enabled and not in debug mode.\n   *\n   * @param entry - The telemetry log entry to record.\n   */\n  recordLog(entry) {\n    try {\n      if (!this.#shouldRecordLog(entry)) {\n        return;\n      }\n      const levelIsValid = typeof entry?.level === \"string\" && VALID_LOG_LEVELS.has(entry.level);\n      const messageIsValid = typeof entry?.message === \"string\" && entry.message.trim().length > 0;\n      let normalizedTimestamp = null;\n      const timestampInput = entry?.timestamp;\n      if (typeof timestampInput === \"number\" || typeof timestampInput === \"string\") {\n        const candidate = new Date(timestampInput);\n        if (!Number.isNaN(candidate.getTime())) {\n          normalizedTimestamp = candidate;\n        }\n      }\n      if (!levelIsValid || !messageIsValid || normalizedTimestamp === null) {\n        if (this.isDebug && typeof console !== \"undefined\") {\n          console.warn(\"[clerk/telemetry] Dropping invalid telemetry log entry\", {\n            levelIsValid,\n            messageIsValid,\n            timestampIsValid: normalizedTimestamp !== null\n          });\n        }\n        return;\n      }\n      const sdkMetadata = this.#getSDKMetadata();\n      const logData = {\n        sdk: sdkMetadata.name,\n        sdkv: sdkMetadata.version,\n        cv: this.#metadata.clerkVersion ?? \"\",\n        lvl: entry.level,\n        msg: entry.message,\n        ts: normalizedTimestamp.toISOString(),\n        pk: this.#metadata.publishableKey || null,\n        payload: this.#sanitizeContext(entry.context)\n      };\n      this.#buffer.push({ kind: \"log\", value: logData });\n      this.#scheduleFlush();\n    } catch (error) {\n      console.error(\"[clerk/telemetry] Error recording telemetry log entry\", error);\n    }\n  }\n  #shouldRecord(preparedPayload, eventSamplingRate) {\n    return this.isEnabled && !this.isDebug && this.#shouldBeSampled(preparedPayload, eventSamplingRate);\n  }\n  #shouldRecordLog(_entry) {\n    return true;\n  }\n  #shouldBeSampled(preparedPayload, eventSamplingRate) {\n    const randomSeed = Math.random();\n    const toBeSampled = randomSeed <= this.#config.samplingRate && (this.#config.perEventSampling === false || typeof eventSamplingRate === \"undefined\" || randomSeed <= eventSamplingRate);\n    if (!toBeSampled) {\n      return false;\n    }\n    return !this.#eventThrottler.isEventThrottled(preparedPayload);\n  }\n  #scheduleFlush() {\n    if (typeof window === \"undefined\") {\n      this.#flush();\n      return;\n    }\n    const isBufferFull = this.#buffer.length >= this.#config.maxBufferSize;\n    if (isBufferFull) {\n      if (this.#pendingFlush) {\n        if (typeof cancelIdleCallback !== \"undefined\") {\n          cancelIdleCallback(Number(this.#pendingFlush));\n        } else {\n          clearTimeout(Number(this.#pendingFlush));\n        }\n      }\n      this.#flush();\n      return;\n    }\n    if (this.#pendingFlush) {\n      return;\n    }\n    if (\"requestIdleCallback\" in window) {\n      this.#pendingFlush = requestIdleCallback(() => {\n        this.#flush();\n        this.#pendingFlush = null;\n      });\n    } else {\n      this.#pendingFlush = setTimeout(() => {\n        this.#flush();\n        this.#pendingFlush = null;\n      }, 0);\n    }\n  }\n  #flush() {\n    const itemsToSend = [...this.#buffer];\n    this.#buffer = [];\n    this.#pendingFlush = null;\n    if (itemsToSend.length === 0) {\n      return;\n    }\n    const eventsToSend = itemsToSend.filter((item) => item.kind === \"event\").map((item) => item.value);\n    const logsToSend = itemsToSend.filter((item) => item.kind === \"log\").map((item) => item.value);\n    if (eventsToSend.length > 0) {\n      const eventsUrl = new URL(\"/v1/event\", this.#config.endpoint);\n      fetch(eventsUrl, {\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        keepalive: true,\n        method: \"POST\",\n        // TODO: We send an array here with that idea that we can eventually send multiple events.\n        body: JSON.stringify({ events: eventsToSend })\n      }).catch(() => void 0);\n    }\n    if (logsToSend.length > 0) {\n      const logsUrl = new URL(\"/v1/logs\", this.#config.endpoint);\n      fetch(logsUrl, {\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        keepalive: true,\n        method: \"POST\",\n        body: JSON.stringify({ logs: logsToSend })\n      }).catch(() => void 0);\n    }\n  }\n  /**\n   * If running in debug mode, log the event and its payload to the console.\n   */\n  #logEvent(event, payload) {\n    if (!this.isDebug) {\n      return;\n    }\n    if (typeof console.groupCollapsed !== \"undefined\") {\n      console.groupCollapsed(\"[clerk/telemetry]\", event);\n      console.log(payload);\n      console.groupEnd();\n    } else {\n      console.log(\"[clerk/telemetry]\", event, payload);\n    }\n  }\n  /**\n   * If in browser, attempt to lazily grab the SDK metadata from the Clerk singleton, otherwise fallback to the initially passed in values.\n   *\n   * This is necessary because the sdkMetadata can be set by the host SDK after the TelemetryCollector is instantiated.\n   */\n  #getSDKMetadata() {\n    const sdkMetadata = {\n      name: this.#metadata.sdk,\n      version: this.#metadata.sdkVersion\n    };\n    if (typeof window !== \"undefined\") {\n      const windowWithClerk = window;\n      if (windowWithClerk.Clerk) {\n        const windowClerk = windowWithClerk.Clerk;\n        if (isWindowClerkWithMetadata(windowClerk) && windowClerk.constructor.sdkMetadata) {\n          const { name, version } = windowClerk.constructor.sdkMetadata;\n          if (name !== void 0) {\n            sdkMetadata.name = name;\n          }\n          if (version !== void 0) {\n            sdkMetadata.version = version;\n          }\n        }\n      }\n    }\n    return sdkMetadata;\n  }\n  /**\n   * Append relevant metadata from the Clerk singleton to the event payload.\n   */\n  #preparePayload(event, payload) {\n    const sdkMetadata = this.#getSDKMetadata();\n    return {\n      event,\n      cv: this.#metadata.clerkVersion ?? \"\",\n      it: this.#metadata.instanceType ?? \"\",\n      sdk: sdkMetadata.name,\n      sdkv: sdkMetadata.version,\n      ...this.#metadata.publishableKey ? { pk: this.#metadata.publishableKey } : {},\n      ...this.#metadata.secretKey ? { sk: this.#metadata.secretKey } : {},\n      payload\n    };\n  }\n  /**\n   * Best-effort sanitization of the context payload. Returns a plain object with JSON-serializable\n   * values or null when the input is missing or not serializable. Arrays are not accepted.\n   */\n  #sanitizeContext(context) {\n    if (context === null || typeof context === \"undefined\") {\n      return null;\n    }\n    if (typeof context !== \"object\") {\n      return null;\n    }\n    try {\n      const cleaned = JSON.parse(JSON.stringify(context));\n      if (cleaned && typeof cleaned === \"object\" && !Array.isArray(cleaned)) {\n        return cleaned;\n      }\n      return null;\n    } catch {\n      return null;\n    }\n  }\n};\n\n// src/telemetry/events/component-mounted.ts\nvar EVENT_COMPONENT_MOUNTED = \"COMPONENT_MOUNTED\";\nvar EVENT_COMPONENT_OPENED = \"COMPONENT_OPENED\";\nvar EVENT_SAMPLING_RATE = 0.1;\nvar AUTH_COMPONENTS = /* @__PURE__ */ new Set([\"SignIn\", \"SignUp\"]);\nfunction getComponentMountedSamplingRate(component) {\n  return AUTH_COMPONENTS.has(component) ? 1 : EVENT_SAMPLING_RATE;\n}\nfunction createPrebuiltComponentEvent(event) {\n  return function(component, props, additionalPayload) {\n    return {\n      event,\n      eventSamplingRate: event === EVENT_COMPONENT_MOUNTED ? getComponentMountedSamplingRate(component) : EVENT_SAMPLING_RATE,\n      payload: {\n        component,\n        appearanceProp: Boolean(props?.appearance),\n        baseTheme: Boolean(props?.appearance?.baseTheme),\n        elements: Boolean(props?.appearance?.elements),\n        variables: Boolean(props?.appearance?.variables),\n        ...additionalPayload\n      }\n    };\n  };\n}\nfunction eventPrebuiltComponentMounted(component, props, additionalPayload) {\n  return createPrebuiltComponentEvent(EVENT_COMPONENT_MOUNTED)(component, props, additionalPayload);\n}\nfunction eventPrebuiltComponentOpened(component, props, additionalPayload) {\n  return createPrebuiltComponentEvent(EVENT_COMPONENT_OPENED)(component, props, additionalPayload);\n}\nfunction eventComponentMounted(component, props = {}) {\n  return {\n    event: EVENT_COMPONENT_MOUNTED,\n    eventSamplingRate: getComponentMountedSamplingRate(component),\n    payload: {\n      component,\n      ...props\n    }\n  };\n}\n\n// src/telemetry/events/method-called.ts\nvar EVENT_METHOD_CALLED = \"METHOD_CALLED\";\nvar EVENT_SAMPLING_RATE2 = 0.1;\nfunction eventMethodCalled(method, payload) {\n  return {\n    event: EVENT_METHOD_CALLED,\n    eventSamplingRate: EVENT_SAMPLING_RATE2,\n    payload: {\n      method,\n      ...payload\n    }\n  };\n}\n\n// src/telemetry/events/framework-metadata.ts\nvar EVENT_FRAMEWORK_METADATA = \"FRAMEWORK_METADATA\";\nvar EVENT_SAMPLING_RATE3 = 0.1;\nfunction eventFrameworkMetadata(payload) {\n  return {\n    event: EVENT_FRAMEWORK_METADATA,\n    eventSamplingRate: EVENT_SAMPLING_RATE3,\n    payload\n  };\n}\n\n// src/telemetry/events/theme-usage.ts\nvar EVENT_THEME_USAGE = \"THEME_USAGE\";\nvar EVENT_SAMPLING_RATE4 = 1;\nfunction eventThemeUsage(appearance) {\n  const payload = analyzeThemeUsage(appearance);\n  return {\n    event: EVENT_THEME_USAGE,\n    eventSamplingRate: EVENT_SAMPLING_RATE4,\n    payload\n  };\n}\nfunction analyzeThemeUsage(appearance) {\n  if (!appearance || typeof appearance !== \"object\") {\n    return {};\n  }\n  const themeProperty = appearance.theme || appearance.baseTheme;\n  if (!themeProperty) {\n    return {};\n  }\n  let themeName;\n  if (Array.isArray(themeProperty)) {\n    for (const theme of themeProperty) {\n      const name = extractThemeName(theme);\n      if (name) {\n        themeName = name;\n        break;\n      }\n    }\n  } else {\n    themeName = extractThemeName(themeProperty);\n  }\n  return { themeName };\n}\nfunction extractThemeName(theme) {\n  if (typeof theme === \"string\") {\n    return theme;\n  }\n  if (typeof theme === \"object\" && theme !== null) {\n    if (\"name\" in theme && typeof theme.name === \"string\") {\n      return theme.name;\n    }\n  }\n  return void 0;\n}\n\n\n//# sourceMappingURL=chunk-RUA3ZE6A.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstUlVBM1pFNkEubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUU4QjtBQUdBOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUNBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3RUFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFZRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2NodW5rLVJVQTNaRTZBLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBpc1RydXRoeVxufSBmcm9tIFwiLi9jaHVuay1HR0ZSTVdGTy5tanNcIjtcbmltcG9ydCB7XG4gIHBhcnNlUHVibGlzaGFibGVLZXlcbn0gZnJvbSBcIi4vY2h1bmstSVY3Qk9PNFUubWpzXCI7XG5cbi8vIHNyYy90ZWxlbWV0cnkvdGhyb3R0bGVyLnRzXG52YXIgREVGQVVMVF9DQUNIRV9UVExfTVMgPSA4NjRlNTtcbnZhciBUZWxlbWV0cnlFdmVudFRocm90dGxlciA9IGNsYXNzIHtcbiAgI2NhY2hlO1xuICAjY2FjaGVUdGwgPSBERUZBVUxUX0NBQ0hFX1RUTF9NUztcbiAgY29uc3RydWN0b3IoY2FjaGUpIHtcbiAgICB0aGlzLiNjYWNoZSA9IGNhY2hlO1xuICB9XG4gIGlzRXZlbnRUaHJvdHRsZWQocGF5bG9hZCkge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3Qga2V5ID0gdGhpcy4jZ2VuZXJhdGVLZXkocGF5bG9hZCk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLiNjYWNoZS5nZXRJdGVtKGtleSk7XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgdGhpcy4jY2FjaGUuc2V0SXRlbShrZXksIG5vdyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZEludmFsaWRhdGUgPSBub3cgLSBlbnRyeSA+IHRoaXMuI2NhY2hlVHRsO1xuICAgIGlmIChzaG91bGRJbnZhbGlkYXRlKSB7XG4gICAgICB0aGlzLiNjYWNoZS5zZXRJdGVtKGtleSwgbm93KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIGNvbnNpc3RlbnQgdW5pcXVlIGtleSBmb3IgdGVsZW1ldHJ5IGV2ZW50cyBieSBzb3J0aW5nIHBheWxvYWQgcHJvcGVydGllcy5cbiAgICogVGhpcyBlbnN1cmVzIHRoYXQgcGF5bG9hZHMgd2l0aCBpZGVudGljYWwgY29udGVudCBpbiBkaWZmZXJlbnQgb3JkZXJzIHByb2R1Y2UgdGhlIHNhbWUga2V5LlxuICAgKi9cbiAgI2dlbmVyYXRlS2V5KGV2ZW50KSB7XG4gICAgY29uc3QgeyBzazogX3NrLCBwazogX3BrLCBwYXlsb2FkLCAuLi5yZXN0IH0gPSBldmVudDtcbiAgICBjb25zdCBzYW5pdGl6ZWRFdmVudCA9IHtcbiAgICAgIC4uLnBheWxvYWQsXG4gICAgICAuLi5yZXN0XG4gICAgfTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoXG4gICAgICBPYmplY3Qua2V5cyh7XG4gICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgIC4uLnJlc3RcbiAgICAgIH0pLnNvcnQoKS5tYXAoKGtleSkgPT4gc2FuaXRpemVkRXZlbnRba2V5XSlcbiAgICApO1xuICB9XG59O1xudmFyIExvY2FsU3RvcmFnZVRocm90dGxlckNhY2hlID0gY2xhc3Mge1xuICAjc3RvcmFnZUtleSA9IFwiY2xlcmtfdGVsZW1ldHJ5X3Rocm90dGxlclwiO1xuICBnZXRJdGVtKGtleSkge1xuICAgIHJldHVybiB0aGlzLiNnZXRDYWNoZSgpW2tleV07XG4gIH1cbiAgc2V0SXRlbShrZXksIHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy4jZ2V0Q2FjaGUoKTtcbiAgICAgIGNhY2hlW2tleV0gPSB2YWx1ZTtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuI3N0b3JhZ2VLZXksIEpTT04uc3RyaW5naWZ5KGNhY2hlKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zdCBpc1F1b3RhRXhjZWVkZWRFcnJvciA9IGVyciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiAvLyBDaGVjayBlcnJvciBuYW1lcyBmb3IgZGlmZmVyZW50IGJyb3dzZXJzXG4gICAgICAoZXJyLm5hbWUgPT09IFwiUXVvdGFFeGNlZWRlZEVycm9yXCIgfHwgZXJyLm5hbWUgPT09IFwiTlNfRVJST1JfRE9NX1FVT1RBX1JFQUNIRURcIik7XG4gICAgICBpZiAoaXNRdW90YUV4Y2VlZGVkRXJyb3IgJiYgbG9jYWxTdG9yYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy4jc3RvcmFnZUtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy4jZ2V0Q2FjaGUoKTtcbiAgICAgIGRlbGV0ZSBjYWNoZVtrZXldO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy4jc3RvcmFnZUtleSwgSlNPTi5zdHJpbmdpZnkoY2FjaGUpKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgI2dldENhY2hlKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjYWNoZVN0cmluZyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuI3N0b3JhZ2VLZXkpO1xuICAgICAgaWYgKCFjYWNoZVN0cmluZykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShjYWNoZVN0cmluZyk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG4gIHN0YXRpYyBpc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhIXdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH1cbn07XG52YXIgSW5NZW1vcnlUaHJvdHRsZXJDYWNoZSA9IGNsYXNzIHtcbiAgI2NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgI21heFNpemUgPSAxZTQ7XG4gIC8vIERlZmVuc2l2ZSBsaW1pdCB0byBwcmV2ZW50IG1lbW9yeSBpc3N1ZXNcbiAgZ2V0SXRlbShrZXkpIHtcbiAgICBpZiAodGhpcy4jY2FjaGUuc2l6ZSA+IHRoaXMuI21heFNpemUpIHtcbiAgICAgIHRoaXMuI2NhY2hlLmNsZWFyKCk7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gIH1cbiAgc2V0SXRlbShrZXksIHZhbHVlKSB7XG4gICAgdGhpcy4jY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICB9XG4gIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgdGhpcy4jY2FjaGUuZGVsZXRlKGtleSk7XG4gIH1cbn07XG5cbi8vIHNyYy90ZWxlbWV0cnkvY29sbGVjdG9yLnRzXG5mdW5jdGlvbiBpc1dpbmRvd0NsZXJrV2l0aE1ldGFkYXRhKGNsZXJrKSB7XG4gIHJldHVybiB0eXBlb2YgY2xlcmsgPT09IFwib2JqZWN0XCIgJiYgY2xlcmsgIT09IG51bGwgJiYgXCJjb25zdHJ1Y3RvclwiIGluIGNsZXJrICYmIHR5cGVvZiBjbGVyay5jb25zdHJ1Y3RvciA9PT0gXCJmdW5jdGlvblwiO1xufVxudmFyIFZBTElEX0xPR19MRVZFTFMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJlcnJvclwiLCBcIndhcm5cIiwgXCJpbmZvXCIsIFwiZGVidWdcIiwgXCJ0cmFjZVwiXSk7XG52YXIgREVGQVVMVF9DT05GSUcgPSB7XG4gIHNhbXBsaW5nUmF0ZTogMSxcbiAgbWF4QnVmZmVyU2l6ZTogNSxcbiAgLy8gUHJvZHVjdGlvbiBlbmRwb2ludDogaHR0cHM6Ly9jbGVyay10ZWxlbWV0cnkuY29tXG4gIC8vIFN0YWdpbmcgZW5kcG9pbnQ6IGh0dHBzOi8vc3RhZ2luZy5jbGVyay10ZWxlbWV0cnkuY29tXG4gIC8vIExvY2FsOiBodHRwOi8vbG9jYWxob3N0Ojg3ODdcbiAgZW5kcG9pbnQ6IFwiaHR0cHM6Ly9jbGVyay10ZWxlbWV0cnkuY29tXCJcbn07XG52YXIgVGVsZW1ldHJ5Q29sbGVjdG9yID0gY2xhc3Mge1xuICAjY29uZmlnO1xuICAjZXZlbnRUaHJvdHRsZXI7XG4gICNtZXRhZGF0YSA9IHt9O1xuICAjYnVmZmVyID0gW107XG4gICNwZW5kaW5nRmx1c2ggPSBudWxsO1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy4jY29uZmlnID0ge1xuICAgICAgbWF4QnVmZmVyU2l6ZTogb3B0aW9ucy5tYXhCdWZmZXJTaXplID8/IERFRkFVTFRfQ09ORklHLm1heEJ1ZmZlclNpemUsXG4gICAgICBzYW1wbGluZ1JhdGU6IG9wdGlvbnMuc2FtcGxpbmdSYXRlID8/IERFRkFVTFRfQ09ORklHLnNhbXBsaW5nUmF0ZSxcbiAgICAgIHBlckV2ZW50U2FtcGxpbmc6IG9wdGlvbnMucGVyRXZlbnRTYW1wbGluZyA/PyB0cnVlLFxuICAgICAgZGlzYWJsZWQ6IG9wdGlvbnMuZGlzYWJsZWQgPz8gZmFsc2UsXG4gICAgICBkZWJ1Zzogb3B0aW9ucy5kZWJ1ZyA/PyBmYWxzZSxcbiAgICAgIGVuZHBvaW50OiBERUZBVUxUX0NPTkZJRy5lbmRwb2ludFxuICAgIH07XG4gICAgaWYgKCFvcHRpb25zLmNsZXJrVmVyc2lvbiAmJiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLiNtZXRhZGF0YS5jbGVya1ZlcnNpb24gPSBcIlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNtZXRhZGF0YS5jbGVya1ZlcnNpb24gPSBvcHRpb25zLmNsZXJrVmVyc2lvbiA/PyBcIlwiO1xuICAgIH1cbiAgICB0aGlzLiNtZXRhZGF0YS5zZGsgPSBvcHRpb25zLnNkaztcbiAgICB0aGlzLiNtZXRhZGF0YS5zZGtWZXJzaW9uID0gb3B0aW9ucy5zZGtWZXJzaW9uO1xuICAgIHRoaXMuI21ldGFkYXRhLnB1Ymxpc2hhYmxlS2V5ID0gb3B0aW9ucy5wdWJsaXNoYWJsZUtleSA/PyBcIlwiO1xuICAgIGNvbnN0IHBhcnNlZEtleSA9IHBhcnNlUHVibGlzaGFibGVLZXkob3B0aW9ucy5wdWJsaXNoYWJsZUtleSk7XG4gICAgaWYgKHBhcnNlZEtleSkge1xuICAgICAgdGhpcy4jbWV0YWRhdGEuaW5zdGFuY2VUeXBlID0gcGFyc2VkS2V5Lmluc3RhbmNlVHlwZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc2VjcmV0S2V5KSB7XG4gICAgICB0aGlzLiNtZXRhZGF0YS5zZWNyZXRLZXkgPSBvcHRpb25zLnNlY3JldEtleS5zdWJzdHJpbmcoMCwgMTYpO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZSA9IExvY2FsU3RvcmFnZVRocm90dGxlckNhY2hlLmlzU3VwcG9ydGVkKCkgPyBuZXcgTG9jYWxTdG9yYWdlVGhyb3R0bGVyQ2FjaGUoKSA6IG5ldyBJbk1lbW9yeVRocm90dGxlckNhY2hlKCk7XG4gICAgdGhpcy4jZXZlbnRUaHJvdHRsZXIgPSBuZXcgVGVsZW1ldHJ5RXZlbnRUaHJvdHRsZXIoY2FjaGUpO1xuICB9XG4gIGdldCBpc0VuYWJsZWQoKSB7XG4gICAgaWYgKHRoaXMuI21ldGFkYXRhLmluc3RhbmNlVHlwZSAhPT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLiNjb25maWcuZGlzYWJsZWQgfHwgdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYgJiYgaXNUcnV0aHkocHJvY2Vzcy5lbnYuQ0xFUktfVEVMRU1FVFJZX0RJU0FCTEVEKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhIXdpbmRvdz8ubmF2aWdhdG9yPy53ZWJkcml2ZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0IGlzRGVidWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbmZpZy5kZWJ1ZyB8fCB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudiAmJiBpc1RydXRoeShwcm9jZXNzLmVudi5DTEVSS19URUxFTUVUUllfREVCVUcpO1xuICB9XG4gIHJlY29yZChldmVudCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcmVwYXJlZFBheWxvYWQgPSB0aGlzLiNwcmVwYXJlUGF5bG9hZChldmVudC5ldmVudCwgZXZlbnQucGF5bG9hZCk7XG4gICAgICB0aGlzLiNsb2dFdmVudChwcmVwYXJlZFBheWxvYWQuZXZlbnQsIHByZXBhcmVkUGF5bG9hZCk7XG4gICAgICBpZiAoIXRoaXMuI3Nob3VsZFJlY29yZChwcmVwYXJlZFBheWxvYWQsIGV2ZW50LmV2ZW50U2FtcGxpbmdSYXRlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLiNidWZmZXIucHVzaCh7IGtpbmQ6IFwiZXZlbnRcIiwgdmFsdWU6IHByZXBhcmVkUGF5bG9hZCB9KTtcbiAgICAgIHRoaXMuI3NjaGVkdWxlRmx1c2goKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltjbGVyay90ZWxlbWV0cnldIEVycm9yIHJlY29yZGluZyB0ZWxlbWV0cnkgZXZlbnRcIiwgZXJyb3IpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVjb3JkcyBhIHRlbGVtZXRyeSBsb2cgZW50cnkgaWYgbG9nZ2luZyBpcyBlbmFibGVkIGFuZCBub3QgaW4gZGVidWcgbW9kZS5cbiAgICpcbiAgICogQHBhcmFtIGVudHJ5IC0gVGhlIHRlbGVtZXRyeSBsb2cgZW50cnkgdG8gcmVjb3JkLlxuICAgKi9cbiAgcmVjb3JkTG9nKGVudHJ5KSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdGhpcy4jc2hvdWxkUmVjb3JkTG9nKGVudHJ5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsZXZlbElzVmFsaWQgPSB0eXBlb2YgZW50cnk/LmxldmVsID09PSBcInN0cmluZ1wiICYmIFZBTElEX0xPR19MRVZFTFMuaGFzKGVudHJ5LmxldmVsKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VJc1ZhbGlkID0gdHlwZW9mIGVudHJ5Py5tZXNzYWdlID09PSBcInN0cmluZ1wiICYmIGVudHJ5Lm1lc3NhZ2UudHJpbSgpLmxlbmd0aCA+IDA7XG4gICAgICBsZXQgbm9ybWFsaXplZFRpbWVzdGFtcCA9IG51bGw7XG4gICAgICBjb25zdCB0aW1lc3RhbXBJbnB1dCA9IGVudHJ5Py50aW1lc3RhbXA7XG4gICAgICBpZiAodHlwZW9mIHRpbWVzdGFtcElucHV0ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB0aW1lc3RhbXBJbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBuZXcgRGF0ZSh0aW1lc3RhbXBJbnB1dCk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGNhbmRpZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgICAgbm9ybWFsaXplZFRpbWVzdGFtcCA9IGNhbmRpZGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFsZXZlbElzVmFsaWQgfHwgIW1lc3NhZ2VJc1ZhbGlkIHx8IG5vcm1hbGl6ZWRUaW1lc3RhbXAgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEZWJ1ZyAmJiB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIltjbGVyay90ZWxlbWV0cnldIERyb3BwaW5nIGludmFsaWQgdGVsZW1ldHJ5IGxvZyBlbnRyeVwiLCB7XG4gICAgICAgICAgICBsZXZlbElzVmFsaWQsXG4gICAgICAgICAgICBtZXNzYWdlSXNWYWxpZCxcbiAgICAgICAgICAgIHRpbWVzdGFtcElzVmFsaWQ6IG5vcm1hbGl6ZWRUaW1lc3RhbXAgIT09IG51bGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzZGtNZXRhZGF0YSA9IHRoaXMuI2dldFNES01ldGFkYXRhKCk7XG4gICAgICBjb25zdCBsb2dEYXRhID0ge1xuICAgICAgICBzZGs6IHNka01ldGFkYXRhLm5hbWUsXG4gICAgICAgIHNka3Y6IHNka01ldGFkYXRhLnZlcnNpb24sXG4gICAgICAgIGN2OiB0aGlzLiNtZXRhZGF0YS5jbGVya1ZlcnNpb24gPz8gXCJcIixcbiAgICAgICAgbHZsOiBlbnRyeS5sZXZlbCxcbiAgICAgICAgbXNnOiBlbnRyeS5tZXNzYWdlLFxuICAgICAgICB0czogbm9ybWFsaXplZFRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICBwazogdGhpcy4jbWV0YWRhdGEucHVibGlzaGFibGVLZXkgfHwgbnVsbCxcbiAgICAgICAgcGF5bG9hZDogdGhpcy4jc2FuaXRpemVDb250ZXh0KGVudHJ5LmNvbnRleHQpXG4gICAgICB9O1xuICAgICAgdGhpcy4jYnVmZmVyLnB1c2goeyBraW5kOiBcImxvZ1wiLCB2YWx1ZTogbG9nRGF0YSB9KTtcbiAgICAgIHRoaXMuI3NjaGVkdWxlRmx1c2goKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltjbGVyay90ZWxlbWV0cnldIEVycm9yIHJlY29yZGluZyB0ZWxlbWV0cnkgbG9nIGVudHJ5XCIsIGVycm9yKTtcbiAgICB9XG4gIH1cbiAgI3Nob3VsZFJlY29yZChwcmVwYXJlZFBheWxvYWQsIGV2ZW50U2FtcGxpbmdSYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNFbmFibGVkICYmICF0aGlzLmlzRGVidWcgJiYgdGhpcy4jc2hvdWxkQmVTYW1wbGVkKHByZXBhcmVkUGF5bG9hZCwgZXZlbnRTYW1wbGluZ1JhdGUpO1xuICB9XG4gICNzaG91bGRSZWNvcmRMb2coX2VudHJ5KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgI3Nob3VsZEJlU2FtcGxlZChwcmVwYXJlZFBheWxvYWQsIGV2ZW50U2FtcGxpbmdSYXRlKSB7XG4gICAgY29uc3QgcmFuZG9tU2VlZCA9IE1hdGgucmFuZG9tKCk7XG4gICAgY29uc3QgdG9CZVNhbXBsZWQgPSByYW5kb21TZWVkIDw9IHRoaXMuI2NvbmZpZy5zYW1wbGluZ1JhdGUgJiYgKHRoaXMuI2NvbmZpZy5wZXJFdmVudFNhbXBsaW5nID09PSBmYWxzZSB8fCB0eXBlb2YgZXZlbnRTYW1wbGluZ1JhdGUgPT09IFwidW5kZWZpbmVkXCIgfHwgcmFuZG9tU2VlZCA8PSBldmVudFNhbXBsaW5nUmF0ZSk7XG4gICAgaWYgKCF0b0JlU2FtcGxlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gIXRoaXMuI2V2ZW50VGhyb3R0bGVyLmlzRXZlbnRUaHJvdHRsZWQocHJlcGFyZWRQYXlsb2FkKTtcbiAgfVxuICAjc2NoZWR1bGVGbHVzaCgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhpcy4jZmx1c2goKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNCdWZmZXJGdWxsID0gdGhpcy4jYnVmZmVyLmxlbmd0aCA+PSB0aGlzLiNjb25maWcubWF4QnVmZmVyU2l6ZTtcbiAgICBpZiAoaXNCdWZmZXJGdWxsKSB7XG4gICAgICBpZiAodGhpcy4jcGVuZGluZ0ZsdXNoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FuY2VsSWRsZUNhbGxiYWNrICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgY2FuY2VsSWRsZUNhbGxiYWNrKE51bWJlcih0aGlzLiNwZW5kaW5nRmx1c2gpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoTnVtYmVyKHRoaXMuI3BlbmRpbmdGbHVzaCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLiNmbHVzaCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jcGVuZGluZ0ZsdXNoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChcInJlcXVlc3RJZGxlQ2FsbGJhY2tcIiBpbiB3aW5kb3cpIHtcbiAgICAgIHRoaXMuI3BlbmRpbmdGbHVzaCA9IHJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICB0aGlzLiNmbHVzaCgpO1xuICAgICAgICB0aGlzLiNwZW5kaW5nRmx1c2ggPSBudWxsO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI3BlbmRpbmdGbHVzaCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLiNmbHVzaCgpO1xuICAgICAgICB0aGlzLiNwZW5kaW5nRmx1c2ggPSBudWxsO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9XG4gICNmbHVzaCgpIHtcbiAgICBjb25zdCBpdGVtc1RvU2VuZCA9IFsuLi50aGlzLiNidWZmZXJdO1xuICAgIHRoaXMuI2J1ZmZlciA9IFtdO1xuICAgIHRoaXMuI3BlbmRpbmdGbHVzaCA9IG51bGw7XG4gICAgaWYgKGl0ZW1zVG9TZW5kLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBldmVudHNUb1NlbmQgPSBpdGVtc1RvU2VuZC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0ua2luZCA9PT0gXCJldmVudFwiKS5tYXAoKGl0ZW0pID0+IGl0ZW0udmFsdWUpO1xuICAgIGNvbnN0IGxvZ3NUb1NlbmQgPSBpdGVtc1RvU2VuZC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0ua2luZCA9PT0gXCJsb2dcIikubWFwKChpdGVtKSA9PiBpdGVtLnZhbHVlKTtcbiAgICBpZiAoZXZlbnRzVG9TZW5kLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGV2ZW50c1VybCA9IG5ldyBVUkwoXCIvdjEvZXZlbnRcIiwgdGhpcy4jY29uZmlnLmVuZHBvaW50KTtcbiAgICAgIGZldGNoKGV2ZW50c1VybCwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAga2VlcGFsaXZlOiB0cnVlLFxuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAvLyBUT0RPOiBXZSBzZW5kIGFuIGFycmF5IGhlcmUgd2l0aCB0aGF0IGlkZWEgdGhhdCB3ZSBjYW4gZXZlbnR1YWxseSBzZW5kIG11bHRpcGxlIGV2ZW50cy5cbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBldmVudHM6IGV2ZW50c1RvU2VuZCB9KVxuICAgICAgfSkuY2F0Y2goKCkgPT4gdm9pZCAwKTtcbiAgICB9XG4gICAgaWYgKGxvZ3NUb1NlbmQubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbG9nc1VybCA9IG5ldyBVUkwoXCIvdjEvbG9nc1wiLCB0aGlzLiNjb25maWcuZW5kcG9pbnQpO1xuICAgICAgZmV0Y2gobG9nc1VybCwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAga2VlcGFsaXZlOiB0cnVlLFxuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGxvZ3M6IGxvZ3NUb1NlbmQgfSlcbiAgICAgIH0pLmNhdGNoKCgpID0+IHZvaWQgMCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJZiBydW5uaW5nIGluIGRlYnVnIG1vZGUsIGxvZyB0aGUgZXZlbnQgYW5kIGl0cyBwYXlsb2FkIHRvIHRoZSBjb25zb2xlLlxuICAgKi9cbiAgI2xvZ0V2ZW50KGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgaWYgKCF0aGlzLmlzRGVidWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlLmdyb3VwQ29sbGFwc2VkICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKFwiW2NsZXJrL3RlbGVtZXRyeV1cIiwgZXZlbnQpO1xuICAgICAgY29uc29sZS5sb2cocGF5bG9hZCk7XG4gICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiW2NsZXJrL3RlbGVtZXRyeV1cIiwgZXZlbnQsIHBheWxvYWQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSWYgaW4gYnJvd3NlciwgYXR0ZW1wdCB0byBsYXppbHkgZ3JhYiB0aGUgU0RLIG1ldGFkYXRhIGZyb20gdGhlIENsZXJrIHNpbmdsZXRvbiwgb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIHRoZSBpbml0aWFsbHkgcGFzc2VkIGluIHZhbHVlcy5cbiAgICpcbiAgICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgc2RrTWV0YWRhdGEgY2FuIGJlIHNldCBieSB0aGUgaG9zdCBTREsgYWZ0ZXIgdGhlIFRlbGVtZXRyeUNvbGxlY3RvciBpcyBpbnN0YW50aWF0ZWQuXG4gICAqL1xuICAjZ2V0U0RLTWV0YWRhdGEoKSB7XG4gICAgY29uc3Qgc2RrTWV0YWRhdGEgPSB7XG4gICAgICBuYW1lOiB0aGlzLiNtZXRhZGF0YS5zZGssXG4gICAgICB2ZXJzaW9uOiB0aGlzLiNtZXRhZGF0YS5zZGtWZXJzaW9uXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY29uc3Qgd2luZG93V2l0aENsZXJrID0gd2luZG93O1xuICAgICAgaWYgKHdpbmRvd1dpdGhDbGVyay5DbGVyaykge1xuICAgICAgICBjb25zdCB3aW5kb3dDbGVyayA9IHdpbmRvd1dpdGhDbGVyay5DbGVyaztcbiAgICAgICAgaWYgKGlzV2luZG93Q2xlcmtXaXRoTWV0YWRhdGEod2luZG93Q2xlcmspICYmIHdpbmRvd0NsZXJrLmNvbnN0cnVjdG9yLnNka01ldGFkYXRhKSB7XG4gICAgICAgICAgY29uc3QgeyBuYW1lLCB2ZXJzaW9uIH0gPSB3aW5kb3dDbGVyay5jb25zdHJ1Y3Rvci5zZGtNZXRhZGF0YTtcbiAgICAgICAgICBpZiAobmFtZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBzZGtNZXRhZGF0YS5uYW1lID0gbmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZlcnNpb24gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgc2RrTWV0YWRhdGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZGtNZXRhZGF0YTtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kIHJlbGV2YW50IG1ldGFkYXRhIGZyb20gdGhlIENsZXJrIHNpbmdsZXRvbiB0byB0aGUgZXZlbnQgcGF5bG9hZC5cbiAgICovXG4gICNwcmVwYXJlUGF5bG9hZChldmVudCwgcGF5bG9hZCkge1xuICAgIGNvbnN0IHNka01ldGFkYXRhID0gdGhpcy4jZ2V0U0RLTWV0YWRhdGEoKTtcbiAgICByZXR1cm4ge1xuICAgICAgZXZlbnQsXG4gICAgICBjdjogdGhpcy4jbWV0YWRhdGEuY2xlcmtWZXJzaW9uID8/IFwiXCIsXG4gICAgICBpdDogdGhpcy4jbWV0YWRhdGEuaW5zdGFuY2VUeXBlID8/IFwiXCIsXG4gICAgICBzZGs6IHNka01ldGFkYXRhLm5hbWUsXG4gICAgICBzZGt2OiBzZGtNZXRhZGF0YS52ZXJzaW9uLFxuICAgICAgLi4udGhpcy4jbWV0YWRhdGEucHVibGlzaGFibGVLZXkgPyB7IHBrOiB0aGlzLiNtZXRhZGF0YS5wdWJsaXNoYWJsZUtleSB9IDoge30sXG4gICAgICAuLi50aGlzLiNtZXRhZGF0YS5zZWNyZXRLZXkgPyB7IHNrOiB0aGlzLiNtZXRhZGF0YS5zZWNyZXRLZXkgfSA6IHt9LFxuICAgICAgcGF5bG9hZFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEJlc3QtZWZmb3J0IHNhbml0aXphdGlvbiBvZiB0aGUgY29udGV4dCBwYXlsb2FkLiBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IHdpdGggSlNPTi1zZXJpYWxpemFibGVcbiAgICogdmFsdWVzIG9yIG51bGwgd2hlbiB0aGUgaW5wdXQgaXMgbWlzc2luZyBvciBub3Qgc2VyaWFsaXphYmxlLiBBcnJheXMgYXJlIG5vdCBhY2NlcHRlZC5cbiAgICovXG4gICNzYW5pdGl6ZUNvbnRleHQoY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09PSBudWxsIHx8IHR5cGVvZiBjb250ZXh0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNsZWFuZWQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbnRleHQpKTtcbiAgICAgIGlmIChjbGVhbmVkICYmIHR5cGVvZiBjbGVhbmVkID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGNsZWFuZWQpKSB7XG4gICAgICAgIHJldHVybiBjbGVhbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy90ZWxlbWV0cnkvZXZlbnRzL2NvbXBvbmVudC1tb3VudGVkLnRzXG52YXIgRVZFTlRfQ09NUE9ORU5UX01PVU5URUQgPSBcIkNPTVBPTkVOVF9NT1VOVEVEXCI7XG52YXIgRVZFTlRfQ09NUE9ORU5UX09QRU5FRCA9IFwiQ09NUE9ORU5UX09QRU5FRFwiO1xudmFyIEVWRU5UX1NBTVBMSU5HX1JBVEUgPSAwLjE7XG52YXIgQVVUSF9DT01QT05FTlRTID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiU2lnbkluXCIsIFwiU2lnblVwXCJdKTtcbmZ1bmN0aW9uIGdldENvbXBvbmVudE1vdW50ZWRTYW1wbGluZ1JhdGUoY29tcG9uZW50KSB7XG4gIHJldHVybiBBVVRIX0NPTVBPTkVOVFMuaGFzKGNvbXBvbmVudCkgPyAxIDogRVZFTlRfU0FNUExJTkdfUkFURTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByZWJ1aWx0Q29tcG9uZW50RXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbXBvbmVudCwgcHJvcHMsIGFkZGl0aW9uYWxQYXlsb2FkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV2ZW50LFxuICAgICAgZXZlbnRTYW1wbGluZ1JhdGU6IGV2ZW50ID09PSBFVkVOVF9DT01QT05FTlRfTU9VTlRFRCA/IGdldENvbXBvbmVudE1vdW50ZWRTYW1wbGluZ1JhdGUoY29tcG9uZW50KSA6IEVWRU5UX1NBTVBMSU5HX1JBVEUsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgYXBwZWFyYW5jZVByb3A6IEJvb2xlYW4ocHJvcHM/LmFwcGVhcmFuY2UpLFxuICAgICAgICBiYXNlVGhlbWU6IEJvb2xlYW4ocHJvcHM/LmFwcGVhcmFuY2U/LmJhc2VUaGVtZSksXG4gICAgICAgIGVsZW1lbnRzOiBCb29sZWFuKHByb3BzPy5hcHBlYXJhbmNlPy5lbGVtZW50cyksXG4gICAgICAgIHZhcmlhYmxlczogQm9vbGVhbihwcm9wcz8uYXBwZWFyYW5jZT8udmFyaWFibGVzKSxcbiAgICAgICAgLi4uYWRkaXRpb25hbFBheWxvYWRcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gZXZlbnRQcmVidWlsdENvbXBvbmVudE1vdW50ZWQoY29tcG9uZW50LCBwcm9wcywgYWRkaXRpb25hbFBheWxvYWQpIHtcbiAgcmV0dXJuIGNyZWF0ZVByZWJ1aWx0Q29tcG9uZW50RXZlbnQoRVZFTlRfQ09NUE9ORU5UX01PVU5URUQpKGNvbXBvbmVudCwgcHJvcHMsIGFkZGl0aW9uYWxQYXlsb2FkKTtcbn1cbmZ1bmN0aW9uIGV2ZW50UHJlYnVpbHRDb21wb25lbnRPcGVuZWQoY29tcG9uZW50LCBwcm9wcywgYWRkaXRpb25hbFBheWxvYWQpIHtcbiAgcmV0dXJuIGNyZWF0ZVByZWJ1aWx0Q29tcG9uZW50RXZlbnQoRVZFTlRfQ09NUE9ORU5UX09QRU5FRCkoY29tcG9uZW50LCBwcm9wcywgYWRkaXRpb25hbFBheWxvYWQpO1xufVxuZnVuY3Rpb24gZXZlbnRDb21wb25lbnRNb3VudGVkKGNvbXBvbmVudCwgcHJvcHMgPSB7fSkge1xuICByZXR1cm4ge1xuICAgIGV2ZW50OiBFVkVOVF9DT01QT05FTlRfTU9VTlRFRCxcbiAgICBldmVudFNhbXBsaW5nUmF0ZTogZ2V0Q29tcG9uZW50TW91bnRlZFNhbXBsaW5nUmF0ZShjb21wb25lbnQpLFxuICAgIHBheWxvYWQ6IHtcbiAgICAgIGNvbXBvbmVudCxcbiAgICAgIC4uLnByb3BzXG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdGVsZW1ldHJ5L2V2ZW50cy9tZXRob2QtY2FsbGVkLnRzXG52YXIgRVZFTlRfTUVUSE9EX0NBTExFRCA9IFwiTUVUSE9EX0NBTExFRFwiO1xudmFyIEVWRU5UX1NBTVBMSU5HX1JBVEUyID0gMC4xO1xuZnVuY3Rpb24gZXZlbnRNZXRob2RDYWxsZWQobWV0aG9kLCBwYXlsb2FkKSB7XG4gIHJldHVybiB7XG4gICAgZXZlbnQ6IEVWRU5UX01FVEhPRF9DQUxMRUQsXG4gICAgZXZlbnRTYW1wbGluZ1JhdGU6IEVWRU5UX1NBTVBMSU5HX1JBVEUyLFxuICAgIHBheWxvYWQ6IHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIC4uLnBheWxvYWRcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy90ZWxlbWV0cnkvZXZlbnRzL2ZyYW1ld29yay1tZXRhZGF0YS50c1xudmFyIEVWRU5UX0ZSQU1FV09SS19NRVRBREFUQSA9IFwiRlJBTUVXT1JLX01FVEFEQVRBXCI7XG52YXIgRVZFTlRfU0FNUExJTkdfUkFURTMgPSAwLjE7XG5mdW5jdGlvbiBldmVudEZyYW1ld29ya01ldGFkYXRhKHBheWxvYWQpIHtcbiAgcmV0dXJuIHtcbiAgICBldmVudDogRVZFTlRfRlJBTUVXT1JLX01FVEFEQVRBLFxuICAgIGV2ZW50U2FtcGxpbmdSYXRlOiBFVkVOVF9TQU1QTElOR19SQVRFMyxcbiAgICBwYXlsb2FkXG4gIH07XG59XG5cbi8vIHNyYy90ZWxlbWV0cnkvZXZlbnRzL3RoZW1lLXVzYWdlLnRzXG52YXIgRVZFTlRfVEhFTUVfVVNBR0UgPSBcIlRIRU1FX1VTQUdFXCI7XG52YXIgRVZFTlRfU0FNUExJTkdfUkFURTQgPSAxO1xuZnVuY3Rpb24gZXZlbnRUaGVtZVVzYWdlKGFwcGVhcmFuY2UpIHtcbiAgY29uc3QgcGF5bG9hZCA9IGFuYWx5emVUaGVtZVVzYWdlKGFwcGVhcmFuY2UpO1xuICByZXR1cm4ge1xuICAgIGV2ZW50OiBFVkVOVF9USEVNRV9VU0FHRSxcbiAgICBldmVudFNhbXBsaW5nUmF0ZTogRVZFTlRfU0FNUExJTkdfUkFURTQsXG4gICAgcGF5bG9hZFxuICB9O1xufVxuZnVuY3Rpb24gYW5hbHl6ZVRoZW1lVXNhZ2UoYXBwZWFyYW5jZSkge1xuICBpZiAoIWFwcGVhcmFuY2UgfHwgdHlwZW9mIGFwcGVhcmFuY2UgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgdGhlbWVQcm9wZXJ0eSA9IGFwcGVhcmFuY2UudGhlbWUgfHwgYXBwZWFyYW5jZS5iYXNlVGhlbWU7XG4gIGlmICghdGhlbWVQcm9wZXJ0eSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBsZXQgdGhlbWVOYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheSh0aGVtZVByb3BlcnR5KSkge1xuICAgIGZvciAoY29uc3QgdGhlbWUgb2YgdGhlbWVQcm9wZXJ0eSkge1xuICAgICAgY29uc3QgbmFtZSA9IGV4dHJhY3RUaGVtZU5hbWUodGhlbWUpO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgdGhlbWVOYW1lID0gbmFtZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoZW1lTmFtZSA9IGV4dHJhY3RUaGVtZU5hbWUodGhlbWVQcm9wZXJ0eSk7XG4gIH1cbiAgcmV0dXJuIHsgdGhlbWVOYW1lIH07XG59XG5mdW5jdGlvbiBleHRyYWN0VGhlbWVOYW1lKHRoZW1lKSB7XG4gIGlmICh0eXBlb2YgdGhlbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdGhlbWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0aGVtZSA9PT0gXCJvYmplY3RcIiAmJiB0aGVtZSAhPT0gbnVsbCkge1xuICAgIGlmIChcIm5hbWVcIiBpbiB0aGVtZSAmJiB0eXBlb2YgdGhlbWUubmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRoZW1lLm5hbWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbmV4cG9ydCB7XG4gIFRlbGVtZXRyeUNvbGxlY3RvcixcbiAgZXZlbnRQcmVidWlsdENvbXBvbmVudE1vdW50ZWQsXG4gIGV2ZW50UHJlYnVpbHRDb21wb25lbnRPcGVuZWQsXG4gIGV2ZW50Q29tcG9uZW50TW91bnRlZCxcbiAgZXZlbnRNZXRob2RDYWxsZWQsXG4gIGV2ZW50RnJhbWV3b3JrTWV0YWRhdGEsXG4gIEVWRU5UX1RIRU1FX1VTQUdFLFxuICBFVkVOVF9TQU1QTElOR19SQVRFNCBhcyBFVkVOVF9TQU1QTElOR19SQVRFLFxuICBldmVudFRoZW1lVXNhZ2Vcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1SVUEzWkU2QS5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-RUA3ZE6A.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isomorphicAtob: () => (/* binding */ isomorphicAtob)\n/* harmony export */ });\n// src/isomorphicAtob.ts\nvar isomorphicAtob = (data) => {\n  if (typeof atob !== \"undefined\" && typeof atob === \"function\") {\n    return atob(data);\n  } else if (typeof global !== \"undefined\" && global.Buffer) {\n    return new global.Buffer(data, \"base64\").toString();\n  }\n  return data;\n};\n\n\n//# sourceMappingURL=chunk-TETGTEI2.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstVEVUR1RFSTIubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFJRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2NodW5rLVRFVEdURUkyLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaXNvbW9ycGhpY0F0b2IudHNcbnZhciBpc29tb3JwaGljQXRvYiA9IChkYXRhKSA9PiB7XG4gIGlmICh0eXBlb2YgYXRvYiAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgYXRvYiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGF0b2IoZGF0YSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuQnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBnbG9iYWwuQnVmZmVyKGRhdGEsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59O1xuXG5leHBvcnQge1xuICBpc29tb3JwaGljQXRvYlxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLVRFVEdURUkyLm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-U7IR7A27.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-U7IR7A27.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadScript: () => (/* binding */ loadScript)\n/* harmony export */ });\n/* harmony import */ var _chunk_PL3YYI2I_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-PL3YYI2I.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-PL3YYI2I.mjs\");\n\n\n// src/loadScript.ts\nvar NO_DOCUMENT_ERROR = \"loadScript cannot be called when document does not exist\";\nvar NO_SRC_ERROR = \"loadScript cannot be called without a src\";\nasync function loadScript(src = \"\", opts) {\n  const { async, defer, beforeLoad, crossOrigin, nonce } = opts || {};\n  const load = () => {\n    return new Promise((resolve, reject) => {\n      if (!src) {\n        reject(new Error(NO_SRC_ERROR));\n      }\n      if (!document || !document.body) {\n        reject(new Error(NO_DOCUMENT_ERROR));\n      }\n      const script = document.createElement(\"script\");\n      if (crossOrigin) {\n        script.setAttribute(\"crossorigin\", crossOrigin);\n      }\n      script.async = async || false;\n      script.defer = defer || false;\n      script.addEventListener(\"load\", () => {\n        script.remove();\n        resolve(script);\n      });\n      script.addEventListener(\"error\", (event) => {\n        script.remove();\n        reject(event.error ?? new Error(`failed to load script: ${src}`));\n      });\n      script.src = src;\n      script.nonce = nonce;\n      beforeLoad?.(script);\n      document.body.appendChild(script);\n    });\n  };\n  return (0,_chunk_PL3YYI2I_mjs__WEBPACK_IMPORTED_MODULE_0__.retry)(load, { shouldRetry: (_, iterations) => iterations <= 5 });\n}\n\n\n//# sourceMappingURL=chunk-U7IR7A27.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstVTdJUjdBMjcubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBRThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0NBQStDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGtFQUFrRSxJQUFJO0FBQ3RFLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFNBQVMsMERBQUssU0FBUyxpREFBaUQ7QUFDeEU7O0FBSUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2lzaGFxYmVsbG8vV2Vic2l0ZS9oYXZlbnJpZGVfZnVsbF9hcHAvbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9jaHVuay1VN0lSN0EyNy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgcmV0cnlcbn0gZnJvbSBcIi4vY2h1bmstUEwzWVlJMkkubWpzXCI7XG5cbi8vIHNyYy9sb2FkU2NyaXB0LnRzXG52YXIgTk9fRE9DVU1FTlRfRVJST1IgPSBcImxvYWRTY3JpcHQgY2Fubm90IGJlIGNhbGxlZCB3aGVuIGRvY3VtZW50IGRvZXMgbm90IGV4aXN0XCI7XG52YXIgTk9fU1JDX0VSUk9SID0gXCJsb2FkU2NyaXB0IGNhbm5vdCBiZSBjYWxsZWQgd2l0aG91dCBhIHNyY1wiO1xuYXN5bmMgZnVuY3Rpb24gbG9hZFNjcmlwdChzcmMgPSBcIlwiLCBvcHRzKSB7XG4gIGNvbnN0IHsgYXN5bmMsIGRlZmVyLCBiZWZvcmVMb2FkLCBjcm9zc09yaWdpbiwgbm9uY2UgfSA9IG9wdHMgfHwge307XG4gIGNvbnN0IGxvYWQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghc3JjKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoTk9fU1JDX0VSUk9SKSk7XG4gICAgICB9XG4gICAgICBpZiAoIWRvY3VtZW50IHx8ICFkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoTk9fRE9DVU1FTlRfRVJST1IpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICBpZiAoY3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgc2NyaXB0LnNldEF0dHJpYnV0ZShcImNyb3Nzb3JpZ2luXCIsIGNyb3NzT3JpZ2luKTtcbiAgICAgIH1cbiAgICAgIHNjcmlwdC5hc3luYyA9IGFzeW5jIHx8IGZhbHNlO1xuICAgICAgc2NyaXB0LmRlZmVyID0gZGVmZXIgfHwgZmFsc2U7XG4gICAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xuICAgICAgICBzY3JpcHQucmVtb3ZlKCk7XG4gICAgICAgIHJlc29sdmUoc2NyaXB0KTtcbiAgICAgIH0pO1xuICAgICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgc2NyaXB0LnJlbW92ZSgpO1xuICAgICAgICByZWplY3QoZXZlbnQuZXJyb3IgPz8gbmV3IEVycm9yKGBmYWlsZWQgdG8gbG9hZCBzY3JpcHQ6ICR7c3JjfWApKTtcbiAgICAgIH0pO1xuICAgICAgc2NyaXB0LnNyYyA9IHNyYztcbiAgICAgIHNjcmlwdC5ub25jZSA9IG5vbmNlO1xuICAgICAgYmVmb3JlTG9hZD8uKHNjcmlwdCk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiByZXRyeShsb2FkLCB7IHNob3VsZFJldHJ5OiAoXywgaXRlcmF0aW9ucykgPT4gaXRlcmF0aW9ucyA8PSA1IH0pO1xufVxuXG5leHBvcnQge1xuICBsb2FkU2NyaXB0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstVTdJUjdBMjcubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-U7IR7A27.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-UEY4AZIP.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-UEY4AZIP.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deprecated: () => (/* binding */ deprecated),\n/* harmony export */   deprecatedObjectProperty: () => (/* binding */ deprecatedObjectProperty),\n/* harmony export */   deprecatedProperty: () => (/* binding */ deprecatedProperty)\n/* harmony export */ });\n/* harmony import */ var _chunk_7HPDNZ3R_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-7HPDNZ3R.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7HPDNZ3R.mjs\");\n\n\n// src/deprecated.ts\nvar displayedWarnings = /* @__PURE__ */ new Set();\nvar deprecated = (fnName, warning, key) => {\n  const hideWarning = (0,_chunk_7HPDNZ3R_mjs__WEBPACK_IMPORTED_MODULE_0__.isTestEnvironment)() || (0,_chunk_7HPDNZ3R_mjs__WEBPACK_IMPORTED_MODULE_0__.isProductionEnvironment)();\n  const messageId = key ?? fnName;\n  if (displayedWarnings.has(messageId) || hideWarning) {\n    return;\n  }\n  displayedWarnings.add(messageId);\n  console.warn(\n    `Clerk - DEPRECATION WARNING: \"${fnName}\" is deprecated and will be removed in the next major release.\n${warning}`\n  );\n};\nvar deprecatedProperty = (cls, propName, warning, isStatic = false) => {\n  const target = isStatic ? cls : cls.prototype;\n  let value = target[propName];\n  Object.defineProperty(target, propName, {\n    get() {\n      deprecated(propName, warning, `${cls.name}:${propName}`);\n      return value;\n    },\n    set(v) {\n      value = v;\n    }\n  });\n};\nvar deprecatedObjectProperty = (obj, propName, warning, key) => {\n  let value = obj[propName];\n  Object.defineProperty(obj, propName, {\n    get() {\n      deprecated(propName, warning, key);\n      return value;\n    },\n    set(v) {\n      value = v;\n    }\n  });\n};\n\n\n//# sourceMappingURL=chunk-UEY4AZIP.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstVUVZNEFaSVAubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFHOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzRUFBaUIsTUFBTSw0RUFBdUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUMsRUFBRSxRQUFRO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUyxHQUFHLFNBQVM7QUFDNUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFNRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2NodW5rLVVFWTRBWklQLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBpc1Byb2R1Y3Rpb25FbnZpcm9ubWVudCxcbiAgaXNUZXN0RW52aXJvbm1lbnRcbn0gZnJvbSBcIi4vY2h1bmstN0hQRE5aM1IubWpzXCI7XG5cbi8vIHNyYy9kZXByZWNhdGVkLnRzXG52YXIgZGlzcGxheWVkV2FybmluZ3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xudmFyIGRlcHJlY2F0ZWQgPSAoZm5OYW1lLCB3YXJuaW5nLCBrZXkpID0+IHtcbiAgY29uc3QgaGlkZVdhcm5pbmcgPSBpc1Rlc3RFbnZpcm9ubWVudCgpIHx8IGlzUHJvZHVjdGlvbkVudmlyb25tZW50KCk7XG4gIGNvbnN0IG1lc3NhZ2VJZCA9IGtleSA/PyBmbk5hbWU7XG4gIGlmIChkaXNwbGF5ZWRXYXJuaW5ncy5oYXMobWVzc2FnZUlkKSB8fCBoaWRlV2FybmluZykge1xuICAgIHJldHVybjtcbiAgfVxuICBkaXNwbGF5ZWRXYXJuaW5ncy5hZGQobWVzc2FnZUlkKTtcbiAgY29uc29sZS53YXJuKFxuICAgIGBDbGVyayAtIERFUFJFQ0FUSU9OIFdBUk5JTkc6IFwiJHtmbk5hbWV9XCIgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG4ke3dhcm5pbmd9YFxuICApO1xufTtcbnZhciBkZXByZWNhdGVkUHJvcGVydHkgPSAoY2xzLCBwcm9wTmFtZSwgd2FybmluZywgaXNTdGF0aWMgPSBmYWxzZSkgPT4ge1xuICBjb25zdCB0YXJnZXQgPSBpc1N0YXRpYyA/IGNscyA6IGNscy5wcm90b3R5cGU7XG4gIGxldCB2YWx1ZSA9IHRhcmdldFtwcm9wTmFtZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BOYW1lLCB7XG4gICAgZ2V0KCkge1xuICAgICAgZGVwcmVjYXRlZChwcm9wTmFtZSwgd2FybmluZywgYCR7Y2xzLm5hbWV9OiR7cHJvcE5hbWV9YCk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBzZXQodikge1xuICAgICAgdmFsdWUgPSB2O1xuICAgIH1cbiAgfSk7XG59O1xudmFyIGRlcHJlY2F0ZWRPYmplY3RQcm9wZXJ0eSA9IChvYmosIHByb3BOYW1lLCB3YXJuaW5nLCBrZXkpID0+IHtcbiAgbGV0IHZhbHVlID0gb2JqW3Byb3BOYW1lXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcE5hbWUsIHtcbiAgICBnZXQoKSB7XG4gICAgICBkZXByZWNhdGVkKHByb3BOYW1lLCB3YXJuaW5nLCBrZXkpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgc2V0KHYpIHtcbiAgICAgIHZhbHVlID0gdjtcbiAgICB9XG4gIH0pO1xufTtcblxuZXhwb3J0IHtcbiAgZGVwcmVjYXRlZCxcbiAgZGVwcmVjYXRlZFByb3BlcnR5LFxuICBkZXByZWNhdGVkT2JqZWN0UHJvcGVydHlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1VRVk0QVpJUC5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-UEY4AZIP.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-YTPL7FML.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-YTPL7FML.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildClerkJsScriptAttributes: () => (/* binding */ buildClerkJsScriptAttributes),\n/* harmony export */   clerkJsScriptUrl: () => (/* binding */ clerkJsScriptUrl),\n/* harmony export */   loadClerkJsScript: () => (/* binding */ loadClerkJsScript),\n/* harmony export */   setClerkJsLoadingErrorPackageName: () => (/* binding */ setClerkJsLoadingErrorPackageName)\n/* harmony export */ });\n/* harmony import */ var _chunk_ELKNO6YM_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-ELKNO6YM.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-ELKNO6YM.mjs\");\n/* harmony import */ var _chunk_6NDGN2IU_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-6NDGN2IU.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-6NDGN2IU.mjs\");\n/* harmony import */ var _chunk_IFTVZ2LQ_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-IFTVZ2LQ.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IFTVZ2LQ.mjs\");\n/* harmony import */ var _chunk_U7IR7A27_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk-U7IR7A27.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-U7IR7A27.mjs\");\n/* harmony import */ var _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chunk-AXHU6TXE.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-AXHU6TXE.mjs\");\n/* harmony import */ var _chunk_IV7BOO4U_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chunk-IV7BOO4U.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IV7BOO4U.mjs\");\n\n\n\n\n\n\n\n// src/loadClerkJsScript.ts\nvar ERROR_CODE = \"failed_to_load_clerk_js\";\nvar ERROR_CODE_TIMEOUT = \"failed_to_load_clerk_js_timeout\";\nvar FAILED_TO_LOAD_ERROR = \"Failed to load Clerk\";\nvar { isDevOrStagingUrl } = (0,_chunk_IV7BOO4U_mjs__WEBPACK_IMPORTED_MODULE_5__.createDevOrStagingUrlCache)();\nvar errorThrower = (0,_chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_4__.buildErrorThrower)({ packageName: \"@clerk/shared\" });\nfunction setClerkJsLoadingErrorPackageName(packageName) {\n  errorThrower.setPackageName({ packageName });\n}\nfunction isClerkProperlyLoaded() {\n  if (typeof window === \"undefined\" || !window.Clerk) {\n    return false;\n  }\n  const clerk = window.Clerk;\n  return typeof clerk === \"object\" && typeof clerk.load === \"function\";\n}\nfunction waitForClerkWithTimeout(timeoutMs) {\n  return new Promise((resolve, reject) => {\n    let resolved = false;\n    const cleanup = (timeoutId2, pollInterval2) => {\n      clearTimeout(timeoutId2);\n      clearInterval(pollInterval2);\n    };\n    const checkAndResolve = () => {\n      if (resolved) {\n        return;\n      }\n      if (isClerkProperlyLoaded()) {\n        resolved = true;\n        cleanup(timeoutId, pollInterval);\n        resolve(null);\n      }\n    };\n    const handleTimeout = () => {\n      if (resolved) {\n        return;\n      }\n      resolved = true;\n      cleanup(timeoutId, pollInterval);\n      if (!isClerkProperlyLoaded()) {\n        reject(new _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_4__.ClerkRuntimeError(FAILED_TO_LOAD_ERROR, { code: ERROR_CODE_TIMEOUT }));\n      } else {\n        resolve(null);\n      }\n    };\n    const timeoutId = setTimeout(handleTimeout, timeoutMs);\n    checkAndResolve();\n    const pollInterval = setInterval(() => {\n      if (resolved) {\n        clearInterval(pollInterval);\n        return;\n      }\n      checkAndResolve();\n    }, 100);\n  });\n}\nvar loadClerkJsScript = async (opts) => {\n  const timeout = opts?.scriptLoadTimeout ?? 15e3;\n  if (isClerkProperlyLoaded()) {\n    return null;\n  }\n  const existingScript = document.querySelector(\"script[data-clerk-js-script]\");\n  if (existingScript) {\n    return waitForClerkWithTimeout(timeout);\n  }\n  if (!opts?.publishableKey) {\n    errorThrower.throwMissingPublishableKeyError();\n    return null;\n  }\n  const loadPromise = waitForClerkWithTimeout(timeout);\n  (0,_chunk_U7IR7A27_mjs__WEBPACK_IMPORTED_MODULE_3__.loadScript)(clerkJsScriptUrl(opts), {\n    async: true,\n    crossOrigin: \"anonymous\",\n    nonce: opts.nonce,\n    beforeLoad: applyClerkJsScriptAttributes(opts)\n  }).catch((error) => {\n    throw new _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_4__.ClerkRuntimeError(FAILED_TO_LOAD_ERROR + (error.message ? `, ${error.message}` : \"\"), {\n      code: ERROR_CODE,\n      cause: error\n    });\n  });\n  return loadPromise;\n};\nvar clerkJsScriptUrl = (opts) => {\n  const { clerkJSUrl, clerkJSVariant, clerkJSVersion, proxyUrl, domain, publishableKey } = opts;\n  if (clerkJSUrl) {\n    return clerkJSUrl;\n  }\n  let scriptHost = \"\";\n  if (!!proxyUrl && (0,_chunk_6NDGN2IU_mjs__WEBPACK_IMPORTED_MODULE_1__.isValidProxyUrl)(proxyUrl)) {\n    scriptHost = (0,_chunk_6NDGN2IU_mjs__WEBPACK_IMPORTED_MODULE_1__.proxyUrlToAbsoluteURL)(proxyUrl).replace(/http(s)?:\\/\\//, \"\");\n  } else if (domain && !isDevOrStagingUrl((0,_chunk_IV7BOO4U_mjs__WEBPACK_IMPORTED_MODULE_5__.parsePublishableKey)(publishableKey)?.frontendApi || \"\")) {\n    scriptHost = (0,_chunk_IFTVZ2LQ_mjs__WEBPACK_IMPORTED_MODULE_2__.addClerkPrefix)(domain);\n  } else {\n    scriptHost = (0,_chunk_IV7BOO4U_mjs__WEBPACK_IMPORTED_MODULE_5__.parsePublishableKey)(publishableKey)?.frontendApi || \"\";\n  }\n  const variant = clerkJSVariant ? `${clerkJSVariant.replace(/\\.+$/, \"\")}.` : \"\";\n  const version = (0,_chunk_ELKNO6YM_mjs__WEBPACK_IMPORTED_MODULE_0__.versionSelector)(clerkJSVersion);\n  return `https://${scriptHost}/npm/@clerk/clerk-js@${version}/dist/clerk.${variant}browser.js`;\n};\nvar buildClerkJsScriptAttributes = (options) => {\n  const obj = {};\n  if (options.publishableKey) {\n    obj[\"data-clerk-publishable-key\"] = options.publishableKey;\n  }\n  if (options.proxyUrl) {\n    obj[\"data-clerk-proxy-url\"] = options.proxyUrl;\n  }\n  if (options.domain) {\n    obj[\"data-clerk-domain\"] = options.domain;\n  }\n  if (options.nonce) {\n    obj.nonce = options.nonce;\n  }\n  return obj;\n};\nvar applyClerkJsScriptAttributes = (options) => (script) => {\n  const attributes = buildClerkJsScriptAttributes(options);\n  for (const attribute in attributes) {\n    script.setAttribute(attribute, attributes[attribute]);\n  }\n};\n\n\n//# sourceMappingURL=chunk-YTPL7FML.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstWVRQTDdGTUwubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFOEI7QUFJQTtBQUdBO0FBR0E7QUFJQTtBQUlBOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0JBQW9CLEVBQUUsK0VBQTBCO0FBQ3RELG1CQUFtQixzRUFBaUIsR0FBRyw4QkFBOEI7QUFDckU7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtFQUFpQix5QkFBeUIsMEJBQTBCO0FBQ3ZGLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLCtEQUFVO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYyxrRUFBaUIsOENBQThDLGNBQWM7QUFDM0Y7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrRUFBK0U7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0VBQWU7QUFDbkMsaUJBQWlCLDBFQUFxQjtBQUN0QyxJQUFJLHNDQUFzQyx3RUFBbUI7QUFDN0QsaUJBQWlCLG1FQUFjO0FBQy9CLElBQUk7QUFDSixpQkFBaUIsd0VBQW1CO0FBQ3BDO0FBQ0Esc0NBQXNDLG1DQUFtQztBQUN6RSxrQkFBa0Isb0VBQWU7QUFDakMsb0JBQW9CLFdBQVcsdUJBQXVCLFFBQVEsY0FBYyxRQUFRO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBT0U7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2lzaGFxYmVsbG8vV2Vic2l0ZS9oYXZlbnJpZGVfZnVsbF9hcHAvbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9jaHVuay1ZVFBMN0ZNTC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgdmVyc2lvblNlbGVjdG9yXG59IGZyb20gXCIuL2NodW5rLUVMS05PNllNLm1qc1wiO1xuaW1wb3J0IHtcbiAgaXNWYWxpZFByb3h5VXJsLFxuICBwcm94eVVybFRvQWJzb2x1dGVVUkxcbn0gZnJvbSBcIi4vY2h1bmstNk5ER04ySVUubWpzXCI7XG5pbXBvcnQge1xuICBhZGRDbGVya1ByZWZpeFxufSBmcm9tIFwiLi9jaHVuay1JRlRWWjJMUS5tanNcIjtcbmltcG9ydCB7XG4gIGxvYWRTY3JpcHRcbn0gZnJvbSBcIi4vY2h1bmstVTdJUjdBMjcubWpzXCI7XG5pbXBvcnQge1xuICBDbGVya1J1bnRpbWVFcnJvcixcbiAgYnVpbGRFcnJvclRocm93ZXJcbn0gZnJvbSBcIi4vY2h1bmstQVhIVTZUWEUubWpzXCI7XG5pbXBvcnQge1xuICBjcmVhdGVEZXZPclN0YWdpbmdVcmxDYWNoZSxcbiAgcGFyc2VQdWJsaXNoYWJsZUtleVxufSBmcm9tIFwiLi9jaHVuay1JVjdCT080VS5tanNcIjtcblxuLy8gc3JjL2xvYWRDbGVya0pzU2NyaXB0LnRzXG52YXIgRVJST1JfQ09ERSA9IFwiZmFpbGVkX3RvX2xvYWRfY2xlcmtfanNcIjtcbnZhciBFUlJPUl9DT0RFX1RJTUVPVVQgPSBcImZhaWxlZF90b19sb2FkX2NsZXJrX2pzX3RpbWVvdXRcIjtcbnZhciBGQUlMRURfVE9fTE9BRF9FUlJPUiA9IFwiRmFpbGVkIHRvIGxvYWQgQ2xlcmtcIjtcbnZhciB7IGlzRGV2T3JTdGFnaW5nVXJsIH0gPSBjcmVhdGVEZXZPclN0YWdpbmdVcmxDYWNoZSgpO1xudmFyIGVycm9yVGhyb3dlciA9IGJ1aWxkRXJyb3JUaHJvd2VyKHsgcGFja2FnZU5hbWU6IFwiQGNsZXJrL3NoYXJlZFwiIH0pO1xuZnVuY3Rpb24gc2V0Q2xlcmtKc0xvYWRpbmdFcnJvclBhY2thZ2VOYW1lKHBhY2thZ2VOYW1lKSB7XG4gIGVycm9yVGhyb3dlci5zZXRQYWNrYWdlTmFtZSh7IHBhY2thZ2VOYW1lIH0pO1xufVxuZnVuY3Rpb24gaXNDbGVya1Byb3Blcmx5TG9hZGVkKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhd2luZG93LkNsZXJrKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGNsZXJrID0gd2luZG93LkNsZXJrO1xuICByZXR1cm4gdHlwZW9mIGNsZXJrID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBjbGVyay5sb2FkID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiB3YWl0Rm9yQ2xlcmtXaXRoVGltZW91dCh0aW1lb3V0TXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBjbGVhbnVwID0gKHRpbWVvdXRJZDIsIHBvbGxJbnRlcnZhbDIpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQyKTtcbiAgICAgIGNsZWFySW50ZXJ2YWwocG9sbEludGVydmFsMik7XG4gICAgfTtcbiAgICBjb25zdCBjaGVja0FuZFJlc29sdmUgPSAoKSA9PiB7XG4gICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ2xlcmtQcm9wZXJseUxvYWRlZCgpKSB7XG4gICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCh0aW1lb3V0SWQsIHBvbGxJbnRlcnZhbCk7XG4gICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVUaW1lb3V0ID0gKCkgPT4ge1xuICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgIGNsZWFudXAodGltZW91dElkLCBwb2xsSW50ZXJ2YWwpO1xuICAgICAgaWYgKCFpc0NsZXJrUHJvcGVybHlMb2FkZWQoKSkge1xuICAgICAgICByZWplY3QobmV3IENsZXJrUnVudGltZUVycm9yKEZBSUxFRF9UT19MT0FEX0VSUk9SLCB7IGNvZGU6IEVSUk9SX0NPREVfVElNRU9VVCB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dChoYW5kbGVUaW1lb3V0LCB0aW1lb3V0TXMpO1xuICAgIGNoZWNrQW5kUmVzb2x2ZSgpO1xuICAgIGNvbnN0IHBvbGxJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgICBjbGVhckludGVydmFsKHBvbGxJbnRlcnZhbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNoZWNrQW5kUmVzb2x2ZSgpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xufVxudmFyIGxvYWRDbGVya0pzU2NyaXB0ID0gYXN5bmMgKG9wdHMpID0+IHtcbiAgY29uc3QgdGltZW91dCA9IG9wdHM/LnNjcmlwdExvYWRUaW1lb3V0ID8/IDE1ZTM7XG4gIGlmIChpc0NsZXJrUHJvcGVybHlMb2FkZWQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nU2NyaXB0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInNjcmlwdFtkYXRhLWNsZXJrLWpzLXNjcmlwdF1cIik7XG4gIGlmIChleGlzdGluZ1NjcmlwdCkge1xuICAgIHJldHVybiB3YWl0Rm9yQ2xlcmtXaXRoVGltZW91dCh0aW1lb3V0KTtcbiAgfVxuICBpZiAoIW9wdHM/LnB1Ymxpc2hhYmxlS2V5KSB7XG4gICAgZXJyb3JUaHJvd2VyLnRocm93TWlzc2luZ1B1Ymxpc2hhYmxlS2V5RXJyb3IoKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBsb2FkUHJvbWlzZSA9IHdhaXRGb3JDbGVya1dpdGhUaW1lb3V0KHRpbWVvdXQpO1xuICBsb2FkU2NyaXB0KGNsZXJrSnNTY3JpcHRVcmwob3B0cyksIHtcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBjcm9zc09yaWdpbjogXCJhbm9ueW1vdXNcIixcbiAgICBub25jZTogb3B0cy5ub25jZSxcbiAgICBiZWZvcmVMb2FkOiBhcHBseUNsZXJrSnNTY3JpcHRBdHRyaWJ1dGVzKG9wdHMpXG4gIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgIHRocm93IG5ldyBDbGVya1J1bnRpbWVFcnJvcihGQUlMRURfVE9fTE9BRF9FUlJPUiArIChlcnJvci5tZXNzYWdlID8gYCwgJHtlcnJvci5tZXNzYWdlfWAgOiBcIlwiKSwge1xuICAgICAgY29kZTogRVJST1JfQ09ERSxcbiAgICAgIGNhdXNlOiBlcnJvclxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGxvYWRQcm9taXNlO1xufTtcbnZhciBjbGVya0pzU2NyaXB0VXJsID0gKG9wdHMpID0+IHtcbiAgY29uc3QgeyBjbGVya0pTVXJsLCBjbGVya0pTVmFyaWFudCwgY2xlcmtKU1ZlcnNpb24sIHByb3h5VXJsLCBkb21haW4sIHB1Ymxpc2hhYmxlS2V5IH0gPSBvcHRzO1xuICBpZiAoY2xlcmtKU1VybCkge1xuICAgIHJldHVybiBjbGVya0pTVXJsO1xuICB9XG4gIGxldCBzY3JpcHRIb3N0ID0gXCJcIjtcbiAgaWYgKCEhcHJveHlVcmwgJiYgaXNWYWxpZFByb3h5VXJsKHByb3h5VXJsKSkge1xuICAgIHNjcmlwdEhvc3QgPSBwcm94eVVybFRvQWJzb2x1dGVVUkwocHJveHlVcmwpLnJlcGxhY2UoL2h0dHAocyk/OlxcL1xcLy8sIFwiXCIpO1xuICB9IGVsc2UgaWYgKGRvbWFpbiAmJiAhaXNEZXZPclN0YWdpbmdVcmwocGFyc2VQdWJsaXNoYWJsZUtleShwdWJsaXNoYWJsZUtleSk/LmZyb250ZW5kQXBpIHx8IFwiXCIpKSB7XG4gICAgc2NyaXB0SG9zdCA9IGFkZENsZXJrUHJlZml4KGRvbWFpbik7XG4gIH0gZWxzZSB7XG4gICAgc2NyaXB0SG9zdCA9IHBhcnNlUHVibGlzaGFibGVLZXkocHVibGlzaGFibGVLZXkpPy5mcm9udGVuZEFwaSB8fCBcIlwiO1xuICB9XG4gIGNvbnN0IHZhcmlhbnQgPSBjbGVya0pTVmFyaWFudCA/IGAke2NsZXJrSlNWYXJpYW50LnJlcGxhY2UoL1xcLiskLywgXCJcIil9LmAgOiBcIlwiO1xuICBjb25zdCB2ZXJzaW9uID0gdmVyc2lvblNlbGVjdG9yKGNsZXJrSlNWZXJzaW9uKTtcbiAgcmV0dXJuIGBodHRwczovLyR7c2NyaXB0SG9zdH0vbnBtL0BjbGVyay9jbGVyay1qc0Ake3ZlcnNpb259L2Rpc3QvY2xlcmsuJHt2YXJpYW50fWJyb3dzZXIuanNgO1xufTtcbnZhciBidWlsZENsZXJrSnNTY3JpcHRBdHRyaWJ1dGVzID0gKG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgb2JqID0ge307XG4gIGlmIChvcHRpb25zLnB1Ymxpc2hhYmxlS2V5KSB7XG4gICAgb2JqW1wiZGF0YS1jbGVyay1wdWJsaXNoYWJsZS1rZXlcIl0gPSBvcHRpb25zLnB1Ymxpc2hhYmxlS2V5O1xuICB9XG4gIGlmIChvcHRpb25zLnByb3h5VXJsKSB7XG4gICAgb2JqW1wiZGF0YS1jbGVyay1wcm94eS11cmxcIl0gPSBvcHRpb25zLnByb3h5VXJsO1xuICB9XG4gIGlmIChvcHRpb25zLmRvbWFpbikge1xuICAgIG9ialtcImRhdGEtY2xlcmstZG9tYWluXCJdID0gb3B0aW9ucy5kb21haW47XG4gIH1cbiAgaWYgKG9wdGlvbnMubm9uY2UpIHtcbiAgICBvYmoubm9uY2UgPSBvcHRpb25zLm5vbmNlO1xuICB9XG4gIHJldHVybiBvYmo7XG59O1xudmFyIGFwcGx5Q2xlcmtKc1NjcmlwdEF0dHJpYnV0ZXMgPSAob3B0aW9ucykgPT4gKHNjcmlwdCkgPT4ge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gYnVpbGRDbGVya0pzU2NyaXB0QXR0cmlidXRlcyhvcHRpb25zKTtcbiAgZm9yIChjb25zdCBhdHRyaWJ1dGUgaW4gYXR0cmlidXRlcykge1xuICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0pO1xuICB9XG59O1xuXG5leHBvcnQge1xuICBzZXRDbGVya0pzTG9hZGluZ0Vycm9yUGFja2FnZU5hbWUsXG4gIGxvYWRDbGVya0pzU2NyaXB0LFxuICBjbGVya0pzU2NyaXB0VXJsLFxuICBidWlsZENsZXJrSnNTY3JpcHRBdHRyaWJ1dGVzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstWVRQTDdGTUwubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-YTPL7FML.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-ZIXJBK4O.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-ZIXJBK4O.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deriveState: () => (/* binding */ deriveState)\n/* harmony export */ });\n// src/deriveState.ts\nvar deriveState = (clerkOperational, state, initialState) => {\n  if (!clerkOperational && initialState) {\n    return deriveFromSsrInitialState(initialState);\n  }\n  return deriveFromClientSideState(state);\n};\nvar deriveFromSsrInitialState = (initialState) => {\n  const userId = initialState.userId;\n  const user = initialState.user;\n  const sessionId = initialState.sessionId;\n  const sessionStatus = initialState.sessionStatus;\n  const sessionClaims = initialState.sessionClaims;\n  const session = initialState.session;\n  const organization = initialState.organization;\n  const orgId = initialState.orgId;\n  const orgRole = initialState.orgRole;\n  const orgPermissions = initialState.orgPermissions;\n  const orgSlug = initialState.orgSlug;\n  const actor = initialState.actor;\n  const factorVerificationAge = initialState.factorVerificationAge;\n  return {\n    userId,\n    user,\n    sessionId,\n    session,\n    sessionStatus,\n    sessionClaims,\n    organization,\n    orgId,\n    orgRole,\n    orgPermissions,\n    orgSlug,\n    actor,\n    factorVerificationAge\n  };\n};\nvar deriveFromClientSideState = (state) => {\n  const userId = state.user ? state.user.id : state.user;\n  const user = state.user;\n  const sessionId = state.session ? state.session.id : state.session;\n  const session = state.session;\n  const sessionStatus = state.session?.status;\n  const sessionClaims = state.session ? state.session.lastActiveToken?.jwt?.claims : null;\n  const factorVerificationAge = state.session ? state.session.factorVerificationAge : null;\n  const actor = session?.actor;\n  const organization = state.organization;\n  const orgId = state.organization ? state.organization.id : state.organization;\n  const orgSlug = organization?.slug;\n  const membership = organization ? user?.organizationMemberships?.find((om) => om.organization.id === orgId) : organization;\n  const orgPermissions = membership ? membership.permissions : membership;\n  const orgRole = membership ? membership.role : membership;\n  return {\n    userId,\n    user,\n    sessionId,\n    session,\n    sessionStatus,\n    sessionClaims,\n    organization,\n    orgId,\n    orgRole,\n    orgSlug,\n    orgPermissions,\n    actor,\n    factorVerificationAge\n  };\n};\n\n\n//# sourceMappingURL=chunk-ZIXJBK4O.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstWklYSkJLNE8ubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstWklYSkJLNE8ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9kZXJpdmVTdGF0ZS50c1xudmFyIGRlcml2ZVN0YXRlID0gKGNsZXJrT3BlcmF0aW9uYWwsIHN0YXRlLCBpbml0aWFsU3RhdGUpID0+IHtcbiAgaWYgKCFjbGVya09wZXJhdGlvbmFsICYmIGluaXRpYWxTdGF0ZSkge1xuICAgIHJldHVybiBkZXJpdmVGcm9tU3NySW5pdGlhbFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIGRlcml2ZUZyb21DbGllbnRTaWRlU3RhdGUoc3RhdGUpO1xufTtcbnZhciBkZXJpdmVGcm9tU3NySW5pdGlhbFN0YXRlID0gKGluaXRpYWxTdGF0ZSkgPT4ge1xuICBjb25zdCB1c2VySWQgPSBpbml0aWFsU3RhdGUudXNlcklkO1xuICBjb25zdCB1c2VyID0gaW5pdGlhbFN0YXRlLnVzZXI7XG4gIGNvbnN0IHNlc3Npb25JZCA9IGluaXRpYWxTdGF0ZS5zZXNzaW9uSWQ7XG4gIGNvbnN0IHNlc3Npb25TdGF0dXMgPSBpbml0aWFsU3RhdGUuc2Vzc2lvblN0YXR1cztcbiAgY29uc3Qgc2Vzc2lvbkNsYWltcyA9IGluaXRpYWxTdGF0ZS5zZXNzaW9uQ2xhaW1zO1xuICBjb25zdCBzZXNzaW9uID0gaW5pdGlhbFN0YXRlLnNlc3Npb247XG4gIGNvbnN0IG9yZ2FuaXphdGlvbiA9IGluaXRpYWxTdGF0ZS5vcmdhbml6YXRpb247XG4gIGNvbnN0IG9yZ0lkID0gaW5pdGlhbFN0YXRlLm9yZ0lkO1xuICBjb25zdCBvcmdSb2xlID0gaW5pdGlhbFN0YXRlLm9yZ1JvbGU7XG4gIGNvbnN0IG9yZ1Blcm1pc3Npb25zID0gaW5pdGlhbFN0YXRlLm9yZ1Blcm1pc3Npb25zO1xuICBjb25zdCBvcmdTbHVnID0gaW5pdGlhbFN0YXRlLm9yZ1NsdWc7XG4gIGNvbnN0IGFjdG9yID0gaW5pdGlhbFN0YXRlLmFjdG9yO1xuICBjb25zdCBmYWN0b3JWZXJpZmljYXRpb25BZ2UgPSBpbml0aWFsU3RhdGUuZmFjdG9yVmVyaWZpY2F0aW9uQWdlO1xuICByZXR1cm4ge1xuICAgIHVzZXJJZCxcbiAgICB1c2VyLFxuICAgIHNlc3Npb25JZCxcbiAgICBzZXNzaW9uLFxuICAgIHNlc3Npb25TdGF0dXMsXG4gICAgc2Vzc2lvbkNsYWltcyxcbiAgICBvcmdhbml6YXRpb24sXG4gICAgb3JnSWQsXG4gICAgb3JnUm9sZSxcbiAgICBvcmdQZXJtaXNzaW9ucyxcbiAgICBvcmdTbHVnLFxuICAgIGFjdG9yLFxuICAgIGZhY3RvclZlcmlmaWNhdGlvbkFnZVxuICB9O1xufTtcbnZhciBkZXJpdmVGcm9tQ2xpZW50U2lkZVN0YXRlID0gKHN0YXRlKSA9PiB7XG4gIGNvbnN0IHVzZXJJZCA9IHN0YXRlLnVzZXIgPyBzdGF0ZS51c2VyLmlkIDogc3RhdGUudXNlcjtcbiAgY29uc3QgdXNlciA9IHN0YXRlLnVzZXI7XG4gIGNvbnN0IHNlc3Npb25JZCA9IHN0YXRlLnNlc3Npb24gPyBzdGF0ZS5zZXNzaW9uLmlkIDogc3RhdGUuc2Vzc2lvbjtcbiAgY29uc3Qgc2Vzc2lvbiA9IHN0YXRlLnNlc3Npb247XG4gIGNvbnN0IHNlc3Npb25TdGF0dXMgPSBzdGF0ZS5zZXNzaW9uPy5zdGF0dXM7XG4gIGNvbnN0IHNlc3Npb25DbGFpbXMgPSBzdGF0ZS5zZXNzaW9uID8gc3RhdGUuc2Vzc2lvbi5sYXN0QWN0aXZlVG9rZW4/Lmp3dD8uY2xhaW1zIDogbnVsbDtcbiAgY29uc3QgZmFjdG9yVmVyaWZpY2F0aW9uQWdlID0gc3RhdGUuc2Vzc2lvbiA/IHN0YXRlLnNlc3Npb24uZmFjdG9yVmVyaWZpY2F0aW9uQWdlIDogbnVsbDtcbiAgY29uc3QgYWN0b3IgPSBzZXNzaW9uPy5hY3RvcjtcbiAgY29uc3Qgb3JnYW5pemF0aW9uID0gc3RhdGUub3JnYW5pemF0aW9uO1xuICBjb25zdCBvcmdJZCA9IHN0YXRlLm9yZ2FuaXphdGlvbiA/IHN0YXRlLm9yZ2FuaXphdGlvbi5pZCA6IHN0YXRlLm9yZ2FuaXphdGlvbjtcbiAgY29uc3Qgb3JnU2x1ZyA9IG9yZ2FuaXphdGlvbj8uc2x1ZztcbiAgY29uc3QgbWVtYmVyc2hpcCA9IG9yZ2FuaXphdGlvbiA/IHVzZXI/Lm9yZ2FuaXphdGlvbk1lbWJlcnNoaXBzPy5maW5kKChvbSkgPT4gb20ub3JnYW5pemF0aW9uLmlkID09PSBvcmdJZCkgOiBvcmdhbml6YXRpb247XG4gIGNvbnN0IG9yZ1Blcm1pc3Npb25zID0gbWVtYmVyc2hpcCA/IG1lbWJlcnNoaXAucGVybWlzc2lvbnMgOiBtZW1iZXJzaGlwO1xuICBjb25zdCBvcmdSb2xlID0gbWVtYmVyc2hpcCA/IG1lbWJlcnNoaXAucm9sZSA6IG1lbWJlcnNoaXA7XG4gIHJldHVybiB7XG4gICAgdXNlcklkLFxuICAgIHVzZXIsXG4gICAgc2Vzc2lvbklkLFxuICAgIHNlc3Npb24sXG4gICAgc2Vzc2lvblN0YXR1cyxcbiAgICBzZXNzaW9uQ2xhaW1zLFxuICAgIG9yZ2FuaXphdGlvbixcbiAgICBvcmdJZCxcbiAgICBvcmdSb2xlLFxuICAgIG9yZ1NsdWcsXG4gICAgb3JnUGVybWlzc2lvbnMsXG4gICAgYWN0b3IsXG4gICAgZmFjdG9yVmVyaWZpY2F0aW9uQWdlXG4gIH07XG59O1xuXG5leHBvcnQge1xuICBkZXJpdmVTdGF0ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLVpJWEpCSzRPLm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-ZIXJBK4O.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/clerkEventBus.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/clerkEventBus.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clerkEvents: () => (/* binding */ clerkEvents),\n/* harmony export */   createClerkEventBus: () => (/* binding */ createClerkEventBus)\n/* harmony export */ });\n/* harmony import */ var _chunk_GVKBGR5N_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-GVKBGR5N.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-GVKBGR5N.mjs\");\n/* harmony import */ var _chunk_IEP6GGEX_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-IEP6GGEX.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IEP6GGEX.mjs\");\n\n\n\n// src/clerkEventBus.ts\nvar clerkEvents = {\n  Status: \"status\"\n};\nvar createClerkEventBus = () => {\n  return (0,_chunk_GVKBGR5N_mjs__WEBPACK_IMPORTED_MODULE_0__.createEventBus)();\n};\n\n//# sourceMappingURL=clerkEventBus.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2xlcmtFdmVudEJ1cy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUU4QjtBQUNBOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtRUFBYztBQUN2QjtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2xlcmtFdmVudEJ1cy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgY3JlYXRlRXZlbnRCdXNcbn0gZnJvbSBcIi4vY2h1bmstR1ZLQkdSNU4ubWpzXCI7XG5pbXBvcnQgXCIuL2NodW5rLUlFUDZHR0VYLm1qc1wiO1xuXG4vLyBzcmMvY2xlcmtFdmVudEJ1cy50c1xudmFyIGNsZXJrRXZlbnRzID0ge1xuICBTdGF0dXM6IFwic3RhdHVzXCJcbn07XG52YXIgY3JlYXRlQ2xlcmtFdmVudEJ1cyA9ICgpID0+IHtcbiAgcmV0dXJuIGNyZWF0ZUV2ZW50QnVzKCk7XG59O1xuZXhwb3J0IHtcbiAgY2xlcmtFdmVudHMsXG4gIGNyZWF0ZUNsZXJrRXZlbnRCdXNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGVya0V2ZW50QnVzLm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/clerkEventBus.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/deprecated.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/deprecated.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deprecated: () => (/* reexport safe */ _chunk_UEY4AZIP_mjs__WEBPACK_IMPORTED_MODULE_0__.deprecated),\n/* harmony export */   deprecatedObjectProperty: () => (/* reexport safe */ _chunk_UEY4AZIP_mjs__WEBPACK_IMPORTED_MODULE_0__.deprecatedObjectProperty),\n/* harmony export */   deprecatedProperty: () => (/* reexport safe */ _chunk_UEY4AZIP_mjs__WEBPACK_IMPORTED_MODULE_0__.deprecatedProperty)\n/* harmony export */ });\n/* harmony import */ var _chunk_UEY4AZIP_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-UEY4AZIP.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-UEY4AZIP.mjs\");\n/* harmony import */ var _chunk_7HPDNZ3R_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-7HPDNZ3R.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7HPDNZ3R.mjs\");\n/* harmony import */ var _chunk_IEP6GGEX_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-IEP6GGEX.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IEP6GGEX.mjs\");\n\n\n\n\n//# sourceMappingURL=deprecated.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvZGVwcmVjYXRlZC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBSThCO0FBQ0E7QUFDQTtBQUs1QjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2RlcHJlY2F0ZWQubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGRlcHJlY2F0ZWQsXG4gIGRlcHJlY2F0ZWRPYmplY3RQcm9wZXJ0eSxcbiAgZGVwcmVjYXRlZFByb3BlcnR5XG59IGZyb20gXCIuL2NodW5rLVVFWTRBWklQLm1qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay03SFBETlozUi5tanNcIjtcbmltcG9ydCBcIi4vY2h1bmstSUVQNkdHRVgubWpzXCI7XG5leHBvcnQge1xuICBkZXByZWNhdGVkLFxuICBkZXByZWNhdGVkT2JqZWN0UHJvcGVydHksXG4gIGRlcHJlY2F0ZWRQcm9wZXJ0eVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlcHJlY2F0ZWQubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/deprecated.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/deriveState.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/deriveState.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deriveState: () => (/* reexport safe */ _chunk_ZIXJBK4O_mjs__WEBPACK_IMPORTED_MODULE_0__.deriveState)\n/* harmony export */ });\n/* harmony import */ var _chunk_ZIXJBK4O_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-ZIXJBK4O.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-ZIXJBK4O.mjs\");\n/* harmony import */ var _chunk_IEP6GGEX_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-IEP6GGEX.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IEP6GGEX.mjs\");\n\n\n\n//# sourceMappingURL=deriveState.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvZGVyaXZlU3RhdGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUU4QjtBQUNBO0FBRzVCO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvZGVyaXZlU3RhdGUubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGRlcml2ZVN0YXRlXG59IGZyb20gXCIuL2NodW5rLVpJWEpCSzRPLm1qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay1JRVA2R0dFWC5tanNcIjtcbmV4cG9ydCB7XG4gIGRlcml2ZVN0YXRlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVyaXZlU3RhdGUubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/deriveState.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/error.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/error.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClerkAPIError: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.ClerkAPIError),\n/* harmony export */   ClerkAPIResponseError: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.ClerkAPIResponseError),\n/* harmony export */   ClerkRuntimeError: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.ClerkRuntimeError),\n/* harmony export */   ClerkWebAuthnError: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.ClerkWebAuthnError),\n/* harmony export */   EmailLinkError: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.EmailLinkError),\n/* harmony export */   EmailLinkErrorCode: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.EmailLinkErrorCode),\n/* harmony export */   EmailLinkErrorCodeStatus: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.EmailLinkErrorCodeStatus),\n/* harmony export */   buildErrorThrower: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.buildErrorThrower),\n/* harmony export */   errorToJSON: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.errorToJSON),\n/* harmony export */   is4xxError: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.is4xxError),\n/* harmony export */   isCaptchaError: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.isCaptchaError),\n/* harmony export */   isClerkAPIResponseError: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.isClerkAPIResponseError),\n/* harmony export */   isClerkRuntimeError: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.isClerkRuntimeError),\n/* harmony export */   isEmailLinkError: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.isEmailLinkError),\n/* harmony export */   isKnownError: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.isKnownError),\n/* harmony export */   isMetamaskError: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.isMetamaskError),\n/* harmony export */   isNetworkError: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.isNetworkError),\n/* harmony export */   isPasswordPwnedError: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.isPasswordPwnedError),\n/* harmony export */   isReverificationCancelledError: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.isReverificationCancelledError),\n/* harmony export */   isUnauthorizedError: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.isUnauthorizedError),\n/* harmony export */   isUserLockedError: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.isUserLockedError),\n/* harmony export */   parseError: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.parseError),\n/* harmony export */   parseErrors: () => (/* reexport safe */ _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__.parseErrors)\n/* harmony export */ });\n/* harmony import */ var _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-AXHU6TXE.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-AXHU6TXE.mjs\");\n/* harmony import */ var _chunk_IEP6GGEX_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-IEP6GGEX.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IEP6GGEX.mjs\");\n\n\n\n//# sourceMappingURL=error.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvZXJyb3IubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QjhCO0FBQ0E7QUF5QjVCO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvZXJyb3IubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENsZXJrQVBJRXJyb3IsXG4gIENsZXJrQVBJUmVzcG9uc2VFcnJvcixcbiAgQ2xlcmtSdW50aW1lRXJyb3IsXG4gIENsZXJrV2ViQXV0aG5FcnJvcixcbiAgRW1haWxMaW5rRXJyb3IsXG4gIEVtYWlsTGlua0Vycm9yQ29kZSxcbiAgRW1haWxMaW5rRXJyb3JDb2RlU3RhdHVzLFxuICBidWlsZEVycm9yVGhyb3dlcixcbiAgZXJyb3JUb0pTT04sXG4gIGlzNHh4RXJyb3IsXG4gIGlzQ2FwdGNoYUVycm9yLFxuICBpc0NsZXJrQVBJUmVzcG9uc2VFcnJvcixcbiAgaXNDbGVya1J1bnRpbWVFcnJvcixcbiAgaXNFbWFpbExpbmtFcnJvcixcbiAgaXNLbm93bkVycm9yLFxuICBpc01ldGFtYXNrRXJyb3IsXG4gIGlzTmV0d29ya0Vycm9yLFxuICBpc1Bhc3N3b3JkUHduZWRFcnJvcixcbiAgaXNSZXZlcmlmaWNhdGlvbkNhbmNlbGxlZEVycm9yLFxuICBpc1VuYXV0aG9yaXplZEVycm9yLFxuICBpc1VzZXJMb2NrZWRFcnJvcixcbiAgcGFyc2VFcnJvcixcbiAgcGFyc2VFcnJvcnNcbn0gZnJvbSBcIi4vY2h1bmstQVhIVTZUWEUubWpzXCI7XG5pbXBvcnQgXCIuL2NodW5rLUlFUDZHR0VYLm1qc1wiO1xuZXhwb3J0IHtcbiAgQ2xlcmtBUElFcnJvcixcbiAgQ2xlcmtBUElSZXNwb25zZUVycm9yLFxuICBDbGVya1J1bnRpbWVFcnJvcixcbiAgQ2xlcmtXZWJBdXRobkVycm9yLFxuICBFbWFpbExpbmtFcnJvcixcbiAgRW1haWxMaW5rRXJyb3JDb2RlLFxuICBFbWFpbExpbmtFcnJvckNvZGVTdGF0dXMsXG4gIGJ1aWxkRXJyb3JUaHJvd2VyLFxuICBlcnJvclRvSlNPTixcbiAgaXM0eHhFcnJvcixcbiAgaXNDYXB0Y2hhRXJyb3IsXG4gIGlzQ2xlcmtBUElSZXNwb25zZUVycm9yLFxuICBpc0NsZXJrUnVudGltZUVycm9yLFxuICBpc0VtYWlsTGlua0Vycm9yLFxuICBpc0tub3duRXJyb3IsXG4gIGlzTWV0YW1hc2tFcnJvcixcbiAgaXNOZXR3b3JrRXJyb3IsXG4gIGlzUGFzc3dvcmRQd25lZEVycm9yLFxuICBpc1JldmVyaWZpY2F0aW9uQ2FuY2VsbGVkRXJyb3IsXG4gIGlzVW5hdXRob3JpemVkRXJyb3IsXG4gIGlzVXNlckxvY2tlZEVycm9yLFxuICBwYXJzZUVycm9yLFxuICBwYXJzZUVycm9yc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/error.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/keys.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/keys.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildPublishableKey: () => (/* reexport safe */ _chunk_IV7BOO4U_mjs__WEBPACK_IMPORTED_MODULE_0__.buildPublishableKey),\n/* harmony export */   createDevOrStagingUrlCache: () => (/* reexport safe */ _chunk_IV7BOO4U_mjs__WEBPACK_IMPORTED_MODULE_0__.createDevOrStagingUrlCache),\n/* harmony export */   getCookieSuffix: () => (/* reexport safe */ _chunk_IV7BOO4U_mjs__WEBPACK_IMPORTED_MODULE_0__.getCookieSuffix),\n/* harmony export */   getSuffixedCookieName: () => (/* reexport safe */ _chunk_IV7BOO4U_mjs__WEBPACK_IMPORTED_MODULE_0__.getSuffixedCookieName),\n/* harmony export */   isDevelopmentFromPublishableKey: () => (/* reexport safe */ _chunk_IV7BOO4U_mjs__WEBPACK_IMPORTED_MODULE_0__.isDevelopmentFromPublishableKey),\n/* harmony export */   isDevelopmentFromSecretKey: () => (/* reexport safe */ _chunk_IV7BOO4U_mjs__WEBPACK_IMPORTED_MODULE_0__.isDevelopmentFromSecretKey),\n/* harmony export */   isProductionFromPublishableKey: () => (/* reexport safe */ _chunk_IV7BOO4U_mjs__WEBPACK_IMPORTED_MODULE_0__.isProductionFromPublishableKey),\n/* harmony export */   isProductionFromSecretKey: () => (/* reexport safe */ _chunk_IV7BOO4U_mjs__WEBPACK_IMPORTED_MODULE_0__.isProductionFromSecretKey),\n/* harmony export */   isPublishableKey: () => (/* reexport safe */ _chunk_IV7BOO4U_mjs__WEBPACK_IMPORTED_MODULE_0__.isPublishableKey),\n/* harmony export */   parsePublishableKey: () => (/* reexport safe */ _chunk_IV7BOO4U_mjs__WEBPACK_IMPORTED_MODULE_0__.parsePublishableKey)\n/* harmony export */ });\n/* harmony import */ var _chunk_IV7BOO4U_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-IV7BOO4U.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IV7BOO4U.mjs\");\n/* harmony import */ var _chunk_TETGTEI2_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-TETGTEI2.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs\");\n/* harmony import */ var _chunk_KOH7GTJO_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-KOH7GTJO.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs\");\n/* harmony import */ var _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk-I6MTSTOF.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs\");\n/* harmony import */ var _chunk_IEP6GGEX_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chunk-IEP6GGEX.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IEP6GGEX.mjs\");\n\n\n\n\n\n\n//# sourceMappingURL=keys.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3Qva2V5cy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBVzhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFZNUI7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2lzaGFxYmVsbG8vV2Vic2l0ZS9oYXZlbnJpZGVfZnVsbF9hcHAvbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9rZXlzLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBidWlsZFB1Ymxpc2hhYmxlS2V5LFxuICBjcmVhdGVEZXZPclN0YWdpbmdVcmxDYWNoZSxcbiAgZ2V0Q29va2llU3VmZml4LFxuICBnZXRTdWZmaXhlZENvb2tpZU5hbWUsXG4gIGlzRGV2ZWxvcG1lbnRGcm9tUHVibGlzaGFibGVLZXksXG4gIGlzRGV2ZWxvcG1lbnRGcm9tU2VjcmV0S2V5LFxuICBpc1Byb2R1Y3Rpb25Gcm9tUHVibGlzaGFibGVLZXksXG4gIGlzUHJvZHVjdGlvbkZyb21TZWNyZXRLZXksXG4gIGlzUHVibGlzaGFibGVLZXksXG4gIHBhcnNlUHVibGlzaGFibGVLZXlcbn0gZnJvbSBcIi4vY2h1bmstSVY3Qk9PNFUubWpzXCI7XG5pbXBvcnQgXCIuL2NodW5rLVRFVEdURUkyLm1qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay1LT0g3R1RKTy5tanNcIjtcbmltcG9ydCBcIi4vY2h1bmstSTZNVFNUT0YubWpzXCI7XG5pbXBvcnQgXCIuL2NodW5rLUlFUDZHR0VYLm1qc1wiO1xuZXhwb3J0IHtcbiAgYnVpbGRQdWJsaXNoYWJsZUtleSxcbiAgY3JlYXRlRGV2T3JTdGFnaW5nVXJsQ2FjaGUsXG4gIGdldENvb2tpZVN1ZmZpeCxcbiAgZ2V0U3VmZml4ZWRDb29raWVOYW1lLFxuICBpc0RldmVsb3BtZW50RnJvbVB1Ymxpc2hhYmxlS2V5LFxuICBpc0RldmVsb3BtZW50RnJvbVNlY3JldEtleSxcbiAgaXNQcm9kdWN0aW9uRnJvbVB1Ymxpc2hhYmxlS2V5LFxuICBpc1Byb2R1Y3Rpb25Gcm9tU2VjcmV0S2V5LFxuICBpc1B1Ymxpc2hhYmxlS2V5LFxuICBwYXJzZVB1Ymxpc2hhYmxlS2V5XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5cy5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/keys.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/loadClerkJsScript.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/loadClerkJsScript.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildClerkJsScriptAttributes: () => (/* reexport safe */ _chunk_YTPL7FML_mjs__WEBPACK_IMPORTED_MODULE_0__.buildClerkJsScriptAttributes),\n/* harmony export */   clerkJsScriptUrl: () => (/* reexport safe */ _chunk_YTPL7FML_mjs__WEBPACK_IMPORTED_MODULE_0__.clerkJsScriptUrl),\n/* harmony export */   loadClerkJsScript: () => (/* reexport safe */ _chunk_YTPL7FML_mjs__WEBPACK_IMPORTED_MODULE_0__.loadClerkJsScript),\n/* harmony export */   setClerkJsLoadingErrorPackageName: () => (/* reexport safe */ _chunk_YTPL7FML_mjs__WEBPACK_IMPORTED_MODULE_0__.setClerkJsLoadingErrorPackageName)\n/* harmony export */ });\n/* harmony import */ var _chunk_YTPL7FML_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-YTPL7FML.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-YTPL7FML.mjs\");\n/* harmony import */ var _chunk_ELKNO6YM_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-ELKNO6YM.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-ELKNO6YM.mjs\");\n/* harmony import */ var _chunk_6NDGN2IU_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-6NDGN2IU.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-6NDGN2IU.mjs\");\n/* harmony import */ var _chunk_IFTVZ2LQ_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk-IFTVZ2LQ.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IFTVZ2LQ.mjs\");\n/* harmony import */ var _chunk_3TMSNP4L_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chunk-3TMSNP4L.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-3TMSNP4L.mjs\");\n/* harmony import */ var _chunk_U7IR7A27_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chunk-U7IR7A27.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-U7IR7A27.mjs\");\n/* harmony import */ var _chunk_PL3YYI2I_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./chunk-PL3YYI2I.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-PL3YYI2I.mjs\");\n/* harmony import */ var _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./chunk-AXHU6TXE.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-AXHU6TXE.mjs\");\n/* harmony import */ var _chunk_IV7BOO4U_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./chunk-IV7BOO4U.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IV7BOO4U.mjs\");\n/* harmony import */ var _chunk_TETGTEI2_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./chunk-TETGTEI2.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs\");\n/* harmony import */ var _chunk_KOH7GTJO_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./chunk-KOH7GTJO.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs\");\n/* harmony import */ var _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./chunk-I6MTSTOF.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs\");\n/* harmony import */ var _chunk_IEP6GGEX_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./chunk-IEP6GGEX.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IEP6GGEX.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=loadClerkJsScript.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvbG9hZENsZXJrSnNTY3JpcHQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSzhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTTVCO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvbG9hZENsZXJrSnNTY3JpcHQubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGJ1aWxkQ2xlcmtKc1NjcmlwdEF0dHJpYnV0ZXMsXG4gIGNsZXJrSnNTY3JpcHRVcmwsXG4gIGxvYWRDbGVya0pzU2NyaXB0LFxuICBzZXRDbGVya0pzTG9hZGluZ0Vycm9yUGFja2FnZU5hbWVcbn0gZnJvbSBcIi4vY2h1bmstWVRQTDdGTUwubWpzXCI7XG5pbXBvcnQgXCIuL2NodW5rLUVMS05PNllNLm1qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay02TkRHTjJJVS5tanNcIjtcbmltcG9ydCBcIi4vY2h1bmstSUZUVloyTFEubWpzXCI7XG5pbXBvcnQgXCIuL2NodW5rLTNUTVNOUDRMLm1qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay1VN0lSN0EyNy5tanNcIjtcbmltcG9ydCBcIi4vY2h1bmstUEwzWVlJMkkubWpzXCI7XG5pbXBvcnQgXCIuL2NodW5rLUFYSFU2VFhFLm1qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay1JVjdCT080VS5tanNcIjtcbmltcG9ydCBcIi4vY2h1bmstVEVUR1RFSTIubWpzXCI7XG5pbXBvcnQgXCIuL2NodW5rLUtPSDdHVEpPLm1qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay1JNk1UU1RPRi5tanNcIjtcbmltcG9ydCBcIi4vY2h1bmstSUVQNkdHRVgubWpzXCI7XG5leHBvcnQge1xuICBidWlsZENsZXJrSnNTY3JpcHRBdHRyaWJ1dGVzLFxuICBjbGVya0pzU2NyaXB0VXJsLFxuICBsb2FkQ2xlcmtKc1NjcmlwdCxcbiAgc2V0Q2xlcmtKc0xvYWRpbmdFcnJvclBhY2thZ2VOYW1lXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZENsZXJrSnNTY3JpcHQubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/loadClerkJsScript.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/object.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/object.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyFunctionToObj: () => (/* reexport safe */ _chunk_CFXQSUF6_mjs__WEBPACK_IMPORTED_MODULE_0__.applyFunctionToObj),\n/* harmony export */   filterProps: () => (/* reexport safe */ _chunk_CFXQSUF6_mjs__WEBPACK_IMPORTED_MODULE_0__.filterProps),\n/* harmony export */   removeUndefined: () => (/* reexport safe */ _chunk_CFXQSUF6_mjs__WEBPACK_IMPORTED_MODULE_0__.removeUndefined),\n/* harmony export */   without: () => (/* reexport safe */ _chunk_CFXQSUF6_mjs__WEBPACK_IMPORTED_MODULE_0__.without)\n/* harmony export */ });\n/* harmony import */ var _chunk_CFXQSUF6_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-CFXQSUF6.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-CFXQSUF6.mjs\");\n/* harmony import */ var _chunk_IEP6GGEX_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-IEP6GGEX.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IEP6GGEX.mjs\");\n\n\n\n//# sourceMappingURL=object.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3Qvb2JqZWN0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFLOEI7QUFDQTtBQU01QjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L29iamVjdC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgYXBwbHlGdW5jdGlvblRvT2JqLFxuICBmaWx0ZXJQcm9wcyxcbiAgcmVtb3ZlVW5kZWZpbmVkLFxuICB3aXRob3V0XG59IGZyb20gXCIuL2NodW5rLUNGWFFTVUY2Lm1qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay1JRVA2R0dFWC5tanNcIjtcbmV4cG9ydCB7XG4gIGFwcGx5RnVuY3Rpb25Ub09iaixcbiAgZmlsdGVyUHJvcHMsXG4gIHJlbW92ZVVuZGVmaW5lZCxcbiAgd2l0aG91dFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdC5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/object.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/react/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/react/index.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClerkInstanceContext: () => (/* binding */ ClerkInstanceContext),\n/* harmony export */   ClientContext: () => (/* binding */ ClientContext),\n/* harmony export */   OptionsContext: () => (/* binding */ OptionsContext),\n/* harmony export */   OrganizationProvider: () => (/* binding */ OrganizationProvider),\n/* harmony export */   SessionContext: () => (/* binding */ SessionContext),\n/* harmony export */   UserContext: () => (/* binding */ UserContext),\n/* harmony export */   __experimental_CheckoutProvider: () => (/* binding */ __experimental_CheckoutProvider),\n/* harmony export */   __experimental_PaymentElement: () => (/* binding */ PaymentElement2),\n/* harmony export */   __experimental_PaymentElementProvider: () => (/* binding */ PaymentElementProvider),\n/* harmony export */   __experimental_useCheckout: () => (/* binding */ useCheckout),\n/* harmony export */   __experimental_usePaymentAttempts: () => (/* binding */ usePaymentAttempts),\n/* harmony export */   __experimental_usePaymentElement: () => (/* binding */ usePaymentElement),\n/* harmony export */   __experimental_usePaymentMethods: () => (/* binding */ usePaymentMethods),\n/* harmony export */   __experimental_usePlans: () => (/* binding */ usePlans),\n/* harmony export */   __experimental_useStatements: () => (/* binding */ useStatements),\n/* harmony export */   __experimental_useSubscription: () => (/* binding */ useSubscription),\n/* harmony export */   assertContextExists: () => (/* binding */ assertContextExists),\n/* harmony export */   createContextAndHook: () => (/* binding */ createContextAndHook),\n/* harmony export */   isDeeplyEqual: () => (/* binding */ isDeeplyEqual),\n/* harmony export */   useAssertWrappedByClerkProvider: () => (/* binding */ useAssertWrappedByClerkProvider),\n/* harmony export */   useClerk: () => (/* binding */ useClerk),\n/* harmony export */   useClerkInstanceContext: () => (/* binding */ useClerkInstanceContext),\n/* harmony export */   useClientContext: () => (/* binding */ useClientContext),\n/* harmony export */   useDeepEqualMemo: () => (/* binding */ useDeepEqualMemo),\n/* harmony export */   useOptionsContext: () => (/* binding */ useOptionsContext),\n/* harmony export */   useOrganization: () => (/* binding */ useOrganization),\n/* harmony export */   useOrganizationContext: () => (/* binding */ useOrganizationContext),\n/* harmony export */   useOrganizationList: () => (/* binding */ useOrganizationList),\n/* harmony export */   useReverification: () => (/* binding */ useReverification),\n/* harmony export */   useSafeLayoutEffect: () => (/* binding */ useSafeLayoutEffect),\n/* harmony export */   useSession: () => (/* binding */ useSession),\n/* harmony export */   useSessionContext: () => (/* binding */ useSessionContext),\n/* harmony export */   useSessionList: () => (/* binding */ useSessionList),\n/* harmony export */   useUser: () => (/* binding */ useUser),\n/* harmony export */   useUserContext: () => (/* binding */ useUserContext)\n/* harmony export */ });\n/* harmony import */ var _chunk_RUA3ZE6A_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chunk-RUA3ZE6A.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-RUA3ZE6A.mjs\");\n/* harmony import */ var _chunk_IBXKDGSZ_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../chunk-IBXKDGSZ.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IBXKDGSZ.mjs\");\n/* harmony import */ var _chunk_7QJ2QTJL_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../chunk-7QJ2QTJL.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7QJ2QTJL.mjs\");\n/* harmony import */ var _chunk_GGFRMWFO_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../chunk-GGFRMWFO.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-GGFRMWFO.mjs\");\n/* harmony import */ var _chunk_7FNX7RWY_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../chunk-7FNX7RWY.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7FNX7RWY.mjs\");\n/* harmony import */ var _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../chunk-AXHU6TXE.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-AXHU6TXE.mjs\");\n/* harmony import */ var _chunk_IV7BOO4U_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../chunk-IV7BOO4U.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IV7BOO4U.mjs\");\n/* harmony import */ var _chunk_TETGTEI2_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../chunk-TETGTEI2.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs\");\n/* harmony import */ var _chunk_KOH7GTJO_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../chunk-KOH7GTJO.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs\");\n/* harmony import */ var _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../chunk-I6MTSTOF.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs\");\n/* harmony import */ var _chunk_43A5F2IE_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../chunk-43A5F2IE.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-43A5F2IE.mjs\");\n/* harmony import */ var _chunk_3CN5LOSN_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../chunk-3CN5LOSN.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-3CN5LOSN.mjs\");\n/* harmony import */ var _chunk_IEP6GGEX_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../chunk-IEP6GGEX.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IEP6GGEX.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! swr */ \"(app-pages-browser)/./node_modules/swr/dist/index/index.mjs\");\n/* harmony import */ var swr_infinite__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! swr/infinite */ \"(app-pages-browser)/./node_modules/swr/dist/infinite/index.mjs\");\n/* harmony import */ var dequal__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! dequal */ \"(app-pages-browser)/./node_modules/dequal/dist/index.mjs\");\n/* harmony import */ var swr_mutation__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! swr/mutation */ \"(app-pages-browser)/./node_modules/swr/dist/mutation/index.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// src/react/hooks/createContextAndHook.ts\n\nfunction assertContextExists(contextVal, msgOrCtx) {\n  if (!contextVal) {\n    throw typeof msgOrCtx === \"string\" ? new Error(msgOrCtx) : new Error(`${msgOrCtx.displayName} not found`);\n  }\n}\nvar createContextAndHook = (displayName, options) => {\n  const { assertCtxFn = assertContextExists } = options || {};\n  const Ctx = react__WEBPACK_IMPORTED_MODULE_13__.createContext(void 0);\n  Ctx.displayName = displayName;\n  const useCtx = () => {\n    const ctx = react__WEBPACK_IMPORTED_MODULE_13__.useContext(Ctx);\n    assertCtxFn(ctx, `${displayName} not found`);\n    return ctx.value;\n  };\n  const useCtxWithoutGuarantee = () => {\n    const ctx = react__WEBPACK_IMPORTED_MODULE_13__.useContext(Ctx);\n    return ctx ? ctx.value : {};\n  };\n  return [Ctx, useCtx, useCtxWithoutGuarantee];\n};\n\n// src/react/contexts.tsx\n\n\n// src/react/clerk-swr.ts\nvar clerk_swr_exports = {};\n(0,_chunk_IEP6GGEX_mjs__WEBPACK_IMPORTED_MODULE_12__.__export)(clerk_swr_exports, {\n  useSWR: () => swr__WEBPACK_IMPORTED_MODULE_14__[\"default\"],\n  useSWRInfinite: () => swr_infinite__WEBPACK_IMPORTED_MODULE_15__[\"default\"]\n});\n(0,_chunk_IEP6GGEX_mjs__WEBPACK_IMPORTED_MODULE_12__.__reExport)(clerk_swr_exports, swr__WEBPACK_IMPORTED_MODULE_14__);\n\n\n\n\n// src/react/contexts.tsx\nvar [ClerkInstanceContext, useClerkInstanceContext] = createContextAndHook(\"ClerkInstanceContext\");\nvar [UserContext, useUserContext] = createContextAndHook(\"UserContext\");\nvar [ClientContext, useClientContext] = createContextAndHook(\"ClientContext\");\nvar [SessionContext, useSessionContext] = createContextAndHook(\n  \"SessionContext\"\n);\nvar OptionsContext = react__WEBPACK_IMPORTED_MODULE_13__.createContext({});\nvar [CheckoutContext, useCheckoutContext] = createContextAndHook(\"CheckoutContext\");\nvar __experimental_CheckoutProvider = ({ children, ...rest }) => {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_13__.createElement(CheckoutContext.Provider, { value: { value: rest } }, children);\n};\nfunction useOptionsContext() {\n  const context = react__WEBPACK_IMPORTED_MODULE_13__.useContext(OptionsContext);\n  if (context === void 0) {\n    throw new Error(\"useOptions must be used within an OptionsContext\");\n  }\n  return context;\n}\nvar [OrganizationContextInternal, useOrganizationContext] = createContextAndHook(\"OrganizationContext\");\nvar OrganizationProvider = ({\n  children,\n  organization,\n  swrConfig\n}) => {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_13__.createElement(clerk_swr_exports.SWRConfig, { value: swrConfig }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_13__.createElement(\n    OrganizationContextInternal.Provider,\n    {\n      value: {\n        value: { organization }\n      }\n    },\n    children\n  ));\n};\nfunction useAssertWrappedByClerkProvider(displayNameOrFn) {\n  const ctx = react__WEBPACK_IMPORTED_MODULE_13__.useContext(ClerkInstanceContext);\n  if (!ctx) {\n    if (typeof displayNameOrFn === \"function\") {\n      displayNameOrFn();\n      return;\n    }\n    throw new Error(\n      `${displayNameOrFn} can only be used within the <ClerkProvider /> component.\n\nPossible fixes:\n1. Ensure that the <ClerkProvider /> is correctly wrapping your application where this component is used.\n2. Check for multiple versions of the \\`@clerk/shared\\` package in your project. Use a tool like \\`npm ls @clerk/shared\\` to identify multiple versions, and update your dependencies to only rely on one.\n\nLearn more: https://clerk.com/docs/components/clerk-provider`.trim()\n    );\n  }\n}\n\n// src/react/hooks/usePagesOrInfinite.ts\n\n\n// src/react/hooks/usePreviousValue.ts\n\nfunction usePreviousValue(value) {\n  const currentRef = (0,react__WEBPACK_IMPORTED_MODULE_13__.useRef)(value);\n  const previousRef = (0,react__WEBPACK_IMPORTED_MODULE_13__.useRef)(null);\n  if (currentRef.current !== value) {\n    previousRef.current = currentRef.current;\n    currentRef.current = value;\n  }\n  return previousRef.current;\n}\n\n// src/react/hooks/usePagesOrInfinite.ts\nfunction getDifferentKeys(obj1, obj2) {\n  const keysSet = new Set(Object.keys(obj2));\n  const differentKeysObject = {};\n  for (const key1 of Object.keys(obj1)) {\n    if (!keysSet.has(key1)) {\n      differentKeysObject[key1] = obj1[key1];\n    }\n  }\n  return differentKeysObject;\n}\nvar useWithSafeValues = (params, defaultValues) => {\n  const shouldUseDefaults = typeof params === \"boolean\" && params;\n  const initialPageRef = (0,react__WEBPACK_IMPORTED_MODULE_13__.useRef)(\n    shouldUseDefaults ? defaultValues.initialPage : params?.initialPage ?? defaultValues.initialPage\n  );\n  const pageSizeRef = (0,react__WEBPACK_IMPORTED_MODULE_13__.useRef)(shouldUseDefaults ? defaultValues.pageSize : params?.pageSize ?? defaultValues.pageSize);\n  const newObj = {};\n  for (const key of Object.keys(defaultValues)) {\n    newObj[key] = shouldUseDefaults ? defaultValues[key] : params?.[key] ?? defaultValues[key];\n  }\n  return {\n    ...newObj,\n    initialPage: initialPageRef.current,\n    pageSize: pageSizeRef.current\n  };\n};\nvar cachingSWROptions = {\n  dedupingInterval: 1e3 * 60,\n  focusThrottleInterval: 1e3 * 60 * 2\n};\nvar usePagesOrInfinite = (params, fetcher, config, cacheKeys) => {\n  const [paginatedPage, setPaginatedPage] = (0,react__WEBPACK_IMPORTED_MODULE_13__.useState)(params.initialPage ?? 1);\n  const initialPageRef = (0,react__WEBPACK_IMPORTED_MODULE_13__.useRef)(params.initialPage ?? 1);\n  const pageSizeRef = (0,react__WEBPACK_IMPORTED_MODULE_13__.useRef)(params.pageSize ?? 10);\n  const enabled = config.enabled ?? true;\n  const cacheMode = config.__experimental_mode === \"cache\";\n  const triggerInfinite = config.infinite ?? false;\n  const keepPreviousData = config.keepPreviousData ?? false;\n  const isSignedIn = config.isSignedIn;\n  const pagesCacheKey = {\n    ...cacheKeys,\n    ...params,\n    initialPage: paginatedPage,\n    pageSize: pageSizeRef.current\n  };\n  const previousIsSignedIn = usePreviousValue(isSignedIn);\n  const shouldFetch = !triggerInfinite && enabled && (!cacheMode ? !!fetcher : true);\n  const swrKey = typeof isSignedIn === \"boolean\" ? previousIsSignedIn === true && isSignedIn === false ? pagesCacheKey : isSignedIn ? shouldFetch ? pagesCacheKey : null : null : shouldFetch ? pagesCacheKey : null;\n  const swrFetcher = !cacheMode && !!fetcher ? (cacheKeyParams) => {\n    if (isSignedIn === false || shouldFetch === false) {\n      return null;\n    }\n    const requestParams = getDifferentKeys(cacheKeyParams, cacheKeys);\n    return fetcher({ ...params, ...requestParams });\n  } : null;\n  const {\n    data: swrData,\n    isValidating: swrIsValidating,\n    isLoading: swrIsLoading,\n    error: swrError,\n    mutate: swrMutate\n  } = (0,swr__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(swrKey, swrFetcher, { keepPreviousData, ...cachingSWROptions });\n  const {\n    data: swrInfiniteData,\n    isLoading: swrInfiniteIsLoading,\n    isValidating: swrInfiniteIsValidating,\n    error: swrInfiniteError,\n    size,\n    setSize,\n    mutate: swrInfiniteMutate\n  } = (0,swr_infinite__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(\n    (pageIndex) => {\n      if (!triggerInfinite || !enabled || isSignedIn === false) {\n        return null;\n      }\n      return {\n        ...params,\n        ...cacheKeys,\n        initialPage: initialPageRef.current + pageIndex,\n        pageSize: pageSizeRef.current\n      };\n    },\n    (cacheKeyParams) => {\n      const requestParams = getDifferentKeys(cacheKeyParams, cacheKeys);\n      return fetcher?.(requestParams);\n    },\n    cachingSWROptions\n  );\n  const page = (0,react__WEBPACK_IMPORTED_MODULE_13__.useMemo)(() => {\n    if (triggerInfinite) {\n      return size;\n    }\n    return paginatedPage;\n  }, [triggerInfinite, size, paginatedPage]);\n  const fetchPage = (0,react__WEBPACK_IMPORTED_MODULE_13__.useCallback)(\n    (numberOrgFn) => {\n      if (triggerInfinite) {\n        void setSize(numberOrgFn);\n        return;\n      }\n      return setPaginatedPage(numberOrgFn);\n    },\n    [setSize, triggerInfinite]\n  );\n  const data = (0,react__WEBPACK_IMPORTED_MODULE_13__.useMemo)(() => {\n    if (triggerInfinite) {\n      return swrInfiniteData?.map((a) => a?.data).flat() ?? [];\n    }\n    return swrData?.data ?? [];\n  }, [triggerInfinite, swrData, swrInfiniteData]);\n  const count = (0,react__WEBPACK_IMPORTED_MODULE_13__.useMemo)(() => {\n    if (triggerInfinite) {\n      return swrInfiniteData?.[swrInfiniteData?.length - 1]?.total_count || 0;\n    }\n    return swrData?.total_count ?? 0;\n  }, [triggerInfinite, swrData, swrInfiniteData]);\n  const isLoading = triggerInfinite ? swrInfiniteIsLoading : swrIsLoading;\n  const isFetching = triggerInfinite ? swrInfiniteIsValidating : swrIsValidating;\n  const error = (triggerInfinite ? swrInfiniteError : swrError) ?? null;\n  const isError = !!error;\n  const fetchNext = (0,react__WEBPACK_IMPORTED_MODULE_13__.useCallback)(() => {\n    fetchPage((n) => Math.max(0, n + 1));\n  }, [fetchPage]);\n  const fetchPrevious = (0,react__WEBPACK_IMPORTED_MODULE_13__.useCallback)(() => {\n    fetchPage((n) => Math.max(0, n - 1));\n  }, [fetchPage]);\n  const offsetCount = (initialPageRef.current - 1) * pageSizeRef.current;\n  const pageCount = Math.ceil((count - offsetCount) / pageSizeRef.current);\n  const hasNextPage = count - offsetCount * pageSizeRef.current > page * pageSizeRef.current;\n  const hasPreviousPage = (page - 1) * pageSizeRef.current > offsetCount * pageSizeRef.current;\n  const setData = triggerInfinite ? (value) => swrInfiniteMutate(value, {\n    revalidate: false\n  }) : (value) => swrMutate(value, {\n    revalidate: false\n  });\n  const revalidate = triggerInfinite ? () => swrInfiniteMutate() : () => swrMutate();\n  return {\n    data,\n    count,\n    error,\n    isLoading,\n    isFetching,\n    isError,\n    page,\n    pageCount,\n    fetchPage,\n    fetchNext,\n    fetchPrevious,\n    hasNextPage,\n    hasPreviousPage,\n    // Let the hook return type define this type\n    revalidate,\n    // Let the hook return type define this type\n    setData\n  };\n};\n\n// src/react/hooks/useOrganization.tsx\nvar undefinedPaginatedResource = {\n  data: void 0,\n  count: void 0,\n  error: void 0,\n  isLoading: false,\n  isFetching: false,\n  isError: false,\n  page: void 0,\n  pageCount: void 0,\n  fetchPage: void 0,\n  fetchNext: void 0,\n  fetchPrevious: void 0,\n  hasNextPage: false,\n  hasPreviousPage: false,\n  revalidate: void 0,\n  setData: void 0\n};\nfunction useOrganization(params) {\n  const {\n    domains: domainListParams,\n    membershipRequests: membershipRequestsListParams,\n    memberships: membersListParams,\n    invitations: invitationsListParams\n  } = params || {};\n  useAssertWrappedByClerkProvider(\"useOrganization\");\n  const { organization } = useOrganizationContext();\n  const session = useSessionContext();\n  const domainSafeValues = useWithSafeValues(domainListParams, {\n    initialPage: 1,\n    pageSize: 10,\n    keepPreviousData: false,\n    infinite: false,\n    enrollmentMode: void 0\n  });\n  const membershipRequestSafeValues = useWithSafeValues(membershipRequestsListParams, {\n    initialPage: 1,\n    pageSize: 10,\n    status: \"pending\",\n    keepPreviousData: false,\n    infinite: false\n  });\n  const membersSafeValues = useWithSafeValues(membersListParams, {\n    initialPage: 1,\n    pageSize: 10,\n    role: void 0,\n    keepPreviousData: false,\n    infinite: false,\n    query: void 0\n  });\n  const invitationsSafeValues = useWithSafeValues(invitationsListParams, {\n    initialPage: 1,\n    pageSize: 10,\n    status: [\"pending\"],\n    keepPreviousData: false,\n    infinite: false\n  });\n  const clerk = useClerkInstanceContext();\n  clerk.telemetry?.record((0,_chunk_RUA3ZE6A_mjs__WEBPACK_IMPORTED_MODULE_0__.eventMethodCalled)(\"useOrganization\"));\n  const domainParams = typeof domainListParams === \"undefined\" ? void 0 : {\n    initialPage: domainSafeValues.initialPage,\n    pageSize: domainSafeValues.pageSize,\n    enrollmentMode: domainSafeValues.enrollmentMode\n  };\n  const membershipRequestParams = typeof membershipRequestsListParams === \"undefined\" ? void 0 : {\n    initialPage: membershipRequestSafeValues.initialPage,\n    pageSize: membershipRequestSafeValues.pageSize,\n    status: membershipRequestSafeValues.status\n  };\n  const membersParams = typeof membersListParams === \"undefined\" ? void 0 : {\n    initialPage: membersSafeValues.initialPage,\n    pageSize: membersSafeValues.pageSize,\n    role: membersSafeValues.role,\n    query: membersSafeValues.query\n  };\n  const invitationsParams = typeof invitationsListParams === \"undefined\" ? void 0 : {\n    initialPage: invitationsSafeValues.initialPage,\n    pageSize: invitationsSafeValues.pageSize,\n    status: invitationsSafeValues.status\n  };\n  const domains = usePagesOrInfinite(\n    {\n      ...domainParams\n    },\n    organization?.getDomains,\n    {\n      keepPreviousData: domainSafeValues.keepPreviousData,\n      infinite: domainSafeValues.infinite,\n      enabled: !!domainParams\n    },\n    {\n      type: \"domains\",\n      organizationId: organization?.id\n    }\n  );\n  const membershipRequests = usePagesOrInfinite(\n    {\n      ...membershipRequestParams\n    },\n    organization?.getMembershipRequests,\n    {\n      keepPreviousData: membershipRequestSafeValues.keepPreviousData,\n      infinite: membershipRequestSafeValues.infinite,\n      enabled: !!membershipRequestParams\n    },\n    {\n      type: \"membershipRequests\",\n      organizationId: organization?.id\n    }\n  );\n  const memberships = usePagesOrInfinite(\n    membersParams || {},\n    organization?.getMemberships,\n    {\n      keepPreviousData: membersSafeValues.keepPreviousData,\n      infinite: membersSafeValues.infinite,\n      enabled: !!membersParams\n    },\n    {\n      type: \"members\",\n      organizationId: organization?.id\n    }\n  );\n  const invitations = usePagesOrInfinite(\n    {\n      ...invitationsParams\n    },\n    organization?.getInvitations,\n    {\n      keepPreviousData: invitationsSafeValues.keepPreviousData,\n      infinite: invitationsSafeValues.infinite,\n      enabled: !!invitationsParams\n    },\n    {\n      type: \"invitations\",\n      organizationId: organization?.id\n    }\n  );\n  if (organization === void 0) {\n    return {\n      isLoaded: false,\n      organization: void 0,\n      membership: void 0,\n      domains: undefinedPaginatedResource,\n      membershipRequests: undefinedPaginatedResource,\n      memberships: undefinedPaginatedResource,\n      invitations: undefinedPaginatedResource\n    };\n  }\n  if (organization === null) {\n    return {\n      isLoaded: true,\n      organization: null,\n      membership: null,\n      domains: null,\n      membershipRequests: null,\n      memberships: null,\n      invitations: null\n    };\n  }\n  if (!clerk.loaded && organization) {\n    return {\n      isLoaded: true,\n      organization,\n      membership: void 0,\n      domains: undefinedPaginatedResource,\n      membershipRequests: undefinedPaginatedResource,\n      memberships: undefinedPaginatedResource,\n      invitations: undefinedPaginatedResource\n    };\n  }\n  return {\n    isLoaded: clerk.loaded,\n    organization,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    membership: (0,_chunk_IBXKDGSZ_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentOrganizationMembership)(session.user.organizationMemberships, organization.id),\n    // your membership in the current org\n    domains,\n    membershipRequests,\n    memberships,\n    invitations\n  };\n}\n\n// src/react/hooks/useOrganizationList.tsx\nvar undefinedPaginatedResource2 = {\n  data: void 0,\n  count: void 0,\n  error: void 0,\n  isLoading: false,\n  isFetching: false,\n  isError: false,\n  page: void 0,\n  pageCount: void 0,\n  fetchPage: void 0,\n  fetchNext: void 0,\n  fetchPrevious: void 0,\n  hasNextPage: false,\n  hasPreviousPage: false,\n  revalidate: void 0,\n  setData: void 0\n};\nfunction useOrganizationList(params) {\n  const { userMemberships, userInvitations, userSuggestions } = params || {};\n  useAssertWrappedByClerkProvider(\"useOrganizationList\");\n  const userMembershipsSafeValues = useWithSafeValues(userMemberships, {\n    initialPage: 1,\n    pageSize: 10,\n    keepPreviousData: false,\n    infinite: false\n  });\n  const userInvitationsSafeValues = useWithSafeValues(userInvitations, {\n    initialPage: 1,\n    pageSize: 10,\n    status: \"pending\",\n    keepPreviousData: false,\n    infinite: false\n  });\n  const userSuggestionsSafeValues = useWithSafeValues(userSuggestions, {\n    initialPage: 1,\n    pageSize: 10,\n    status: \"pending\",\n    keepPreviousData: false,\n    infinite: false\n  });\n  const clerk = useClerkInstanceContext();\n  const user = useUserContext();\n  clerk.telemetry?.record((0,_chunk_RUA3ZE6A_mjs__WEBPACK_IMPORTED_MODULE_0__.eventMethodCalled)(\"useOrganizationList\"));\n  const userMembershipsParams = typeof userMemberships === \"undefined\" ? void 0 : {\n    initialPage: userMembershipsSafeValues.initialPage,\n    pageSize: userMembershipsSafeValues.pageSize\n  };\n  const userInvitationsParams = typeof userInvitations === \"undefined\" ? void 0 : {\n    initialPage: userInvitationsSafeValues.initialPage,\n    pageSize: userInvitationsSafeValues.pageSize,\n    status: userInvitationsSafeValues.status\n  };\n  const userSuggestionsParams = typeof userSuggestions === \"undefined\" ? void 0 : {\n    initialPage: userSuggestionsSafeValues.initialPage,\n    pageSize: userSuggestionsSafeValues.pageSize,\n    status: userSuggestionsSafeValues.status\n  };\n  const isClerkLoaded = !!(clerk.loaded && user);\n  const memberships = usePagesOrInfinite(\n    userMembershipsParams || {},\n    user?.getOrganizationMemberships,\n    {\n      keepPreviousData: userMembershipsSafeValues.keepPreviousData,\n      infinite: userMembershipsSafeValues.infinite,\n      enabled: !!userMembershipsParams\n    },\n    {\n      type: \"userMemberships\",\n      userId: user?.id\n    }\n  );\n  const invitations = usePagesOrInfinite(\n    {\n      ...userInvitationsParams\n    },\n    user?.getOrganizationInvitations,\n    {\n      keepPreviousData: userInvitationsSafeValues.keepPreviousData,\n      infinite: userInvitationsSafeValues.infinite,\n      enabled: !!userInvitationsParams\n    },\n    {\n      type: \"userInvitations\",\n      userId: user?.id\n    }\n  );\n  const suggestions = usePagesOrInfinite(\n    {\n      ...userSuggestionsParams\n    },\n    user?.getOrganizationSuggestions,\n    {\n      keepPreviousData: userSuggestionsSafeValues.keepPreviousData,\n      infinite: userSuggestionsSafeValues.infinite,\n      enabled: !!userSuggestionsParams\n    },\n    {\n      type: \"userSuggestions\",\n      userId: user?.id\n    }\n  );\n  if (!isClerkLoaded) {\n    return {\n      isLoaded: false,\n      createOrganization: void 0,\n      setActive: void 0,\n      userMemberships: undefinedPaginatedResource2,\n      userInvitations: undefinedPaginatedResource2,\n      userSuggestions: undefinedPaginatedResource2\n    };\n  }\n  return {\n    isLoaded: isClerkLoaded,\n    setActive: clerk.setActive,\n    createOrganization: clerk.createOrganization,\n    userMemberships: memberships,\n    userInvitations: invitations,\n    userSuggestions: suggestions\n  };\n}\n\n// src/react/hooks/useSafeLayoutEffect.tsx\n\nvar useSafeLayoutEffect = typeof window !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_13__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_13__.useEffect;\n\n// src/react/hooks/useSession.ts\nvar hookName = `useSession`;\nvar useSession = () => {\n  useAssertWrappedByClerkProvider(hookName);\n  const session = useSessionContext();\n  const clerk = useClerkInstanceContext();\n  clerk.telemetry?.record((0,_chunk_RUA3ZE6A_mjs__WEBPACK_IMPORTED_MODULE_0__.eventMethodCalled)(hookName));\n  if (session === void 0) {\n    return { isLoaded: false, isSignedIn: void 0, session: void 0 };\n  }\n  if (session === null) {\n    return { isLoaded: true, isSignedIn: false, session: null };\n  }\n  return { isLoaded: true, isSignedIn: clerk.isSignedIn, session };\n};\n\n// src/react/hooks/useSessionList.ts\nvar hookName2 = \"useSessionList\";\nvar useSessionList = () => {\n  useAssertWrappedByClerkProvider(hookName2);\n  const isomorphicClerk = useClerkInstanceContext();\n  const client = useClientContext();\n  const clerk = useClerkInstanceContext();\n  clerk.telemetry?.record((0,_chunk_RUA3ZE6A_mjs__WEBPACK_IMPORTED_MODULE_0__.eventMethodCalled)(hookName2));\n  if (!client) {\n    return { isLoaded: false, sessions: void 0, setActive: void 0 };\n  }\n  return {\n    isLoaded: true,\n    sessions: client.sessions,\n    setActive: isomorphicClerk.setActive\n  };\n};\n\n// src/react/hooks/useUser.ts\nvar hookName3 = \"useUser\";\nfunction useUser() {\n  useAssertWrappedByClerkProvider(hookName3);\n  const user = useUserContext();\n  const clerk = useClerkInstanceContext();\n  clerk.telemetry?.record((0,_chunk_RUA3ZE6A_mjs__WEBPACK_IMPORTED_MODULE_0__.eventMethodCalled)(hookName3));\n  if (user === void 0) {\n    return { isLoaded: false, isSignedIn: void 0, user: void 0 };\n  }\n  if (user === null) {\n    return { isLoaded: true, isSignedIn: false, user: null };\n  }\n  return { isLoaded: true, isSignedIn: true, user };\n}\n\n// src/react/hooks/useClerk.ts\nvar useClerk = () => {\n  useAssertWrappedByClerkProvider(\"useClerk\");\n  return useClerkInstanceContext();\n};\n\n// src/react/hooks/useDeepEqualMemo.ts\n\n\nvar useDeepEqualMemoize = (value) => {\n  const ref = react__WEBPACK_IMPORTED_MODULE_13__.useRef(value);\n  if (!(0,dequal__WEBPACK_IMPORTED_MODULE_16__.dequal)(value, ref.current)) {\n    ref.current = value;\n  }\n  return react__WEBPACK_IMPORTED_MODULE_13__.useMemo(() => ref.current, [ref.current]);\n};\nvar useDeepEqualMemo = (factory, dependencyArray) => {\n  return react__WEBPACK_IMPORTED_MODULE_13__.useMemo(factory, useDeepEqualMemoize(dependencyArray));\n};\nvar isDeeplyEqual = dequal__WEBPACK_IMPORTED_MODULE_16__.dequal;\n\n// src/react/hooks/useReverification.ts\n\nvar CLERK_API_REVERIFICATION_ERROR_CODE = \"session_reverification_required\";\nasync function resolveResult(result) {\n  try {\n    const r = await result;\n    if (r instanceof Response) {\n      return r.json();\n    }\n    return r;\n  } catch (e) {\n    if ((0,_chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_5__.isClerkAPIResponseError)(e) && e.errors.find(({ code }) => code === CLERK_API_REVERIFICATION_ERROR_CODE)) {\n      return (0,_chunk_43A5F2IE_mjs__WEBPACK_IMPORTED_MODULE_10__.reverificationError)();\n    }\n    throw e;\n  }\n}\nfunction createReverificationHandler(params) {\n  function assertReverification(fetcher) {\n    return async (...args) => {\n      let result = await resolveResult(fetcher(...args));\n      if ((0,_chunk_43A5F2IE_mjs__WEBPACK_IMPORTED_MODULE_10__.isReverificationHint)(result)) {\n        const resolvers = (0,_chunk_7QJ2QTJL_mjs__WEBPACK_IMPORTED_MODULE_2__.createDeferredPromise)();\n        const isValidMetadata = (0,_chunk_3CN5LOSN_mjs__WEBPACK_IMPORTED_MODULE_11__.validateReverificationConfig)(result.clerk_error.metadata?.reverification);\n        const level = isValidMetadata ? isValidMetadata().level : void 0;\n        const cancel = () => {\n          resolvers.reject(\n            new _chunk_AXHU6TXE_mjs__WEBPACK_IMPORTED_MODULE_5__.ClerkRuntimeError(\"User cancelled attempted verification\", {\n              code: \"reverification_cancelled\"\n            })\n          );\n        };\n        const complete = () => {\n          resolvers.resolve(true);\n        };\n        if (params.onNeedsReverification === void 0) {\n          params.openUIComponent?.({\n            level,\n            afterVerification: complete,\n            afterVerificationCancelled: cancel\n          });\n        } else {\n          params.onNeedsReverification({\n            cancel,\n            complete,\n            level\n          });\n        }\n        await resolvers.promise;\n        result = await resolveResult(fetcher(...args));\n      }\n      return result;\n    };\n  }\n  return assertReverification;\n}\nvar useReverification = (fetcher, options) => {\n  const { __internal_openReverification, telemetry } = useClerk();\n  const fetcherRef = (0,react__WEBPACK_IMPORTED_MODULE_13__.useRef)(fetcher);\n  const optionsRef = (0,react__WEBPACK_IMPORTED_MODULE_13__.useRef)(options);\n  telemetry?.record(\n    (0,_chunk_RUA3ZE6A_mjs__WEBPACK_IMPORTED_MODULE_0__.eventMethodCalled)(\"useReverification\", {\n      onNeedsReverification: Boolean(options?.onNeedsReverification)\n    })\n  );\n  useSafeLayoutEffect(() => {\n    fetcherRef.current = fetcher;\n    optionsRef.current = options;\n  });\n  return (0,react__WEBPACK_IMPORTED_MODULE_13__.useCallback)(\n    (...args) => {\n      const handler = createReverificationHandler({\n        openUIComponent: __internal_openReverification,\n        telemetry,\n        ...optionsRef.current\n      })(fetcherRef.current);\n      return handler(...args);\n    },\n    [__internal_openReverification, telemetry]\n  );\n};\n\n// src/react/hooks/createBillingPaginatedHook.tsx\nfunction createBillingPaginatedHook({\n  hookName: hookName5,\n  resourceType,\n  useFetcher,\n  options\n}) {\n  return function useBillingHook(params) {\n    const { for: _for, ...paginationParams } = params || {};\n    useAssertWrappedByClerkProvider(hookName5);\n    const fetchFn = useFetcher(_for || \"user\");\n    const safeValues = useWithSafeValues(paginationParams, {\n      initialPage: 1,\n      pageSize: 10,\n      keepPreviousData: false,\n      infinite: false,\n      __experimental_mode: void 0\n    });\n    const clerk = useClerkInstanceContext();\n    const environment = clerk.__unstable__environment;\n    const user = useUserContext();\n    const { organization } = useOrganizationContext();\n    clerk.telemetry?.record((0,_chunk_RUA3ZE6A_mjs__WEBPACK_IMPORTED_MODULE_0__.eventMethodCalled)(hookName5));\n    const hookParams = typeof paginationParams === \"undefined\" ? void 0 : {\n      initialPage: safeValues.initialPage,\n      pageSize: safeValues.pageSize,\n      ...options?.unauthenticated ? {} : _for === \"organization\" ? { orgId: organization?.id } : {}\n    };\n    const isOrganization = _for === \"organization\";\n    const billingEnabled = isOrganization ? environment?.commerceSettings.billing.organization.enabled : environment?.commerceSettings.billing.user.enabled;\n    const isEnabled = !!hookParams && clerk.loaded && !!billingEnabled;\n    const result = usePagesOrInfinite(\n      hookParams || {},\n      fetchFn,\n      {\n        keepPreviousData: safeValues.keepPreviousData,\n        infinite: safeValues.infinite,\n        enabled: isEnabled,\n        ...options?.unauthenticated ? {} : { isSignedIn: Boolean(user) },\n        __experimental_mode: safeValues.__experimental_mode\n      },\n      {\n        type: resourceType,\n        // userId: user?.id,\n        ...options?.unauthenticated ? {} : {\n          userId: user?.id,\n          ..._for === \"organization\" ? { orgId: organization?.id } : {}\n        }\n      }\n    );\n    return result;\n  };\n}\n\n// src/react/hooks/useStatements.tsx\nvar useStatements = createBillingPaginatedHook({\n  hookName: \"useStatements\",\n  resourceType: \"billing-statements\",\n  useFetcher: () => {\n    const clerk = useClerkInstanceContext();\n    if (clerk.loaded) {\n      return clerk.billing.getStatements;\n    }\n    return void 0;\n  }\n});\n\n// src/react/hooks/usePaymentAttempts.tsx\nvar usePaymentAttempts = createBillingPaginatedHook({\n  hookName: \"usePaymentAttempts\",\n  resourceType: \"billing-payment-attempts\",\n  useFetcher: () => {\n    const clerk = useClerkInstanceContext();\n    if (clerk.loaded) {\n      return clerk.billing.getPaymentAttempts;\n    }\n    return void 0;\n  }\n});\n\n// src/react/hooks/usePaymentMethods.tsx\nvar usePaymentMethods = createBillingPaginatedHook({\n  hookName: \"usePaymentMethods\",\n  resourceType: \"commerce-payment-methods\",\n  useFetcher: (resource) => {\n    const { organization } = useOrganizationContext();\n    const user = useUserContext();\n    if (resource === \"organization\") {\n      return organization?.getPaymentMethods;\n    }\n    return user?.getPaymentMethods;\n  }\n});\n\n// src/react/hooks/usePlans.tsx\nvar usePlans = createBillingPaginatedHook({\n  hookName: \"usePlans\",\n  resourceType: \"billing-plans\",\n  useFetcher: (_for) => {\n    const clerk = useClerkInstanceContext();\n    if (!clerk.loaded) {\n      return void 0;\n    }\n    return (params) => clerk.billing.getPlans({ ...params, for: _for });\n  },\n  options: {\n    unauthenticated: true\n  }\n});\n\n// src/react/hooks/useSubscription.tsx\n\nvar hookName4 = \"useSubscription\";\nvar useSubscription = (params) => {\n  useAssertWrappedByClerkProvider(hookName4);\n  const clerk = useClerkInstanceContext();\n  const user = useUserContext();\n  const { organization } = useOrganizationContext();\n  const environment = clerk.__unstable__environment;\n  clerk.telemetry?.record((0,_chunk_RUA3ZE6A_mjs__WEBPACK_IMPORTED_MODULE_0__.eventMethodCalled)(hookName4));\n  const isOrganization = params?.for === \"organization\";\n  const billingEnabled = isOrganization ? environment?.commerceSettings.billing.organization.enabled : environment?.commerceSettings.billing.user.enabled;\n  const swr = (0,swr__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(\n    billingEnabled ? {\n      type: \"commerce-subscription\",\n      userId: user?.id,\n      args: { orgId: isOrganization ? organization?.id : void 0 }\n    } : null,\n    ({ args, userId }) => {\n      if (userId) {\n        return clerk.billing.getSubscription(args);\n      }\n      return null;\n    },\n    {\n      dedupingInterval: 1e3 * 60,\n      keepPreviousData: params?.keepPreviousData\n    }\n  );\n  const revalidate = (0,react__WEBPACK_IMPORTED_MODULE_13__.useCallback)(() => swr.mutate(), [swr.mutate]);\n  return {\n    data: swr.data,\n    error: swr.error,\n    isLoading: swr.isLoading,\n    isFetching: swr.isValidating,\n    revalidate\n  };\n};\n\n// src/react/hooks/useCheckout.ts\n\nvar useCheckout = (options) => {\n  const contextOptions = useCheckoutContext();\n  const { for: forOrganization, planId, planPeriod } = options || contextOptions;\n  const clerk = useClerk();\n  const { organization } = useOrganization();\n  const { isLoaded, user } = useUser();\n  if (!isLoaded) {\n    throw new Error(\"Clerk: Ensure that `useCheckout` is inside a component wrapped with `<ClerkLoaded />`.\");\n  }\n  if (!user) {\n    throw new Error(\"Clerk: Ensure that `useCheckout` is inside a component wrapped with `<SignedIn />`.\");\n  }\n  if (forOrganization === \"organization\" && !organization) {\n    throw new Error(\n      \"Clerk: Ensure your flow checks for an active organization. Retrieve `orgId` from `useAuth()` and confirm it is defined. For SSR, see: https://clerk.com/docs/reference/backend/types/auth-object#how-to-access-the-auth-object\"\n    );\n  }\n  const manager = (0,react__WEBPACK_IMPORTED_MODULE_13__.useMemo)(\n    () => clerk.__experimental_checkout({ planId, planPeriod, for: forOrganization }),\n    [user.id, organization?.id, planId, planPeriod, forOrganization]\n  );\n  const managerProperties = (0,react__WEBPACK_IMPORTED_MODULE_13__.useSyncExternalStore)(\n    (cb) => manager.subscribe(cb),\n    () => manager.getState(),\n    () => manager.getState()\n  );\n  const properties = (0,react__WEBPACK_IMPORTED_MODULE_13__.useMemo)(() => {\n    if (!managerProperties.checkout) {\n      return {\n        id: null,\n        externalClientSecret: null,\n        externalGatewayId: null,\n        status: null,\n        totals: null,\n        isImmediatePlanChange: null,\n        planPeriod: null,\n        plan: null,\n        paymentMethod: null,\n        freeTrialEndsAt: null,\n        payer: null\n      };\n    }\n    const {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      reload,\n      confirm,\n      pathRoot,\n      // All the above need to be removed from the properties\n      ...rest\n    } = managerProperties.checkout;\n    return rest;\n  }, [managerProperties.checkout]);\n  const checkout = {\n    ...properties,\n    getState: manager.getState,\n    start: manager.start,\n    confirm: manager.confirm,\n    clear: manager.clear,\n    finalize: manager.finalize,\n    isStarting: managerProperties.isStarting,\n    isConfirming: managerProperties.isConfirming,\n    error: managerProperties.error,\n    status: managerProperties.status,\n    fetchStatus: managerProperties.fetchStatus\n  };\n  return {\n    checkout\n  };\n};\n\n// src/react/commerce.tsx\n\n\n\n\n// src/react/stripe-react/index.tsx\n\n\n// src/react/stripe-react/utils.ts\n\nvar usePrevious = (value) => {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_13__.useRef)(value);\n  (0,react__WEBPACK_IMPORTED_MODULE_13__.useEffect)(() => {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n};\nvar useAttachEvent = (element, event, cb) => {\n  const cbDefined = !!cb;\n  const cbRef = (0,react__WEBPACK_IMPORTED_MODULE_13__.useRef)(cb);\n  (0,react__WEBPACK_IMPORTED_MODULE_13__.useEffect)(() => {\n    cbRef.current = cb;\n  }, [cb]);\n  (0,react__WEBPACK_IMPORTED_MODULE_13__.useEffect)(() => {\n    if (!cbDefined || !element) {\n      return () => {\n      };\n    }\n    const decoratedCb = (...args) => {\n      if (cbRef.current) {\n        cbRef.current(...args);\n      }\n    };\n    element.on(event, decoratedCb);\n    return () => {\n      element.off(event, decoratedCb);\n    };\n  }, [cbDefined, event, element, cbRef]);\n};\n\n// src/react/stripe-react/index.tsx\nvar ElementsContext = react__WEBPACK_IMPORTED_MODULE_13__.createContext(null);\nElementsContext.displayName = \"ElementsContext\";\nvar parseElementsContext = (ctx, useCase) => {\n  if (!ctx) {\n    throw new Error(\n      `Could not find Elements context; You need to wrap the part of your app that ${useCase} in an <Elements> provider.`\n    );\n  }\n  return ctx;\n};\nvar Elements = ({\n  stripe: rawStripeProp,\n  options,\n  children\n}) => {\n  const parsed = react__WEBPACK_IMPORTED_MODULE_13__.useMemo(() => parseStripeProp(rawStripeProp), [rawStripeProp]);\n  const [ctx, setContext] = react__WEBPACK_IMPORTED_MODULE_13__.useState(() => ({\n    stripe: parsed.tag === \"sync\" ? parsed.stripe : null,\n    elements: parsed.tag === \"sync\" ? parsed.stripe.elements(options) : null\n  }));\n  react__WEBPACK_IMPORTED_MODULE_13__.useEffect(() => {\n    let isMounted = true;\n    const safeSetContext = (stripe) => {\n      setContext((ctx2) => {\n        if (ctx2.stripe) {\n          return ctx2;\n        }\n        return {\n          stripe,\n          elements: stripe.elements(options)\n        };\n      });\n    };\n    if (parsed.tag === \"async\" && !ctx.stripe) {\n      parsed.stripePromise.then((stripe) => {\n        if (stripe && isMounted) {\n          safeSetContext(stripe);\n        }\n      });\n    } else if (parsed.tag === \"sync\" && !ctx.stripe) {\n      safeSetContext(parsed.stripe);\n    }\n    return () => {\n      isMounted = false;\n    };\n  }, [parsed, ctx, options]);\n  const prevStripe = usePrevious(rawStripeProp);\n  react__WEBPACK_IMPORTED_MODULE_13__.useEffect(() => {\n    if (prevStripe !== null && prevStripe !== rawStripeProp) {\n      console.warn(\"Unsupported prop change on Elements: You cannot change the `stripe` prop after setting it.\");\n    }\n  }, [prevStripe, rawStripeProp]);\n  const prevOptions = usePrevious(options);\n  react__WEBPACK_IMPORTED_MODULE_13__.useEffect(() => {\n    if (!ctx.elements) {\n      return;\n    }\n    const updates = extractAllowedOptionsUpdates(options, prevOptions, [\"clientSecret\", \"fonts\"]);\n    if (updates) {\n      ctx.elements.update(updates);\n    }\n  }, [options, prevOptions, ctx.elements]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_13__.createElement(ElementsContext.Provider, { value: ctx }, children);\n};\nvar useElementsContextWithUseCase = (useCaseMessage) => {\n  const ctx = react__WEBPACK_IMPORTED_MODULE_13__.useContext(ElementsContext);\n  return parseElementsContext(ctx, useCaseMessage);\n};\nvar useElements = () => {\n  const { elements } = useElementsContextWithUseCase(\"calls useElements()\");\n  return elements;\n};\nvar INVALID_STRIPE_ERROR = \"Invalid prop `stripe` supplied to `Elements`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.\";\nvar validateStripe = (maybeStripe, errorMsg = INVALID_STRIPE_ERROR) => {\n  if (maybeStripe === null || isStripe(maybeStripe)) {\n    return maybeStripe;\n  }\n  throw new Error(errorMsg);\n};\nvar parseStripeProp = (raw, errorMsg = INVALID_STRIPE_ERROR) => {\n  if (isPromise(raw)) {\n    return {\n      tag: \"async\",\n      stripePromise: Promise.resolve(raw).then((result) => validateStripe(result, errorMsg))\n    };\n  }\n  const stripe = validateStripe(raw, errorMsg);\n  if (stripe === null) {\n    return { tag: \"empty\" };\n  }\n  return { tag: \"sync\", stripe };\n};\nvar isUnknownObject = (raw) => {\n  return raw !== null && typeof raw === \"object\";\n};\nvar isPromise = (raw) => {\n  return isUnknownObject(raw) && typeof raw.then === \"function\";\n};\nvar isStripe = (raw) => {\n  return isUnknownObject(raw) && typeof raw.elements === \"function\" && typeof raw.createToken === \"function\" && typeof raw.createPaymentMethod === \"function\" && typeof raw.confirmCardPayment === \"function\";\n};\nvar extractAllowedOptionsUpdates = (options, prevOptions, immutableKeys) => {\n  if (!isUnknownObject(options)) {\n    return null;\n  }\n  return Object.keys(options).reduce((newOptions, key) => {\n    const isUpdated = !isUnknownObject(prevOptions) || !isEqual(options[key], prevOptions[key]);\n    if (immutableKeys.includes(key)) {\n      if (isUpdated) {\n        console.warn(`Unsupported prop change: options.${key} is not a mutable property.`);\n      }\n      return newOptions;\n    }\n    if (!isUpdated) {\n      return newOptions;\n    }\n    return { ...newOptions || {}, [key]: options[key] };\n  }, null);\n};\nvar PLAIN_OBJECT_STR = \"[object Object]\";\nvar isEqual = (left, right) => {\n  if (!isUnknownObject(left) || !isUnknownObject(right)) {\n    return left === right;\n  }\n  const leftArray = Array.isArray(left);\n  const rightArray = Array.isArray(right);\n  if (leftArray !== rightArray) {\n    return false;\n  }\n  const leftPlainObject = Object.prototype.toString.call(left) === PLAIN_OBJECT_STR;\n  const rightPlainObject = Object.prototype.toString.call(right) === PLAIN_OBJECT_STR;\n  if (leftPlainObject !== rightPlainObject) {\n    return false;\n  }\n  if (!leftPlainObject && !leftArray) {\n    return left === right;\n  }\n  const leftKeys = Object.keys(left);\n  const rightKeys = Object.keys(right);\n  if (leftKeys.length !== rightKeys.length) {\n    return false;\n  }\n  const keySet = {};\n  for (let i = 0; i < leftKeys.length; i += 1) {\n    keySet[leftKeys[i]] = true;\n  }\n  for (let i = 0; i < rightKeys.length; i += 1) {\n    keySet[rightKeys[i]] = true;\n  }\n  const allKeys = Object.keys(keySet);\n  if (allKeys.length !== leftKeys.length) {\n    return false;\n  }\n  const l = left;\n  const r = right;\n  const pred = (key) => {\n    return isEqual(l[key], r[key]);\n  };\n  return allKeys.every(pred);\n};\nvar useStripe = () => {\n  const { stripe } = useElementsOrCheckoutSdkContextWithUseCase(\"calls useStripe()\");\n  return stripe;\n};\nvar useElementsOrCheckoutSdkContextWithUseCase = (useCaseString) => {\n  const elementsContext = react__WEBPACK_IMPORTED_MODULE_13__.useContext(ElementsContext);\n  return parseElementsContext(elementsContext, useCaseString);\n};\nvar capitalized = (str) => str.charAt(0).toUpperCase() + str.slice(1);\nvar createElementComponent = (type, isServer2) => {\n  const displayName = `${capitalized(type)}Element`;\n  const ClientElement = ({\n    id,\n    className,\n    fallback,\n    options = {},\n    onBlur,\n    onFocus,\n    onReady,\n    onChange,\n    onEscape,\n    onClick,\n    onLoadError,\n    onLoaderStart,\n    onNetworksChange,\n    onConfirm,\n    onCancel,\n    onShippingAddressChange,\n    onShippingRateChange\n  }) => {\n    const ctx = useElementsOrCheckoutSdkContextWithUseCase(`mounts <${displayName}>`);\n    const elements = \"elements\" in ctx ? ctx.elements : null;\n    const [element, setElement] = react__WEBPACK_IMPORTED_MODULE_13__.useState(null);\n    const elementRef = react__WEBPACK_IMPORTED_MODULE_13__.useRef(null);\n    const domNode = react__WEBPACK_IMPORTED_MODULE_13__.useRef(null);\n    const [isReady, setReady] = (0,react__WEBPACK_IMPORTED_MODULE_13__.useState)(false);\n    useAttachEvent(element, \"blur\", onBlur);\n    useAttachEvent(element, \"focus\", onFocus);\n    useAttachEvent(element, \"escape\", onEscape);\n    useAttachEvent(element, \"click\", onClick);\n    useAttachEvent(element, \"loaderror\", onLoadError);\n    useAttachEvent(element, \"loaderstart\", onLoaderStart);\n    useAttachEvent(element, \"networkschange\", onNetworksChange);\n    useAttachEvent(element, \"confirm\", onConfirm);\n    useAttachEvent(element, \"cancel\", onCancel);\n    useAttachEvent(element, \"shippingaddresschange\", onShippingAddressChange);\n    useAttachEvent(element, \"shippingratechange\", onShippingRateChange);\n    useAttachEvent(element, \"change\", onChange);\n    let readyCallback;\n    if (onReady) {\n      readyCallback = () => {\n        setReady(true);\n        onReady(element);\n      };\n    }\n    useAttachEvent(element, \"ready\", readyCallback);\n    react__WEBPACK_IMPORTED_MODULE_13__.useLayoutEffect(() => {\n      if (elementRef.current === null && domNode.current !== null && elements) {\n        let newElement = null;\n        if (elements) {\n          newElement = elements.create(type, options);\n        }\n        elementRef.current = newElement;\n        setElement(newElement);\n        if (newElement) {\n          newElement.mount(domNode.current);\n        }\n      }\n    }, [elements, options]);\n    const prevOptions = usePrevious(options);\n    react__WEBPACK_IMPORTED_MODULE_13__.useEffect(() => {\n      if (!elementRef.current) {\n        return;\n      }\n      const updates = extractAllowedOptionsUpdates(options, prevOptions, [\"paymentRequest\"]);\n      if (updates && \"update\" in elementRef.current) {\n        elementRef.current.update(updates);\n      }\n    }, [options, prevOptions]);\n    react__WEBPACK_IMPORTED_MODULE_13__.useLayoutEffect(() => {\n      return () => {\n        if (elementRef.current && typeof elementRef.current.destroy === \"function\") {\n          try {\n            elementRef.current.destroy();\n            elementRef.current = null;\n          } catch {\n          }\n        }\n      };\n    }, []);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_13__.createElement(react__WEBPACK_IMPORTED_MODULE_13__.Fragment, null, !isReady && fallback, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_13__.createElement(\n      \"div\",\n      {\n        id,\n        style: {\n          height: isReady ? \"unset\" : \"0px\",\n          visibility: isReady ? \"visible\" : \"hidden\"\n        },\n        className,\n        ref: domNode\n      }\n    ));\n  };\n  const ServerElement = (props) => {\n    useElementsOrCheckoutSdkContextWithUseCase(`mounts <${displayName}>`);\n    const { id, className } = props;\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_13__.createElement(\n      \"div\",\n      {\n        id,\n        className\n      }\n    );\n  };\n  const Element = isServer2 ? ServerElement : ClientElement;\n  Element.displayName = displayName;\n  Element.__elementType = type;\n  return Element;\n};\nvar isServer = typeof window === \"undefined\";\nvar PaymentElement = createElementComponent(\"payment\", isServer);\n\n// src/react/commerce.tsx\nvar [StripeLibsContext, useStripeLibsContext] = createContextAndHook(\"StripeLibsContext\");\nvar StripeLibsProvider = ({ children }) => {\n  const clerk = useClerk();\n  const { data: stripeClerkLibs } = (0,swr__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(\n    \"clerk-stripe-sdk\",\n    async () => {\n      const loadStripe = await clerk.__internal_loadStripeJs();\n      return { loadStripe };\n    },\n    {\n      keepPreviousData: true,\n      revalidateOnFocus: false,\n      dedupingInterval: Infinity\n    }\n  );\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_13__.createElement(\n    StripeLibsContext.Provider,\n    {\n      value: {\n        value: stripeClerkLibs || null\n      }\n    },\n    children\n  );\n};\nvar useInternalEnvironment = () => {\n  const clerk = useClerk();\n  return clerk.__unstable__environment;\n};\nvar usePaymentSourceUtils = (forResource = \"user\") => {\n  const { organization } = useOrganization();\n  const { user } = useUser();\n  const resource = forResource === \"organization\" ? organization : user;\n  const stripeClerkLibs = useStripeLibsContext();\n  const { data: initializedPaymentMethod, trigger: initializePaymentMethod } = (0,swr_mutation__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(\n    {\n      key: \"billing-payment-method-initialize\",\n      resourceId: resource?.id\n    },\n    () => {\n      return resource?.initializePaymentMethod({\n        gateway: \"stripe\"\n      });\n    }\n  );\n  const environment = useInternalEnvironment();\n  (0,react__WEBPACK_IMPORTED_MODULE_13__.useEffect)(() => {\n    if (!resource?.id) {\n      return;\n    }\n    initializePaymentMethod().catch(() => {\n    });\n  }, [resource?.id]);\n  const externalGatewayId = initializedPaymentMethod?.externalGatewayId;\n  const externalClientSecret = initializedPaymentMethod?.externalClientSecret;\n  const paymentMethodOrder = initializedPaymentMethod?.paymentMethodOrder;\n  const stripePublishableKey = environment?.commerceSettings.billing.stripePublishableKey;\n  const { data: stripe } = (0,swr__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(\n    stripeClerkLibs && externalGatewayId && stripePublishableKey ? { key: \"stripe-sdk\", externalGatewayId, stripePublishableKey } : null,\n    ({ stripePublishableKey: stripePublishableKey2, externalGatewayId: externalGatewayId2 }) => {\n      return stripeClerkLibs?.loadStripe(stripePublishableKey2, {\n        stripeAccount: externalGatewayId2\n      });\n    },\n    {\n      keepPreviousData: true,\n      revalidateOnFocus: false,\n      dedupingInterval: 1e3 * 60\n      // 1 minute\n    }\n  );\n  return {\n    stripe,\n    initializePaymentMethod,\n    externalClientSecret,\n    paymentMethodOrder\n  };\n};\nvar [PaymentElementContext, usePaymentElementContext] = createContextAndHook(\"PaymentElementContext\");\nvar [StripeUtilsContext, useStripeUtilsContext] = createContextAndHook(\"StripeUtilsContext\");\nvar ValidateStripeUtils = ({ children }) => {\n  const stripe = useStripe();\n  const elements = useElements();\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_13__.createElement(StripeUtilsContext.Provider, { value: { value: { stripe, elements } } }, children);\n};\nvar DummyStripeUtils = ({ children }) => {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_13__.createElement(StripeUtilsContext.Provider, { value: { value: {} } }, children);\n};\nvar PropsProvider = ({ children, ...props }) => {\n  const utils = usePaymentSourceUtils(props.for);\n  const [isPaymentElementReady, setIsPaymentElementReady] = (0,react__WEBPACK_IMPORTED_MODULE_13__.useState)(false);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_13__.createElement(\n    PaymentElementContext.Provider,\n    {\n      value: {\n        value: {\n          ...props,\n          ...utils,\n          setIsPaymentElementReady,\n          isPaymentElementReady\n        }\n      }\n    },\n    children\n  );\n};\nvar PaymentElementProvider = ({ children, ...props }) => {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_13__.createElement(StripeLibsProvider, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_13__.createElement(PropsProvider, { ...props }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_13__.createElement(PaymentElementInternalRoot, null, children)));\n};\nvar PaymentElementInternalRoot = (props) => {\n  const { stripe, externalClientSecret, stripeAppearance } = usePaymentElementContext();\n  if (stripe && externalClientSecret) {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_13__.createElement(\n      Elements,\n      {\n        key: externalClientSecret,\n        stripe,\n        options: {\n          loader: \"never\",\n          clientSecret: externalClientSecret,\n          appearance: {\n            variables: stripeAppearance\n          }\n        }\n      },\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_13__.createElement(ValidateStripeUtils, null, props.children)\n    );\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_13__.createElement(DummyStripeUtils, null, props.children);\n};\nvar PaymentElement2 = ({ fallback }) => {\n  const {\n    setIsPaymentElementReady,\n    paymentMethodOrder,\n    checkout,\n    stripe,\n    externalClientSecret,\n    paymentDescription,\n    for: _for\n  } = usePaymentElementContext();\n  const environment = useInternalEnvironment();\n  const applePay = (0,react__WEBPACK_IMPORTED_MODULE_13__.useMemo)(() => {\n    if (!checkout || !checkout.totals || !checkout.plan) {\n      return void 0;\n    }\n    return {\n      recurringPaymentRequest: {\n        paymentDescription: paymentDescription || \"\",\n        managementURL: _for === \"organization\" ? environment?.displayConfig.organizationProfileUrl || \"\" : environment?.displayConfig.userProfileUrl || \"\",\n        regularBilling: {\n          amount: checkout.totals.totalDueNow?.amount || checkout.totals.grandTotal.amount,\n          label: checkout.plan.name,\n          recurringPaymentIntervalUnit: checkout.planPeriod === \"annual\" ? \"year\" : \"month\"\n        }\n      }\n    };\n  }, [checkout, paymentDescription, _for, environment]);\n  const options = (0,react__WEBPACK_IMPORTED_MODULE_13__.useMemo)(() => {\n    return {\n      layout: {\n        type: \"tabs\",\n        defaultCollapsed: false\n      },\n      paymentMethodOrder,\n      applePay\n    };\n  }, [applePay, paymentMethodOrder]);\n  const onReady = (0,react__WEBPACK_IMPORTED_MODULE_13__.useCallback)(() => {\n    setIsPaymentElementReady(true);\n  }, [setIsPaymentElementReady]);\n  if (!stripe || !externalClientSecret) {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_13__.createElement(react__WEBPACK_IMPORTED_MODULE_13__.Fragment, null, fallback);\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_13__.createElement(\n    PaymentElement,\n    {\n      fallback,\n      onReady,\n      options\n    }\n  );\n};\nvar throwLibsMissingError = () => {\n  throw new Error(\n    \"Clerk: Unable to submit, Stripe libraries are not yet loaded. Be sure to check `isFormReady` before calling `submit`.\"\n  );\n};\nvar usePaymentElement = () => {\n  const { isPaymentElementReady, initializePaymentMethod } = usePaymentElementContext();\n  const { stripe, elements } = useStripeUtilsContext();\n  const { externalClientSecret } = usePaymentElementContext();\n  const submit = (0,react__WEBPACK_IMPORTED_MODULE_13__.useCallback)(async () => {\n    if (!stripe || !elements) {\n      return throwLibsMissingError();\n    }\n    const { setupIntent, error } = await stripe.confirmSetup({\n      elements,\n      confirmParams: {\n        return_url: window.location.href\n      },\n      redirect: \"if_required\"\n    });\n    if (error) {\n      return {\n        data: null,\n        error: {\n          gateway: \"stripe\",\n          error: {\n            code: error.code,\n            message: error.message,\n            type: error.type\n          }\n        }\n      };\n    }\n    return {\n      data: { gateway: \"stripe\", paymentToken: setupIntent.payment_method },\n      error: null\n    };\n  }, [stripe, elements]);\n  const reset = (0,react__WEBPACK_IMPORTED_MODULE_13__.useCallback)(async () => {\n    if (!stripe || !elements) {\n      return throwLibsMissingError();\n    }\n    await initializePaymentMethod();\n  }, [stripe, elements, initializePaymentMethod]);\n  const isProviderReady = Boolean(stripe && externalClientSecret);\n  if (!isProviderReady) {\n    return {\n      submit: throwLibsMissingError,\n      reset: throwLibsMissingError,\n      isFormReady: false,\n      provider: void 0,\n      isProviderReady: false\n    };\n  }\n  return {\n    submit,\n    reset,\n    isFormReady: isPaymentElementReady,\n    provider: {\n      name: \"stripe\"\n    },\n    isProviderReady\n  };\n};\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvcmVhY3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRStCO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQUlBOztBQUUvQjtBQUMwQjtBQUMxQjtBQUNBO0FBQ0EsNEVBQTRFLHNCQUFzQjtBQUNsRztBQUNBO0FBQ0E7QUFDQSxVQUFVLG9DQUFvQztBQUM5QyxjQUFjLGlEQUFtQjtBQUNqQztBQUNBO0FBQ0EsZ0JBQWdCLDhDQUFnQjtBQUNoQyx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzJCOztBQUUzQjtBQUNBO0FBQ0EsOERBQVE7QUFDUixnQkFBZ0IsNENBQVE7QUFDeEIsd0JBQXdCLHFEQUFRO0FBQ2hDLENBQUM7QUFDRCxnRUFBVSxvQkFBb0IsaUNBQVE7QUFDTjtBQUNVO0FBQ1M7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlEQUFvQixHQUFHO0FBQzVDO0FBQ0EseUNBQXlDLG1CQUFtQjtBQUM1RCx5QkFBeUIsaURBQW9CLDZCQUE2QixTQUFTLGVBQWU7QUFDbEc7QUFDQTtBQUNBLGtCQUFrQiw4Q0FBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUJBQXlCLGlEQUFvQixnQ0FBZ0Msa0JBQWtCLGtCQUFrQixpREFBb0I7QUFDckk7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4Q0FBaUI7QUFDL0I7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQkFBa0IsK0NBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtCQUFrQixtREFBWTtBQUM5QjtBQUNBLEdBQUc7QUFDSDtBQUNBLDJCQUEyQixpREFBb0IsQ0FBQyw0Q0FBZTtBQUMvRDtBQUNBLHlCQUF5QixpREFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaURBQWlEO0FBQzNELFVBQVUsbUJBQW1CO0FBQzdCLFVBQVUsdUJBQXVCO0FBQ2pDLGlCQUFpQixtREFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkRBQTZEO0FBQzNFO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZ0JBQWdCLG1EQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQXFDRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L3JlYWN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBldmVudE1ldGhvZENhbGxlZFxufSBmcm9tIFwiLi4vY2h1bmstUlVBM1pFNkEubWpzXCI7XG5pbXBvcnQge1xuICBnZXRDdXJyZW50T3JnYW5pemF0aW9uTWVtYmVyc2hpcFxufSBmcm9tIFwiLi4vY2h1bmstSUJYS0RHU1oubWpzXCI7XG5pbXBvcnQge1xuICBjcmVhdGVEZWZlcnJlZFByb21pc2Vcbn0gZnJvbSBcIi4uL2NodW5rLTdRSjJRVEpMLm1qc1wiO1xuaW1wb3J0IFwiLi4vY2h1bmstR0dGUk1XRk8ubWpzXCI7XG5pbXBvcnQgXCIuLi9jaHVuay03Rk5YN1JXWS5tanNcIjtcbmltcG9ydCB7XG4gIENsZXJrUnVudGltZUVycm9yLFxuICBpc0NsZXJrQVBJUmVzcG9uc2VFcnJvclxufSBmcm9tIFwiLi4vY2h1bmstQVhIVTZUWEUubWpzXCI7XG5pbXBvcnQgXCIuLi9jaHVuay1JVjdCT080VS5tanNcIjtcbmltcG9ydCBcIi4uL2NodW5rLVRFVEdURUkyLm1qc1wiO1xuaW1wb3J0IFwiLi4vY2h1bmstS09IN0dUSk8ubWpzXCI7XG5pbXBvcnQgXCIuLi9jaHVuay1JNk1UU1RPRi5tanNcIjtcbmltcG9ydCB7XG4gIGlzUmV2ZXJpZmljYXRpb25IaW50LFxuICByZXZlcmlmaWNhdGlvbkVycm9yXG59IGZyb20gXCIuLi9jaHVuay00M0E1RjJJRS5tanNcIjtcbmltcG9ydCB7XG4gIHZhbGlkYXRlUmV2ZXJpZmljYXRpb25Db25maWdcbn0gZnJvbSBcIi4uL2NodW5rLTNDTjVMT1NOLm1qc1wiO1xuaW1wb3J0IHtcbiAgX19leHBvcnQsXG4gIF9fcmVFeHBvcnRcbn0gZnJvbSBcIi4uL2NodW5rLUlFUDZHR0VYLm1qc1wiO1xuXG4vLyBzcmMvcmVhY3QvaG9va3MvY3JlYXRlQ29udGV4dEFuZEhvb2sudHNcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIGFzc2VydENvbnRleHRFeGlzdHMoY29udGV4dFZhbCwgbXNnT3JDdHgpIHtcbiAgaWYgKCFjb250ZXh0VmFsKSB7XG4gICAgdGhyb3cgdHlwZW9mIG1zZ09yQ3R4ID09PSBcInN0cmluZ1wiID8gbmV3IEVycm9yKG1zZ09yQ3R4KSA6IG5ldyBFcnJvcihgJHttc2dPckN0eC5kaXNwbGF5TmFtZX0gbm90IGZvdW5kYCk7XG4gIH1cbn1cbnZhciBjcmVhdGVDb250ZXh0QW5kSG9vayA9IChkaXNwbGF5TmFtZSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCB7IGFzc2VydEN0eEZuID0gYXNzZXJ0Q29udGV4dEV4aXN0cyB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgQ3R4ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuICBDdHguZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgY29uc3QgdXNlQ3R4ID0gKCkgPT4ge1xuICAgIGNvbnN0IGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoQ3R4KTtcbiAgICBhc3NlcnRDdHhGbihjdHgsIGAke2Rpc3BsYXlOYW1lfSBub3QgZm91bmRgKTtcbiAgICByZXR1cm4gY3R4LnZhbHVlO1xuICB9O1xuICBjb25zdCB1c2VDdHhXaXRob3V0R3VhcmFudGVlID0gKCkgPT4ge1xuICAgIGNvbnN0IGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoQ3R4KTtcbiAgICByZXR1cm4gY3R4ID8gY3R4LnZhbHVlIDoge307XG4gIH07XG4gIHJldHVybiBbQ3R4LCB1c2VDdHgsIHVzZUN0eFdpdGhvdXRHdWFyYW50ZWVdO1xufTtcblxuLy8gc3JjL3JlYWN0L2NvbnRleHRzLnRzeFxuaW1wb3J0IFJlYWN0MiBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3JlYWN0L2NsZXJrLXN3ci50c1xudmFyIGNsZXJrX3N3cl9leHBvcnRzID0ge307XG5fX2V4cG9ydChjbGVya19zd3JfZXhwb3J0cywge1xuICB1c2VTV1I6ICgpID0+IGRlZmF1bHQyLFxuICB1c2VTV1JJbmZpbml0ZTogKCkgPT4gZGVmYXVsdDNcbn0pO1xuX19yZUV4cG9ydChjbGVya19zd3JfZXhwb3J0cywgc3dyX3N0YXIpO1xuaW1wb3J0ICogYXMgc3dyX3N0YXIgZnJvbSBcInN3clwiO1xuaW1wb3J0IHsgZGVmYXVsdCBhcyBkZWZhdWx0MiB9IGZyb20gXCJzd3JcIjtcbmltcG9ydCB7IGRlZmF1bHQgYXMgZGVmYXVsdDMgfSBmcm9tIFwic3dyL2luZmluaXRlXCI7XG5cbi8vIHNyYy9yZWFjdC9jb250ZXh0cy50c3hcbnZhciBbQ2xlcmtJbnN0YW5jZUNvbnRleHQsIHVzZUNsZXJrSW5zdGFuY2VDb250ZXh0XSA9IGNyZWF0ZUNvbnRleHRBbmRIb29rKFwiQ2xlcmtJbnN0YW5jZUNvbnRleHRcIik7XG52YXIgW1VzZXJDb250ZXh0LCB1c2VVc2VyQ29udGV4dF0gPSBjcmVhdGVDb250ZXh0QW5kSG9vayhcIlVzZXJDb250ZXh0XCIpO1xudmFyIFtDbGllbnRDb250ZXh0LCB1c2VDbGllbnRDb250ZXh0XSA9IGNyZWF0ZUNvbnRleHRBbmRIb29rKFwiQ2xpZW50Q29udGV4dFwiKTtcbnZhciBbU2Vzc2lvbkNvbnRleHQsIHVzZVNlc3Npb25Db250ZXh0XSA9IGNyZWF0ZUNvbnRleHRBbmRIb29rKFxuICBcIlNlc3Npb25Db250ZXh0XCJcbik7XG52YXIgT3B0aW9uc0NvbnRleHQgPSBSZWFjdDIuY3JlYXRlQ29udGV4dCh7fSk7XG52YXIgW0NoZWNrb3V0Q29udGV4dCwgdXNlQ2hlY2tvdXRDb250ZXh0XSA9IGNyZWF0ZUNvbnRleHRBbmRIb29rKFwiQ2hlY2tvdXRDb250ZXh0XCIpO1xudmFyIF9fZXhwZXJpbWVudGFsX0NoZWNrb3V0UHJvdmlkZXIgPSAoeyBjaGlsZHJlbiwgLi4ucmVzdCB9KSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoQ2hlY2tvdXRDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB7IHZhbHVlOiByZXN0IH0gfSwgY2hpbGRyZW4pO1xufTtcbmZ1bmN0aW9uIHVzZU9wdGlvbnNDb250ZXh0KCkge1xuICBjb25zdCBjb250ZXh0ID0gUmVhY3QyLnVzZUNvbnRleHQoT3B0aW9uc0NvbnRleHQpO1xuICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXNlT3B0aW9ucyBtdXN0IGJlIHVzZWQgd2l0aGluIGFuIE9wdGlvbnNDb250ZXh0XCIpO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxudmFyIFtPcmdhbml6YXRpb25Db250ZXh0SW50ZXJuYWwsIHVzZU9yZ2FuaXphdGlvbkNvbnRleHRdID0gY3JlYXRlQ29udGV4dEFuZEhvb2soXCJPcmdhbml6YXRpb25Db250ZXh0XCIpO1xudmFyIE9yZ2FuaXphdGlvblByb3ZpZGVyID0gKHtcbiAgY2hpbGRyZW4sXG4gIG9yZ2FuaXphdGlvbixcbiAgc3dyQ29uZmlnXG59KSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoY2xlcmtfc3dyX2V4cG9ydHMuU1dSQ29uZmlnLCB7IHZhbHVlOiBzd3JDb25maWcgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFxuICAgIE9yZ2FuaXphdGlvbkNvbnRleHRJbnRlcm5hbC5Qcm92aWRlcixcbiAgICB7XG4gICAgICB2YWx1ZToge1xuICAgICAgICB2YWx1ZTogeyBvcmdhbml6YXRpb24gfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2hpbGRyZW5cbiAgKSk7XG59O1xuZnVuY3Rpb24gdXNlQXNzZXJ0V3JhcHBlZEJ5Q2xlcmtQcm92aWRlcihkaXNwbGF5TmFtZU9yRm4pIHtcbiAgY29uc3QgY3R4ID0gUmVhY3QyLnVzZUNvbnRleHQoQ2xlcmtJbnN0YW5jZUNvbnRleHQpO1xuICBpZiAoIWN0eCkge1xuICAgIGlmICh0eXBlb2YgZGlzcGxheU5hbWVPckZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGRpc3BsYXlOYW1lT3JGbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgJHtkaXNwbGF5TmFtZU9yRm59IGNhbiBvbmx5IGJlIHVzZWQgd2l0aGluIHRoZSA8Q2xlcmtQcm92aWRlciAvPiBjb21wb25lbnQuXG5cblBvc3NpYmxlIGZpeGVzOlxuMS4gRW5zdXJlIHRoYXQgdGhlIDxDbGVya1Byb3ZpZGVyIC8+IGlzIGNvcnJlY3RseSB3cmFwcGluZyB5b3VyIGFwcGxpY2F0aW9uIHdoZXJlIHRoaXMgY29tcG9uZW50IGlzIHVzZWQuXG4yLiBDaGVjayBmb3IgbXVsdGlwbGUgdmVyc2lvbnMgb2YgdGhlIFxcYEBjbGVyay9zaGFyZWRcXGAgcGFja2FnZSBpbiB5b3VyIHByb2plY3QuIFVzZSBhIHRvb2wgbGlrZSBcXGBucG0gbHMgQGNsZXJrL3NoYXJlZFxcYCB0byBpZGVudGlmeSBtdWx0aXBsZSB2ZXJzaW9ucywgYW5kIHVwZGF0ZSB5b3VyIGRlcGVuZGVuY2llcyB0byBvbmx5IHJlbHkgb24gb25lLlxuXG5MZWFybiBtb3JlOiBodHRwczovL2NsZXJrLmNvbS9kb2NzL2NvbXBvbmVudHMvY2xlcmstcHJvdmlkZXJgLnRyaW0oKVxuICAgICk7XG4gIH1cbn1cblxuLy8gc3JjL3JlYWN0L2hvb2tzL3VzZVBhZ2VzT3JJbmZpbml0ZS50c1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZU1lbW8sIHVzZVJlZiBhcyB1c2VSZWYyLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvcmVhY3QvaG9va3MvdXNlUHJldmlvdXNWYWx1ZS50c1xuaW1wb3J0IHsgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VQcmV2aW91c1ZhbHVlKHZhbHVlKSB7XG4gIGNvbnN0IGN1cnJlbnRSZWYgPSB1c2VSZWYodmFsdWUpO1xuICBjb25zdCBwcmV2aW91c1JlZiA9IHVzZVJlZihudWxsKTtcbiAgaWYgKGN1cnJlbnRSZWYuY3VycmVudCAhPT0gdmFsdWUpIHtcbiAgICBwcmV2aW91c1JlZi5jdXJyZW50ID0gY3VycmVudFJlZi5jdXJyZW50O1xuICAgIGN1cnJlbnRSZWYuY3VycmVudCA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBwcmV2aW91c1JlZi5jdXJyZW50O1xufVxuXG4vLyBzcmMvcmVhY3QvaG9va3MvdXNlUGFnZXNPckluZmluaXRlLnRzXG5mdW5jdGlvbiBnZXREaWZmZXJlbnRLZXlzKG9iajEsIG9iajIpIHtcbiAgY29uc3Qga2V5c1NldCA9IG5ldyBTZXQoT2JqZWN0LmtleXMob2JqMikpO1xuICBjb25zdCBkaWZmZXJlbnRLZXlzT2JqZWN0ID0ge307XG4gIGZvciAoY29uc3Qga2V5MSBvZiBPYmplY3Qua2V5cyhvYmoxKSkge1xuICAgIGlmICgha2V5c1NldC5oYXMoa2V5MSkpIHtcbiAgICAgIGRpZmZlcmVudEtleXNPYmplY3Rba2V5MV0gPSBvYmoxW2tleTFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGlmZmVyZW50S2V5c09iamVjdDtcbn1cbnZhciB1c2VXaXRoU2FmZVZhbHVlcyA9IChwYXJhbXMsIGRlZmF1bHRWYWx1ZXMpID0+IHtcbiAgY29uc3Qgc2hvdWxkVXNlRGVmYXVsdHMgPSB0eXBlb2YgcGFyYW1zID09PSBcImJvb2xlYW5cIiAmJiBwYXJhbXM7XG4gIGNvbnN0IGluaXRpYWxQYWdlUmVmID0gdXNlUmVmMihcbiAgICBzaG91bGRVc2VEZWZhdWx0cyA/IGRlZmF1bHRWYWx1ZXMuaW5pdGlhbFBhZ2UgOiBwYXJhbXM/LmluaXRpYWxQYWdlID8/IGRlZmF1bHRWYWx1ZXMuaW5pdGlhbFBhZ2VcbiAgKTtcbiAgY29uc3QgcGFnZVNpemVSZWYgPSB1c2VSZWYyKHNob3VsZFVzZURlZmF1bHRzID8gZGVmYXVsdFZhbHVlcy5wYWdlU2l6ZSA6IHBhcmFtcz8ucGFnZVNpemUgPz8gZGVmYXVsdFZhbHVlcy5wYWdlU2l6ZSk7XG4gIGNvbnN0IG5ld09iaiA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhkZWZhdWx0VmFsdWVzKSkge1xuICAgIG5ld09ialtrZXldID0gc2hvdWxkVXNlRGVmYXVsdHMgPyBkZWZhdWx0VmFsdWVzW2tleV0gOiBwYXJhbXM/LltrZXldID8/IGRlZmF1bHRWYWx1ZXNba2V5XTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLm5ld09iaixcbiAgICBpbml0aWFsUGFnZTogaW5pdGlhbFBhZ2VSZWYuY3VycmVudCxcbiAgICBwYWdlU2l6ZTogcGFnZVNpemVSZWYuY3VycmVudFxuICB9O1xufTtcbnZhciBjYWNoaW5nU1dST3B0aW9ucyA9IHtcbiAgZGVkdXBpbmdJbnRlcnZhbDogMWUzICogNjAsXG4gIGZvY3VzVGhyb3R0bGVJbnRlcnZhbDogMWUzICogNjAgKiAyXG59O1xudmFyIHVzZVBhZ2VzT3JJbmZpbml0ZSA9IChwYXJhbXMsIGZldGNoZXIsIGNvbmZpZywgY2FjaGVLZXlzKSA9PiB7XG4gIGNvbnN0IFtwYWdpbmF0ZWRQYWdlLCBzZXRQYWdpbmF0ZWRQYWdlXSA9IHVzZVN0YXRlKHBhcmFtcy5pbml0aWFsUGFnZSA/PyAxKTtcbiAgY29uc3QgaW5pdGlhbFBhZ2VSZWYgPSB1c2VSZWYyKHBhcmFtcy5pbml0aWFsUGFnZSA/PyAxKTtcbiAgY29uc3QgcGFnZVNpemVSZWYgPSB1c2VSZWYyKHBhcmFtcy5wYWdlU2l6ZSA/PyAxMCk7XG4gIGNvbnN0IGVuYWJsZWQgPSBjb25maWcuZW5hYmxlZCA/PyB0cnVlO1xuICBjb25zdCBjYWNoZU1vZGUgPSBjb25maWcuX19leHBlcmltZW50YWxfbW9kZSA9PT0gXCJjYWNoZVwiO1xuICBjb25zdCB0cmlnZ2VySW5maW5pdGUgPSBjb25maWcuaW5maW5pdGUgPz8gZmFsc2U7XG4gIGNvbnN0IGtlZXBQcmV2aW91c0RhdGEgPSBjb25maWcua2VlcFByZXZpb3VzRGF0YSA/PyBmYWxzZTtcbiAgY29uc3QgaXNTaWduZWRJbiA9IGNvbmZpZy5pc1NpZ25lZEluO1xuICBjb25zdCBwYWdlc0NhY2hlS2V5ID0ge1xuICAgIC4uLmNhY2hlS2V5cyxcbiAgICAuLi5wYXJhbXMsXG4gICAgaW5pdGlhbFBhZ2U6IHBhZ2luYXRlZFBhZ2UsXG4gICAgcGFnZVNpemU6IHBhZ2VTaXplUmVmLmN1cnJlbnRcbiAgfTtcbiAgY29uc3QgcHJldmlvdXNJc1NpZ25lZEluID0gdXNlUHJldmlvdXNWYWx1ZShpc1NpZ25lZEluKTtcbiAgY29uc3Qgc2hvdWxkRmV0Y2ggPSAhdHJpZ2dlckluZmluaXRlICYmIGVuYWJsZWQgJiYgKCFjYWNoZU1vZGUgPyAhIWZldGNoZXIgOiB0cnVlKTtcbiAgY29uc3Qgc3dyS2V5ID0gdHlwZW9mIGlzU2lnbmVkSW4gPT09IFwiYm9vbGVhblwiID8gcHJldmlvdXNJc1NpZ25lZEluID09PSB0cnVlICYmIGlzU2lnbmVkSW4gPT09IGZhbHNlID8gcGFnZXNDYWNoZUtleSA6IGlzU2lnbmVkSW4gPyBzaG91bGRGZXRjaCA/IHBhZ2VzQ2FjaGVLZXkgOiBudWxsIDogbnVsbCA6IHNob3VsZEZldGNoID8gcGFnZXNDYWNoZUtleSA6IG51bGw7XG4gIGNvbnN0IHN3ckZldGNoZXIgPSAhY2FjaGVNb2RlICYmICEhZmV0Y2hlciA/IChjYWNoZUtleVBhcmFtcykgPT4ge1xuICAgIGlmIChpc1NpZ25lZEluID09PSBmYWxzZSB8fCBzaG91bGRGZXRjaCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0gZ2V0RGlmZmVyZW50S2V5cyhjYWNoZUtleVBhcmFtcywgY2FjaGVLZXlzKTtcbiAgICByZXR1cm4gZmV0Y2hlcih7IC4uLnBhcmFtcywgLi4ucmVxdWVzdFBhcmFtcyB9KTtcbiAgfSA6IG51bGw7XG4gIGNvbnN0IHtcbiAgICBkYXRhOiBzd3JEYXRhLFxuICAgIGlzVmFsaWRhdGluZzogc3dySXNWYWxpZGF0aW5nLFxuICAgIGlzTG9hZGluZzogc3dySXNMb2FkaW5nLFxuICAgIGVycm9yOiBzd3JFcnJvcixcbiAgICBtdXRhdGU6IHN3ck11dGF0ZVxuICB9ID0gZGVmYXVsdDIoc3dyS2V5LCBzd3JGZXRjaGVyLCB7IGtlZXBQcmV2aW91c0RhdGEsIC4uLmNhY2hpbmdTV1JPcHRpb25zIH0pO1xuICBjb25zdCB7XG4gICAgZGF0YTogc3dySW5maW5pdGVEYXRhLFxuICAgIGlzTG9hZGluZzogc3dySW5maW5pdGVJc0xvYWRpbmcsXG4gICAgaXNWYWxpZGF0aW5nOiBzd3JJbmZpbml0ZUlzVmFsaWRhdGluZyxcbiAgICBlcnJvcjogc3dySW5maW5pdGVFcnJvcixcbiAgICBzaXplLFxuICAgIHNldFNpemUsXG4gICAgbXV0YXRlOiBzd3JJbmZpbml0ZU11dGF0ZVxuICB9ID0gZGVmYXVsdDMoXG4gICAgKHBhZ2VJbmRleCkgPT4ge1xuICAgICAgaWYgKCF0cmlnZ2VySW5maW5pdGUgfHwgIWVuYWJsZWQgfHwgaXNTaWduZWRJbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIC4uLmNhY2hlS2V5cyxcbiAgICAgICAgaW5pdGlhbFBhZ2U6IGluaXRpYWxQYWdlUmVmLmN1cnJlbnQgKyBwYWdlSW5kZXgsXG4gICAgICAgIHBhZ2VTaXplOiBwYWdlU2l6ZVJlZi5jdXJyZW50XG4gICAgICB9O1xuICAgIH0sXG4gICAgKGNhY2hlS2V5UGFyYW1zKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0gZ2V0RGlmZmVyZW50S2V5cyhjYWNoZUtleVBhcmFtcywgY2FjaGVLZXlzKTtcbiAgICAgIHJldHVybiBmZXRjaGVyPy4ocmVxdWVzdFBhcmFtcyk7XG4gICAgfSxcbiAgICBjYWNoaW5nU1dST3B0aW9uc1xuICApO1xuICBjb25zdCBwYWdlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHRyaWdnZXJJbmZpbml0ZSkge1xuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIHJldHVybiBwYWdpbmF0ZWRQYWdlO1xuICB9LCBbdHJpZ2dlckluZmluaXRlLCBzaXplLCBwYWdpbmF0ZWRQYWdlXSk7XG4gIGNvbnN0IGZldGNoUGFnZSA9IHVzZUNhbGxiYWNrKFxuICAgIChudW1iZXJPcmdGbikgPT4ge1xuICAgICAgaWYgKHRyaWdnZXJJbmZpbml0ZSkge1xuICAgICAgICB2b2lkIHNldFNpemUobnVtYmVyT3JnRm4pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0UGFnaW5hdGVkUGFnZShudW1iZXJPcmdGbik7XG4gICAgfSxcbiAgICBbc2V0U2l6ZSwgdHJpZ2dlckluZmluaXRlXVxuICApO1xuICBjb25zdCBkYXRhID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHRyaWdnZXJJbmZpbml0ZSkge1xuICAgICAgcmV0dXJuIHN3ckluZmluaXRlRGF0YT8ubWFwKChhKSA9PiBhPy5kYXRhKS5mbGF0KCkgPz8gW107XG4gICAgfVxuICAgIHJldHVybiBzd3JEYXRhPy5kYXRhID8/IFtdO1xuICB9LCBbdHJpZ2dlckluZmluaXRlLCBzd3JEYXRhLCBzd3JJbmZpbml0ZURhdGFdKTtcbiAgY29uc3QgY291bnQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAodHJpZ2dlckluZmluaXRlKSB7XG4gICAgICByZXR1cm4gc3dySW5maW5pdGVEYXRhPy5bc3dySW5maW5pdGVEYXRhPy5sZW5ndGggLSAxXT8udG90YWxfY291bnQgfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIHN3ckRhdGE/LnRvdGFsX2NvdW50ID8/IDA7XG4gIH0sIFt0cmlnZ2VySW5maW5pdGUsIHN3ckRhdGEsIHN3ckluZmluaXRlRGF0YV0pO1xuICBjb25zdCBpc0xvYWRpbmcgPSB0cmlnZ2VySW5maW5pdGUgPyBzd3JJbmZpbml0ZUlzTG9hZGluZyA6IHN3cklzTG9hZGluZztcbiAgY29uc3QgaXNGZXRjaGluZyA9IHRyaWdnZXJJbmZpbml0ZSA/IHN3ckluZmluaXRlSXNWYWxpZGF0aW5nIDogc3dySXNWYWxpZGF0aW5nO1xuICBjb25zdCBlcnJvciA9ICh0cmlnZ2VySW5maW5pdGUgPyBzd3JJbmZpbml0ZUVycm9yIDogc3dyRXJyb3IpID8/IG51bGw7XG4gIGNvbnN0IGlzRXJyb3IgPSAhIWVycm9yO1xuICBjb25zdCBmZXRjaE5leHQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgZmV0Y2hQYWdlKChuKSA9PiBNYXRoLm1heCgwLCBuICsgMSkpO1xuICB9LCBbZmV0Y2hQYWdlXSk7XG4gIGNvbnN0IGZldGNoUHJldmlvdXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgZmV0Y2hQYWdlKChuKSA9PiBNYXRoLm1heCgwLCBuIC0gMSkpO1xuICB9LCBbZmV0Y2hQYWdlXSk7XG4gIGNvbnN0IG9mZnNldENvdW50ID0gKGluaXRpYWxQYWdlUmVmLmN1cnJlbnQgLSAxKSAqIHBhZ2VTaXplUmVmLmN1cnJlbnQ7XG4gIGNvbnN0IHBhZ2VDb3VudCA9IE1hdGguY2VpbCgoY291bnQgLSBvZmZzZXRDb3VudCkgLyBwYWdlU2l6ZVJlZi5jdXJyZW50KTtcbiAgY29uc3QgaGFzTmV4dFBhZ2UgPSBjb3VudCAtIG9mZnNldENvdW50ICogcGFnZVNpemVSZWYuY3VycmVudCA+IHBhZ2UgKiBwYWdlU2l6ZVJlZi5jdXJyZW50O1xuICBjb25zdCBoYXNQcmV2aW91c1BhZ2UgPSAocGFnZSAtIDEpICogcGFnZVNpemVSZWYuY3VycmVudCA+IG9mZnNldENvdW50ICogcGFnZVNpemVSZWYuY3VycmVudDtcbiAgY29uc3Qgc2V0RGF0YSA9IHRyaWdnZXJJbmZpbml0ZSA/ICh2YWx1ZSkgPT4gc3dySW5maW5pdGVNdXRhdGUodmFsdWUsIHtcbiAgICByZXZhbGlkYXRlOiBmYWxzZVxuICB9KSA6ICh2YWx1ZSkgPT4gc3dyTXV0YXRlKHZhbHVlLCB7XG4gICAgcmV2YWxpZGF0ZTogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IHJldmFsaWRhdGUgPSB0cmlnZ2VySW5maW5pdGUgPyAoKSA9PiBzd3JJbmZpbml0ZU11dGF0ZSgpIDogKCkgPT4gc3dyTXV0YXRlKCk7XG4gIHJldHVybiB7XG4gICAgZGF0YSxcbiAgICBjb3VudCxcbiAgICBlcnJvcixcbiAgICBpc0xvYWRpbmcsXG4gICAgaXNGZXRjaGluZyxcbiAgICBpc0Vycm9yLFxuICAgIHBhZ2UsXG4gICAgcGFnZUNvdW50LFxuICAgIGZldGNoUGFnZSxcbiAgICBmZXRjaE5leHQsXG4gICAgZmV0Y2hQcmV2aW91cyxcbiAgICBoYXNOZXh0UGFnZSxcbiAgICBoYXNQcmV2aW91c1BhZ2UsXG4gICAgLy8gTGV0IHRoZSBob29rIHJldHVybiB0eXBlIGRlZmluZSB0aGlzIHR5cGVcbiAgICByZXZhbGlkYXRlLFxuICAgIC8vIExldCB0aGUgaG9vayByZXR1cm4gdHlwZSBkZWZpbmUgdGhpcyB0eXBlXG4gICAgc2V0RGF0YVxuICB9O1xufTtcblxuLy8gc3JjL3JlYWN0L2hvb2tzL3VzZU9yZ2FuaXphdGlvbi50c3hcbnZhciB1bmRlZmluZWRQYWdpbmF0ZWRSZXNvdXJjZSA9IHtcbiAgZGF0YTogdm9pZCAwLFxuICBjb3VudDogdm9pZCAwLFxuICBlcnJvcjogdm9pZCAwLFxuICBpc0xvYWRpbmc6IGZhbHNlLFxuICBpc0ZldGNoaW5nOiBmYWxzZSxcbiAgaXNFcnJvcjogZmFsc2UsXG4gIHBhZ2U6IHZvaWQgMCxcbiAgcGFnZUNvdW50OiB2b2lkIDAsXG4gIGZldGNoUGFnZTogdm9pZCAwLFxuICBmZXRjaE5leHQ6IHZvaWQgMCxcbiAgZmV0Y2hQcmV2aW91czogdm9pZCAwLFxuICBoYXNOZXh0UGFnZTogZmFsc2UsXG4gIGhhc1ByZXZpb3VzUGFnZTogZmFsc2UsXG4gIHJldmFsaWRhdGU6IHZvaWQgMCxcbiAgc2V0RGF0YTogdm9pZCAwXG59O1xuZnVuY3Rpb24gdXNlT3JnYW5pemF0aW9uKHBhcmFtcykge1xuICBjb25zdCB7XG4gICAgZG9tYWluczogZG9tYWluTGlzdFBhcmFtcyxcbiAgICBtZW1iZXJzaGlwUmVxdWVzdHM6IG1lbWJlcnNoaXBSZXF1ZXN0c0xpc3RQYXJhbXMsXG4gICAgbWVtYmVyc2hpcHM6IG1lbWJlcnNMaXN0UGFyYW1zLFxuICAgIGludml0YXRpb25zOiBpbnZpdGF0aW9uc0xpc3RQYXJhbXNcbiAgfSA9IHBhcmFtcyB8fCB7fTtcbiAgdXNlQXNzZXJ0V3JhcHBlZEJ5Q2xlcmtQcm92aWRlcihcInVzZU9yZ2FuaXphdGlvblwiKTtcbiAgY29uc3QgeyBvcmdhbml6YXRpb24gfSA9IHVzZU9yZ2FuaXphdGlvbkNvbnRleHQoKTtcbiAgY29uc3Qgc2Vzc2lvbiA9IHVzZVNlc3Npb25Db250ZXh0KCk7XG4gIGNvbnN0IGRvbWFpblNhZmVWYWx1ZXMgPSB1c2VXaXRoU2FmZVZhbHVlcyhkb21haW5MaXN0UGFyYW1zLCB7XG4gICAgaW5pdGlhbFBhZ2U6IDEsXG4gICAgcGFnZVNpemU6IDEwLFxuICAgIGtlZXBQcmV2aW91c0RhdGE6IGZhbHNlLFxuICAgIGluZmluaXRlOiBmYWxzZSxcbiAgICBlbnJvbGxtZW50TW9kZTogdm9pZCAwXG4gIH0pO1xuICBjb25zdCBtZW1iZXJzaGlwUmVxdWVzdFNhZmVWYWx1ZXMgPSB1c2VXaXRoU2FmZVZhbHVlcyhtZW1iZXJzaGlwUmVxdWVzdHNMaXN0UGFyYW1zLCB7XG4gICAgaW5pdGlhbFBhZ2U6IDEsXG4gICAgcGFnZVNpemU6IDEwLFxuICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAga2VlcFByZXZpb3VzRGF0YTogZmFsc2UsXG4gICAgaW5maW5pdGU6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBtZW1iZXJzU2FmZVZhbHVlcyA9IHVzZVdpdGhTYWZlVmFsdWVzKG1lbWJlcnNMaXN0UGFyYW1zLCB7XG4gICAgaW5pdGlhbFBhZ2U6IDEsXG4gICAgcGFnZVNpemU6IDEwLFxuICAgIHJvbGU6IHZvaWQgMCxcbiAgICBrZWVwUHJldmlvdXNEYXRhOiBmYWxzZSxcbiAgICBpbmZpbml0ZTogZmFsc2UsXG4gICAgcXVlcnk6IHZvaWQgMFxuICB9KTtcbiAgY29uc3QgaW52aXRhdGlvbnNTYWZlVmFsdWVzID0gdXNlV2l0aFNhZmVWYWx1ZXMoaW52aXRhdGlvbnNMaXN0UGFyYW1zLCB7XG4gICAgaW5pdGlhbFBhZ2U6IDEsXG4gICAgcGFnZVNpemU6IDEwLFxuICAgIHN0YXR1czogW1wicGVuZGluZ1wiXSxcbiAgICBrZWVwUHJldmlvdXNEYXRhOiBmYWxzZSxcbiAgICBpbmZpbml0ZTogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IGNsZXJrID0gdXNlQ2xlcmtJbnN0YW5jZUNvbnRleHQoKTtcbiAgY2xlcmsudGVsZW1ldHJ5Py5yZWNvcmQoZXZlbnRNZXRob2RDYWxsZWQoXCJ1c2VPcmdhbml6YXRpb25cIikpO1xuICBjb25zdCBkb21haW5QYXJhbXMgPSB0eXBlb2YgZG9tYWluTGlzdFBhcmFtcyA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IHtcbiAgICBpbml0aWFsUGFnZTogZG9tYWluU2FmZVZhbHVlcy5pbml0aWFsUGFnZSxcbiAgICBwYWdlU2l6ZTogZG9tYWluU2FmZVZhbHVlcy5wYWdlU2l6ZSxcbiAgICBlbnJvbGxtZW50TW9kZTogZG9tYWluU2FmZVZhbHVlcy5lbnJvbGxtZW50TW9kZVxuICB9O1xuICBjb25zdCBtZW1iZXJzaGlwUmVxdWVzdFBhcmFtcyA9IHR5cGVvZiBtZW1iZXJzaGlwUmVxdWVzdHNMaXN0UGFyYW1zID09PSBcInVuZGVmaW5lZFwiID8gdm9pZCAwIDoge1xuICAgIGluaXRpYWxQYWdlOiBtZW1iZXJzaGlwUmVxdWVzdFNhZmVWYWx1ZXMuaW5pdGlhbFBhZ2UsXG4gICAgcGFnZVNpemU6IG1lbWJlcnNoaXBSZXF1ZXN0U2FmZVZhbHVlcy5wYWdlU2l6ZSxcbiAgICBzdGF0dXM6IG1lbWJlcnNoaXBSZXF1ZXN0U2FmZVZhbHVlcy5zdGF0dXNcbiAgfTtcbiAgY29uc3QgbWVtYmVyc1BhcmFtcyA9IHR5cGVvZiBtZW1iZXJzTGlzdFBhcmFtcyA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IHtcbiAgICBpbml0aWFsUGFnZTogbWVtYmVyc1NhZmVWYWx1ZXMuaW5pdGlhbFBhZ2UsXG4gICAgcGFnZVNpemU6IG1lbWJlcnNTYWZlVmFsdWVzLnBhZ2VTaXplLFxuICAgIHJvbGU6IG1lbWJlcnNTYWZlVmFsdWVzLnJvbGUsXG4gICAgcXVlcnk6IG1lbWJlcnNTYWZlVmFsdWVzLnF1ZXJ5XG4gIH07XG4gIGNvbnN0IGludml0YXRpb25zUGFyYW1zID0gdHlwZW9mIGludml0YXRpb25zTGlzdFBhcmFtcyA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IHtcbiAgICBpbml0aWFsUGFnZTogaW52aXRhdGlvbnNTYWZlVmFsdWVzLmluaXRpYWxQYWdlLFxuICAgIHBhZ2VTaXplOiBpbnZpdGF0aW9uc1NhZmVWYWx1ZXMucGFnZVNpemUsXG4gICAgc3RhdHVzOiBpbnZpdGF0aW9uc1NhZmVWYWx1ZXMuc3RhdHVzXG4gIH07XG4gIGNvbnN0IGRvbWFpbnMgPSB1c2VQYWdlc09ySW5maW5pdGUoXG4gICAge1xuICAgICAgLi4uZG9tYWluUGFyYW1zXG4gICAgfSxcbiAgICBvcmdhbml6YXRpb24/LmdldERvbWFpbnMsXG4gICAge1xuICAgICAga2VlcFByZXZpb3VzRGF0YTogZG9tYWluU2FmZVZhbHVlcy5rZWVwUHJldmlvdXNEYXRhLFxuICAgICAgaW5maW5pdGU6IGRvbWFpblNhZmVWYWx1ZXMuaW5maW5pdGUsXG4gICAgICBlbmFibGVkOiAhIWRvbWFpblBhcmFtc1xuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJkb21haW5zXCIsXG4gICAgICBvcmdhbml6YXRpb25JZDogb3JnYW5pemF0aW9uPy5pZFxuICAgIH1cbiAgKTtcbiAgY29uc3QgbWVtYmVyc2hpcFJlcXVlc3RzID0gdXNlUGFnZXNPckluZmluaXRlKFxuICAgIHtcbiAgICAgIC4uLm1lbWJlcnNoaXBSZXF1ZXN0UGFyYW1zXG4gICAgfSxcbiAgICBvcmdhbml6YXRpb24/LmdldE1lbWJlcnNoaXBSZXF1ZXN0cyxcbiAgICB7XG4gICAgICBrZWVwUHJldmlvdXNEYXRhOiBtZW1iZXJzaGlwUmVxdWVzdFNhZmVWYWx1ZXMua2VlcFByZXZpb3VzRGF0YSxcbiAgICAgIGluZmluaXRlOiBtZW1iZXJzaGlwUmVxdWVzdFNhZmVWYWx1ZXMuaW5maW5pdGUsXG4gICAgICBlbmFibGVkOiAhIW1lbWJlcnNoaXBSZXF1ZXN0UGFyYW1zXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcIm1lbWJlcnNoaXBSZXF1ZXN0c1wiLFxuICAgICAgb3JnYW5pemF0aW9uSWQ6IG9yZ2FuaXphdGlvbj8uaWRcbiAgICB9XG4gICk7XG4gIGNvbnN0IG1lbWJlcnNoaXBzID0gdXNlUGFnZXNPckluZmluaXRlKFxuICAgIG1lbWJlcnNQYXJhbXMgfHwge30sXG4gICAgb3JnYW5pemF0aW9uPy5nZXRNZW1iZXJzaGlwcyxcbiAgICB7XG4gICAgICBrZWVwUHJldmlvdXNEYXRhOiBtZW1iZXJzU2FmZVZhbHVlcy5rZWVwUHJldmlvdXNEYXRhLFxuICAgICAgaW5maW5pdGU6IG1lbWJlcnNTYWZlVmFsdWVzLmluZmluaXRlLFxuICAgICAgZW5hYmxlZDogISFtZW1iZXJzUGFyYW1zXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcIm1lbWJlcnNcIixcbiAgICAgIG9yZ2FuaXphdGlvbklkOiBvcmdhbml6YXRpb24/LmlkXG4gICAgfVxuICApO1xuICBjb25zdCBpbnZpdGF0aW9ucyA9IHVzZVBhZ2VzT3JJbmZpbml0ZShcbiAgICB7XG4gICAgICAuLi5pbnZpdGF0aW9uc1BhcmFtc1xuICAgIH0sXG4gICAgb3JnYW5pemF0aW9uPy5nZXRJbnZpdGF0aW9ucyxcbiAgICB7XG4gICAgICBrZWVwUHJldmlvdXNEYXRhOiBpbnZpdGF0aW9uc1NhZmVWYWx1ZXMua2VlcFByZXZpb3VzRGF0YSxcbiAgICAgIGluZmluaXRlOiBpbnZpdGF0aW9uc1NhZmVWYWx1ZXMuaW5maW5pdGUsXG4gICAgICBlbmFibGVkOiAhIWludml0YXRpb25zUGFyYW1zXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcImludml0YXRpb25zXCIsXG4gICAgICBvcmdhbml6YXRpb25JZDogb3JnYW5pemF0aW9uPy5pZFxuICAgIH1cbiAgKTtcbiAgaWYgKG9yZ2FuaXphdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGVkOiBmYWxzZSxcbiAgICAgIG9yZ2FuaXphdGlvbjogdm9pZCAwLFxuICAgICAgbWVtYmVyc2hpcDogdm9pZCAwLFxuICAgICAgZG9tYWluczogdW5kZWZpbmVkUGFnaW5hdGVkUmVzb3VyY2UsXG4gICAgICBtZW1iZXJzaGlwUmVxdWVzdHM6IHVuZGVmaW5lZFBhZ2luYXRlZFJlc291cmNlLFxuICAgICAgbWVtYmVyc2hpcHM6IHVuZGVmaW5lZFBhZ2luYXRlZFJlc291cmNlLFxuICAgICAgaW52aXRhdGlvbnM6IHVuZGVmaW5lZFBhZ2luYXRlZFJlc291cmNlXG4gICAgfTtcbiAgfVxuICBpZiAob3JnYW5pemF0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGVkOiB0cnVlLFxuICAgICAgb3JnYW5pemF0aW9uOiBudWxsLFxuICAgICAgbWVtYmVyc2hpcDogbnVsbCxcbiAgICAgIGRvbWFpbnM6IG51bGwsXG4gICAgICBtZW1iZXJzaGlwUmVxdWVzdHM6IG51bGwsXG4gICAgICBtZW1iZXJzaGlwczogbnVsbCxcbiAgICAgIGludml0YXRpb25zOiBudWxsXG4gICAgfTtcbiAgfVxuICBpZiAoIWNsZXJrLmxvYWRlZCAmJiBvcmdhbml6YXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNMb2FkZWQ6IHRydWUsXG4gICAgICBvcmdhbml6YXRpb24sXG4gICAgICBtZW1iZXJzaGlwOiB2b2lkIDAsXG4gICAgICBkb21haW5zOiB1bmRlZmluZWRQYWdpbmF0ZWRSZXNvdXJjZSxcbiAgICAgIG1lbWJlcnNoaXBSZXF1ZXN0czogdW5kZWZpbmVkUGFnaW5hdGVkUmVzb3VyY2UsXG4gICAgICBtZW1iZXJzaGlwczogdW5kZWZpbmVkUGFnaW5hdGVkUmVzb3VyY2UsXG4gICAgICBpbnZpdGF0aW9uczogdW5kZWZpbmVkUGFnaW5hdGVkUmVzb3VyY2VcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNMb2FkZWQ6IGNsZXJrLmxvYWRlZCxcbiAgICBvcmdhbml6YXRpb24sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICBtZW1iZXJzaGlwOiBnZXRDdXJyZW50T3JnYW5pemF0aW9uTWVtYmVyc2hpcChzZXNzaW9uLnVzZXIub3JnYW5pemF0aW9uTWVtYmVyc2hpcHMsIG9yZ2FuaXphdGlvbi5pZCksXG4gICAgLy8geW91ciBtZW1iZXJzaGlwIGluIHRoZSBjdXJyZW50IG9yZ1xuICAgIGRvbWFpbnMsXG4gICAgbWVtYmVyc2hpcFJlcXVlc3RzLFxuICAgIG1lbWJlcnNoaXBzLFxuICAgIGludml0YXRpb25zXG4gIH07XG59XG5cbi8vIHNyYy9yZWFjdC9ob29rcy91c2VPcmdhbml6YXRpb25MaXN0LnRzeFxudmFyIHVuZGVmaW5lZFBhZ2luYXRlZFJlc291cmNlMiA9IHtcbiAgZGF0YTogdm9pZCAwLFxuICBjb3VudDogdm9pZCAwLFxuICBlcnJvcjogdm9pZCAwLFxuICBpc0xvYWRpbmc6IGZhbHNlLFxuICBpc0ZldGNoaW5nOiBmYWxzZSxcbiAgaXNFcnJvcjogZmFsc2UsXG4gIHBhZ2U6IHZvaWQgMCxcbiAgcGFnZUNvdW50OiB2b2lkIDAsXG4gIGZldGNoUGFnZTogdm9pZCAwLFxuICBmZXRjaE5leHQ6IHZvaWQgMCxcbiAgZmV0Y2hQcmV2aW91czogdm9pZCAwLFxuICBoYXNOZXh0UGFnZTogZmFsc2UsXG4gIGhhc1ByZXZpb3VzUGFnZTogZmFsc2UsXG4gIHJldmFsaWRhdGU6IHZvaWQgMCxcbiAgc2V0RGF0YTogdm9pZCAwXG59O1xuZnVuY3Rpb24gdXNlT3JnYW5pemF0aW9uTGlzdChwYXJhbXMpIHtcbiAgY29uc3QgeyB1c2VyTWVtYmVyc2hpcHMsIHVzZXJJbnZpdGF0aW9ucywgdXNlclN1Z2dlc3Rpb25zIH0gPSBwYXJhbXMgfHwge307XG4gIHVzZUFzc2VydFdyYXBwZWRCeUNsZXJrUHJvdmlkZXIoXCJ1c2VPcmdhbml6YXRpb25MaXN0XCIpO1xuICBjb25zdCB1c2VyTWVtYmVyc2hpcHNTYWZlVmFsdWVzID0gdXNlV2l0aFNhZmVWYWx1ZXModXNlck1lbWJlcnNoaXBzLCB7XG4gICAgaW5pdGlhbFBhZ2U6IDEsXG4gICAgcGFnZVNpemU6IDEwLFxuICAgIGtlZXBQcmV2aW91c0RhdGE6IGZhbHNlLFxuICAgIGluZmluaXRlOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgdXNlckludml0YXRpb25zU2FmZVZhbHVlcyA9IHVzZVdpdGhTYWZlVmFsdWVzKHVzZXJJbnZpdGF0aW9ucywge1xuICAgIGluaXRpYWxQYWdlOiAxLFxuICAgIHBhZ2VTaXplOiAxMCxcbiAgICBzdGF0dXM6IFwicGVuZGluZ1wiLFxuICAgIGtlZXBQcmV2aW91c0RhdGE6IGZhbHNlLFxuICAgIGluZmluaXRlOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgdXNlclN1Z2dlc3Rpb25zU2FmZVZhbHVlcyA9IHVzZVdpdGhTYWZlVmFsdWVzKHVzZXJTdWdnZXN0aW9ucywge1xuICAgIGluaXRpYWxQYWdlOiAxLFxuICAgIHBhZ2VTaXplOiAxMCxcbiAgICBzdGF0dXM6IFwicGVuZGluZ1wiLFxuICAgIGtlZXBQcmV2aW91c0RhdGE6IGZhbHNlLFxuICAgIGluZmluaXRlOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgY2xlcmsgPSB1c2VDbGVya0luc3RhbmNlQ29udGV4dCgpO1xuICBjb25zdCB1c2VyID0gdXNlVXNlckNvbnRleHQoKTtcbiAgY2xlcmsudGVsZW1ldHJ5Py5yZWNvcmQoZXZlbnRNZXRob2RDYWxsZWQoXCJ1c2VPcmdhbml6YXRpb25MaXN0XCIpKTtcbiAgY29uc3QgdXNlck1lbWJlcnNoaXBzUGFyYW1zID0gdHlwZW9mIHVzZXJNZW1iZXJzaGlwcyA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IHtcbiAgICBpbml0aWFsUGFnZTogdXNlck1lbWJlcnNoaXBzU2FmZVZhbHVlcy5pbml0aWFsUGFnZSxcbiAgICBwYWdlU2l6ZTogdXNlck1lbWJlcnNoaXBzU2FmZVZhbHVlcy5wYWdlU2l6ZVxuICB9O1xuICBjb25zdCB1c2VySW52aXRhdGlvbnNQYXJhbXMgPSB0eXBlb2YgdXNlckludml0YXRpb25zID09PSBcInVuZGVmaW5lZFwiID8gdm9pZCAwIDoge1xuICAgIGluaXRpYWxQYWdlOiB1c2VySW52aXRhdGlvbnNTYWZlVmFsdWVzLmluaXRpYWxQYWdlLFxuICAgIHBhZ2VTaXplOiB1c2VySW52aXRhdGlvbnNTYWZlVmFsdWVzLnBhZ2VTaXplLFxuICAgIHN0YXR1czogdXNlckludml0YXRpb25zU2FmZVZhbHVlcy5zdGF0dXNcbiAgfTtcbiAgY29uc3QgdXNlclN1Z2dlc3Rpb25zUGFyYW1zID0gdHlwZW9mIHVzZXJTdWdnZXN0aW9ucyA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IHtcbiAgICBpbml0aWFsUGFnZTogdXNlclN1Z2dlc3Rpb25zU2FmZVZhbHVlcy5pbml0aWFsUGFnZSxcbiAgICBwYWdlU2l6ZTogdXNlclN1Z2dlc3Rpb25zU2FmZVZhbHVlcy5wYWdlU2l6ZSxcbiAgICBzdGF0dXM6IHVzZXJTdWdnZXN0aW9uc1NhZmVWYWx1ZXMuc3RhdHVzXG4gIH07XG4gIGNvbnN0IGlzQ2xlcmtMb2FkZWQgPSAhIShjbGVyay5sb2FkZWQgJiYgdXNlcik7XG4gIGNvbnN0IG1lbWJlcnNoaXBzID0gdXNlUGFnZXNPckluZmluaXRlKFxuICAgIHVzZXJNZW1iZXJzaGlwc1BhcmFtcyB8fCB7fSxcbiAgICB1c2VyPy5nZXRPcmdhbml6YXRpb25NZW1iZXJzaGlwcyxcbiAgICB7XG4gICAgICBrZWVwUHJldmlvdXNEYXRhOiB1c2VyTWVtYmVyc2hpcHNTYWZlVmFsdWVzLmtlZXBQcmV2aW91c0RhdGEsXG4gICAgICBpbmZpbml0ZTogdXNlck1lbWJlcnNoaXBzU2FmZVZhbHVlcy5pbmZpbml0ZSxcbiAgICAgIGVuYWJsZWQ6ICEhdXNlck1lbWJlcnNoaXBzUGFyYW1zXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcInVzZXJNZW1iZXJzaGlwc1wiLFxuICAgICAgdXNlcklkOiB1c2VyPy5pZFxuICAgIH1cbiAgKTtcbiAgY29uc3QgaW52aXRhdGlvbnMgPSB1c2VQYWdlc09ySW5maW5pdGUoXG4gICAge1xuICAgICAgLi4udXNlckludml0YXRpb25zUGFyYW1zXG4gICAgfSxcbiAgICB1c2VyPy5nZXRPcmdhbml6YXRpb25JbnZpdGF0aW9ucyxcbiAgICB7XG4gICAgICBrZWVwUHJldmlvdXNEYXRhOiB1c2VySW52aXRhdGlvbnNTYWZlVmFsdWVzLmtlZXBQcmV2aW91c0RhdGEsXG4gICAgICBpbmZpbml0ZTogdXNlckludml0YXRpb25zU2FmZVZhbHVlcy5pbmZpbml0ZSxcbiAgICAgIGVuYWJsZWQ6ICEhdXNlckludml0YXRpb25zUGFyYW1zXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcInVzZXJJbnZpdGF0aW9uc1wiLFxuICAgICAgdXNlcklkOiB1c2VyPy5pZFxuICAgIH1cbiAgKTtcbiAgY29uc3Qgc3VnZ2VzdGlvbnMgPSB1c2VQYWdlc09ySW5maW5pdGUoXG4gICAge1xuICAgICAgLi4udXNlclN1Z2dlc3Rpb25zUGFyYW1zXG4gICAgfSxcbiAgICB1c2VyPy5nZXRPcmdhbml6YXRpb25TdWdnZXN0aW9ucyxcbiAgICB7XG4gICAgICBrZWVwUHJldmlvdXNEYXRhOiB1c2VyU3VnZ2VzdGlvbnNTYWZlVmFsdWVzLmtlZXBQcmV2aW91c0RhdGEsXG4gICAgICBpbmZpbml0ZTogdXNlclN1Z2dlc3Rpb25zU2FmZVZhbHVlcy5pbmZpbml0ZSxcbiAgICAgIGVuYWJsZWQ6ICEhdXNlclN1Z2dlc3Rpb25zUGFyYW1zXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcInVzZXJTdWdnZXN0aW9uc1wiLFxuICAgICAgdXNlcklkOiB1c2VyPy5pZFxuICAgIH1cbiAgKTtcbiAgaWYgKCFpc0NsZXJrTG9hZGVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGVkOiBmYWxzZSxcbiAgICAgIGNyZWF0ZU9yZ2FuaXphdGlvbjogdm9pZCAwLFxuICAgICAgc2V0QWN0aXZlOiB2b2lkIDAsXG4gICAgICB1c2VyTWVtYmVyc2hpcHM6IHVuZGVmaW5lZFBhZ2luYXRlZFJlc291cmNlMixcbiAgICAgIHVzZXJJbnZpdGF0aW9uczogdW5kZWZpbmVkUGFnaW5hdGVkUmVzb3VyY2UyLFxuICAgICAgdXNlclN1Z2dlc3Rpb25zOiB1bmRlZmluZWRQYWdpbmF0ZWRSZXNvdXJjZTJcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNMb2FkZWQ6IGlzQ2xlcmtMb2FkZWQsXG4gICAgc2V0QWN0aXZlOiBjbGVyay5zZXRBY3RpdmUsXG4gICAgY3JlYXRlT3JnYW5pemF0aW9uOiBjbGVyay5jcmVhdGVPcmdhbml6YXRpb24sXG4gICAgdXNlck1lbWJlcnNoaXBzOiBtZW1iZXJzaGlwcyxcbiAgICB1c2VySW52aXRhdGlvbnM6IGludml0YXRpb25zLFxuICAgIHVzZXJTdWdnZXN0aW9uczogc3VnZ2VzdGlvbnNcbiAgfTtcbn1cblxuLy8gc3JjL3JlYWN0L2hvb2tzL3VzZVNhZmVMYXlvdXRFZmZlY3QudHN4XG5pbXBvcnQgUmVhY3QzIGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZVNhZmVMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gUmVhY3QzLnVzZUxheW91dEVmZmVjdCA6IFJlYWN0My51c2VFZmZlY3Q7XG5cbi8vIHNyYy9yZWFjdC9ob29rcy91c2VTZXNzaW9uLnRzXG52YXIgaG9va05hbWUgPSBgdXNlU2Vzc2lvbmA7XG52YXIgdXNlU2Vzc2lvbiA9ICgpID0+IHtcbiAgdXNlQXNzZXJ0V3JhcHBlZEJ5Q2xlcmtQcm92aWRlcihob29rTmFtZSk7XG4gIGNvbnN0IHNlc3Npb24gPSB1c2VTZXNzaW9uQ29udGV4dCgpO1xuICBjb25zdCBjbGVyayA9IHVzZUNsZXJrSW5zdGFuY2VDb250ZXh0KCk7XG4gIGNsZXJrLnRlbGVtZXRyeT8ucmVjb3JkKGV2ZW50TWV0aG9kQ2FsbGVkKGhvb2tOYW1lKSk7XG4gIGlmIChzZXNzaW9uID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4geyBpc0xvYWRlZDogZmFsc2UsIGlzU2lnbmVkSW46IHZvaWQgMCwgc2Vzc2lvbjogdm9pZCAwIH07XG4gIH1cbiAgaWYgKHNlc3Npb24gPT09IG51bGwpIHtcbiAgICByZXR1cm4geyBpc0xvYWRlZDogdHJ1ZSwgaXNTaWduZWRJbjogZmFsc2UsIHNlc3Npb246IG51bGwgfTtcbiAgfVxuICByZXR1cm4geyBpc0xvYWRlZDogdHJ1ZSwgaXNTaWduZWRJbjogY2xlcmsuaXNTaWduZWRJbiwgc2Vzc2lvbiB9O1xufTtcblxuLy8gc3JjL3JlYWN0L2hvb2tzL3VzZVNlc3Npb25MaXN0LnRzXG52YXIgaG9va05hbWUyID0gXCJ1c2VTZXNzaW9uTGlzdFwiO1xudmFyIHVzZVNlc3Npb25MaXN0ID0gKCkgPT4ge1xuICB1c2VBc3NlcnRXcmFwcGVkQnlDbGVya1Byb3ZpZGVyKGhvb2tOYW1lMik7XG4gIGNvbnN0IGlzb21vcnBoaWNDbGVyayA9IHVzZUNsZXJrSW5zdGFuY2VDb250ZXh0KCk7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudENvbnRleHQoKTtcbiAgY29uc3QgY2xlcmsgPSB1c2VDbGVya0luc3RhbmNlQ29udGV4dCgpO1xuICBjbGVyay50ZWxlbWV0cnk/LnJlY29yZChldmVudE1ldGhvZENhbGxlZChob29rTmFtZTIpKTtcbiAgaWYgKCFjbGllbnQpIHtcbiAgICByZXR1cm4geyBpc0xvYWRlZDogZmFsc2UsIHNlc3Npb25zOiB2b2lkIDAsIHNldEFjdGl2ZTogdm9pZCAwIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRlZDogdHJ1ZSxcbiAgICBzZXNzaW9uczogY2xpZW50LnNlc3Npb25zLFxuICAgIHNldEFjdGl2ZTogaXNvbW9ycGhpY0NsZXJrLnNldEFjdGl2ZVxuICB9O1xufTtcblxuLy8gc3JjL3JlYWN0L2hvb2tzL3VzZVVzZXIudHNcbnZhciBob29rTmFtZTMgPSBcInVzZVVzZXJcIjtcbmZ1bmN0aW9uIHVzZVVzZXIoKSB7XG4gIHVzZUFzc2VydFdyYXBwZWRCeUNsZXJrUHJvdmlkZXIoaG9va05hbWUzKTtcbiAgY29uc3QgdXNlciA9IHVzZVVzZXJDb250ZXh0KCk7XG4gIGNvbnN0IGNsZXJrID0gdXNlQ2xlcmtJbnN0YW5jZUNvbnRleHQoKTtcbiAgY2xlcmsudGVsZW1ldHJ5Py5yZWNvcmQoZXZlbnRNZXRob2RDYWxsZWQoaG9va05hbWUzKSk7XG4gIGlmICh1c2VyID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4geyBpc0xvYWRlZDogZmFsc2UsIGlzU2lnbmVkSW46IHZvaWQgMCwgdXNlcjogdm9pZCAwIH07XG4gIH1cbiAgaWYgKHVzZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4geyBpc0xvYWRlZDogdHJ1ZSwgaXNTaWduZWRJbjogZmFsc2UsIHVzZXI6IG51bGwgfTtcbiAgfVxuICByZXR1cm4geyBpc0xvYWRlZDogdHJ1ZSwgaXNTaWduZWRJbjogdHJ1ZSwgdXNlciB9O1xufVxuXG4vLyBzcmMvcmVhY3QvaG9va3MvdXNlQ2xlcmsudHNcbnZhciB1c2VDbGVyayA9ICgpID0+IHtcbiAgdXNlQXNzZXJ0V3JhcHBlZEJ5Q2xlcmtQcm92aWRlcihcInVzZUNsZXJrXCIpO1xuICByZXR1cm4gdXNlQ2xlcmtJbnN0YW5jZUNvbnRleHQoKTtcbn07XG5cbi8vIHNyYy9yZWFjdC9ob29rcy91c2VEZWVwRXF1YWxNZW1vLnRzXG5pbXBvcnQgeyBkZXF1YWwgYXMgZGVlcEVxdWFsIH0gZnJvbSBcImRlcXVhbFwiO1xuaW1wb3J0IFJlYWN0NCBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VEZWVwRXF1YWxNZW1vaXplID0gKHZhbHVlKSA9PiB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0NC51c2VSZWYodmFsdWUpO1xuICBpZiAoIWRlZXBFcXVhbCh2YWx1ZSwgcmVmLmN1cnJlbnQpKSB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gUmVhY3Q0LnVzZU1lbW8oKCkgPT4gcmVmLmN1cnJlbnQsIFtyZWYuY3VycmVudF0pO1xufTtcbnZhciB1c2VEZWVwRXF1YWxNZW1vID0gKGZhY3RvcnksIGRlcGVuZGVuY3lBcnJheSkgPT4ge1xuICByZXR1cm4gUmVhY3Q0LnVzZU1lbW8oZmFjdG9yeSwgdXNlRGVlcEVxdWFsTWVtb2l6ZShkZXBlbmRlbmN5QXJyYXkpKTtcbn07XG52YXIgaXNEZWVwbHlFcXVhbCA9IGRlZXBFcXVhbDtcblxuLy8gc3JjL3JlYWN0L2hvb2tzL3VzZVJldmVyaWZpY2F0aW9uLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsIHVzZVJlZiBhcyB1c2VSZWYzIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgQ0xFUktfQVBJX1JFVkVSSUZJQ0FUSU9OX0VSUk9SX0NPREUgPSBcInNlc3Npb25fcmV2ZXJpZmljYXRpb25fcmVxdWlyZWRcIjtcbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVSZXN1bHQocmVzdWx0KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgciA9IGF3YWl0IHJlc3VsdDtcbiAgICBpZiAociBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gci5qc29uKCk7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGlzQ2xlcmtBUElSZXNwb25zZUVycm9yKGUpICYmIGUuZXJyb3JzLmZpbmQoKHsgY29kZSB9KSA9PiBjb2RlID09PSBDTEVSS19BUElfUkVWRVJJRklDQVRJT05fRVJST1JfQ09ERSkpIHtcbiAgICAgIHJldHVybiByZXZlcmlmaWNhdGlvbkVycm9yKCk7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVJldmVyaWZpY2F0aW9uSGFuZGxlcihwYXJhbXMpIHtcbiAgZnVuY3Rpb24gYXNzZXJ0UmV2ZXJpZmljYXRpb24oZmV0Y2hlcikge1xuICAgIHJldHVybiBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHJlc29sdmVSZXN1bHQoZmV0Y2hlciguLi5hcmdzKSk7XG4gICAgICBpZiAoaXNSZXZlcmlmaWNhdGlvbkhpbnQocmVzdWx0KSkge1xuICAgICAgICBjb25zdCByZXNvbHZlcnMgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKTtcbiAgICAgICAgY29uc3QgaXNWYWxpZE1ldGFkYXRhID0gdmFsaWRhdGVSZXZlcmlmaWNhdGlvbkNvbmZpZyhyZXN1bHQuY2xlcmtfZXJyb3IubWV0YWRhdGE/LnJldmVyaWZpY2F0aW9uKTtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBpc1ZhbGlkTWV0YWRhdGEgPyBpc1ZhbGlkTWV0YWRhdGEoKS5sZXZlbCA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmVycy5yZWplY3QoXG4gICAgICAgICAgICBuZXcgQ2xlcmtSdW50aW1lRXJyb3IoXCJVc2VyIGNhbmNlbGxlZCBhdHRlbXB0ZWQgdmVyaWZpY2F0aW9uXCIsIHtcbiAgICAgICAgICAgICAgY29kZTogXCJyZXZlcmlmaWNhdGlvbl9jYW5jZWxsZWRcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlcnMucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHBhcmFtcy5vbk5lZWRzUmV2ZXJpZmljYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgICAgIHBhcmFtcy5vcGVuVUlDb21wb25lbnQ/Lih7XG4gICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgIGFmdGVyVmVyaWZpY2F0aW9uOiBjb21wbGV0ZSxcbiAgICAgICAgICAgIGFmdGVyVmVyaWZpY2F0aW9uQ2FuY2VsbGVkOiBjYW5jZWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJhbXMub25OZWVkc1JldmVyaWZpY2F0aW9uKHtcbiAgICAgICAgICAgIGNhbmNlbCxcbiAgICAgICAgICAgIGNvbXBsZXRlLFxuICAgICAgICAgICAgbGV2ZWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCByZXNvbHZlcnMucHJvbWlzZTtcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgcmVzb2x2ZVJlc3VsdChmZXRjaGVyKC4uLmFyZ3MpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gYXNzZXJ0UmV2ZXJpZmljYXRpb247XG59XG52YXIgdXNlUmV2ZXJpZmljYXRpb24gPSAoZmV0Y2hlciwgb3B0aW9ucykgPT4ge1xuICBjb25zdCB7IF9faW50ZXJuYWxfb3BlblJldmVyaWZpY2F0aW9uLCB0ZWxlbWV0cnkgfSA9IHVzZUNsZXJrKCk7XG4gIGNvbnN0IGZldGNoZXJSZWYgPSB1c2VSZWYzKGZldGNoZXIpO1xuICBjb25zdCBvcHRpb25zUmVmID0gdXNlUmVmMyhvcHRpb25zKTtcbiAgdGVsZW1ldHJ5Py5yZWNvcmQoXG4gICAgZXZlbnRNZXRob2RDYWxsZWQoXCJ1c2VSZXZlcmlmaWNhdGlvblwiLCB7XG4gICAgICBvbk5lZWRzUmV2ZXJpZmljYXRpb246IEJvb2xlYW4ob3B0aW9ucz8ub25OZWVkc1JldmVyaWZpY2F0aW9uKVxuICAgIH0pXG4gICk7XG4gIHVzZVNhZmVMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGZldGNoZXJSZWYuY3VycmVudCA9IGZldGNoZXI7XG4gICAgb3B0aW9uc1JlZi5jdXJyZW50ID0gb3B0aW9ucztcbiAgfSk7XG4gIHJldHVybiB1c2VDYWxsYmFjazIoXG4gICAgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBjcmVhdGVSZXZlcmlmaWNhdGlvbkhhbmRsZXIoe1xuICAgICAgICBvcGVuVUlDb21wb25lbnQ6IF9faW50ZXJuYWxfb3BlblJldmVyaWZpY2F0aW9uLFxuICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgIC4uLm9wdGlvbnNSZWYuY3VycmVudFxuICAgICAgfSkoZmV0Y2hlclJlZi5jdXJyZW50KTtcbiAgICAgIHJldHVybiBoYW5kbGVyKC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgW19faW50ZXJuYWxfb3BlblJldmVyaWZpY2F0aW9uLCB0ZWxlbWV0cnldXG4gICk7XG59O1xuXG4vLyBzcmMvcmVhY3QvaG9va3MvY3JlYXRlQmlsbGluZ1BhZ2luYXRlZEhvb2sudHN4XG5mdW5jdGlvbiBjcmVhdGVCaWxsaW5nUGFnaW5hdGVkSG9vayh7XG4gIGhvb2tOYW1lOiBob29rTmFtZTUsXG4gIHJlc291cmNlVHlwZSxcbiAgdXNlRmV0Y2hlcixcbiAgb3B0aW9uc1xufSkge1xuICByZXR1cm4gZnVuY3Rpb24gdXNlQmlsbGluZ0hvb2socGFyYW1zKSB7XG4gICAgY29uc3QgeyBmb3I6IF9mb3IsIC4uLnBhZ2luYXRpb25QYXJhbXMgfSA9IHBhcmFtcyB8fCB7fTtcbiAgICB1c2VBc3NlcnRXcmFwcGVkQnlDbGVya1Byb3ZpZGVyKGhvb2tOYW1lNSk7XG4gICAgY29uc3QgZmV0Y2hGbiA9IHVzZUZldGNoZXIoX2ZvciB8fCBcInVzZXJcIik7XG4gICAgY29uc3Qgc2FmZVZhbHVlcyA9IHVzZVdpdGhTYWZlVmFsdWVzKHBhZ2luYXRpb25QYXJhbXMsIHtcbiAgICAgIGluaXRpYWxQYWdlOiAxLFxuICAgICAgcGFnZVNpemU6IDEwLFxuICAgICAga2VlcFByZXZpb3VzRGF0YTogZmFsc2UsXG4gICAgICBpbmZpbml0ZTogZmFsc2UsXG4gICAgICBfX2V4cGVyaW1lbnRhbF9tb2RlOiB2b2lkIDBcbiAgICB9KTtcbiAgICBjb25zdCBjbGVyayA9IHVzZUNsZXJrSW5zdGFuY2VDb250ZXh0KCk7XG4gICAgY29uc3QgZW52aXJvbm1lbnQgPSBjbGVyay5fX3Vuc3RhYmxlX19lbnZpcm9ubWVudDtcbiAgICBjb25zdCB1c2VyID0gdXNlVXNlckNvbnRleHQoKTtcbiAgICBjb25zdCB7IG9yZ2FuaXphdGlvbiB9ID0gdXNlT3JnYW5pemF0aW9uQ29udGV4dCgpO1xuICAgIGNsZXJrLnRlbGVtZXRyeT8ucmVjb3JkKGV2ZW50TWV0aG9kQ2FsbGVkKGhvb2tOYW1lNSkpO1xuICAgIGNvbnN0IGhvb2tQYXJhbXMgPSB0eXBlb2YgcGFnaW5hdGlvblBhcmFtcyA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IHtcbiAgICAgIGluaXRpYWxQYWdlOiBzYWZlVmFsdWVzLmluaXRpYWxQYWdlLFxuICAgICAgcGFnZVNpemU6IHNhZmVWYWx1ZXMucGFnZVNpemUsXG4gICAgICAuLi5vcHRpb25zPy51bmF1dGhlbnRpY2F0ZWQgPyB7fSA6IF9mb3IgPT09IFwib3JnYW5pemF0aW9uXCIgPyB7IG9yZ0lkOiBvcmdhbml6YXRpb24/LmlkIH0gOiB7fVxuICAgIH07XG4gICAgY29uc3QgaXNPcmdhbml6YXRpb24gPSBfZm9yID09PSBcIm9yZ2FuaXphdGlvblwiO1xuICAgIGNvbnN0IGJpbGxpbmdFbmFibGVkID0gaXNPcmdhbml6YXRpb24gPyBlbnZpcm9ubWVudD8uY29tbWVyY2VTZXR0aW5ncy5iaWxsaW5nLm9yZ2FuaXphdGlvbi5lbmFibGVkIDogZW52aXJvbm1lbnQ/LmNvbW1lcmNlU2V0dGluZ3MuYmlsbGluZy51c2VyLmVuYWJsZWQ7XG4gICAgY29uc3QgaXNFbmFibGVkID0gISFob29rUGFyYW1zICYmIGNsZXJrLmxvYWRlZCAmJiAhIWJpbGxpbmdFbmFibGVkO1xuICAgIGNvbnN0IHJlc3VsdCA9IHVzZVBhZ2VzT3JJbmZpbml0ZShcbiAgICAgIGhvb2tQYXJhbXMgfHwge30sXG4gICAgICBmZXRjaEZuLFxuICAgICAge1xuICAgICAgICBrZWVwUHJldmlvdXNEYXRhOiBzYWZlVmFsdWVzLmtlZXBQcmV2aW91c0RhdGEsXG4gICAgICAgIGluZmluaXRlOiBzYWZlVmFsdWVzLmluZmluaXRlLFxuICAgICAgICBlbmFibGVkOiBpc0VuYWJsZWQsXG4gICAgICAgIC4uLm9wdGlvbnM/LnVuYXV0aGVudGljYXRlZCA/IHt9IDogeyBpc1NpZ25lZEluOiBCb29sZWFuKHVzZXIpIH0sXG4gICAgICAgIF9fZXhwZXJpbWVudGFsX21vZGU6IHNhZmVWYWx1ZXMuX19leHBlcmltZW50YWxfbW9kZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdHlwZTogcmVzb3VyY2VUeXBlLFxuICAgICAgICAvLyB1c2VySWQ6IHVzZXI/LmlkLFxuICAgICAgICAuLi5vcHRpb25zPy51bmF1dGhlbnRpY2F0ZWQgPyB7fSA6IHtcbiAgICAgICAgICB1c2VySWQ6IHVzZXI/LmlkLFxuICAgICAgICAgIC4uLl9mb3IgPT09IFwib3JnYW5pemF0aW9uXCIgPyB7IG9yZ0lkOiBvcmdhbml6YXRpb24/LmlkIH0gOiB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vLyBzcmMvcmVhY3QvaG9va3MvdXNlU3RhdGVtZW50cy50c3hcbnZhciB1c2VTdGF0ZW1lbnRzID0gY3JlYXRlQmlsbGluZ1BhZ2luYXRlZEhvb2soe1xuICBob29rTmFtZTogXCJ1c2VTdGF0ZW1lbnRzXCIsXG4gIHJlc291cmNlVHlwZTogXCJiaWxsaW5nLXN0YXRlbWVudHNcIixcbiAgdXNlRmV0Y2hlcjogKCkgPT4ge1xuICAgIGNvbnN0IGNsZXJrID0gdXNlQ2xlcmtJbnN0YW5jZUNvbnRleHQoKTtcbiAgICBpZiAoY2xlcmsubG9hZGVkKSB7XG4gICAgICByZXR1cm4gY2xlcmsuYmlsbGluZy5nZXRTdGF0ZW1lbnRzO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59KTtcblxuLy8gc3JjL3JlYWN0L2hvb2tzL3VzZVBheW1lbnRBdHRlbXB0cy50c3hcbnZhciB1c2VQYXltZW50QXR0ZW1wdHMgPSBjcmVhdGVCaWxsaW5nUGFnaW5hdGVkSG9vayh7XG4gIGhvb2tOYW1lOiBcInVzZVBheW1lbnRBdHRlbXB0c1wiLFxuICByZXNvdXJjZVR5cGU6IFwiYmlsbGluZy1wYXltZW50LWF0dGVtcHRzXCIsXG4gIHVzZUZldGNoZXI6ICgpID0+IHtcbiAgICBjb25zdCBjbGVyayA9IHVzZUNsZXJrSW5zdGFuY2VDb250ZXh0KCk7XG4gICAgaWYgKGNsZXJrLmxvYWRlZCkge1xuICAgICAgcmV0dXJuIGNsZXJrLmJpbGxpbmcuZ2V0UGF5bWVudEF0dGVtcHRzO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59KTtcblxuLy8gc3JjL3JlYWN0L2hvb2tzL3VzZVBheW1lbnRNZXRob2RzLnRzeFxudmFyIHVzZVBheW1lbnRNZXRob2RzID0gY3JlYXRlQmlsbGluZ1BhZ2luYXRlZEhvb2soe1xuICBob29rTmFtZTogXCJ1c2VQYXltZW50TWV0aG9kc1wiLFxuICByZXNvdXJjZVR5cGU6IFwiY29tbWVyY2UtcGF5bWVudC1tZXRob2RzXCIsXG4gIHVzZUZldGNoZXI6IChyZXNvdXJjZSkgPT4ge1xuICAgIGNvbnN0IHsgb3JnYW5pemF0aW9uIH0gPSB1c2VPcmdhbml6YXRpb25Db250ZXh0KCk7XG4gICAgY29uc3QgdXNlciA9IHVzZVVzZXJDb250ZXh0KCk7XG4gICAgaWYgKHJlc291cmNlID09PSBcIm9yZ2FuaXphdGlvblwiKSB7XG4gICAgICByZXR1cm4gb3JnYW5pemF0aW9uPy5nZXRQYXltZW50TWV0aG9kcztcbiAgICB9XG4gICAgcmV0dXJuIHVzZXI/LmdldFBheW1lbnRNZXRob2RzO1xuICB9XG59KTtcblxuLy8gc3JjL3JlYWN0L2hvb2tzL3VzZVBsYW5zLnRzeFxudmFyIHVzZVBsYW5zID0gY3JlYXRlQmlsbGluZ1BhZ2luYXRlZEhvb2soe1xuICBob29rTmFtZTogXCJ1c2VQbGFuc1wiLFxuICByZXNvdXJjZVR5cGU6IFwiYmlsbGluZy1wbGFuc1wiLFxuICB1c2VGZXRjaGVyOiAoX2ZvcikgPT4ge1xuICAgIGNvbnN0IGNsZXJrID0gdXNlQ2xlcmtJbnN0YW5jZUNvbnRleHQoKTtcbiAgICBpZiAoIWNsZXJrLmxvYWRlZCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIChwYXJhbXMpID0+IGNsZXJrLmJpbGxpbmcuZ2V0UGxhbnMoeyAuLi5wYXJhbXMsIGZvcjogX2ZvciB9KTtcbiAgfSxcbiAgb3B0aW9uczoge1xuICAgIHVuYXV0aGVudGljYXRlZDogdHJ1ZVxuICB9XG59KTtcblxuLy8gc3JjL3JlYWN0L2hvb2tzL3VzZVN1YnNjcmlwdGlvbi50c3hcbmltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMyB9IGZyb20gXCJyZWFjdFwiO1xudmFyIGhvb2tOYW1lNCA9IFwidXNlU3Vic2NyaXB0aW9uXCI7XG52YXIgdXNlU3Vic2NyaXB0aW9uID0gKHBhcmFtcykgPT4ge1xuICB1c2VBc3NlcnRXcmFwcGVkQnlDbGVya1Byb3ZpZGVyKGhvb2tOYW1lNCk7XG4gIGNvbnN0IGNsZXJrID0gdXNlQ2xlcmtJbnN0YW5jZUNvbnRleHQoKTtcbiAgY29uc3QgdXNlciA9IHVzZVVzZXJDb250ZXh0KCk7XG4gIGNvbnN0IHsgb3JnYW5pemF0aW9uIH0gPSB1c2VPcmdhbml6YXRpb25Db250ZXh0KCk7XG4gIGNvbnN0IGVudmlyb25tZW50ID0gY2xlcmsuX191bnN0YWJsZV9fZW52aXJvbm1lbnQ7XG4gIGNsZXJrLnRlbGVtZXRyeT8ucmVjb3JkKGV2ZW50TWV0aG9kQ2FsbGVkKGhvb2tOYW1lNCkpO1xuICBjb25zdCBpc09yZ2FuaXphdGlvbiA9IHBhcmFtcz8uZm9yID09PSBcIm9yZ2FuaXphdGlvblwiO1xuICBjb25zdCBiaWxsaW5nRW5hYmxlZCA9IGlzT3JnYW5pemF0aW9uID8gZW52aXJvbm1lbnQ/LmNvbW1lcmNlU2V0dGluZ3MuYmlsbGluZy5vcmdhbml6YXRpb24uZW5hYmxlZCA6IGVudmlyb25tZW50Py5jb21tZXJjZVNldHRpbmdzLmJpbGxpbmcudXNlci5lbmFibGVkO1xuICBjb25zdCBzd3IgPSBkZWZhdWx0MihcbiAgICBiaWxsaW5nRW5hYmxlZCA/IHtcbiAgICAgIHR5cGU6IFwiY29tbWVyY2Utc3Vic2NyaXB0aW9uXCIsXG4gICAgICB1c2VySWQ6IHVzZXI/LmlkLFxuICAgICAgYXJnczogeyBvcmdJZDogaXNPcmdhbml6YXRpb24gPyBvcmdhbml6YXRpb24/LmlkIDogdm9pZCAwIH1cbiAgICB9IDogbnVsbCxcbiAgICAoeyBhcmdzLCB1c2VySWQgfSkgPT4ge1xuICAgICAgaWYgKHVzZXJJZCkge1xuICAgICAgICByZXR1cm4gY2xlcmsuYmlsbGluZy5nZXRTdWJzY3JpcHRpb24oYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHtcbiAgICAgIGRlZHVwaW5nSW50ZXJ2YWw6IDFlMyAqIDYwLFxuICAgICAga2VlcFByZXZpb3VzRGF0YTogcGFyYW1zPy5rZWVwUHJldmlvdXNEYXRhXG4gICAgfVxuICApO1xuICBjb25zdCByZXZhbGlkYXRlID0gdXNlQ2FsbGJhY2szKCgpID0+IHN3ci5tdXRhdGUoKSwgW3N3ci5tdXRhdGVdKTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBzd3IuZGF0YSxcbiAgICBlcnJvcjogc3dyLmVycm9yLFxuICAgIGlzTG9hZGluZzogc3dyLmlzTG9hZGluZyxcbiAgICBpc0ZldGNoaW5nOiBzd3IuaXNWYWxpZGF0aW5nLFxuICAgIHJldmFsaWRhdGVcbiAgfTtcbn07XG5cbi8vIHNyYy9yZWFjdC9ob29rcy91c2VDaGVja291dC50c1xuaW1wb3J0IHsgdXNlTWVtbyBhcyB1c2VNZW1vMiwgdXNlU3luY0V4dGVybmFsU3RvcmUgfSBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VDaGVja291dCA9IChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGNvbnRleHRPcHRpb25zID0gdXNlQ2hlY2tvdXRDb250ZXh0KCk7XG4gIGNvbnN0IHsgZm9yOiBmb3JPcmdhbml6YXRpb24sIHBsYW5JZCwgcGxhblBlcmlvZCB9ID0gb3B0aW9ucyB8fCBjb250ZXh0T3B0aW9ucztcbiAgY29uc3QgY2xlcmsgPSB1c2VDbGVyaygpO1xuICBjb25zdCB7IG9yZ2FuaXphdGlvbiB9ID0gdXNlT3JnYW5pemF0aW9uKCk7XG4gIGNvbnN0IHsgaXNMb2FkZWQsIHVzZXIgfSA9IHVzZVVzZXIoKTtcbiAgaWYgKCFpc0xvYWRlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNsZXJrOiBFbnN1cmUgdGhhdCBgdXNlQ2hlY2tvdXRgIGlzIGluc2lkZSBhIGNvbXBvbmVudCB3cmFwcGVkIHdpdGggYDxDbGVya0xvYWRlZCAvPmAuXCIpO1xuICB9XG4gIGlmICghdXNlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNsZXJrOiBFbnN1cmUgdGhhdCBgdXNlQ2hlY2tvdXRgIGlzIGluc2lkZSBhIGNvbXBvbmVudCB3cmFwcGVkIHdpdGggYDxTaWduZWRJbiAvPmAuXCIpO1xuICB9XG4gIGlmIChmb3JPcmdhbml6YXRpb24gPT09IFwib3JnYW5pemF0aW9uXCIgJiYgIW9yZ2FuaXphdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiQ2xlcms6IEVuc3VyZSB5b3VyIGZsb3cgY2hlY2tzIGZvciBhbiBhY3RpdmUgb3JnYW5pemF0aW9uLiBSZXRyaWV2ZSBgb3JnSWRgIGZyb20gYHVzZUF1dGgoKWAgYW5kIGNvbmZpcm0gaXQgaXMgZGVmaW5lZC4gRm9yIFNTUiwgc2VlOiBodHRwczovL2NsZXJrLmNvbS9kb2NzL3JlZmVyZW5jZS9iYWNrZW5kL3R5cGVzL2F1dGgtb2JqZWN0I2hvdy10by1hY2Nlc3MtdGhlLWF1dGgtb2JqZWN0XCJcbiAgICApO1xuICB9XG4gIGNvbnN0IG1hbmFnZXIgPSB1c2VNZW1vMihcbiAgICAoKSA9PiBjbGVyay5fX2V4cGVyaW1lbnRhbF9jaGVja291dCh7IHBsYW5JZCwgcGxhblBlcmlvZCwgZm9yOiBmb3JPcmdhbml6YXRpb24gfSksXG4gICAgW3VzZXIuaWQsIG9yZ2FuaXphdGlvbj8uaWQsIHBsYW5JZCwgcGxhblBlcmlvZCwgZm9yT3JnYW5pemF0aW9uXVxuICApO1xuICBjb25zdCBtYW5hZ2VyUHJvcGVydGllcyA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgIChjYikgPT4gbWFuYWdlci5zdWJzY3JpYmUoY2IpLFxuICAgICgpID0+IG1hbmFnZXIuZ2V0U3RhdGUoKSxcbiAgICAoKSA9PiBtYW5hZ2VyLmdldFN0YXRlKClcbiAgKTtcbiAgY29uc3QgcHJvcGVydGllcyA9IHVzZU1lbW8yKCgpID0+IHtcbiAgICBpZiAoIW1hbmFnZXJQcm9wZXJ0aWVzLmNoZWNrb3V0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogbnVsbCxcbiAgICAgICAgZXh0ZXJuYWxDbGllbnRTZWNyZXQ6IG51bGwsXG4gICAgICAgIGV4dGVybmFsR2F0ZXdheUlkOiBudWxsLFxuICAgICAgICBzdGF0dXM6IG51bGwsXG4gICAgICAgIHRvdGFsczogbnVsbCxcbiAgICAgICAgaXNJbW1lZGlhdGVQbGFuQ2hhbmdlOiBudWxsLFxuICAgICAgICBwbGFuUGVyaW9kOiBudWxsLFxuICAgICAgICBwbGFuOiBudWxsLFxuICAgICAgICBwYXltZW50TWV0aG9kOiBudWxsLFxuICAgICAgICBmcmVlVHJpYWxFbmRzQXQ6IG51bGwsXG4gICAgICAgIHBheWVyOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICByZWxvYWQsXG4gICAgICBjb25maXJtLFxuICAgICAgcGF0aFJvb3QsXG4gICAgICAvLyBBbGwgdGhlIGFib3ZlIG5lZWQgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBwcm9wZXJ0aWVzXG4gICAgICAuLi5yZXN0XG4gICAgfSA9IG1hbmFnZXJQcm9wZXJ0aWVzLmNoZWNrb3V0O1xuICAgIHJldHVybiByZXN0O1xuICB9LCBbbWFuYWdlclByb3BlcnRpZXMuY2hlY2tvdXRdKTtcbiAgY29uc3QgY2hlY2tvdXQgPSB7XG4gICAgLi4ucHJvcGVydGllcyxcbiAgICBnZXRTdGF0ZTogbWFuYWdlci5nZXRTdGF0ZSxcbiAgICBzdGFydDogbWFuYWdlci5zdGFydCxcbiAgICBjb25maXJtOiBtYW5hZ2VyLmNvbmZpcm0sXG4gICAgY2xlYXI6IG1hbmFnZXIuY2xlYXIsXG4gICAgZmluYWxpemU6IG1hbmFnZXIuZmluYWxpemUsXG4gICAgaXNTdGFydGluZzogbWFuYWdlclByb3BlcnRpZXMuaXNTdGFydGluZyxcbiAgICBpc0NvbmZpcm1pbmc6IG1hbmFnZXJQcm9wZXJ0aWVzLmlzQ29uZmlybWluZyxcbiAgICBlcnJvcjogbWFuYWdlclByb3BlcnRpZXMuZXJyb3IsXG4gICAgc3RhdHVzOiBtYW5hZ2VyUHJvcGVydGllcy5zdGF0dXMsXG4gICAgZmV0Y2hTdGF0dXM6IG1hbmFnZXJQcm9wZXJ0aWVzLmZldGNoU3RhdHVzXG4gIH07XG4gIHJldHVybiB7XG4gICAgY2hlY2tvdXRcbiAgfTtcbn07XG5cbi8vIHNyYy9yZWFjdC9jb21tZXJjZS50c3hcbmltcG9ydCBSZWFjdDYsIHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2s0LCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MiwgdXNlTWVtbyBhcyB1c2VNZW1vMywgdXNlU3RhdGUgYXMgdXNlU3RhdGUzIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdXNlU1dSIGZyb20gXCJzd3JcIjtcbmltcG9ydCB1c2VTV1JNdXRhdGlvbiBmcm9tIFwic3dyL211dGF0aW9uXCI7XG5cbi8vIHNyYy9yZWFjdC9zdHJpcGUtcmVhY3QvaW5kZXgudHN4XG5pbXBvcnQgUmVhY3Q1LCB7IHVzZVN0YXRlIGFzIHVzZVN0YXRlMiB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvcmVhY3Qvc3RyaXBlLXJlYWN0L3V0aWxzLnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiBhcyB1c2VSZWY0IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlUHJldmlvdXMgPSAodmFsdWUpID0+IHtcbiAgY29uc3QgcmVmID0gdXNlUmVmNCh2YWx1ZSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiByZWYuY3VycmVudDtcbn07XG52YXIgdXNlQXR0YWNoRXZlbnQgPSAoZWxlbWVudCwgZXZlbnQsIGNiKSA9PiB7XG4gIGNvbnN0IGNiRGVmaW5lZCA9ICEhY2I7XG4gIGNvbnN0IGNiUmVmID0gdXNlUmVmNChjYik7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY2JSZWYuY3VycmVudCA9IGNiO1xuICB9LCBbY2JdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNiRGVmaW5lZCB8fCAhZWxlbWVudCkge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGRlY29yYXRlZENiID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIGlmIChjYlJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNiUmVmLmN1cnJlbnQoLi4uYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBlbGVtZW50Lm9uKGV2ZW50LCBkZWNvcmF0ZWRDYik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGVsZW1lbnQub2ZmKGV2ZW50LCBkZWNvcmF0ZWRDYik7XG4gICAgfTtcbiAgfSwgW2NiRGVmaW5lZCwgZXZlbnQsIGVsZW1lbnQsIGNiUmVmXSk7XG59O1xuXG4vLyBzcmMvcmVhY3Qvc3RyaXBlLXJlYWN0L2luZGV4LnRzeFxudmFyIEVsZW1lbnRzQ29udGV4dCA9IFJlYWN0NS5jcmVhdGVDb250ZXh0KG51bGwpO1xuRWxlbWVudHNDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJFbGVtZW50c0NvbnRleHRcIjtcbnZhciBwYXJzZUVsZW1lbnRzQ29udGV4dCA9IChjdHgsIHVzZUNhc2UpID0+IHtcbiAgaWYgKCFjdHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ291bGQgbm90IGZpbmQgRWxlbWVudHMgY29udGV4dDsgWW91IG5lZWQgdG8gd3JhcCB0aGUgcGFydCBvZiB5b3VyIGFwcCB0aGF0ICR7dXNlQ2FzZX0gaW4gYW4gPEVsZW1lbnRzPiBwcm92aWRlci5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY3R4O1xufTtcbnZhciBFbGVtZW50cyA9ICh7XG4gIHN0cmlwZTogcmF3U3RyaXBlUHJvcCxcbiAgb3B0aW9ucyxcbiAgY2hpbGRyZW5cbn0pID0+IHtcbiAgY29uc3QgcGFyc2VkID0gUmVhY3Q1LnVzZU1lbW8oKCkgPT4gcGFyc2VTdHJpcGVQcm9wKHJhd1N0cmlwZVByb3ApLCBbcmF3U3RyaXBlUHJvcF0pO1xuICBjb25zdCBbY3R4LCBzZXRDb250ZXh0XSA9IFJlYWN0NS51c2VTdGF0ZSgoKSA9PiAoe1xuICAgIHN0cmlwZTogcGFyc2VkLnRhZyA9PT0gXCJzeW5jXCIgPyBwYXJzZWQuc3RyaXBlIDogbnVsbCxcbiAgICBlbGVtZW50czogcGFyc2VkLnRhZyA9PT0gXCJzeW5jXCIgPyBwYXJzZWQuc3RyaXBlLmVsZW1lbnRzKG9wdGlvbnMpIDogbnVsbFxuICB9KSk7XG4gIFJlYWN0NS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBpc01vdW50ZWQgPSB0cnVlO1xuICAgIGNvbnN0IHNhZmVTZXRDb250ZXh0ID0gKHN0cmlwZSkgPT4ge1xuICAgICAgc2V0Q29udGV4dCgoY3R4MikgPT4ge1xuICAgICAgICBpZiAoY3R4Mi5zdHJpcGUpIHtcbiAgICAgICAgICByZXR1cm4gY3R4MjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0cmlwZSxcbiAgICAgICAgICBlbGVtZW50czogc3RyaXBlLmVsZW1lbnRzKG9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChwYXJzZWQudGFnID09PSBcImFzeW5jXCIgJiYgIWN0eC5zdHJpcGUpIHtcbiAgICAgIHBhcnNlZC5zdHJpcGVQcm9taXNlLnRoZW4oKHN0cmlwZSkgPT4ge1xuICAgICAgICBpZiAoc3RyaXBlICYmIGlzTW91bnRlZCkge1xuICAgICAgICAgIHNhZmVTZXRDb250ZXh0KHN0cmlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLnRhZyA9PT0gXCJzeW5jXCIgJiYgIWN0eC5zdHJpcGUpIHtcbiAgICAgIHNhZmVTZXRDb250ZXh0KHBhcnNlZC5zdHJpcGUpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW3BhcnNlZCwgY3R4LCBvcHRpb25zXSk7XG4gIGNvbnN0IHByZXZTdHJpcGUgPSB1c2VQcmV2aW91cyhyYXdTdHJpcGVQcm9wKTtcbiAgUmVhY3Q1LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHByZXZTdHJpcGUgIT09IG51bGwgJiYgcHJldlN0cmlwZSAhPT0gcmF3U3RyaXBlUHJvcCkge1xuICAgICAgY29uc29sZS53YXJuKFwiVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2Ugb24gRWxlbWVudHM6IFlvdSBjYW5ub3QgY2hhbmdlIHRoZSBgc3RyaXBlYCBwcm9wIGFmdGVyIHNldHRpbmcgaXQuXCIpO1xuICAgIH1cbiAgfSwgW3ByZXZTdHJpcGUsIHJhd1N0cmlwZVByb3BdKTtcbiAgY29uc3QgcHJldk9wdGlvbnMgPSB1c2VQcmV2aW91cyhvcHRpb25zKTtcbiAgUmVhY3Q1LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjdHguZWxlbWVudHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlcyA9IGV4dHJhY3RBbGxvd2VkT3B0aW9uc1VwZGF0ZXMob3B0aW9ucywgcHJldk9wdGlvbnMsIFtcImNsaWVudFNlY3JldFwiLCBcImZvbnRzXCJdKTtcbiAgICBpZiAodXBkYXRlcykge1xuICAgICAgY3R4LmVsZW1lbnRzLnVwZGF0ZSh1cGRhdGVzKTtcbiAgICB9XG4gIH0sIFtvcHRpb25zLCBwcmV2T3B0aW9ucywgY3R4LmVsZW1lbnRzXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoRWxlbWVudHNDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjdHggfSwgY2hpbGRyZW4pO1xufTtcbnZhciB1c2VFbGVtZW50c0NvbnRleHRXaXRoVXNlQ2FzZSA9ICh1c2VDYXNlTWVzc2FnZSkgPT4ge1xuICBjb25zdCBjdHggPSBSZWFjdDUudXNlQ29udGV4dChFbGVtZW50c0NvbnRleHQpO1xuICByZXR1cm4gcGFyc2VFbGVtZW50c0NvbnRleHQoY3R4LCB1c2VDYXNlTWVzc2FnZSk7XG59O1xudmFyIHVzZUVsZW1lbnRzID0gKCkgPT4ge1xuICBjb25zdCB7IGVsZW1lbnRzIH0gPSB1c2VFbGVtZW50c0NvbnRleHRXaXRoVXNlQ2FzZShcImNhbGxzIHVzZUVsZW1lbnRzKClcIik7XG4gIHJldHVybiBlbGVtZW50cztcbn07XG52YXIgSU5WQUxJRF9TVFJJUEVfRVJST1IgPSBcIkludmFsaWQgcHJvcCBgc3RyaXBlYCBzdXBwbGllZCB0byBgRWxlbWVudHNgLiBXZSByZWNvbW1lbmQgdXNpbmcgdGhlIGBsb2FkU3RyaXBlYCB1dGlsaXR5IGZyb20gYEBzdHJpcGUvc3RyaXBlLWpzYC4gU2VlIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50cy1wcm9wcy1zdHJpcGUgZm9yIGRldGFpbHMuXCI7XG52YXIgdmFsaWRhdGVTdHJpcGUgPSAobWF5YmVTdHJpcGUsIGVycm9yTXNnID0gSU5WQUxJRF9TVFJJUEVfRVJST1IpID0+IHtcbiAgaWYgKG1heWJlU3RyaXBlID09PSBudWxsIHx8IGlzU3RyaXBlKG1heWJlU3RyaXBlKSkge1xuICAgIHJldHVybiBtYXliZVN0cmlwZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpO1xufTtcbnZhciBwYXJzZVN0cmlwZVByb3AgPSAocmF3LCBlcnJvck1zZyA9IElOVkFMSURfU1RSSVBFX0VSUk9SKSA9PiB7XG4gIGlmIChpc1Byb21pc2UocmF3KSkge1xuICAgIHJldHVybiB7XG4gICAgICB0YWc6IFwiYXN5bmNcIixcbiAgICAgIHN0cmlwZVByb21pc2U6IFByb21pc2UucmVzb2x2ZShyYXcpLnRoZW4oKHJlc3VsdCkgPT4gdmFsaWRhdGVTdHJpcGUocmVzdWx0LCBlcnJvck1zZykpXG4gICAgfTtcbiAgfVxuICBjb25zdCBzdHJpcGUgPSB2YWxpZGF0ZVN0cmlwZShyYXcsIGVycm9yTXNnKTtcbiAgaWYgKHN0cmlwZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7IHRhZzogXCJlbXB0eVwiIH07XG4gIH1cbiAgcmV0dXJuIHsgdGFnOiBcInN5bmNcIiwgc3RyaXBlIH07XG59O1xudmFyIGlzVW5rbm93bk9iamVjdCA9IChyYXcpID0+IHtcbiAgcmV0dXJuIHJhdyAhPT0gbnVsbCAmJiB0eXBlb2YgcmF3ID09PSBcIm9iamVjdFwiO1xufTtcbnZhciBpc1Byb21pc2UgPSAocmF3KSA9PiB7XG4gIHJldHVybiBpc1Vua25vd25PYmplY3QocmF3KSAmJiB0eXBlb2YgcmF3LnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn07XG52YXIgaXNTdHJpcGUgPSAocmF3KSA9PiB7XG4gIHJldHVybiBpc1Vua25vd25PYmplY3QocmF3KSAmJiB0eXBlb2YgcmF3LmVsZW1lbnRzID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHJhdy5jcmVhdGVUb2tlbiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiByYXcuY3JlYXRlUGF5bWVudE1ldGhvZCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiByYXcuY29uZmlybUNhcmRQYXltZW50ID09PSBcImZ1bmN0aW9uXCI7XG59O1xudmFyIGV4dHJhY3RBbGxvd2VkT3B0aW9uc1VwZGF0ZXMgPSAob3B0aW9ucywgcHJldk9wdGlvbnMsIGltbXV0YWJsZUtleXMpID0+IHtcbiAgaWYgKCFpc1Vua25vd25PYmplY3Qob3B0aW9ucykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmtleXMob3B0aW9ucykucmVkdWNlKChuZXdPcHRpb25zLCBrZXkpID0+IHtcbiAgICBjb25zdCBpc1VwZGF0ZWQgPSAhaXNVbmtub3duT2JqZWN0KHByZXZPcHRpb25zKSB8fCAhaXNFcXVhbChvcHRpb25zW2tleV0sIHByZXZPcHRpb25zW2tleV0pO1xuICAgIGlmIChpbW11dGFibGVLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIGlmIChpc1VwZGF0ZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZTogb3B0aW9ucy4ke2tleX0gaXMgbm90IGEgbXV0YWJsZSBwcm9wZXJ0eS5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdPcHRpb25zO1xuICAgIH1cbiAgICBpZiAoIWlzVXBkYXRlZCkge1xuICAgICAgcmV0dXJuIG5ld09wdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiB7IC4uLm5ld09wdGlvbnMgfHwge30sIFtrZXldOiBvcHRpb25zW2tleV0gfTtcbiAgfSwgbnVsbCk7XG59O1xudmFyIFBMQUlOX09CSkVDVF9TVFIgPSBcIltvYmplY3QgT2JqZWN0XVwiO1xudmFyIGlzRXF1YWwgPSAobGVmdCwgcmlnaHQpID0+IHtcbiAgaWYgKCFpc1Vua25vd25PYmplY3QobGVmdCkgfHwgIWlzVW5rbm93bk9iamVjdChyaWdodCkpIHtcbiAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7XG4gIH1cbiAgY29uc3QgbGVmdEFycmF5ID0gQXJyYXkuaXNBcnJheShsZWZ0KTtcbiAgY29uc3QgcmlnaHRBcnJheSA9IEFycmF5LmlzQXJyYXkocmlnaHQpO1xuICBpZiAobGVmdEFycmF5ICE9PSByaWdodEFycmF5KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGxlZnRQbGFpbk9iamVjdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChsZWZ0KSA9PT0gUExBSU5fT0JKRUNUX1NUUjtcbiAgY29uc3QgcmlnaHRQbGFpbk9iamVjdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyaWdodCkgPT09IFBMQUlOX09CSkVDVF9TVFI7XG4gIGlmIChsZWZ0UGxhaW5PYmplY3QgIT09IHJpZ2h0UGxhaW5PYmplY3QpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFsZWZ0UGxhaW5PYmplY3QgJiYgIWxlZnRBcnJheSkge1xuICAgIHJldHVybiBsZWZ0ID09PSByaWdodDtcbiAgfVxuICBjb25zdCBsZWZ0S2V5cyA9IE9iamVjdC5rZXlzKGxlZnQpO1xuICBjb25zdCByaWdodEtleXMgPSBPYmplY3Qua2V5cyhyaWdodCk7XG4gIGlmIChsZWZ0S2V5cy5sZW5ndGggIT09IHJpZ2h0S2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qga2V5U2V0ID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdEtleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBrZXlTZXRbbGVmdEtleXNbaV1dID0gdHJ1ZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJpZ2h0S2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGtleVNldFtyaWdodEtleXNbaV1dID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBhbGxLZXlzID0gT2JqZWN0LmtleXMoa2V5U2V0KTtcbiAgaWYgKGFsbEtleXMubGVuZ3RoICE9PSBsZWZ0S2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbCA9IGxlZnQ7XG4gIGNvbnN0IHIgPSByaWdodDtcbiAgY29uc3QgcHJlZCA9IChrZXkpID0+IHtcbiAgICByZXR1cm4gaXNFcXVhbChsW2tleV0sIHJba2V5XSk7XG4gIH07XG4gIHJldHVybiBhbGxLZXlzLmV2ZXJ5KHByZWQpO1xufTtcbnZhciB1c2VTdHJpcGUgPSAoKSA9PiB7XG4gIGNvbnN0IHsgc3RyaXBlIH0gPSB1c2VFbGVtZW50c09yQ2hlY2tvdXRTZGtDb250ZXh0V2l0aFVzZUNhc2UoXCJjYWxscyB1c2VTdHJpcGUoKVwiKTtcbiAgcmV0dXJuIHN0cmlwZTtcbn07XG52YXIgdXNlRWxlbWVudHNPckNoZWNrb3V0U2RrQ29udGV4dFdpdGhVc2VDYXNlID0gKHVzZUNhc2VTdHJpbmcpID0+IHtcbiAgY29uc3QgZWxlbWVudHNDb250ZXh0ID0gUmVhY3Q1LnVzZUNvbnRleHQoRWxlbWVudHNDb250ZXh0KTtcbiAgcmV0dXJuIHBhcnNlRWxlbWVudHNDb250ZXh0KGVsZW1lbnRzQ29udGV4dCwgdXNlQ2FzZVN0cmluZyk7XG59O1xudmFyIGNhcGl0YWxpemVkID0gKHN0cikgPT4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xudmFyIGNyZWF0ZUVsZW1lbnRDb21wb25lbnQgPSAodHlwZSwgaXNTZXJ2ZXIyKSA9PiB7XG4gIGNvbnN0IGRpc3BsYXlOYW1lID0gYCR7Y2FwaXRhbGl6ZWQodHlwZSl9RWxlbWVudGA7XG4gIGNvbnN0IENsaWVudEVsZW1lbnQgPSAoe1xuICAgIGlkLFxuICAgIGNsYXNzTmFtZSxcbiAgICBmYWxsYmFjayxcbiAgICBvcHRpb25zID0ge30sXG4gICAgb25CbHVyLFxuICAgIG9uRm9jdXMsXG4gICAgb25SZWFkeSxcbiAgICBvbkNoYW5nZSxcbiAgICBvbkVzY2FwZSxcbiAgICBvbkNsaWNrLFxuICAgIG9uTG9hZEVycm9yLFxuICAgIG9uTG9hZGVyU3RhcnQsXG4gICAgb25OZXR3b3Jrc0NoYW5nZSxcbiAgICBvbkNvbmZpcm0sXG4gICAgb25DYW5jZWwsXG4gICAgb25TaGlwcGluZ0FkZHJlc3NDaGFuZ2UsXG4gICAgb25TaGlwcGluZ1JhdGVDaGFuZ2VcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGN0eCA9IHVzZUVsZW1lbnRzT3JDaGVja291dFNka0NvbnRleHRXaXRoVXNlQ2FzZShgbW91bnRzIDwke2Rpc3BsYXlOYW1lfT5gKTtcbiAgICBjb25zdCBlbGVtZW50cyA9IFwiZWxlbWVudHNcIiBpbiBjdHggPyBjdHguZWxlbWVudHMgOiBudWxsO1xuICAgIGNvbnN0IFtlbGVtZW50LCBzZXRFbGVtZW50XSA9IFJlYWN0NS51c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBlbGVtZW50UmVmID0gUmVhY3Q1LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBkb21Ob2RlID0gUmVhY3Q1LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBbaXNSZWFkeSwgc2V0UmVhZHldID0gdXNlU3RhdGUyKGZhbHNlKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCBcImJsdXJcIiwgb25CbHVyKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCBcImZvY3VzXCIsIG9uRm9jdXMpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsIFwiZXNjYXBlXCIsIG9uRXNjYXBlKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCBcImNsaWNrXCIsIG9uQ2xpY2spO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsIFwibG9hZGVycm9yXCIsIG9uTG9hZEVycm9yKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCBcImxvYWRlcnN0YXJ0XCIsIG9uTG9hZGVyU3RhcnQpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsIFwibmV0d29ya3NjaGFuZ2VcIiwgb25OZXR3b3Jrc0NoYW5nZSk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgXCJjb25maXJtXCIsIG9uQ29uZmlybSk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgXCJjYW5jZWxcIiwgb25DYW5jZWwpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsIFwic2hpcHBpbmdhZGRyZXNzY2hhbmdlXCIsIG9uU2hpcHBpbmdBZGRyZXNzQ2hhbmdlKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCBcInNoaXBwaW5ncmF0ZWNoYW5nZVwiLCBvblNoaXBwaW5nUmF0ZUNoYW5nZSk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgXCJjaGFuZ2VcIiwgb25DaGFuZ2UpO1xuICAgIGxldCByZWFkeUNhbGxiYWNrO1xuICAgIGlmIChvblJlYWR5KSB7XG4gICAgICByZWFkeUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICBzZXRSZWFkeSh0cnVlKTtcbiAgICAgICAgb25SZWFkeShlbGVtZW50KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsIFwicmVhZHlcIiwgcmVhZHlDYWxsYmFjayk7XG4gICAgUmVhY3Q1LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoZWxlbWVudFJlZi5jdXJyZW50ID09PSBudWxsICYmIGRvbU5vZGUuY3VycmVudCAhPT0gbnVsbCAmJiBlbGVtZW50cykge1xuICAgICAgICBsZXQgbmV3RWxlbWVudCA9IG51bGw7XG4gICAgICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICAgIG5ld0VsZW1lbnQgPSBlbGVtZW50cy5jcmVhdGUodHlwZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50ID0gbmV3RWxlbWVudDtcbiAgICAgICAgc2V0RWxlbWVudChuZXdFbGVtZW50KTtcbiAgICAgICAgaWYgKG5ld0VsZW1lbnQpIHtcbiAgICAgICAgICBuZXdFbGVtZW50Lm1vdW50KGRvbU5vZGUuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbZWxlbWVudHMsIG9wdGlvbnNdKTtcbiAgICBjb25zdCBwcmV2T3B0aW9ucyA9IHVzZVByZXZpb3VzKG9wdGlvbnMpO1xuICAgIFJlYWN0NS51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKCFlbGVtZW50UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdXBkYXRlcyA9IGV4dHJhY3RBbGxvd2VkT3B0aW9uc1VwZGF0ZXMob3B0aW9ucywgcHJldk9wdGlvbnMsIFtcInBheW1lbnRSZXF1ZXN0XCJdKTtcbiAgICAgIGlmICh1cGRhdGVzICYmIFwidXBkYXRlXCIgaW4gZWxlbWVudFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGVsZW1lbnRSZWYuY3VycmVudC51cGRhdGUodXBkYXRlcyk7XG4gICAgICB9XG4gICAgfSwgW29wdGlvbnMsIHByZXZPcHRpb25zXSk7XG4gICAgUmVhY3Q1LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudFJlZi5jdXJyZW50ICYmIHR5cGVvZiBlbGVtZW50UmVmLmN1cnJlbnQuZGVzdHJveSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVsZW1lbnRSZWYuY3VycmVudC5kZXN0cm95KCk7XG4gICAgICAgICAgICBlbGVtZW50UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChSZWFjdDUuRnJhZ21lbnQsIG51bGwsICFpc1JlYWR5ICYmIGZhbGxiYWNrLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBpZCxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBoZWlnaHQ6IGlzUmVhZHkgPyBcInVuc2V0XCIgOiBcIjBweFwiLFxuICAgICAgICAgIHZpc2liaWxpdHk6IGlzUmVhZHkgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICByZWY6IGRvbU5vZGVcbiAgICAgIH1cbiAgICApKTtcbiAgfTtcbiAgY29uc3QgU2VydmVyRWxlbWVudCA9IChwcm9wcykgPT4ge1xuICAgIHVzZUVsZW1lbnRzT3JDaGVja291dFNka0NvbnRleHRXaXRoVXNlQ2FzZShgbW91bnRzIDwke2Rpc3BsYXlOYW1lfT5gKTtcbiAgICBjb25zdCB7IGlkLCBjbGFzc05hbWUgfSA9IHByb3BzO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBpZCxcbiAgICAgICAgY2xhc3NOYW1lXG4gICAgICB9XG4gICAgKTtcbiAgfTtcbiAgY29uc3QgRWxlbWVudCA9IGlzU2VydmVyMiA/IFNlcnZlckVsZW1lbnQgOiBDbGllbnRFbGVtZW50O1xuICBFbGVtZW50LmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gIEVsZW1lbnQuX19lbGVtZW50VHlwZSA9IHR5cGU7XG4gIHJldHVybiBFbGVtZW50O1xufTtcbnZhciBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCI7XG52YXIgUGF5bWVudEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KFwicGF5bWVudFwiLCBpc1NlcnZlcik7XG5cbi8vIHNyYy9yZWFjdC9jb21tZXJjZS50c3hcbnZhciBbU3RyaXBlTGlic0NvbnRleHQsIHVzZVN0cmlwZUxpYnNDb250ZXh0XSA9IGNyZWF0ZUNvbnRleHRBbmRIb29rKFwiU3RyaXBlTGlic0NvbnRleHRcIik7XG52YXIgU3RyaXBlTGlic1Byb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBjbGVyayA9IHVzZUNsZXJrKCk7XG4gIGNvbnN0IHsgZGF0YTogc3RyaXBlQ2xlcmtMaWJzIH0gPSB1c2VTV1IoXG4gICAgXCJjbGVyay1zdHJpcGUtc2RrXCIsXG4gICAgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbG9hZFN0cmlwZSA9IGF3YWl0IGNsZXJrLl9faW50ZXJuYWxfbG9hZFN0cmlwZUpzKCk7XG4gICAgICByZXR1cm4geyBsb2FkU3RyaXBlIH07XG4gICAgfSxcbiAgICB7XG4gICAgICBrZWVwUHJldmlvdXNEYXRhOiB0cnVlLFxuICAgICAgcmV2YWxpZGF0ZU9uRm9jdXM6IGZhbHNlLFxuICAgICAgZGVkdXBpbmdJbnRlcnZhbDogSW5maW5pdHlcbiAgICB9XG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q2LmNyZWF0ZUVsZW1lbnQoXG4gICAgU3RyaXBlTGlic0NvbnRleHQuUHJvdmlkZXIsXG4gICAge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdmFsdWU6IHN0cmlwZUNsZXJrTGlicyB8fCBudWxsXG4gICAgICB9XG4gICAgfSxcbiAgICBjaGlsZHJlblxuICApO1xufTtcbnZhciB1c2VJbnRlcm5hbEVudmlyb25tZW50ID0gKCkgPT4ge1xuICBjb25zdCBjbGVyayA9IHVzZUNsZXJrKCk7XG4gIHJldHVybiBjbGVyay5fX3Vuc3RhYmxlX19lbnZpcm9ubWVudDtcbn07XG52YXIgdXNlUGF5bWVudFNvdXJjZVV0aWxzID0gKGZvclJlc291cmNlID0gXCJ1c2VyXCIpID0+IHtcbiAgY29uc3QgeyBvcmdhbml6YXRpb24gfSA9IHVzZU9yZ2FuaXphdGlvbigpO1xuICBjb25zdCB7IHVzZXIgfSA9IHVzZVVzZXIoKTtcbiAgY29uc3QgcmVzb3VyY2UgPSBmb3JSZXNvdXJjZSA9PT0gXCJvcmdhbml6YXRpb25cIiA/IG9yZ2FuaXphdGlvbiA6IHVzZXI7XG4gIGNvbnN0IHN0cmlwZUNsZXJrTGlicyA9IHVzZVN0cmlwZUxpYnNDb250ZXh0KCk7XG4gIGNvbnN0IHsgZGF0YTogaW5pdGlhbGl6ZWRQYXltZW50TWV0aG9kLCB0cmlnZ2VyOiBpbml0aWFsaXplUGF5bWVudE1ldGhvZCB9ID0gdXNlU1dSTXV0YXRpb24oXG4gICAge1xuICAgICAga2V5OiBcImJpbGxpbmctcGF5bWVudC1tZXRob2QtaW5pdGlhbGl6ZVwiLFxuICAgICAgcmVzb3VyY2VJZDogcmVzb3VyY2U/LmlkXG4gICAgfSxcbiAgICAoKSA9PiB7XG4gICAgICByZXR1cm4gcmVzb3VyY2U/LmluaXRpYWxpemVQYXltZW50TWV0aG9kKHtcbiAgICAgICAgZ2F0ZXdheTogXCJzdHJpcGVcIlxuICAgICAgfSk7XG4gICAgfVxuICApO1xuICBjb25zdCBlbnZpcm9ubWVudCA9IHVzZUludGVybmFsRW52aXJvbm1lbnQoKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgaWYgKCFyZXNvdXJjZT8uaWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZVBheW1lbnRNZXRob2QoKS5jYXRjaCgoKSA9PiB7XG4gICAgfSk7XG4gIH0sIFtyZXNvdXJjZT8uaWRdKTtcbiAgY29uc3QgZXh0ZXJuYWxHYXRld2F5SWQgPSBpbml0aWFsaXplZFBheW1lbnRNZXRob2Q/LmV4dGVybmFsR2F0ZXdheUlkO1xuICBjb25zdCBleHRlcm5hbENsaWVudFNlY3JldCA9IGluaXRpYWxpemVkUGF5bWVudE1ldGhvZD8uZXh0ZXJuYWxDbGllbnRTZWNyZXQ7XG4gIGNvbnN0IHBheW1lbnRNZXRob2RPcmRlciA9IGluaXRpYWxpemVkUGF5bWVudE1ldGhvZD8ucGF5bWVudE1ldGhvZE9yZGVyO1xuICBjb25zdCBzdHJpcGVQdWJsaXNoYWJsZUtleSA9IGVudmlyb25tZW50Py5jb21tZXJjZVNldHRpbmdzLmJpbGxpbmcuc3RyaXBlUHVibGlzaGFibGVLZXk7XG4gIGNvbnN0IHsgZGF0YTogc3RyaXBlIH0gPSB1c2VTV1IoXG4gICAgc3RyaXBlQ2xlcmtMaWJzICYmIGV4dGVybmFsR2F0ZXdheUlkICYmIHN0cmlwZVB1Ymxpc2hhYmxlS2V5ID8geyBrZXk6IFwic3RyaXBlLXNka1wiLCBleHRlcm5hbEdhdGV3YXlJZCwgc3RyaXBlUHVibGlzaGFibGVLZXkgfSA6IG51bGwsXG4gICAgKHsgc3RyaXBlUHVibGlzaGFibGVLZXk6IHN0cmlwZVB1Ymxpc2hhYmxlS2V5MiwgZXh0ZXJuYWxHYXRld2F5SWQ6IGV4dGVybmFsR2F0ZXdheUlkMiB9KSA9PiB7XG4gICAgICByZXR1cm4gc3RyaXBlQ2xlcmtMaWJzPy5sb2FkU3RyaXBlKHN0cmlwZVB1Ymxpc2hhYmxlS2V5Miwge1xuICAgICAgICBzdHJpcGVBY2NvdW50OiBleHRlcm5hbEdhdGV3YXlJZDJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAge1xuICAgICAga2VlcFByZXZpb3VzRGF0YTogdHJ1ZSxcbiAgICAgIHJldmFsaWRhdGVPbkZvY3VzOiBmYWxzZSxcbiAgICAgIGRlZHVwaW5nSW50ZXJ2YWw6IDFlMyAqIDYwXG4gICAgICAvLyAxIG1pbnV0ZVxuICAgIH1cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBzdHJpcGUsXG4gICAgaW5pdGlhbGl6ZVBheW1lbnRNZXRob2QsXG4gICAgZXh0ZXJuYWxDbGllbnRTZWNyZXQsXG4gICAgcGF5bWVudE1ldGhvZE9yZGVyXG4gIH07XG59O1xudmFyIFtQYXltZW50RWxlbWVudENvbnRleHQsIHVzZVBheW1lbnRFbGVtZW50Q29udGV4dF0gPSBjcmVhdGVDb250ZXh0QW5kSG9vayhcIlBheW1lbnRFbGVtZW50Q29udGV4dFwiKTtcbnZhciBbU3RyaXBlVXRpbHNDb250ZXh0LCB1c2VTdHJpcGVVdGlsc0NvbnRleHRdID0gY3JlYXRlQ29udGV4dEFuZEhvb2soXCJTdHJpcGVVdGlsc0NvbnRleHRcIik7XG52YXIgVmFsaWRhdGVTdHJpcGVVdGlscyA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3Qgc3RyaXBlID0gdXNlU3RyaXBlKCk7XG4gIGNvbnN0IGVsZW1lbnRzID0gdXNlRWxlbWVudHMoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDYuY3JlYXRlRWxlbWVudChTdHJpcGVVdGlsc0NvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHsgdmFsdWU6IHsgc3RyaXBlLCBlbGVtZW50cyB9IH0gfSwgY2hpbGRyZW4pO1xufTtcbnZhciBEdW1teVN0cmlwZVV0aWxzID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Ni5jcmVhdGVFbGVtZW50KFN0cmlwZVV0aWxzQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogeyB2YWx1ZToge30gfSB9LCBjaGlsZHJlbik7XG59O1xudmFyIFByb3BzUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiwgLi4ucHJvcHMgfSkgPT4ge1xuICBjb25zdCB1dGlscyA9IHVzZVBheW1lbnRTb3VyY2VVdGlscyhwcm9wcy5mb3IpO1xuICBjb25zdCBbaXNQYXltZW50RWxlbWVudFJlYWR5LCBzZXRJc1BheW1lbnRFbGVtZW50UmVhZHldID0gdXNlU3RhdGUzKGZhbHNlKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDYuY3JlYXRlRWxlbWVudChcbiAgICBQYXltZW50RWxlbWVudENvbnRleHQuUHJvdmlkZXIsXG4gICAge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAuLi51dGlscyxcbiAgICAgICAgICBzZXRJc1BheW1lbnRFbGVtZW50UmVhZHksXG4gICAgICAgICAgaXNQYXltZW50RWxlbWVudFJlYWR5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNoaWxkcmVuXG4gICk7XG59O1xudmFyIFBheW1lbnRFbGVtZW50UHJvdmlkZXIgPSAoeyBjaGlsZHJlbiwgLi4ucHJvcHMgfSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Ni5jcmVhdGVFbGVtZW50KFN0cmlwZUxpYnNQcm92aWRlciwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0Ni5jcmVhdGVFbGVtZW50KFByb3BzUHJvdmlkZXIsIHsgLi4ucHJvcHMgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0Ni5jcmVhdGVFbGVtZW50KFBheW1lbnRFbGVtZW50SW50ZXJuYWxSb290LCBudWxsLCBjaGlsZHJlbikpKTtcbn07XG52YXIgUGF5bWVudEVsZW1lbnRJbnRlcm5hbFJvb3QgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgeyBzdHJpcGUsIGV4dGVybmFsQ2xpZW50U2VjcmV0LCBzdHJpcGVBcHBlYXJhbmNlIH0gPSB1c2VQYXltZW50RWxlbWVudENvbnRleHQoKTtcbiAgaWYgKHN0cmlwZSAmJiBleHRlcm5hbENsaWVudFNlY3JldCkge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q2LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBFbGVtZW50cyxcbiAgICAgIHtcbiAgICAgICAga2V5OiBleHRlcm5hbENsaWVudFNlY3JldCxcbiAgICAgICAgc3RyaXBlLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgbG9hZGVyOiBcIm5ldmVyXCIsXG4gICAgICAgICAgY2xpZW50U2VjcmV0OiBleHRlcm5hbENsaWVudFNlY3JldCxcbiAgICAgICAgICBhcHBlYXJhbmNlOiB7XG4gICAgICAgICAgICB2YXJpYWJsZXM6IHN0cmlwZUFwcGVhcmFuY2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3Q2LmNyZWF0ZUVsZW1lbnQoVmFsaWRhdGVTdHJpcGVVdGlscywgbnVsbCwgcHJvcHMuY2hpbGRyZW4pXG4gICAgKTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Ni5jcmVhdGVFbGVtZW50KER1bW15U3RyaXBlVXRpbHMsIG51bGwsIHByb3BzLmNoaWxkcmVuKTtcbn07XG52YXIgUGF5bWVudEVsZW1lbnQyID0gKHsgZmFsbGJhY2sgfSkgPT4ge1xuICBjb25zdCB7XG4gICAgc2V0SXNQYXltZW50RWxlbWVudFJlYWR5LFxuICAgIHBheW1lbnRNZXRob2RPcmRlcixcbiAgICBjaGVja291dCxcbiAgICBzdHJpcGUsXG4gICAgZXh0ZXJuYWxDbGllbnRTZWNyZXQsXG4gICAgcGF5bWVudERlc2NyaXB0aW9uLFxuICAgIGZvcjogX2ZvclxuICB9ID0gdXNlUGF5bWVudEVsZW1lbnRDb250ZXh0KCk7XG4gIGNvbnN0IGVudmlyb25tZW50ID0gdXNlSW50ZXJuYWxFbnZpcm9ubWVudCgpO1xuICBjb25zdCBhcHBsZVBheSA9IHVzZU1lbW8zKCgpID0+IHtcbiAgICBpZiAoIWNoZWNrb3V0IHx8ICFjaGVja291dC50b3RhbHMgfHwgIWNoZWNrb3V0LnBsYW4pIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZWN1cnJpbmdQYXltZW50UmVxdWVzdDoge1xuICAgICAgICBwYXltZW50RGVzY3JpcHRpb246IHBheW1lbnREZXNjcmlwdGlvbiB8fCBcIlwiLFxuICAgICAgICBtYW5hZ2VtZW50VVJMOiBfZm9yID09PSBcIm9yZ2FuaXphdGlvblwiID8gZW52aXJvbm1lbnQ/LmRpc3BsYXlDb25maWcub3JnYW5pemF0aW9uUHJvZmlsZVVybCB8fCBcIlwiIDogZW52aXJvbm1lbnQ/LmRpc3BsYXlDb25maWcudXNlclByb2ZpbGVVcmwgfHwgXCJcIixcbiAgICAgICAgcmVndWxhckJpbGxpbmc6IHtcbiAgICAgICAgICBhbW91bnQ6IGNoZWNrb3V0LnRvdGFscy50b3RhbER1ZU5vdz8uYW1vdW50IHx8IGNoZWNrb3V0LnRvdGFscy5ncmFuZFRvdGFsLmFtb3VudCxcbiAgICAgICAgICBsYWJlbDogY2hlY2tvdXQucGxhbi5uYW1lLFxuICAgICAgICAgIHJlY3VycmluZ1BheW1lbnRJbnRlcnZhbFVuaXQ6IGNoZWNrb3V0LnBsYW5QZXJpb2QgPT09IFwiYW5udWFsXCIgPyBcInllYXJcIiA6IFwibW9udGhcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2NoZWNrb3V0LCBwYXltZW50RGVzY3JpcHRpb24sIF9mb3IsIGVudmlyb25tZW50XSk7XG4gIGNvbnN0IG9wdGlvbnMgPSB1c2VNZW1vMygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxheW91dDoge1xuICAgICAgICB0eXBlOiBcInRhYnNcIixcbiAgICAgICAgZGVmYXVsdENvbGxhcHNlZDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBwYXltZW50TWV0aG9kT3JkZXIsXG4gICAgICBhcHBsZVBheVxuICAgIH07XG4gIH0sIFthcHBsZVBheSwgcGF5bWVudE1ldGhvZE9yZGVyXSk7XG4gIGNvbnN0IG9uUmVhZHkgPSB1c2VDYWxsYmFjazQoKCkgPT4ge1xuICAgIHNldElzUGF5bWVudEVsZW1lbnRSZWFkeSh0cnVlKTtcbiAgfSwgW3NldElzUGF5bWVudEVsZW1lbnRSZWFkeV0pO1xuICBpZiAoIXN0cmlwZSB8fCAhZXh0ZXJuYWxDbGllbnRTZWNyZXQpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Ni5jcmVhdGVFbGVtZW50KFJlYWN0Ni5GcmFnbWVudCwgbnVsbCwgZmFsbGJhY2spO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q2LmNyZWF0ZUVsZW1lbnQoXG4gICAgUGF5bWVudEVsZW1lbnQsXG4gICAge1xuICAgICAgZmFsbGJhY2ssXG4gICAgICBvblJlYWR5LFxuICAgICAgb3B0aW9uc1xuICAgIH1cbiAgKTtcbn07XG52YXIgdGhyb3dMaWJzTWlzc2luZ0Vycm9yID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgXCJDbGVyazogVW5hYmxlIHRvIHN1Ym1pdCwgU3RyaXBlIGxpYnJhcmllcyBhcmUgbm90IHlldCBsb2FkZWQuIEJlIHN1cmUgdG8gY2hlY2sgYGlzRm9ybVJlYWR5YCBiZWZvcmUgY2FsbGluZyBgc3VibWl0YC5cIlxuICApO1xufTtcbnZhciB1c2VQYXltZW50RWxlbWVudCA9ICgpID0+IHtcbiAgY29uc3QgeyBpc1BheW1lbnRFbGVtZW50UmVhZHksIGluaXRpYWxpemVQYXltZW50TWV0aG9kIH0gPSB1c2VQYXltZW50RWxlbWVudENvbnRleHQoKTtcbiAgY29uc3QgeyBzdHJpcGUsIGVsZW1lbnRzIH0gPSB1c2VTdHJpcGVVdGlsc0NvbnRleHQoKTtcbiAgY29uc3QgeyBleHRlcm5hbENsaWVudFNlY3JldCB9ID0gdXNlUGF5bWVudEVsZW1lbnRDb250ZXh0KCk7XG4gIGNvbnN0IHN1Ym1pdCA9IHVzZUNhbGxiYWNrNChhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFzdHJpcGUgfHwgIWVsZW1lbnRzKSB7XG4gICAgICByZXR1cm4gdGhyb3dMaWJzTWlzc2luZ0Vycm9yKCk7XG4gICAgfVxuICAgIGNvbnN0IHsgc2V0dXBJbnRlbnQsIGVycm9yIH0gPSBhd2FpdCBzdHJpcGUuY29uZmlybVNldHVwKHtcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgY29uZmlybVBhcmFtczoge1xuICAgICAgICByZXR1cm5fdXJsOiB3aW5kb3cubG9jYXRpb24uaHJlZlxuICAgICAgfSxcbiAgICAgIHJlZGlyZWN0OiBcImlmX3JlcXVpcmVkXCJcbiAgICB9KTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgZ2F0ZXdheTogXCJzdHJpcGVcIixcbiAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgY29kZTogZXJyb3IuY29kZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICB0eXBlOiBlcnJvci50eXBlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogeyBnYXRld2F5OiBcInN0cmlwZVwiLCBwYXltZW50VG9rZW46IHNldHVwSW50ZW50LnBheW1lbnRfbWV0aG9kIH0sXG4gICAgICBlcnJvcjogbnVsbFxuICAgIH07XG4gIH0sIFtzdHJpcGUsIGVsZW1lbnRzXSk7XG4gIGNvbnN0IHJlc2V0ID0gdXNlQ2FsbGJhY2s0KGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXN0cmlwZSB8fCAhZWxlbWVudHMpIHtcbiAgICAgIHJldHVybiB0aHJvd0xpYnNNaXNzaW5nRXJyb3IoKTtcbiAgICB9XG4gICAgYXdhaXQgaW5pdGlhbGl6ZVBheW1lbnRNZXRob2QoKTtcbiAgfSwgW3N0cmlwZSwgZWxlbWVudHMsIGluaXRpYWxpemVQYXltZW50TWV0aG9kXSk7XG4gIGNvbnN0IGlzUHJvdmlkZXJSZWFkeSA9IEJvb2xlYW4oc3RyaXBlICYmIGV4dGVybmFsQ2xpZW50U2VjcmV0KTtcbiAgaWYgKCFpc1Byb3ZpZGVyUmVhZHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VibWl0OiB0aHJvd0xpYnNNaXNzaW5nRXJyb3IsXG4gICAgICByZXNldDogdGhyb3dMaWJzTWlzc2luZ0Vycm9yLFxuICAgICAgaXNGb3JtUmVhZHk6IGZhbHNlLFxuICAgICAgcHJvdmlkZXI6IHZvaWQgMCxcbiAgICAgIGlzUHJvdmlkZXJSZWFkeTogZmFsc2VcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgc3VibWl0LFxuICAgIHJlc2V0LFxuICAgIGlzRm9ybVJlYWR5OiBpc1BheW1lbnRFbGVtZW50UmVhZHksXG4gICAgcHJvdmlkZXI6IHtcbiAgICAgIG5hbWU6IFwic3RyaXBlXCJcbiAgICB9LFxuICAgIGlzUHJvdmlkZXJSZWFkeVxuICB9O1xufTtcbmV4cG9ydCB7XG4gIENsZXJrSW5zdGFuY2VDb250ZXh0LFxuICBDbGllbnRDb250ZXh0LFxuICBPcHRpb25zQ29udGV4dCxcbiAgT3JnYW5pemF0aW9uUHJvdmlkZXIsXG4gIFNlc3Npb25Db250ZXh0LFxuICBVc2VyQ29udGV4dCxcbiAgX19leHBlcmltZW50YWxfQ2hlY2tvdXRQcm92aWRlcixcbiAgUGF5bWVudEVsZW1lbnQyIGFzIF9fZXhwZXJpbWVudGFsX1BheW1lbnRFbGVtZW50LFxuICBQYXltZW50RWxlbWVudFByb3ZpZGVyIGFzIF9fZXhwZXJpbWVudGFsX1BheW1lbnRFbGVtZW50UHJvdmlkZXIsXG4gIHVzZUNoZWNrb3V0IGFzIF9fZXhwZXJpbWVudGFsX3VzZUNoZWNrb3V0LFxuICB1c2VQYXltZW50QXR0ZW1wdHMgYXMgX19leHBlcmltZW50YWxfdXNlUGF5bWVudEF0dGVtcHRzLFxuICB1c2VQYXltZW50RWxlbWVudCBhcyBfX2V4cGVyaW1lbnRhbF91c2VQYXltZW50RWxlbWVudCxcbiAgdXNlUGF5bWVudE1ldGhvZHMgYXMgX19leHBlcmltZW50YWxfdXNlUGF5bWVudE1ldGhvZHMsXG4gIHVzZVBsYW5zIGFzIF9fZXhwZXJpbWVudGFsX3VzZVBsYW5zLFxuICB1c2VTdGF0ZW1lbnRzIGFzIF9fZXhwZXJpbWVudGFsX3VzZVN0YXRlbWVudHMsXG4gIHVzZVN1YnNjcmlwdGlvbiBhcyBfX2V4cGVyaW1lbnRhbF91c2VTdWJzY3JpcHRpb24sXG4gIGFzc2VydENvbnRleHRFeGlzdHMsXG4gIGNyZWF0ZUNvbnRleHRBbmRIb29rLFxuICBpc0RlZXBseUVxdWFsLFxuICB1c2VBc3NlcnRXcmFwcGVkQnlDbGVya1Byb3ZpZGVyLFxuICB1c2VDbGVyayxcbiAgdXNlQ2xlcmtJbnN0YW5jZUNvbnRleHQsXG4gIHVzZUNsaWVudENvbnRleHQsXG4gIHVzZURlZXBFcXVhbE1lbW8sXG4gIHVzZU9wdGlvbnNDb250ZXh0LFxuICB1c2VPcmdhbml6YXRpb24sXG4gIHVzZU9yZ2FuaXphdGlvbkNvbnRleHQsXG4gIHVzZU9yZ2FuaXphdGlvbkxpc3QsXG4gIHVzZVJldmVyaWZpY2F0aW9uLFxuICB1c2VTYWZlTGF5b3V0RWZmZWN0LFxuICB1c2VTZXNzaW9uLFxuICB1c2VTZXNzaW9uQ29udGV4dCxcbiAgdXNlU2Vzc2lvbkxpc3QsXG4gIHVzZVVzZXIsXG4gIHVzZVVzZXJDb250ZXh0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/react/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/telemetry.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/telemetry.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EVENT_SAMPLING_RATE: () => (/* reexport safe */ _chunk_RUA3ZE6A_mjs__WEBPACK_IMPORTED_MODULE_0__.EVENT_SAMPLING_RATE),\n/* harmony export */   EVENT_THEME_USAGE: () => (/* reexport safe */ _chunk_RUA3ZE6A_mjs__WEBPACK_IMPORTED_MODULE_0__.EVENT_THEME_USAGE),\n/* harmony export */   TelemetryCollector: () => (/* reexport safe */ _chunk_RUA3ZE6A_mjs__WEBPACK_IMPORTED_MODULE_0__.TelemetryCollector),\n/* harmony export */   eventComponentMounted: () => (/* reexport safe */ _chunk_RUA3ZE6A_mjs__WEBPACK_IMPORTED_MODULE_0__.eventComponentMounted),\n/* harmony export */   eventFrameworkMetadata: () => (/* reexport safe */ _chunk_RUA3ZE6A_mjs__WEBPACK_IMPORTED_MODULE_0__.eventFrameworkMetadata),\n/* harmony export */   eventMethodCalled: () => (/* reexport safe */ _chunk_RUA3ZE6A_mjs__WEBPACK_IMPORTED_MODULE_0__.eventMethodCalled),\n/* harmony export */   eventPrebuiltComponentMounted: () => (/* reexport safe */ _chunk_RUA3ZE6A_mjs__WEBPACK_IMPORTED_MODULE_0__.eventPrebuiltComponentMounted),\n/* harmony export */   eventPrebuiltComponentOpened: () => (/* reexport safe */ _chunk_RUA3ZE6A_mjs__WEBPACK_IMPORTED_MODULE_0__.eventPrebuiltComponentOpened),\n/* harmony export */   eventThemeUsage: () => (/* reexport safe */ _chunk_RUA3ZE6A_mjs__WEBPACK_IMPORTED_MODULE_0__.eventThemeUsage)\n/* harmony export */ });\n/* harmony import */ var _chunk_RUA3ZE6A_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-RUA3ZE6A.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-RUA3ZE6A.mjs\");\n/* harmony import */ var _chunk_GGFRMWFO_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-GGFRMWFO.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-GGFRMWFO.mjs\");\n/* harmony import */ var _chunk_IV7BOO4U_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-IV7BOO4U.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IV7BOO4U.mjs\");\n/* harmony import */ var _chunk_TETGTEI2_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk-TETGTEI2.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs\");\n/* harmony import */ var _chunk_KOH7GTJO_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chunk-KOH7GTJO.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs\");\n/* harmony import */ var _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chunk-I6MTSTOF.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs\");\n/* harmony import */ var _chunk_IEP6GGEX_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./chunk-IEP6GGEX.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IEP6GGEX.mjs\");\n\n\n\n\n\n\n\n\n//# sourceMappingURL=telemetry.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvdGVsZW1ldHJ5Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBVThCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVzVCO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvdGVsZW1ldHJ5Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBFVkVOVF9TQU1QTElOR19SQVRFLFxuICBFVkVOVF9USEVNRV9VU0FHRSxcbiAgVGVsZW1ldHJ5Q29sbGVjdG9yLFxuICBldmVudENvbXBvbmVudE1vdW50ZWQsXG4gIGV2ZW50RnJhbWV3b3JrTWV0YWRhdGEsXG4gIGV2ZW50TWV0aG9kQ2FsbGVkLFxuICBldmVudFByZWJ1aWx0Q29tcG9uZW50TW91bnRlZCxcbiAgZXZlbnRQcmVidWlsdENvbXBvbmVudE9wZW5lZCxcbiAgZXZlbnRUaGVtZVVzYWdlXG59IGZyb20gXCIuL2NodW5rLVJVQTNaRTZBLm1qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay1HR0ZSTVdGTy5tanNcIjtcbmltcG9ydCBcIi4vY2h1bmstSVY3Qk9PNFUubWpzXCI7XG5pbXBvcnQgXCIuL2NodW5rLVRFVEdURUkyLm1qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay1LT0g3R1RKTy5tanNcIjtcbmltcG9ydCBcIi4vY2h1bmstSTZNVFNUT0YubWpzXCI7XG5pbXBvcnQgXCIuL2NodW5rLUlFUDZHR0VYLm1qc1wiO1xuZXhwb3J0IHtcbiAgRVZFTlRfU0FNUExJTkdfUkFURSxcbiAgRVZFTlRfVEhFTUVfVVNBR0UsXG4gIFRlbGVtZXRyeUNvbGxlY3RvcixcbiAgZXZlbnRDb21wb25lbnRNb3VudGVkLFxuICBldmVudEZyYW1ld29ya01ldGFkYXRhLFxuICBldmVudE1ldGhvZENhbGxlZCxcbiAgZXZlbnRQcmVidWlsdENvbXBvbmVudE1vdW50ZWQsXG4gIGV2ZW50UHJlYnVpbHRDb21wb25lbnRPcGVuZWQsXG4gIGV2ZW50VGhlbWVVc2FnZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbGVtZXRyeS5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/telemetry.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/utils/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/utils/index.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allSettled: () => (/* reexport safe */ _chunk_ARQUL5DC_mjs__WEBPACK_IMPORTED_MODULE_0__.allSettled),\n/* harmony export */   createDeferredPromise: () => (/* reexport safe */ _chunk_7QJ2QTJL_mjs__WEBPACK_IMPORTED_MODULE_1__.createDeferredPromise),\n/* harmony export */   fastDeepMergeAndKeep: () => (/* reexport safe */ _chunk_ARQUL5DC_mjs__WEBPACK_IMPORTED_MODULE_0__.fastDeepMergeAndKeep),\n/* harmony export */   fastDeepMergeAndReplace: () => (/* reexport safe */ _chunk_ARQUL5DC_mjs__WEBPACK_IMPORTED_MODULE_0__.fastDeepMergeAndReplace),\n/* harmony export */   handleValueOrFn: () => (/* reexport safe */ _chunk_O32JQBM6_mjs__WEBPACK_IMPORTED_MODULE_4__.handleValueOrFn),\n/* harmony export */   isDevelopmentEnvironment: () => (/* reexport safe */ _chunk_7HPDNZ3R_mjs__WEBPACK_IMPORTED_MODULE_5__.isDevelopmentEnvironment),\n/* harmony export */   isProductionEnvironment: () => (/* reexport safe */ _chunk_7HPDNZ3R_mjs__WEBPACK_IMPORTED_MODULE_5__.isProductionEnvironment),\n/* harmony export */   isStaging: () => (/* reexport safe */ _chunk_3TMSNP4L_mjs__WEBPACK_IMPORTED_MODULE_3__.isStaging),\n/* harmony export */   isTestEnvironment: () => (/* reexport safe */ _chunk_7HPDNZ3R_mjs__WEBPACK_IMPORTED_MODULE_5__.isTestEnvironment),\n/* harmony export */   logErrorInDevMode: () => (/* reexport safe */ _chunk_ARQUL5DC_mjs__WEBPACK_IMPORTED_MODULE_0__.logErrorInDevMode),\n/* harmony export */   noop: () => (/* reexport safe */ _chunk_7FNX7RWY_mjs__WEBPACK_IMPORTED_MODULE_2__.noop)\n/* harmony export */ });\n/* harmony import */ var _chunk_ARQUL5DC_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chunk-ARQUL5DC.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-ARQUL5DC.mjs\");\n/* harmony import */ var _chunk_7QJ2QTJL_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../chunk-7QJ2QTJL.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7QJ2QTJL.mjs\");\n/* harmony import */ var _chunk_7FNX7RWY_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../chunk-7FNX7RWY.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7FNX7RWY.mjs\");\n/* harmony import */ var _chunk_3TMSNP4L_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../chunk-3TMSNP4L.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-3TMSNP4L.mjs\");\n/* harmony import */ var _chunk_O32JQBM6_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../chunk-O32JQBM6.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-O32JQBM6.mjs\");\n/* harmony import */ var _chunk_7HPDNZ3R_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../chunk-7HPDNZ3R.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7HPDNZ3R.mjs\");\n/* harmony import */ var _chunk_IEP6GGEX_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../chunk-IEP6GGEX.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IEP6GGEX.mjs\");\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvdXRpbHMvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUsrQjtBQUdBO0FBR0E7QUFHQTtBQUdBO0FBS0E7QUFDQTtBQWE3QjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L3V0aWxzL2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBhbGxTZXR0bGVkLFxuICBmYXN0RGVlcE1lcmdlQW5kS2VlcCxcbiAgZmFzdERlZXBNZXJnZUFuZFJlcGxhY2UsXG4gIGxvZ0Vycm9ySW5EZXZNb2RlXG59IGZyb20gXCIuLi9jaHVuay1BUlFVTDVEQy5tanNcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZURlZmVycmVkUHJvbWlzZVxufSBmcm9tIFwiLi4vY2h1bmstN1FKMlFUSkwubWpzXCI7XG5pbXBvcnQge1xuICBub29wXG59IGZyb20gXCIuLi9jaHVuay03Rk5YN1JXWS5tanNcIjtcbmltcG9ydCB7XG4gIGlzU3RhZ2luZ1xufSBmcm9tIFwiLi4vY2h1bmstM1RNU05QNEwubWpzXCI7XG5pbXBvcnQge1xuICBoYW5kbGVWYWx1ZU9yRm5cbn0gZnJvbSBcIi4uL2NodW5rLU8zMkpRQk02Lm1qc1wiO1xuaW1wb3J0IHtcbiAgaXNEZXZlbG9wbWVudEVudmlyb25tZW50LFxuICBpc1Byb2R1Y3Rpb25FbnZpcm9ubWVudCxcbiAgaXNUZXN0RW52aXJvbm1lbnRcbn0gZnJvbSBcIi4uL2NodW5rLTdIUEROWjNSLm1qc1wiO1xuaW1wb3J0IFwiLi4vY2h1bmstSUVQNkdHRVgubWpzXCI7XG5leHBvcnQge1xuICBhbGxTZXR0bGVkLFxuICBjcmVhdGVEZWZlcnJlZFByb21pc2UsXG4gIGZhc3REZWVwTWVyZ2VBbmRLZWVwLFxuICBmYXN0RGVlcE1lcmdlQW5kUmVwbGFjZSxcbiAgaGFuZGxlVmFsdWVPckZuLFxuICBpc0RldmVsb3BtZW50RW52aXJvbm1lbnQsXG4gIGlzUHJvZHVjdGlvbkVudmlyb25tZW50LFxuICBpc1N0YWdpbmcsXG4gIGlzVGVzdEVudmlyb25tZW50LFxuICBsb2dFcnJvckluRGV2TW9kZSxcbiAgbm9vcFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/utils/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ably/build/ably.js":
/*!*****************************************!*\
  !*** ./node_modules/ably/build/ably.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*@license Copyright 2015-2022 Ably Real-time Ltd (ably.com)\n\nAbly JavaScript Library v2.14.0\nhttps://github.com/ably/ably-js\n\nReleased under the Apache Licence v2.0*/(function (g, f) {\n    if (true) {\n      module.exports = f();\n    } else {}\n  }(this, () => {\nvar exports = {};\nvar module = { exports };\n\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/platform/web/index.ts\nvar web_exports = {};\n__export(web_exports, {\n  ErrorInfo: () => ErrorInfo,\n  Realtime: () => DefaultRealtime,\n  Rest: () => DefaultRest,\n  default: () => web_default,\n  makeProtocolMessageFromDeserialized: () => makeFromDeserializedWithDependencies,\n  msgpack: () => msgpack_default\n});\nmodule.exports = __toCommonJS(web_exports);\n\n// src/common/platform.ts\nvar Platform = class {\n};\n\n// src/common/lib/util/logger.ts\nvar globalObject = typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof window !== \"undefined\" ? window : self;\nfunction pad(timeSegment, three) {\n  return `${timeSegment}`.padStart(three ? 3 : 2, \"0\");\n}\nfunction getHandler(logger) {\n  return Platform.Config.logTimestamps ? function(msg) {\n    const time = /* @__PURE__ */ new Date();\n    logger(\n      pad(time.getHours()) + \":\" + pad(time.getMinutes()) + \":\" + pad(time.getSeconds()) + \".\" + pad(time.getMilliseconds(), 1) + \" \" + msg\n    );\n  } : function(msg) {\n    logger(msg);\n  };\n}\nvar getDefaultLoggers = () => {\n  var _a2;\n  let consoleLogger;\n  let errorLogger;\n  if (typeof ((_a2 = globalObject == null ? void 0 : globalObject.console) == null ? void 0 : _a2.log) === \"function\") {\n    consoleLogger = function(...args) {\n      console.log.apply(console, args);\n    };\n    errorLogger = console.warn ? function(...args) {\n      console.warn.apply(console, args);\n    } : consoleLogger;\n  } else {\n    consoleLogger = errorLogger = function() {\n    };\n  }\n  return [consoleLogger, errorLogger].map(getHandler);\n};\nvar _Logger = class _Logger {\n  constructor() {\n    this.deprecated = (description, msg) => {\n      this.deprecationWarning(`${description} is deprecated and will be removed in a future version. ${msg}`);\n    };\n    /* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent\n      the object being serialised if the log level will not output the message */\n    this.shouldLog = (level) => {\n      return level <= this.logLevel;\n    };\n    this.setLog = (level, handler) => {\n      if (level !== void 0)\n        this.logLevel = level;\n      if (handler !== void 0)\n        this.logHandler = this.logErrorHandler = handler;\n    };\n    this.logLevel = _Logger.defaultLogLevel;\n    this.logHandler = _Logger.defaultLogHandler;\n    this.logErrorHandler = _Logger.defaultLogErrorHandler;\n  }\n  static initLogHandlers() {\n    const [logHandler, logErrorHandler] = getDefaultLoggers();\n    this.defaultLogHandler = logHandler;\n    this.defaultLogErrorHandler = logErrorHandler;\n    this.defaultLogger = new _Logger();\n  }\n  /**\n   * Calls to this method are never stripped by the `stripLogs` esbuild plugin. Use it for log statements that you wish to always be included in the modular variant of the SDK.\n   */\n  static logActionNoStrip(logger, level, action, message) {\n    logger.logAction(level, action, message);\n  }\n  logAction(level, action, message) {\n    if (this.shouldLog(level)) {\n      (level === 1 /* Error */ ? this.logErrorHandler : this.logHandler)(\"Ably: \" + action + \": \" + message, level);\n    }\n  }\n  renamedClientOption(oldName, newName) {\n    this.deprecationWarning(\n      `The \\`${oldName}\\` client option has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`\n    );\n  }\n  renamedMethod(className, oldName, newName) {\n    this.deprecationWarning(\n      `\\`${className}\\`\\u2019s \\`${oldName}\\` method has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`\n    );\n  }\n  deprecationWarning(message) {\n    if (this.shouldLog(1 /* Error */)) {\n      this.logErrorHandler(`Ably: Deprecation warning - ${message}`, 1 /* Error */);\n    }\n  }\n};\n_Logger.defaultLogLevel = 1 /* Error */;\n// public constants\n_Logger.LOG_NONE = 0 /* None */;\n_Logger.LOG_ERROR = 1 /* Error */;\n_Logger.LOG_MAJOR = 2 /* Major */;\n_Logger.LOG_MINOR = 3 /* Minor */;\n_Logger.LOG_MICRO = 4 /* Micro */;\n/* public static functions */\n/**\n * In the modular variant of the SDK, the `stripLogs` esbuild plugin strips out all calls to this method (when invoked as `Logger.logAction(...)`) except when called with level `Logger.LOG_ERROR`. If you wish for a log statement to never be stripped, use the {@link logActionNoStrip} method instead.\n *\n * The aforementioned plugin expects `level` to be an expression of the form `Logger.LOG_*`; that is, you can’t dynamically specify the log level.\n */\n_Logger.logAction = (logger, level, action, message) => {\n  _Logger.logActionNoStrip(logger, level, action, message);\n};\nvar Logger = _Logger;\nvar logger_default = Logger;\n\n// src/common/lib/util/utils.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  Format: () => Format,\n  allSame: () => allSame,\n  allToLowerCase: () => allToLowerCase,\n  allToUpperCase: () => allToUpperCase,\n  arrChooseN: () => arrChooseN,\n  arrDeleteValue: () => arrDeleteValue,\n  arrEquals: () => arrEquals,\n  arrIntersect: () => arrIntersect,\n  arrIntersectOb: () => arrIntersectOb,\n  arrPopRandomElement: () => arrPopRandomElement,\n  arrWithoutValue: () => arrWithoutValue,\n  cheapRandStr: () => cheapRandStr,\n  containsValue: () => containsValue,\n  copy: () => copy,\n  createMissingPluginError: () => createMissingPluginError,\n  dataSizeBytes: () => dataSizeBytes,\n  decodeBody: () => decodeBody,\n  encodeBody: () => encodeBody,\n  ensureArray: () => ensureArray,\n  forInOwnNonNullProperties: () => forInOwnNonNullProperties,\n  getBackoffCoefficient: () => getBackoffCoefficient,\n  getGlobalObject: () => getGlobalObject,\n  getJitterCoefficient: () => getJitterCoefficient,\n  getRetryTime: () => getRetryTime,\n  inherits: () => inherits,\n  inspectBody: () => inspectBody,\n  inspectError: () => inspectError,\n  intersect: () => intersect,\n  isEmpty: () => isEmpty,\n  isErrorInfoOrPartialErrorInfo: () => isErrorInfoOrPartialErrorInfo,\n  isNil: () => isNil,\n  isObject: () => isObject,\n  keysArray: () => keysArray,\n  matchDerivedChannel: () => matchDerivedChannel,\n  mixin: () => mixin,\n  parseQueryString: () => parseQueryString,\n  prototypicalClone: () => prototypicalClone,\n  randomString: () => randomString,\n  shallowClone: () => shallowClone,\n  shallowEquals: () => shallowEquals,\n  throwMissingPluginError: () => throwMissingPluginError,\n  toBase64: () => toBase64,\n  toQueryString: () => toQueryString,\n  valuesArray: () => valuesArray,\n  whenPromiseSettles: () => whenPromiseSettles,\n  withTimeoutAsync: () => withTimeoutAsync\n});\n\n// src/common/lib/types/errorinfo.ts\nfunction toString(err) {\n  let result = \"[\" + err.constructor.name;\n  if (err.message)\n    result += \": \" + err.message;\n  if (err.statusCode)\n    result += \"; statusCode=\" + err.statusCode;\n  if (err.code)\n    result += \"; code=\" + err.code;\n  if (err.cause)\n    result += \"; cause=\" + inspectError(err.cause);\n  if (err.href && !(err.message && err.message.indexOf(\"help.ably.io\") > -1))\n    result += \"; see \" + err.href + \" \";\n  result += \"]\";\n  return result;\n}\nvar ErrorInfo = class _ErrorInfo extends Error {\n  constructor(message, code, statusCode, cause) {\n    super(message);\n    if (typeof Object.setPrototypeOf !== \"undefined\") {\n      Object.setPrototypeOf(this, _ErrorInfo.prototype);\n    }\n    this.code = code;\n    this.statusCode = statusCode;\n    this.cause = cause;\n  }\n  toString() {\n    return toString(this);\n  }\n  static fromValues(values) {\n    const { message, code, statusCode } = values;\n    if (typeof message !== \"string\" || typeof code !== \"number\" || typeof statusCode !== \"number\") {\n      throw new Error(\"ErrorInfo.fromValues(): invalid values: \" + Platform.Config.inspect(values));\n    }\n    const result = Object.assign(new _ErrorInfo(message, code, statusCode), values);\n    if (result.code && !result.href) {\n      result.href = \"https://help.ably.io/error/\" + result.code;\n    }\n    return result;\n  }\n};\nvar PartialErrorInfo = class _PartialErrorInfo extends Error {\n  constructor(message, code, statusCode, cause) {\n    super(message);\n    if (typeof Object.setPrototypeOf !== \"undefined\") {\n      Object.setPrototypeOf(this, _PartialErrorInfo.prototype);\n    }\n    this.code = code;\n    this.statusCode = statusCode;\n    this.cause = cause;\n  }\n  toString() {\n    return toString(this);\n  }\n  static fromValues(values) {\n    const { message, code, statusCode } = values;\n    if (typeof message !== \"string\" || !isNil(code) && typeof code !== \"number\" || !isNil(statusCode) && typeof statusCode !== \"number\") {\n      throw new Error(\"PartialErrorInfo.fromValues(): invalid values: \" + Platform.Config.inspect(values));\n    }\n    const result = Object.assign(new _PartialErrorInfo(message, code, statusCode), values);\n    if (result.code && !result.href) {\n      result.href = \"https://help.ably.io/error/\" + result.code;\n    }\n    return result;\n  }\n};\n\n// src/common/lib/util/utils.ts\nfunction randomPosn(arrOrStr) {\n  return Math.floor(Math.random() * arrOrStr.length);\n}\nfunction mixin(target, ...args) {\n  for (let i = 0; i < args.length; i++) {\n    const source = args[i];\n    if (!source) {\n      break;\n    }\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n}\nfunction copy(src) {\n  return mixin({}, src);\n}\nfunction ensureArray(obj) {\n  if (isNil(obj)) {\n    return [];\n  }\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return [obj];\n}\nfunction isObject(ob) {\n  return Object.prototype.toString.call(ob) == \"[object Object]\";\n}\nfunction isEmpty(ob) {\n  for (const prop in ob)\n    return false;\n  return true;\n}\nfunction isNil(arg) {\n  return arg == null;\n}\nfunction shallowClone(ob) {\n  const result = new Object();\n  for (const prop in ob)\n    result[prop] = ob[prop];\n  return result;\n}\nfunction prototypicalClone(ob, ownProperties) {\n  class F {\n  }\n  F.prototype = ob;\n  const result = new F();\n  if (ownProperties)\n    mixin(result, ownProperties);\n  return result;\n}\nvar inherits = function(ctor, superCtor) {\n  if (Platform.Config.inherits) {\n    Platform.Config.inherits(ctor, superCtor);\n    return;\n  }\n  ctor.super_ = superCtor;\n  ctor.prototype = prototypicalClone(superCtor.prototype, { constructor: ctor });\n};\nfunction containsValue(ob, val) {\n  for (const i in ob) {\n    if (ob[i] == val)\n      return true;\n  }\n  return false;\n}\nfunction intersect(arr, ob) {\n  return Array.isArray(ob) ? arrIntersect(arr, ob) : arrIntersectOb(arr, ob);\n}\nfunction arrIntersect(arr1, arr2) {\n  const result = [];\n  for (let i = 0; i < arr1.length; i++) {\n    const member = arr1[i];\n    if (arr2.indexOf(member) != -1)\n      result.push(member);\n  }\n  return result;\n}\nfunction arrIntersectOb(arr, ob) {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    const member = arr[i];\n    if (member in ob)\n      result.push(member);\n  }\n  return result;\n}\nfunction arrDeleteValue(arr, val) {\n  const idx = arr.indexOf(val);\n  const res = idx != -1;\n  if (res)\n    arr.splice(idx, 1);\n  return res;\n}\nfunction arrWithoutValue(arr, val) {\n  const newArr = arr.slice();\n  arrDeleteValue(newArr, val);\n  return newArr;\n}\nfunction keysArray(ob, ownOnly) {\n  const result = [];\n  for (const prop in ob) {\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))\n      continue;\n    result.push(prop);\n  }\n  return result;\n}\nfunction valuesArray(ob, ownOnly) {\n  const result = [];\n  for (const prop in ob) {\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))\n      continue;\n    result.push(ob[prop]);\n  }\n  return result;\n}\nfunction forInOwnNonNullProperties(ob, fn) {\n  for (const prop in ob) {\n    if (Object.prototype.hasOwnProperty.call(ob, prop) && ob[prop]) {\n      fn(prop);\n    }\n  }\n}\nfunction allSame(arr, prop) {\n  if (arr.length === 0) {\n    return true;\n  }\n  const first = arr[0][prop];\n  return arr.every(function(item) {\n    return item[prop] === first;\n  });\n}\nvar Format = /* @__PURE__ */ ((Format2) => {\n  Format2[\"msgpack\"] = \"msgpack\";\n  Format2[\"json\"] = \"json\";\n  return Format2;\n})(Format || {});\nfunction arrPopRandomElement(arr) {\n  return arr.splice(randomPosn(arr), 1)[0];\n}\nfunction toQueryString(params) {\n  const parts = [];\n  if (params) {\n    for (const key in params)\n      parts.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n  }\n  return parts.length ? \"?\" + parts.join(\"&\") : \"\";\n}\nfunction parseQueryString(query) {\n  let match;\n  const search = /([^?&=]+)=?([^&]*)/g;\n  const result = {};\n  while (match = search.exec(query))\n    result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);\n  return result;\n}\nfunction isErrorInfoOrPartialErrorInfo(err) {\n  return typeof err == \"object\" && err !== null && (err instanceof ErrorInfo || err instanceof PartialErrorInfo);\n}\nfunction inspectError(err) {\n  var _a2, _b;\n  if (err instanceof Error || ((_a2 = err == null ? void 0 : err.constructor) == null ? void 0 : _a2.name) === \"ErrorInfo\" || ((_b = err == null ? void 0 : err.constructor) == null ? void 0 : _b.name) === \"PartialErrorInfo\")\n    return err.toString();\n  return Platform.Config.inspect(err);\n}\nfunction inspectBody(body) {\n  if (Platform.BufferUtils.isBuffer(body)) {\n    return body.toString();\n  } else if (typeof body === \"string\") {\n    return body;\n  } else {\n    return Platform.Config.inspect(body);\n  }\n}\nfunction dataSizeBytes(data) {\n  if (Platform.BufferUtils.isBuffer(data)) {\n    return Platform.BufferUtils.byteLength(data);\n  }\n  if (typeof data === \"string\") {\n    return Platform.Config.stringByteSize(data);\n  }\n  if (typeof data === \"number\") {\n    return 8;\n  }\n  if (typeof data === \"boolean\") {\n    return 1;\n  }\n  throw new Error(\n    `Expected input of Utils.dataSizeBytes to be a string, a number, a boolean or a buffer, but was: ${typeof data}`\n  );\n}\nfunction cheapRandStr() {\n  return String(Math.random()).substr(2);\n}\nvar randomString = async (numBytes) => {\n  const buffer = await Platform.Config.getRandomArrayBuffer(numBytes);\n  return Platform.BufferUtils.base64Encode(buffer);\n};\nfunction arrChooseN(arr, n2) {\n  const numItems = Math.min(n2, arr.length), mutableArr = arr.slice(), result = [];\n  for (let i = 0; i < numItems; i++) {\n    result.push(arrPopRandomElement(mutableArr));\n  }\n  return result;\n}\nfunction whenPromiseSettles(promise, callback) {\n  promise.then((result) => {\n    callback == null ? void 0 : callback(null, result);\n  }).catch((err) => {\n    callback == null ? void 0 : callback(err);\n  });\n}\nfunction decodeBody(body, MsgPack, format) {\n  if (format == \"msgpack\") {\n    if (!MsgPack) {\n      throwMissingPluginError(\"MsgPack\");\n    }\n    return MsgPack.decode(body);\n  }\n  return JSON.parse(String(body));\n}\nfunction encodeBody(body, MsgPack, format) {\n  if (format == \"msgpack\") {\n    if (!MsgPack) {\n      throwMissingPluginError(\"MsgPack\");\n    }\n    return MsgPack.encode(body, true);\n  }\n  return JSON.stringify(body);\n}\nfunction allToLowerCase(arr) {\n  return arr.map(function(element) {\n    return element && element.toLowerCase();\n  });\n}\nfunction allToUpperCase(arr) {\n  return arr.map(function(element) {\n    return element && element.toUpperCase();\n  });\n}\nfunction getBackoffCoefficient(count) {\n  return Math.min((count + 2) / 3, 2);\n}\nfunction getJitterCoefficient() {\n  return 1 - Math.random() * 0.2;\n}\nfunction getRetryTime(initialTimeout, retryAttempt) {\n  return initialTimeout * getBackoffCoefficient(retryAttempt) * getJitterCoefficient();\n}\nfunction getGlobalObject() {\n  if (typeof __webpack_require__.g !== \"undefined\") {\n    return __webpack_require__.g;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  return self;\n}\nfunction shallowEquals(source, target) {\n  return Object.keys(source).every((key) => source[key] === target[key]) && Object.keys(target).every((key) => target[key] === source[key]);\n}\nfunction matchDerivedChannel(name) {\n  const regex = /^(\\[([^?]*)(?:(.*))\\])?(.+)$/;\n  const match = name.match(regex);\n  if (!match || !match.length || match.length < 5) {\n    throw new ErrorInfo(\"regex match failed\", 400, 40010);\n  }\n  if (match[2]) {\n    throw new ErrorInfo(`cannot use a derived option with a ${match[2]} channel`, 400, 40010);\n  }\n  return {\n    qualifierParam: match[3] || \"\",\n    channelName: match[4]\n  };\n}\nfunction toBase64(str) {\n  const bufferUtils = Platform.BufferUtils;\n  const textBuffer = bufferUtils.utf8Encode(str);\n  return bufferUtils.base64Encode(textBuffer);\n}\nfunction arrEquals(a, b) {\n  return a.length === b.length && a.every(function(val, i) {\n    return val === b[i];\n  });\n}\nfunction createMissingPluginError(pluginName) {\n  return new ErrorInfo(`${pluginName} plugin not provided`, 40019, 400);\n}\nfunction throwMissingPluginError(pluginName) {\n  throw createMissingPluginError(pluginName);\n}\nasync function withTimeoutAsync(promise, timeout = 5e3, err = \"Timeout expired\") {\n  const e = new ErrorInfo(err, 5e4, 500);\n  return Promise.race([promise, new Promise((_resolve, reject) => setTimeout(() => reject(e), timeout))]);\n}\n\n// package.json\nvar version = \"2.14.0\";\n\n// src/common/lib/util/defaults.ts\nvar agent = \"ably-js/\" + version;\nvar Defaults = {\n  ENDPOINT: \"main\",\n  ENVIRONMENT: \"\",\n  REST_HOST: \"rest.ably.io\",\n  REALTIME_HOST: \"realtime.ably.io\",\n  FALLBACK_HOSTS: [\n    \"main.a.fallback.ably-realtime.com\",\n    \"main.b.fallback.ably-realtime.com\",\n    \"main.c.fallback.ably-realtime.com\",\n    \"main.d.fallback.ably-realtime.com\",\n    \"main.e.fallback.ably-realtime.com\"\n  ],\n  PORT: 80,\n  TLS_PORT: 443,\n  TIMEOUTS: {\n    /* Documented as options params: */\n    disconnectedRetryTimeout: 15e3,\n    suspendedRetryTimeout: 3e4,\n    /* Undocumented, but part of the api and can be used by customers: */\n    httpRequestTimeout: 1e4,\n    httpMaxRetryDuration: 15e3,\n    channelRetryTimeout: 15e3,\n    fallbackRetryTimeout: 6e5,\n    /* For internal / test use only: */\n    connectionStateTtl: 12e4,\n    realtimeRequestTimeout: 1e4,\n    recvTimeout: 9e4,\n    webSocketConnectTimeout: 1e4,\n    webSocketSlowTimeout: 4e3\n  },\n  httpMaxRetryCount: 3,\n  maxMessageSize: 65536,\n  version,\n  protocolVersion: 4,\n  agent,\n  getPort,\n  getHttpScheme,\n  getPrimaryDomainFromEndpoint,\n  getEndpointFallbackHosts,\n  getFallbackHosts,\n  getHosts,\n  checkHost,\n  objectifyOptions,\n  normaliseOptions,\n  defaultGetHeaders,\n  defaultPostHeaders\n};\nfunction getPort(options, tls) {\n  return tls || options.tls ? options.tlsPort : options.port;\n}\nfunction getHttpScheme(options) {\n  return options.tls ? \"https://\" : \"http://\";\n}\nfunction isFqdnIpOrLocalhost(endpoint) {\n  return endpoint.includes(\".\") || endpoint.includes(\"::\") || endpoint === \"localhost\";\n}\nfunction getPrimaryDomainFromEndpoint(endpoint) {\n  if (isFqdnIpOrLocalhost(endpoint))\n    return endpoint;\n  if (endpoint.startsWith(\"nonprod:\")) {\n    const routingPolicyId = endpoint.replace(\"nonprod:\", \"\");\n    return `${routingPolicyId}.realtime.ably-nonprod.net`;\n  }\n  return `${endpoint}.realtime.ably.net`;\n}\nfunction getEndpointFallbackHosts(endpoint) {\n  if (isFqdnIpOrLocalhost(endpoint))\n    return [];\n  if (endpoint.startsWith(\"nonprod:\")) {\n    const routingPolicyId = endpoint.replace(\"nonprod:\", \"\");\n    return endpointFallbacks(routingPolicyId, \"ably-realtime-nonprod.com\");\n  }\n  return endpointFallbacks(endpoint, \"ably-realtime.com\");\n}\nfunction endpointFallbacks(routingPolicyId, domain) {\n  return [\"a\", \"b\", \"c\", \"d\", \"e\"].map((id) => `${routingPolicyId}.${id}.fallback.${domain}`);\n}\nfunction getFallbackHosts(options) {\n  const fallbackHosts = options.fallbackHosts, httpMaxRetryCount = typeof options.httpMaxRetryCount !== \"undefined\" ? options.httpMaxRetryCount : Defaults.httpMaxRetryCount;\n  return fallbackHosts ? arrChooseN(fallbackHosts, httpMaxRetryCount) : [];\n}\nfunction getHosts(options) {\n  return [options.primaryDomain].concat(getFallbackHosts(options));\n}\nfunction checkHost(host) {\n  if (typeof host !== \"string\") {\n    throw new ErrorInfo(\"host must be a string; was a \" + typeof host, 4e4, 400);\n  }\n  if (!host.length) {\n    throw new ErrorInfo(\"host must not be zero-length\", 4e4, 400);\n  }\n}\nfunction getTimeouts(options) {\n  const timeouts = {};\n  for (const prop in Defaults.TIMEOUTS) {\n    timeouts[prop] = options[prop] || Defaults.TIMEOUTS[prop];\n  }\n  return timeouts;\n}\nfunction getAgentString(options) {\n  let agentStr = Defaults.agent;\n  if (options.agents) {\n    for (var agent2 in options.agents) {\n      agentStr += \" \" + agent2 + \"/\" + options.agents[agent2];\n    }\n  }\n  return agentStr;\n}\nfunction objectifyOptions(options, allowKeyOrToken, sourceForErrorMessage, logger, modularPluginsToInclude) {\n  if (options === void 0) {\n    const msg = allowKeyOrToken ? `${sourceForErrorMessage} must be initialized with either a client options object, an Ably API key, or an Ably Token` : `${sourceForErrorMessage} must be initialized with a client options object`;\n    logger_default.logAction(logger, logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n    throw new Error(msg);\n  }\n  let optionsObj;\n  if (typeof options === \"string\") {\n    if (options.indexOf(\":\") == -1) {\n      if (!allowKeyOrToken) {\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably Token; you must provide a client options object with a \\`plugins\\` property. (Set this Ably Token as the object\\u2019s \\`token\\` property.)`;\n        logger_default.logAction(logger, logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n        throw new Error(msg);\n      }\n      optionsObj = { token: options };\n    } else {\n      if (!allowKeyOrToken) {\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably API key; you must provide a client options object with a \\`plugins\\` property. (Set this Ably API key as the object\\u2019s \\`key\\` property.)`;\n        logger_default.logAction(logger, logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n        throw new Error(msg);\n      }\n      optionsObj = { key: options };\n    }\n  } else {\n    optionsObj = options;\n  }\n  if (modularPluginsToInclude) {\n    optionsObj = __spreadProps(__spreadValues({}, optionsObj), { plugins: __spreadValues(__spreadValues({}, modularPluginsToInclude), optionsObj.plugins) });\n  }\n  return optionsObj;\n}\nfunction checkIfClientOptionsAreValid(options) {\n  if (options.endpoint && (options.environment || options.restHost || options.realtimeHost)) {\n    throw new ErrorInfo(\n      \"The `endpoint` option cannot be used in conjunction with the `environment`, `restHost`, or `realtimeHost` options.\",\n      40106,\n      400\n    );\n  }\n  if (options.environment && (options.restHost || options.realtimeHost)) {\n    throw new ErrorInfo(\n      \"The `environment` option cannot be used in conjunction with the `restHost`, or `realtimeHost` options.\",\n      40106,\n      400\n    );\n  }\n}\nfunction normaliseOptions(options, MsgPack, logger) {\n  const loggerToUse = logger != null ? logger : logger_default.defaultLogger;\n  if (options.environment) {\n    loggerToUse.deprecated(\"The `environment` client option\", \"Use the `endpoint` client option instead.\");\n  }\n  if (options.restHost) {\n    loggerToUse.deprecated(\"The `restHost` client option\", \"Use the `endpoint` client option instead.\");\n  }\n  if (options.realtimeHost) {\n    loggerToUse.deprecated(\"The `realtimeHost` client option\", \"Use the `endpoint` client option instead.\");\n  }\n  checkIfClientOptionsAreValid(options);\n  if (typeof options.recover === \"function\" && options.closeOnUnload === true) {\n    logger_default.logAction(\n      loggerToUse,\n      logger_default.LOG_ERROR,\n      \"Defaults.normaliseOptions\",\n      \"closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter\"\n    );\n    options.recover = void 0;\n  }\n  if (!(\"closeOnUnload\" in options)) {\n    options.closeOnUnload = !options.recover;\n  }\n  if (!(\"queueMessages\" in options))\n    options.queueMessages = true;\n  const endpoint = options.endpoint || Defaults.ENDPOINT;\n  if (!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {\n    options.fallbackHosts = getEndpointFallbackHosts(options.environment || endpoint);\n  }\n  const primaryDomainFromEnvironment = options.environment && `${options.environment}.realtime.ably.net`;\n  const primaryDomainFromLegacyOptions = options.restHost || options.realtimeHost || primaryDomainFromEnvironment;\n  const primaryDomain = primaryDomainFromLegacyOptions || getPrimaryDomainFromEndpoint(endpoint);\n  (options.fallbackHosts || []).concat(primaryDomain).forEach(checkHost);\n  options.port = options.port || Defaults.PORT;\n  options.tlsPort = options.tlsPort || Defaults.TLS_PORT;\n  if (!(\"tls\" in options))\n    options.tls = true;\n  const timeouts = getTimeouts(options);\n  if (MsgPack) {\n    if (\"useBinaryProtocol\" in options) {\n      options.useBinaryProtocol = Platform.Config.supportsBinary && options.useBinaryProtocol;\n    } else {\n      options.useBinaryProtocol = Platform.Config.preferBinary;\n    }\n  } else {\n    options.useBinaryProtocol = false;\n  }\n  const headers = {};\n  if (options.clientId) {\n    headers[\"X-Ably-ClientId\"] = Platform.BufferUtils.base64Encode(Platform.BufferUtils.utf8Encode(options.clientId));\n  }\n  if (!(\"idempotentRestPublishing\" in options)) {\n    options.idempotentRestPublishing = true;\n  }\n  let connectivityCheckParams = null;\n  let connectivityCheckUrl = options.connectivityCheckUrl;\n  if (options.connectivityCheckUrl) {\n    let [uri, qs] = options.connectivityCheckUrl.split(\"?\");\n    connectivityCheckParams = qs ? parseQueryString(qs) : {};\n    if (uri.indexOf(\"://\") === -1) {\n      uri = \"https://\" + uri;\n    }\n    connectivityCheckUrl = uri;\n  }\n  let wsConnectivityCheckUrl = options.wsConnectivityCheckUrl;\n  if (wsConnectivityCheckUrl && wsConnectivityCheckUrl.indexOf(\"://\") === -1) {\n    wsConnectivityCheckUrl = \"wss://\" + wsConnectivityCheckUrl;\n  }\n  return __spreadProps(__spreadValues({}, options), {\n    primaryDomain,\n    maxMessageSize: options.maxMessageSize || Defaults.maxMessageSize,\n    timeouts,\n    connectivityCheckParams,\n    connectivityCheckUrl,\n    wsConnectivityCheckUrl,\n    headers\n  });\n}\nfunction normaliseChannelOptions(Crypto2, logger, options) {\n  const channelOptions = options || {};\n  if (channelOptions.cipher) {\n    if (!Crypto2)\n      throwMissingPluginError(\"Crypto\");\n    const cipher = Crypto2.getCipher(channelOptions.cipher, logger);\n    channelOptions.cipher = cipher.cipherParams;\n    channelOptions.channelCipher = cipher.cipher;\n  } else if (\"cipher\" in channelOptions) {\n    channelOptions.cipher = void 0;\n    channelOptions.channelCipher = null;\n  }\n  return channelOptions;\n}\nvar contentTypes = {\n  json: \"application/json\",\n  xml: \"application/xml\",\n  html: \"text/html\",\n  msgpack: \"application/x-msgpack\",\n  text: \"text/plain\"\n};\nvar defaultHeadersOptions = {\n  format: \"json\" /* json */,\n  protocolVersion: Defaults.protocolVersion\n};\nfunction defaultGetHeaders(options, {\n  format = defaultHeadersOptions.format,\n  protocolVersion = defaultHeadersOptions.protocolVersion\n} = {}) {\n  const accept = contentTypes[format];\n  return {\n    accept,\n    \"X-Ably-Version\": protocolVersion.toString(),\n    \"Ably-Agent\": getAgentString(options)\n  };\n}\nfunction defaultPostHeaders(options, {\n  format = defaultHeadersOptions.format,\n  protocolVersion = defaultHeadersOptions.protocolVersion\n} = {}) {\n  let contentType;\n  const accept = contentType = contentTypes[format];\n  return {\n    accept,\n    \"content-type\": contentType,\n    \"X-Ably-Version\": protocolVersion.toString(),\n    \"Ably-Agent\": getAgentString(options)\n  };\n}\nvar defaults_default = Defaults;\nfunction getDefaults(platformDefaults) {\n  return Object.assign(Defaults, platformDefaults);\n}\n\n// src/common/lib/util/multicaster.ts\nvar Multicaster = class _Multicaster {\n  // Private constructor; use static Multicaster.create instead\n  constructor(logger, members) {\n    this.logger = logger;\n    this.members = members || [];\n  }\n  call(err, result) {\n    for (const member of this.members) {\n      if (member) {\n        try {\n          member(err, result);\n        } catch (e) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"Multicaster multiple callback handler\",\n            \"Unexpected exception: \" + e + \"; stack = \" + e.stack\n          );\n        }\n      }\n    }\n  }\n  push(...args) {\n    this.members.push(...args);\n  }\n  createPromise() {\n    return new Promise((resolve, reject) => {\n      this.push((err, result) => {\n        err ? reject(err) : resolve(result);\n      });\n    });\n  }\n  resolveAll(result) {\n    this.call(null, result);\n  }\n  rejectAll(err) {\n    this.call(err);\n  }\n  static create(logger, members) {\n    const instance = new _Multicaster(logger, members);\n    return Object.assign((err, result) => instance.call(err, result), {\n      push: (fn) => instance.push(fn),\n      createPromise: () => instance.createPromise(),\n      resolveAll: (result) => instance.resolveAll(result),\n      rejectAll: (err) => instance.rejectAll(err)\n    });\n  }\n};\nvar multicaster_default = Multicaster;\n\n// src/common/constants/HttpMethods.ts\nvar HttpMethods = /* @__PURE__ */ ((HttpMethods2) => {\n  HttpMethods2[\"Get\"] = \"get\";\n  HttpMethods2[\"Delete\"] = \"delete\";\n  HttpMethods2[\"Post\"] = \"post\";\n  HttpMethods2[\"Put\"] = \"put\";\n  HttpMethods2[\"Patch\"] = \"patch\";\n  return HttpMethods2;\n})(HttpMethods || {});\nvar HttpMethods_default = HttpMethods;\n\n// src/common/constants/HttpStatusCodes.ts\nvar HttpStatusCodes = /* @__PURE__ */ ((HttpStatusCodes2) => {\n  HttpStatusCodes2[HttpStatusCodes2[\"Success\"] = 200] = \"Success\";\n  HttpStatusCodes2[HttpStatusCodes2[\"NoContent\"] = 204] = \"NoContent\";\n  HttpStatusCodes2[HttpStatusCodes2[\"BadRequest\"] = 400] = \"BadRequest\";\n  HttpStatusCodes2[HttpStatusCodes2[\"Unauthorized\"] = 401] = \"Unauthorized\";\n  HttpStatusCodes2[HttpStatusCodes2[\"Forbidden\"] = 403] = \"Forbidden\";\n  HttpStatusCodes2[HttpStatusCodes2[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n  HttpStatusCodes2[HttpStatusCodes2[\"InternalServerError\"] = 500] = \"InternalServerError\";\n  return HttpStatusCodes2;\n})(HttpStatusCodes || {});\nfunction isSuccessCode(statusCode) {\n  return statusCode >= 200 /* Success */ && statusCode < 400 /* BadRequest */;\n}\nvar HttpStatusCodes_default = HttpStatusCodes;\n\n// src/common/lib/client/auth.ts\nvar MAX_TOKEN_LENGTH = Math.pow(2, 17);\nfunction random() {\n  return (\"000000\" + Math.floor(Math.random() * 1e16)).slice(-16);\n}\nfunction isRealtime(client) {\n  return !!client.connection;\n}\nfunction normaliseAuthcallbackError(err) {\n  if (!isErrorInfoOrPartialErrorInfo(err)) {\n    return new ErrorInfo(inspectError(err), err.code || 40170, err.statusCode || 401);\n  }\n  if (!err.code) {\n    if (err.statusCode === 403) {\n      err.code = 40300;\n    } else {\n      err.code = 40170;\n      err.statusCode = 401;\n    }\n  }\n  return err;\n}\nvar hmac = (text, key) => {\n  const bufferUtils = Platform.BufferUtils;\n  const textBuffer = bufferUtils.utf8Encode(text);\n  const keyBuffer = bufferUtils.utf8Encode(key);\n  const digest = bufferUtils.hmacSha256(textBuffer, keyBuffer);\n  return bufferUtils.base64Encode(digest);\n};\nfunction c14n(capability) {\n  if (!capability)\n    return \"\";\n  if (typeof capability == \"string\")\n    capability = JSON.parse(capability);\n  const c14nCapability = /* @__PURE__ */ Object.create(null);\n  const keys = keysArray(capability, true);\n  if (!keys)\n    return \"\";\n  keys.sort();\n  for (let i = 0; i < keys.length; i++) {\n    c14nCapability[keys[i]] = capability[keys[i]].sort();\n  }\n  return JSON.stringify(c14nCapability);\n}\nfunction logAndValidateTokenAuthMethod(authOptions, logger) {\n  if (authOptions.authCallback) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with authCallback\");\n  } else if (authOptions.authUrl) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with authUrl\");\n  } else if (authOptions.key) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with client-side signing\");\n  } else if (authOptions.tokenDetails) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with supplied token only\");\n  } else {\n    const msg = \"authOptions must include valid authentication parameters\";\n    logger_default.logAction(logger, logger_default.LOG_ERROR, \"Auth()\", msg);\n    throw new Error(msg);\n  }\n}\nfunction basicAuthForced(options) {\n  return \"useTokenAuth\" in options && !options.useTokenAuth;\n}\nfunction useTokenAuth(options) {\n  return options.useTokenAuth || !basicAuthForced(options) && (options.authCallback || options.authUrl || options.token || options.tokenDetails);\n}\nfunction noWayToRenew(options) {\n  return !options.key && !options.authCallback && !options.authUrl;\n}\nvar trId = 0;\nfunction getTokenRequestId() {\n  return trId++;\n}\nvar Auth = class {\n  constructor(client, options) {\n    // This initialization is always overwritten and only used to prevent a TypeScript compiler error\n    this.authOptions = {};\n    this.client = client;\n    this.tokenParams = options.defaultTokenParams || {};\n    this.currentTokenRequestId = null;\n    this.waitingForTokenRequest = null;\n    if (useTokenAuth(options)) {\n      if (noWayToRenew(options)) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"Auth()\",\n          \"Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help\"\n        );\n      }\n      this._saveTokenOptions(options.defaultTokenParams, options);\n      logAndValidateTokenAuthMethod(this.authOptions, this.logger);\n    } else {\n      if (!options.key) {\n        const msg = \"No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)\";\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth()\", msg);\n        throw new ErrorInfo(msg, 40160, 401);\n      }\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth()\", \"anonymous, using basic auth\");\n      this._saveBasicOptions(options);\n    }\n  }\n  get logger() {\n    return this.client.logger;\n  }\n  async authorize(tokenParams, authOptions) {\n    if (authOptions && authOptions.key && this.authOptions.key !== authOptions.key) {\n      throw new ErrorInfo(\"Unable to update auth options with incompatible key\", 40102, 401);\n    }\n    try {\n      let tokenDetails = await this._forceNewToken(tokenParams != null ? tokenParams : null, authOptions != null ? authOptions : null);\n      if (isRealtime(this.client)) {\n        return new Promise((resolve, reject) => {\n          this.client.connection.connectionManager.onAuthUpdated(\n            tokenDetails,\n            (err, tokenDetails2) => err ? reject(err) : resolve(tokenDetails2)\n          );\n        });\n      } else {\n        return tokenDetails;\n      }\n    } catch (err) {\n      if (this.client.connection && err.statusCode === HttpStatusCodes_default.Forbidden) {\n        this.client.connection.connectionManager.actOnErrorFromAuthorize(err);\n      }\n      throw err;\n    }\n  }\n  /* For internal use, eg by connectionManager - useful when want to call back\n   * as soon as we have the new token, rather than waiting for it to take\n   * effect on the connection as #authorize does */\n  async _forceNewToken(tokenParams, authOptions) {\n    this.tokenDetails = null;\n    this._saveTokenOptions(tokenParams, authOptions);\n    logAndValidateTokenAuthMethod(this.authOptions, this.logger);\n    try {\n      return this._ensureValidAuthCredentials(true);\n    } finally {\n      delete this.tokenParams.timestamp;\n      delete this.authOptions.queryTime;\n    }\n  }\n  async requestToken(tokenParams, authOptions) {\n    const resolvedAuthOptions = authOptions || this.authOptions;\n    const resolvedTokenParams = tokenParams || copy(this.tokenParams);\n    let tokenRequestCallback, client = this.client;\n    if (resolvedAuthOptions.authCallback) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.requestToken()\", \"using token auth with authCallback\");\n      tokenRequestCallback = resolvedAuthOptions.authCallback;\n    } else if (resolvedAuthOptions.authUrl) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.requestToken()\", \"using token auth with authUrl\");\n      tokenRequestCallback = (params, cb) => {\n        const authHeaders = mixin(\n          { accept: \"application/json, text/plain\" },\n          resolvedAuthOptions.authHeaders\n        );\n        const usePost = resolvedAuthOptions.authMethod && resolvedAuthOptions.authMethod.toLowerCase() === \"post\";\n        let providedQsParams;\n        const queryIdx = resolvedAuthOptions.authUrl.indexOf(\"?\");\n        if (queryIdx > -1) {\n          providedQsParams = parseQueryString(resolvedAuthOptions.authUrl.slice(queryIdx));\n          resolvedAuthOptions.authUrl = resolvedAuthOptions.authUrl.slice(0, queryIdx);\n          if (!usePost) {\n            resolvedAuthOptions.authParams = mixin(\n              providedQsParams,\n              resolvedAuthOptions.authParams\n            );\n          }\n        }\n        const authParams = mixin({}, resolvedAuthOptions.authParams || {}, params);\n        const authUrlRequestCallback = (result) => {\n          var _a2, _b;\n          let body = (_a2 = result.body) != null ? _a2 : null;\n          let contentType = null;\n          if (result.error) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MICRO,\n              \"Auth.requestToken().tokenRequestCallback\",\n              \"Received Error: \" + inspectError(result.error)\n            );\n          } else {\n            const contentTypeHeaderOrHeaders = (_b = result.headers[\"content-type\"]) != null ? _b : null;\n            if (Array.isArray(contentTypeHeaderOrHeaders)) {\n              contentType = contentTypeHeaderOrHeaders.join(\", \");\n            } else {\n              contentType = contentTypeHeaderOrHeaders;\n            }\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MICRO,\n              \"Auth.requestToken().tokenRequestCallback\",\n              \"Received; content-type: \" + contentType + \"; body: \" + inspectBody(body)\n            );\n          }\n          if (result.error) {\n            cb(result.error, null);\n            return;\n          }\n          if (result.unpacked) {\n            cb(null, body);\n            return;\n          }\n          if (Platform.BufferUtils.isBuffer(body))\n            body = body.toString();\n          if (!contentType) {\n            cb(new ErrorInfo(\"authUrl response is missing a content-type header\", 40170, 401), null);\n            return;\n          }\n          const json = contentType.indexOf(\"application/json\") > -1, text = contentType.indexOf(\"text/plain\") > -1 || contentType.indexOf(\"application/jwt\") > -1;\n          if (!json && !text) {\n            cb(\n              new ErrorInfo(\n                \"authUrl responded with unacceptable content-type \" + contentType + \", should be either text/plain, application/jwt or application/json\",\n                40170,\n                401\n              ),\n              null\n            );\n            return;\n          }\n          if (json) {\n            if (body.length > MAX_TOKEN_LENGTH) {\n              cb(new ErrorInfo(\"authUrl response exceeded max permitted length\", 40170, 401), null);\n              return;\n            }\n            try {\n              body = JSON.parse(body);\n            } catch (e) {\n              cb(\n                new ErrorInfo(\n                  \"Unexpected error processing authURL response; err = \" + e.message,\n                  40170,\n                  401\n                ),\n                null\n              );\n              return;\n            }\n          }\n          cb(null, body, contentType);\n        };\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"Auth.requestToken().tokenRequestCallback\",\n          \"Requesting token from \" + resolvedAuthOptions.authUrl + \"; Params: \" + JSON.stringify(authParams) + \"; method: \" + (usePost ? \"POST\" : \"GET\")\n        );\n        if (usePost) {\n          const headers = authHeaders || {};\n          headers[\"content-type\"] = \"application/x-www-form-urlencoded\";\n          const body = toQueryString(authParams).slice(1);\n          whenPromiseSettles(\n            this.client.http.doUri(\n              HttpMethods_default.Post,\n              resolvedAuthOptions.authUrl,\n              headers,\n              body,\n              providedQsParams\n            ),\n            (err, result) => err ? authUrlRequestCallback(err) : authUrlRequestCallback(result)\n          );\n        } else {\n          whenPromiseSettles(\n            this.client.http.doUri(HttpMethods_default.Get, resolvedAuthOptions.authUrl, authHeaders || {}, null, authParams),\n            (err, result) => err ? authUrlRequestCallback(err) : authUrlRequestCallback(result)\n          );\n        }\n      };\n    } else if (resolvedAuthOptions.key) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"Auth.requestToken()\",\n        \"using token auth with client-side signing\"\n      );\n      tokenRequestCallback = (params, cb) => {\n        whenPromiseSettles(\n          this.createTokenRequest(params, resolvedAuthOptions),\n          (err, result) => cb(err, result != null ? result : null)\n        );\n      };\n    } else {\n      const msg = \"Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)\";\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"Auth()\",\n        \"library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help\"\n      );\n      throw new ErrorInfo(msg, 40171, 403);\n    }\n    if (\"capability\" in resolvedTokenParams)\n      resolvedTokenParams.capability = c14n(\n        resolvedTokenParams.capability\n      );\n    const tokenRequest = (signedTokenParams, tokenCb) => {\n      const keyName = signedTokenParams.keyName, path = \"/keys/\" + keyName + \"/requestToken\", tokenUri = function(host) {\n        return client.baseUri(host) + path;\n      };\n      const requestHeaders = defaults_default.defaultPostHeaders(this.client.options);\n      if (resolvedAuthOptions.requestHeaders)\n        mixin(requestHeaders, resolvedAuthOptions.requestHeaders);\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"Auth.requestToken().requestToken\",\n        \"Sending POST to \" + path + \"; Token params: \" + JSON.stringify(signedTokenParams)\n      );\n      whenPromiseSettles(\n        this.client.http.do(HttpMethods_default.Post, tokenUri, requestHeaders, JSON.stringify(signedTokenParams), null),\n        (err, result) => err ? tokenCb(err) : tokenCb(result.error, result.body, result.unpacked)\n      );\n    };\n    return new Promise((resolve, reject) => {\n      let tokenRequestCallbackTimeoutExpired = false, timeoutLength = this.client.options.timeouts.realtimeRequestTimeout, tokenRequestCallbackTimeout = setTimeout(() => {\n        tokenRequestCallbackTimeoutExpired = true;\n        const msg = \"Token request callback timed out after \" + timeoutLength / 1e3 + \" seconds\";\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n        reject(new ErrorInfo(msg, 40170, 401));\n      }, timeoutLength);\n      tokenRequestCallback(resolvedTokenParams, (err, tokenRequestOrDetails, contentType) => {\n        if (tokenRequestCallbackTimeoutExpired)\n          return;\n        clearTimeout(tokenRequestCallbackTimeout);\n        if (err) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"Auth.requestToken()\",\n            \"token request signing call returned error; err = \" + inspectError(err)\n          );\n          reject(normaliseAuthcallbackError(err));\n          return;\n        }\n        if (typeof tokenRequestOrDetails === \"string\") {\n          if (tokenRequestOrDetails.length === 0) {\n            reject(new ErrorInfo(\"Token string is empty\", 40170, 401));\n          } else if (tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {\n            reject(\n              new ErrorInfo(\n                \"Token string exceeded max permitted length (was \" + tokenRequestOrDetails.length + \" bytes)\",\n                40170,\n                401\n              )\n            );\n          } else if (tokenRequestOrDetails === \"undefined\" || tokenRequestOrDetails === \"null\") {\n            reject(new ErrorInfo(\"Token string was literal null/undefined\", 40170, 401));\n          } else if (tokenRequestOrDetails[0] === \"{\" && !(contentType && contentType.indexOf(\"application/jwt\") > -1)) {\n            reject(\n              new ErrorInfo(\n                \"Token was double-encoded; make sure you're not JSON-encoding an already encoded token request or details\",\n                40170,\n                401\n              )\n            );\n          } else {\n            resolve({ token: tokenRequestOrDetails });\n          }\n          return;\n        }\n        if (typeof tokenRequestOrDetails !== \"object\" || tokenRequestOrDetails === null) {\n          const msg = \"Expected token request callback to call back with a token string or token request/details object, but got a \" + typeof tokenRequestOrDetails;\n          logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n          reject(new ErrorInfo(msg, 40170, 401));\n          return;\n        }\n        const objectSize = JSON.stringify(tokenRequestOrDetails).length;\n        if (objectSize > MAX_TOKEN_LENGTH && !resolvedAuthOptions.suppressMaxLengthCheck) {\n          reject(\n            new ErrorInfo(\n              \"Token request/details object exceeded max permitted stringified size (was \" + objectSize + \" bytes)\",\n              40170,\n              401\n            )\n          );\n          return;\n        }\n        if (\"issued\" in tokenRequestOrDetails) {\n          resolve(tokenRequestOrDetails);\n          return;\n        }\n        if (!(\"keyName\" in tokenRequestOrDetails)) {\n          const msg = \"Expected token request callback to call back with a token string, token request object, or token details object\";\n          logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n          reject(new ErrorInfo(msg, 40170, 401));\n          return;\n        }\n        tokenRequest(tokenRequestOrDetails, (err2, tokenResponse, unpacked) => {\n          if (err2) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_ERROR,\n              \"Auth.requestToken()\",\n              \"token request API call returned error; err = \" + inspectError(err2)\n            );\n            reject(normaliseAuthcallbackError(err2));\n            return;\n          }\n          if (!unpacked)\n            tokenResponse = JSON.parse(tokenResponse);\n          logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.getToken()\", \"token received\");\n          resolve(tokenResponse);\n        });\n      });\n    });\n  }\n  /**\n   * Create and sign a token request based on the given options.\n   * NOTE this can only be used when the key value is available locally.\n   * Otherwise, signed token requests must be obtained from the key\n   * owner (either using the token request callback or url).\n   *\n   * @param authOptions\n   * an object containing the request options:\n   * - key:           the key to use. If not specified, a key passed in constructing\n   *                  the Rest interface will be used\n   *\n   * - queryTime      (optional) boolean indicating that the ably system should be\n   *                  queried for the current time when none is specified explicitly\n   *\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\n   *                  requestToken request\n   *\n   * @param tokenParams\n   * an object containing the parameters for the requested token:\n   * - ttl:       (optional) the requested life of the token in ms. If none is specified\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\n   *                  exceeding that lifetime will be rejected with an error.\n   *\n   * - capability:    (optional) the capability to associate with the access token.\n   *                  If none is specified, a token will be requested with all of the\n   *                  capabilities of the specified key.\n   *\n   * - clientId:      (optional) a client ID to associate with the token; if not\n   *                  specified, a clientId passed in constructing the Rest interface will be used\n   *\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\n   *                  the system will be queried for a time value to use.\n   */\n  async createTokenRequest(tokenParams, authOptions) {\n    authOptions = authOptions || this.authOptions;\n    tokenParams = tokenParams || copy(this.tokenParams);\n    const key = authOptions.key;\n    if (!key) {\n      throw new ErrorInfo(\"No key specified\", 40101, 403);\n    }\n    const keyParts = key.split(\":\"), keyName = keyParts[0], keySecret = keyParts[1];\n    if (!keySecret) {\n      throw new ErrorInfo(\"Invalid key specified\", 40101, 403);\n    }\n    if (tokenParams.clientId === \"\") {\n      throw new ErrorInfo(\"clientId can\\u2019t be an empty string\", 40012, 400);\n    }\n    if (\"capability\" in tokenParams) {\n      tokenParams.capability = c14n(tokenParams.capability);\n    }\n    const request = mixin({ keyName }, tokenParams), clientId = tokenParams.clientId || \"\", ttl = tokenParams.ttl || \"\", capability = tokenParams.capability || \"\";\n    if (!request.timestamp) {\n      request.timestamp = await this._getTimestamp(authOptions && authOptions.queryTime);\n    }\n    const nonce = request.nonce || (request.nonce = random()), timestamp = request.timestamp;\n    const signText = request.keyName + \"\\n\" + ttl + \"\\n\" + capability + \"\\n\" + clientId + \"\\n\" + timestamp + \"\\n\" + nonce + \"\\n\";\n    request.mac = request.mac || hmac(signText, keySecret);\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.getTokenRequest()\", \"generated signed request\");\n    return request;\n  }\n  /**\n   * Get the auth query params to use for a websocket connection,\n   * based on the current auth parameters\n   */\n  async getAuthParams() {\n    if (this.method == \"basic\")\n      return { key: this.key };\n    else {\n      let tokenDetails = await this._ensureValidAuthCredentials(false);\n      if (!tokenDetails) {\n        throw new Error(\"Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails\");\n      }\n      return { access_token: tokenDetails.token };\n    }\n  }\n  /**\n   * Get the authorization header to use for a REST or comet request,\n   * based on the current auth parameters\n   */\n  async getAuthHeaders() {\n    if (this.method == \"basic\") {\n      return { authorization: \"Basic \" + this.basicKey };\n    } else {\n      const tokenDetails = await this._ensureValidAuthCredentials(false);\n      if (!tokenDetails) {\n        throw new Error(\"Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails\");\n      }\n      return { authorization: \"Bearer \" + toBase64(tokenDetails.token) };\n    }\n  }\n  _saveBasicOptions(authOptions) {\n    this.method = \"basic\";\n    this.key = authOptions.key;\n    this.basicKey = toBase64(authOptions.key);\n    this.authOptions = authOptions || {};\n    if (\"clientId\" in authOptions) {\n      this._userSetClientId(authOptions.clientId);\n    }\n  }\n  _saveTokenOptions(tokenParams, authOptions) {\n    this.method = \"token\";\n    if (tokenParams) {\n      this.tokenParams = tokenParams;\n    }\n    if (authOptions) {\n      if (authOptions.token) {\n        authOptions.tokenDetails = typeof authOptions.token === \"string\" ? { token: authOptions.token } : authOptions.token;\n      }\n      if (authOptions.tokenDetails) {\n        this.tokenDetails = authOptions.tokenDetails;\n      }\n      if (\"clientId\" in authOptions) {\n        this._userSetClientId(authOptions.clientId);\n      }\n      this.authOptions = authOptions;\n    }\n  }\n  /* @param forceSupersede: force a new token request even if there's one in\n   * progress, making all pending callbacks wait for the new one */\n  async _ensureValidAuthCredentials(forceSupersede) {\n    const token = this.tokenDetails;\n    if (token) {\n      if (this._tokenClientIdMismatch(token.clientId)) {\n        throw new ErrorInfo(\n          \"Mismatch between clientId in token (\" + token.clientId + \") and current clientId (\" + this.clientId + \")\",\n          40102,\n          403\n        );\n      }\n      if (!this.client.isTimeOffsetSet() || !token.expires || token.expires >= this.client.getTimestampUsingOffset()) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"Auth.getToken()\",\n          \"using cached token; expires = \" + token.expires\n        );\n        return token;\n      }\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.getToken()\", \"deleting expired token\");\n      this.tokenDetails = null;\n    }\n    const promise = (this.waitingForTokenRequest || (this.waitingForTokenRequest = multicaster_default.create(this.logger))).createPromise();\n    if (this.currentTokenRequestId !== null && !forceSupersede) {\n      return promise;\n    }\n    const tokenRequestId = this.currentTokenRequestId = getTokenRequestId();\n    let tokenResponse, caughtError = null;\n    try {\n      tokenResponse = await this.requestToken(this.tokenParams, this.authOptions);\n    } catch (err) {\n      caughtError = err;\n    }\n    if (this.currentTokenRequestId > tokenRequestId) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"Auth._ensureValidAuthCredentials()\",\n        \"Discarding token request response; overtaken by newer one\"\n      );\n      return promise;\n    }\n    this.currentTokenRequestId = null;\n    const multicaster = this.waitingForTokenRequest;\n    this.waitingForTokenRequest = null;\n    if (caughtError) {\n      multicaster == null ? void 0 : multicaster.rejectAll(caughtError);\n      return promise;\n    }\n    multicaster == null ? void 0 : multicaster.resolveAll(this.tokenDetails = tokenResponse);\n    return promise;\n  }\n  /* User-set: check types, '*' is disallowed, throw any errors */\n  _userSetClientId(clientId) {\n    if (!(typeof clientId === \"string\" || clientId === null)) {\n      throw new ErrorInfo(\"clientId must be either a string or null\", 40012, 400);\n    } else if (clientId === \"*\") {\n      throw new ErrorInfo(\n        'Can\\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: \"*\"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: \"*\"}, authOptions)',\n        40012,\n        400\n      );\n    } else {\n      const err = this._uncheckedSetClientId(clientId);\n      if (err)\n        throw err;\n    }\n  }\n  /* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */\n  _uncheckedSetClientId(clientId) {\n    if (this._tokenClientIdMismatch(clientId)) {\n      const msg = \"Unexpected clientId mismatch: client has \" + this.clientId + \", requested \" + clientId;\n      const err = new ErrorInfo(msg, 40102, 401);\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth._uncheckedSetClientId()\", msg);\n      return err;\n    } else {\n      this.clientId = this.tokenParams.clientId = clientId;\n      return null;\n    }\n  }\n  _tokenClientIdMismatch(tokenClientId) {\n    return !!(this.clientId && this.clientId !== \"*\" && tokenClientId && tokenClientId !== \"*\" && this.clientId !== tokenClientId);\n  }\n  static isTokenErr(error) {\n    return error.code && error.code >= 40140 && error.code < 40150;\n  }\n  revokeTokens(specifiers, options) {\n    return this.client.rest.revokeTokens(specifiers, options);\n  }\n  /**\n   * Same as {@link BaseClient.getTimestamp} but also takes into account {@link Auth.authOptions}\n   */\n  async _getTimestamp(queryTime) {\n    return this.client.getTimestamp(queryTime || !!this.authOptions.queryTime);\n  }\n};\nvar auth_default = Auth;\n\n// src/common/types/http.ts\nfunction paramString(params) {\n  const paramPairs = [];\n  if (params) {\n    for (const needle in params) {\n      paramPairs.push(needle + \"=\" + params[needle]);\n    }\n  }\n  return paramPairs.join(\"&\");\n}\nfunction appendingParams(uri, params) {\n  return uri + (params ? \"?\" : \"\") + paramString(params);\n}\nfunction logResult(result, method, uri, params, logger) {\n  if (result.error) {\n    logger_default.logActionNoStrip(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Http.\" + method + \"()\",\n      \"Received Error; \" + appendingParams(uri, params) + \"; Error: \" + inspectError(result.error)\n    );\n  } else {\n    logger_default.logActionNoStrip(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Http.\" + method + \"()\",\n      \"Received; \" + appendingParams(uri, params) + \"; Headers: \" + paramString(result.headers) + \"; StatusCode: \" + result.statusCode + \"; Body\" + (Platform.BufferUtils.isBuffer(result.body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(result.body) : \": \" + result.body)\n    );\n  }\n}\nfunction logRequest(method, uri, body, params, logger) {\n  if (logger.shouldLog(logger_default.LOG_MICRO)) {\n    logger_default.logActionNoStrip(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Http.\" + method + \"()\",\n      \"Sending; \" + appendingParams(uri, params) + \"; Body\" + (Platform.BufferUtils.isBuffer(body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(body) : \": \" + body)\n    );\n  }\n}\nvar Http = class {\n  constructor(client) {\n    this.client = client;\n    this.platformHttp = new Platform.Http(client);\n    this.checkConnectivity = this.platformHttp.checkConnectivity ? () => this.platformHttp.checkConnectivity() : void 0;\n  }\n  get logger() {\n    var _a2, _b;\n    return (_b = (_a2 = this.client) == null ? void 0 : _a2.logger) != null ? _b : logger_default.defaultLogger;\n  }\n  get supportsAuthHeaders() {\n    return this.platformHttp.supportsAuthHeaders;\n  }\n  get supportsLinkHeaders() {\n    return this.platformHttp.supportsLinkHeaders;\n  }\n  _getHosts(client) {\n    const connection = client.connection, connectionHost = connection && connection.connectionManager.host;\n    if (connectionHost) {\n      return [connectionHost].concat(defaults_default.getFallbackHosts(client.options));\n    }\n    return defaults_default.getHosts(client.options);\n  }\n  /**\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\n   */\n  async do(method, path, headers, body, params) {\n    try {\n      const client = this.client;\n      if (!client) {\n        return { error: new ErrorInfo(\"http.do called without client\", 5e4, 500) };\n      }\n      const uriFromHost = typeof path === \"function\" ? path : function(host) {\n        return client.baseUri(host) + path;\n      };\n      const currentFallback = client._currentFallback;\n      if (currentFallback) {\n        if (currentFallback.validUntil > Date.now()) {\n          const result = await this.doUri(method, uriFromHost(currentFallback.host), headers, body, params);\n          if (result.error && this.platformHttp.shouldFallback(result.error)) {\n            client._currentFallback = null;\n            return this.do(method, path, headers, body, params);\n          }\n          return result;\n        } else {\n          client._currentFallback = null;\n        }\n      }\n      const hosts = this._getHosts(client);\n      if (hosts.length === 1) {\n        return this.doUri(method, uriFromHost(hosts[0]), headers, body, params);\n      }\n      let tryAHostStartedAt = null;\n      const tryAHost = async (candidateHosts, persistOnSuccess) => {\n        const host = candidateHosts.shift();\n        tryAHostStartedAt = tryAHostStartedAt != null ? tryAHostStartedAt : /* @__PURE__ */ new Date();\n        const result = await this.doUri(method, uriFromHost(host), headers, body, params);\n        if (result.error && this.platformHttp.shouldFallback(result.error) && candidateHosts.length) {\n          const elapsedTime = Date.now() - tryAHostStartedAt.getTime();\n          if (elapsedTime > client.options.timeouts.httpMaxRetryDuration) {\n            return {\n              error: new ErrorInfo(\n                `Timeout for trying fallback hosts retries. Total elapsed time exceeded the ${client.options.timeouts.httpMaxRetryDuration}ms limit`,\n                50003,\n                500\n              )\n            };\n          }\n          return tryAHost(candidateHosts, true);\n        }\n        if (persistOnSuccess) {\n          client._currentFallback = {\n            host,\n            validUntil: Date.now() + client.options.timeouts.fallbackRetryTimeout\n          };\n        }\n        return result;\n      };\n      return tryAHost(hosts);\n    } catch (err) {\n      return { error: new ErrorInfo(`Unexpected error in Http.do: ${inspectError(err)}`, 500, 5e4) };\n    }\n  }\n  /**\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\n   */\n  async doUri(method, uri, headers, body, params) {\n    try {\n      logRequest(method, uri, body, params, this.logger);\n      const result = await this.platformHttp.doUri(method, uri, headers, body, params);\n      if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n        logResult(result, method, uri, params, this.logger);\n      }\n      return result;\n    } catch (err) {\n      return { error: new ErrorInfo(`Unexpected error in Http.doUri: ${inspectError(err)}`, 500, 5e4) };\n    }\n  }\n};\n\n// src/common/lib/util/eventemitter.ts\nfunction callListener(logger, eventThis, listener, args) {\n  try {\n    listener.apply(eventThis, args);\n  } catch (e) {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_ERROR,\n      \"EventEmitter.emit()\",\n      \"Unexpected listener exception: \" + e + \"; stack = \" + (e && e.stack)\n    );\n  }\n}\nfunction removeListener(targetListeners, listener, eventFilter) {\n  let listeners;\n  let index;\n  let eventName;\n  for (let targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {\n    listeners = targetListeners[targetListenersIndex];\n    if (eventFilter) {\n      listeners = listeners[eventFilter];\n    }\n    if (Array.isArray(listeners)) {\n      while ((index = listeners.indexOf(listener)) !== -1) {\n        listeners.splice(index, 1);\n      }\n      if (eventFilter && listeners.length === 0) {\n        delete targetListeners[targetListenersIndex][eventFilter];\n      }\n    } else if (isObject(listeners)) {\n      for (eventName in listeners) {\n        if (Object.prototype.hasOwnProperty.call(listeners, eventName) && Array.isArray(listeners[eventName])) {\n          removeListener([listeners], listener, eventName);\n        }\n      }\n    }\n  }\n}\nvar EventEmitter = class {\n  constructor(logger) {\n    this.logger = logger;\n    this.any = [];\n    this.events = /* @__PURE__ */ Object.create(null);\n    this.anyOnce = [];\n    this.eventsOnce = /* @__PURE__ */ Object.create(null);\n  }\n  on(...args) {\n    if (args.length === 1) {\n      const listener = args[0];\n      if (typeof listener === \"function\") {\n        this.any.push(listener);\n      } else {\n        throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n      }\n    }\n    if (args.length === 2) {\n      const [event, listener] = args;\n      if (typeof listener !== \"function\") {\n        throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n      }\n      if (isNil(event)) {\n        this.any.push(listener);\n      } else if (Array.isArray(event)) {\n        event.forEach((eventName) => {\n          this.on(eventName, listener);\n        });\n      } else {\n        if (typeof event !== \"string\") {\n          throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n        }\n        const listeners = this.events[event] || (this.events[event] = []);\n        listeners.push(listener);\n      }\n    }\n  }\n  off(...args) {\n    if (args.length == 0 || isNil(args[0]) && isNil(args[1])) {\n      this.any = [];\n      this.events = /* @__PURE__ */ Object.create(null);\n      this.anyOnce = [];\n      this.eventsOnce = /* @__PURE__ */ Object.create(null);\n      return;\n    }\n    const [firstArg, secondArg] = args;\n    let listener = null;\n    let event = null;\n    if (args.length === 1 || !secondArg) {\n      if (typeof firstArg === \"function\") {\n        listener = firstArg;\n      } else {\n        event = firstArg;\n      }\n    } else {\n      if (typeof secondArg !== \"function\") {\n        throw new Error(\"EventEmitter.off(): invalid arguments:\" + Platform.Config.inspect(args));\n      }\n      [event, listener] = [firstArg, secondArg];\n    }\n    if (listener && isNil(event)) {\n      removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);\n      return;\n    }\n    if (Array.isArray(event)) {\n      event.forEach((eventName) => {\n        this.off(eventName, listener);\n      });\n      return;\n    }\n    if (typeof event !== \"string\") {\n      throw new Error(\"EventEmitter.off(): invalid arguments:\" + Platform.Config.inspect(args));\n    }\n    if (listener) {\n      removeListener([this.events, this.eventsOnce], listener, event);\n    } else {\n      delete this.events[event];\n      delete this.eventsOnce[event];\n    }\n  }\n  /**\n   * Get the array of listeners for a given event; excludes once events\n   * @param event (optional) the name of the event, or none for 'any'\n   * @return array of events, or null if none\n   */\n  listeners(event) {\n    if (event) {\n      const listeners = this.events[event] || [];\n      if (this.eventsOnce[event])\n        Array.prototype.push.apply(listeners, this.eventsOnce[event]);\n      return listeners.length ? listeners : null;\n    }\n    return this.any.length ? this.any : null;\n  }\n  /**\n   * Emit an event\n   * @param event the event name\n   * @param args the arguments to pass to the listener\n   */\n  emit(event, ...args) {\n    const eventThis = { event };\n    const listeners = [];\n    if (this.anyOnce.length) {\n      Array.prototype.push.apply(listeners, this.anyOnce);\n      this.anyOnce = [];\n    }\n    if (this.any.length) {\n      Array.prototype.push.apply(listeners, this.any);\n    }\n    const eventsOnceListeners = this.eventsOnce[event];\n    if (eventsOnceListeners) {\n      Array.prototype.push.apply(listeners, eventsOnceListeners);\n      delete this.eventsOnce[event];\n    }\n    const eventsListeners = this.events[event];\n    if (eventsListeners) {\n      Array.prototype.push.apply(listeners, eventsListeners);\n    }\n    listeners.forEach((listener) => {\n      callListener(this.logger, eventThis, listener, args);\n    });\n  }\n  once(...args) {\n    const argCount = args.length;\n    if (argCount === 0 || argCount === 1 && typeof args[0] !== \"function\") {\n      const event = args[0];\n      return new Promise((resolve) => {\n        this.once(event, resolve);\n      });\n    }\n    const [firstArg, secondArg] = args;\n    if (args.length === 1 && typeof firstArg === \"function\") {\n      this.anyOnce.push(firstArg);\n    } else if (isNil(firstArg)) {\n      if (typeof secondArg !== \"function\") {\n        throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n      }\n      this.anyOnce.push(secondArg);\n    } else if (Array.isArray(firstArg)) {\n      const self2 = this;\n      const listenerWrapper = function() {\n        const innerArgs = Array.prototype.slice.call(arguments);\n        firstArg.forEach(function(eventName) {\n          self2.off(eventName, listenerWrapper);\n        });\n        if (typeof secondArg !== \"function\") {\n          throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n        }\n        secondArg.apply(this, innerArgs);\n      };\n      firstArg.forEach(function(eventName) {\n        self2.on(eventName, listenerWrapper);\n      });\n    } else {\n      if (typeof firstArg !== \"string\") {\n        throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n      }\n      const listeners = this.eventsOnce[firstArg] || (this.eventsOnce[firstArg] = []);\n      if (secondArg) {\n        if (typeof secondArg !== \"function\") {\n          throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n        }\n        listeners.push(secondArg);\n      }\n    }\n  }\n  /**\n   * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState\n   * @param targetState the name of the state event to listen to\n   * @param currentState the name of the current state of this object\n   */\n  async whenState(targetState, currentState) {\n    if (typeof targetState !== \"string\" || typeof currentState !== \"string\") {\n      throw new Error(\"whenState requires a valid state String argument\");\n    }\n    if (targetState === currentState) {\n      return null;\n    } else {\n      return this.once(targetState);\n    }\n  }\n};\nvar eventemitter_default = EventEmitter;\n\n// src/common/lib/types/protocolmessagecommon.ts\nvar actions = {\n  HEARTBEAT: 0,\n  ACK: 1,\n  NACK: 2,\n  CONNECT: 3,\n  CONNECTED: 4,\n  DISCONNECT: 5,\n  DISCONNECTED: 6,\n  CLOSE: 7,\n  CLOSED: 8,\n  ERROR: 9,\n  ATTACH: 10,\n  ATTACHED: 11,\n  DETACH: 12,\n  DETACHED: 13,\n  PRESENCE: 14,\n  MESSAGE: 15,\n  SYNC: 16,\n  AUTH: 17,\n  ACTIVATE: 18,\n  OBJECT: 19,\n  OBJECT_SYNC: 20,\n  ANNOTATION: 21\n};\nvar ActionName = [];\nObject.keys(actions).forEach(function(name) {\n  ActionName[actions[name]] = name;\n});\nvar flags = {\n  /* Channel attach state flags */\n  HAS_PRESENCE: 1 << 0,\n  HAS_BACKLOG: 1 << 1,\n  RESUMED: 1 << 2,\n  TRANSIENT: 1 << 4,\n  ATTACH_RESUME: 1 << 5,\n  HAS_OBJECTS: 1 << 7,\n  /* Channel mode flags */\n  PRESENCE: 1 << 16,\n  PUBLISH: 1 << 17,\n  SUBSCRIBE: 1 << 18,\n  PRESENCE_SUBSCRIBE: 1 << 19,\n  ANNOTATION_PUBLISH: 1 << 21,\n  ANNOTATION_SUBSCRIBE: 1 << 22,\n  OBJECT_SUBSCRIBE: 1 << 24,\n  OBJECT_PUBLISH: 1 << 25\n};\nvar flagNames = Object.keys(flags);\nflags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE | flags.ANNOTATION_PUBLISH | flags.ANNOTATION_SUBSCRIBE | flags.OBJECT_SUBSCRIBE | flags.OBJECT_PUBLISH;\nvar channelModes = [\n  \"PRESENCE\",\n  \"PUBLISH\",\n  \"SUBSCRIBE\",\n  \"PRESENCE_SUBSCRIBE\",\n  \"ANNOTATION_PUBLISH\",\n  \"ANNOTATION_SUBSCRIBE\",\n  \"OBJECT_SUBSCRIBE\",\n  \"OBJECT_PUBLISH\"\n];\n\n// src/common/lib/types/basemessage.ts\nfunction normaliseContext(context) {\n  if (!context || !context.channelOptions) {\n    return {\n      channelOptions: context,\n      plugins: {},\n      baseEncodedPreviousPayload: void 0\n    };\n  }\n  return context;\n}\nfunction normalizeCipherOptions(Crypto2, logger, options) {\n  if (options && options.cipher) {\n    if (!Crypto2)\n      throwMissingPluginError(\"Crypto\");\n    const cipher = Crypto2.getCipher(options.cipher, logger);\n    return {\n      cipher: cipher.cipherParams,\n      channelCipher: cipher.cipher\n    };\n  }\n  return options != null ? options : {};\n}\nasync function encrypt(msg, cipherOptions) {\n  const { data, encoding } = await encryptData(msg.data, msg.encoding, cipherOptions);\n  msg.data = data;\n  msg.encoding = encoding;\n  return msg;\n}\nasync function encryptData(data, encoding, cipherOptions) {\n  let cipher = cipherOptions.channelCipher;\n  let dataToEncrypt = data;\n  let finalEncoding = encoding ? encoding + \"/\" : \"\";\n  if (!Platform.BufferUtils.isBuffer(dataToEncrypt)) {\n    dataToEncrypt = Platform.BufferUtils.utf8Encode(String(dataToEncrypt));\n    finalEncoding = finalEncoding + \"utf-8/\";\n  }\n  const ciphertext = await cipher.encrypt(dataToEncrypt);\n  finalEncoding = finalEncoding + \"cipher+\" + cipher.algorithm;\n  return {\n    data: ciphertext,\n    encoding: finalEncoding\n  };\n}\nasync function encode(msg, options) {\n  const { data, encoding } = encodeData(msg.data, msg.encoding);\n  msg.data = data;\n  msg.encoding = encoding;\n  if (options != null && options.cipher) {\n    return encrypt(msg, options);\n  } else {\n    return msg;\n  }\n}\nfunction encodeData(data, encoding) {\n  const nativeDataType = typeof data == \"string\" || Platform.BufferUtils.isBuffer(data) || data === null || data === void 0;\n  if (nativeDataType) {\n    return {\n      data,\n      encoding\n    };\n  }\n  if (isObject(data) || Array.isArray(data)) {\n    return {\n      data: JSON.stringify(data),\n      encoding: encoding ? encoding + \"/json\" : \"json\"\n    };\n  }\n  throw new ErrorInfo(\"Data type is unsupported\", 40013, 400);\n}\nasync function decode(message, inputContext) {\n  const { data, encoding, error } = await decodeData(message.data, message.encoding, inputContext);\n  message.data = data;\n  message.encoding = encoding;\n  if (error) {\n    throw error;\n  }\n}\nasync function decodeData(data, encoding, inputContext) {\n  const context = normaliseContext(inputContext);\n  let lastPayload = data;\n  let decodedData = data;\n  let finalEncoding = encoding;\n  let decodingError;\n  if (encoding) {\n    const xforms = encoding.split(\"/\");\n    let lastProcessedEncodingIndex;\n    let encodingsToProcess = xforms.length;\n    let xform = \"\";\n    try {\n      while ((lastProcessedEncodingIndex = encodingsToProcess) > 0) {\n        const match = xforms[--encodingsToProcess].match(/([-\\w]+)(\\+([\\w-]+))?/);\n        if (!match)\n          break;\n        xform = match[1];\n        switch (xform) {\n          case \"base64\":\n            decodedData = Platform.BufferUtils.base64Decode(String(decodedData));\n            if (lastProcessedEncodingIndex == xforms.length) {\n              lastPayload = decodedData;\n            }\n            continue;\n          case \"utf-8\":\n            decodedData = Platform.BufferUtils.utf8Decode(decodedData);\n            continue;\n          case \"json\":\n            decodedData = JSON.parse(decodedData);\n            continue;\n          case \"cipher\":\n            if (context.channelOptions != null && context.channelOptions.cipher && context.channelOptions.channelCipher) {\n              const xformAlgorithm = match[3], cipher = context.channelOptions.channelCipher;\n              if (xformAlgorithm != cipher.algorithm) {\n                throw new Error(\"Unable to decrypt message with given cipher; incompatible cipher params\");\n              }\n              decodedData = await cipher.decrypt(decodedData);\n              continue;\n            } else {\n              throw new Error(\"Unable to decrypt message; not an encrypted channel\");\n            }\n          case \"vcdiff\":\n            if (!context.plugins || !context.plugins.vcdiff) {\n              throw new ErrorInfo(\"Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)\", 40019, 400);\n            }\n            if (typeof Uint8Array === \"undefined\") {\n              throw new ErrorInfo(\n                \"Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)\",\n                40020,\n                400\n              );\n            }\n            try {\n              let deltaBase = context.baseEncodedPreviousPayload;\n              if (typeof deltaBase === \"string\") {\n                deltaBase = Platform.BufferUtils.utf8Encode(deltaBase);\n              }\n              const deltaBaseBuffer = Platform.BufferUtils.toBuffer(deltaBase);\n              decodedData = Platform.BufferUtils.toBuffer(decodedData);\n              decodedData = Platform.BufferUtils.arrayBufferViewToBuffer(\n                context.plugins.vcdiff.decode(decodedData, deltaBaseBuffer)\n              );\n              lastPayload = decodedData;\n            } catch (e) {\n              throw new ErrorInfo(\"Vcdiff delta decode failed with \" + e, 40018, 400);\n            }\n            continue;\n          default:\n            throw new Error(\"Unknown encoding\");\n        }\n      }\n    } catch (e) {\n      const err = e;\n      decodingError = new ErrorInfo(\n        `Error processing the ${xform} encoding, decoder returned \\u2018${err.message}\\u2019`,\n        err.code || 40013,\n        400\n      );\n    } finally {\n      finalEncoding = lastProcessedEncodingIndex <= 0 ? null : xforms.slice(0, lastProcessedEncodingIndex).join(\"/\");\n    }\n  }\n  if (decodingError) {\n    return {\n      error: decodingError,\n      data: decodedData,\n      encoding: finalEncoding\n    };\n  }\n  context.baseEncodedPreviousPayload = lastPayload;\n  return {\n    data: decodedData,\n    encoding: finalEncoding\n  };\n}\nfunction wireToJSON(...args) {\n  const format = args.length > 0 ? \"json\" /* json */ : \"msgpack\" /* msgpack */;\n  const { data, encoding } = encodeDataForWire(this.data, this.encoding, format);\n  return Object.assign({}, this, { encoding, data });\n}\nfunction encodeDataForWire(data, encoding, format) {\n  if (!data || !Platform.BufferUtils.isBuffer(data)) {\n    return {\n      data,\n      encoding\n    };\n  }\n  if (format === \"msgpack\" /* msgpack */) {\n    return {\n      data: Platform.BufferUtils.toBuffer(data),\n      encoding\n    };\n  }\n  return {\n    data: Platform.BufferUtils.base64Encode(data),\n    encoding: encoding ? encoding + \"/base64\" : \"base64\"\n  };\n}\nvar MessageEncoding = {\n  encryptData,\n  encodeData,\n  encodeDataForWire,\n  decodeData\n};\nfunction populateFieldsFromParent(parent) {\n  const { id, connectionId, timestamp } = parent;\n  let msgs;\n  switch (parent.action) {\n    case actions.MESSAGE: {\n      msgs = parent.messages;\n      break;\n    }\n    case actions.PRESENCE:\n    case actions.SYNC:\n      msgs = parent.presence;\n      break;\n    case actions.ANNOTATION:\n      msgs = parent.annotations;\n      break;\n    case actions.OBJECT:\n    case actions.OBJECT_SYNC:\n      msgs = parent.state;\n      break;\n    default:\n      throw new ErrorInfo(\"Unexpected action \" + parent.action, 4e4, 400);\n  }\n  for (let i = 0; i < msgs.length; i++) {\n    const msg = msgs[i];\n    if (!msg.connectionId) {\n      msg.connectionId = connectionId;\n    }\n    if (!msg.timestamp) {\n      msg.timestamp = timestamp;\n    }\n    if (id && !msg.id) {\n      msg.id = id + \":\" + i;\n    }\n  }\n}\nfunction strMsg(m, cls) {\n  let result = \"[\" + cls;\n  for (const attr in m) {\n    if (attr === \"data\") {\n      if (typeof m.data == \"string\") {\n        result += \"; data=\" + m.data;\n      } else if (Platform.BufferUtils.isBuffer(m.data)) {\n        result += \"; data (buffer)=\" + Platform.BufferUtils.base64Encode(m.data);\n      } else if (typeof m.data !== \"undefined\") {\n        result += \"; data (json)=\" + JSON.stringify(m.data);\n      }\n    } else if (attr && (attr === \"extras\" || attr === \"operation\")) {\n      result += \"; \" + attr + \"=\" + JSON.stringify(m[attr]);\n    } else if (attr === \"version\") {\n      result += \"; version=\" + JSON.stringify(m[attr]);\n    } else if (attr === \"annotations\") {\n      result += \"; annotations=\" + JSON.stringify(m[attr]);\n    } else if (m[attr] !== void 0) {\n      result += \"; \" + attr + \"=\" + m[attr];\n    }\n  }\n  result += \"]\";\n  return result;\n}\nvar BaseMessage = class {\n};\n\n// src/common/lib/client/baseclient.ts\nvar BaseClient = class {\n  constructor(options) {\n    /**\n     * These exports are for use by UMD plugins; reason being so that constructors and static methods can be accessed by these plugins without needing to import the classes directly and result in the class existing in both the plugin and the core library.\n     */\n    this.Platform = Platform;\n    this.ErrorInfo = ErrorInfo;\n    this.Logger = logger_default;\n    this.Defaults = defaults_default;\n    this.Utils = utils_exports;\n    this.EventEmitter = eventemitter_default;\n    this.MessageEncoding = MessageEncoding;\n    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n    this._additionalHTTPRequestImplementations = (_a2 = options.plugins) != null ? _a2 : null;\n    this.logger = new logger_default();\n    this.logger.setLog(options.logLevel, options.logHandler);\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"BaseClient()\",\n      \"initialized with clientOptions \" + Platform.Config.inspect(options)\n    );\n    this._MsgPack = (_c = (_b = options.plugins) == null ? void 0 : _b.MsgPack) != null ? _c : null;\n    const normalOptions = this.options = defaults_default.normaliseOptions(options, this._MsgPack, this.logger);\n    if (normalOptions.key) {\n      const keyMatch = normalOptions.key.match(/^([^:\\s]+):([^:.\\s]+)$/);\n      if (!keyMatch) {\n        const msg = \"invalid key parameter\";\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"BaseClient()\", msg);\n        throw new ErrorInfo(msg, 40400, 404);\n      }\n      normalOptions.keyName = keyMatch[1];\n      normalOptions.keySecret = keyMatch[2];\n    }\n    if (\"clientId\" in normalOptions) {\n      if (!(typeof normalOptions.clientId === \"string\" || normalOptions.clientId === null))\n        throw new ErrorInfo(\"clientId must be either a string or null\", 40012, 400);\n      else if (normalOptions.clientId === \"*\")\n        throw new ErrorInfo(\n          'Can\\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: \"*\"}})',\n          40012,\n          400\n        );\n    }\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"BaseClient()\", \"started; version = \" + defaults_default.version);\n    this._currentFallback = null;\n    this.serverTimeOffset = null;\n    this.http = new Http(this);\n    this.auth = new auth_default(this, normalOptions);\n    this._rest = ((_d = options.plugins) == null ? void 0 : _d.Rest) ? new options.plugins.Rest(this) : null;\n    this._Crypto = (_f = (_e = options.plugins) == null ? void 0 : _e.Crypto) != null ? _f : null;\n    this.__FilteredSubscriptions = (_h = (_g = options.plugins) == null ? void 0 : _g.MessageInteractions) != null ? _h : null;\n    this._Annotations = (_j = (_i = options.plugins) == null ? void 0 : _i.Annotations) != null ? _j : null;\n  }\n  get rest() {\n    if (!this._rest) {\n      throwMissingPluginError(\"Rest\");\n    }\n    return this._rest;\n  }\n  get _FilteredSubscriptions() {\n    if (!this.__FilteredSubscriptions) {\n      throwMissingPluginError(\"MessageInteractions\");\n    }\n    return this.__FilteredSubscriptions;\n  }\n  get channels() {\n    return this.rest.channels;\n  }\n  get push() {\n    return this.rest.push;\n  }\n  /** RSH8 */\n  device() {\n    var _a2;\n    if (!((_a2 = this.options.plugins) == null ? void 0 : _a2.Push) || !this.push.LocalDevice) {\n      throwMissingPluginError(\"Push\");\n    }\n    if (!this._device) {\n      this._device = this.push.LocalDevice.load(this);\n    }\n    return this._device;\n  }\n  baseUri(host) {\n    return defaults_default.getHttpScheme(this.options) + host + \":\" + defaults_default.getPort(this.options, false);\n  }\n  async stats(params) {\n    return this.rest.stats(params);\n  }\n  async time(params) {\n    return this.rest.time(params);\n  }\n  async request(method, path, version2, params, body, customHeaders) {\n    return this.rest.request(method, path, version2, params, body, customHeaders);\n  }\n  batchPublish(specOrSpecs) {\n    return this.rest.batchPublish(specOrSpecs);\n  }\n  batchPresence(channels) {\n    return this.rest.batchPresence(channels);\n  }\n  setLog(logOptions) {\n    this.logger.setLog(logOptions.level, logOptions.handler);\n  }\n  /**\n   * Get the current time based on the local clock,\n   * or if the option queryTime is true, return the server time.\n   * The server time offset from the local time is stored so that\n   * only one request to the server to get the time is ever needed\n   */\n  async getTimestamp(queryTime) {\n    if (!this.isTimeOffsetSet() && queryTime) {\n      return this.time();\n    }\n    return this.getTimestampUsingOffset();\n  }\n  getTimestampUsingOffset() {\n    return Date.now() + (this.serverTimeOffset || 0);\n  }\n  isTimeOffsetSet() {\n    return this.serverTimeOffset !== null;\n  }\n};\nBaseClient.Platform = Platform;\nvar baseclient_default = BaseClient;\n\n// src/common/lib/types/devicedetails.ts\nvar DeviceDetails = class _DeviceDetails {\n  toJSON() {\n    var _a2, _b, _c;\n    return {\n      id: this.id,\n      deviceSecret: this.deviceSecret,\n      platform: this.platform,\n      formFactor: this.formFactor,\n      clientId: this.clientId,\n      metadata: this.metadata,\n      deviceIdentityToken: this.deviceIdentityToken,\n      push: {\n        recipient: (_a2 = this.push) == null ? void 0 : _a2.recipient,\n        state: (_b = this.push) == null ? void 0 : _b.state,\n        error: (_c = this.push) == null ? void 0 : _c.error\n      }\n    };\n  }\n  toString() {\n    var _a2, _b, _c, _d;\n    let result = \"[DeviceDetails\";\n    if (this.id)\n      result += \"; id=\" + this.id;\n    if (this.platform)\n      result += \"; platform=\" + this.platform;\n    if (this.formFactor)\n      result += \"; formFactor=\" + this.formFactor;\n    if (this.clientId)\n      result += \"; clientId=\" + this.clientId;\n    if (this.metadata)\n      result += \"; metadata=\" + this.metadata;\n    if (this.deviceIdentityToken)\n      result += \"; deviceIdentityToken=\" + JSON.stringify(this.deviceIdentityToken);\n    if ((_a2 = this.push) == null ? void 0 : _a2.recipient)\n      result += \"; push.recipient=\" + JSON.stringify(this.push.recipient);\n    if ((_b = this.push) == null ? void 0 : _b.state)\n      result += \"; push.state=\" + this.push.state;\n    if ((_c = this.push) == null ? void 0 : _c.error)\n      result += \"; push.error=\" + JSON.stringify(this.push.error);\n    if ((_d = this.push) == null ? void 0 : _d.metadata)\n      result += \"; push.metadata=\" + this.push.metadata;\n    result += \"]\";\n    return result;\n  }\n  static toRequestBody(body, MsgPack, format) {\n    return encodeBody(body, MsgPack, format);\n  }\n  static fromResponseBody(body, MsgPack, format) {\n    if (format) {\n      body = decodeBody(body, MsgPack, format);\n    }\n    if (Array.isArray(body)) {\n      return _DeviceDetails.fromValuesArray(body);\n    } else {\n      return _DeviceDetails.fromValues(body);\n    }\n  }\n  static fromValues(values) {\n    values.error = values.error && ErrorInfo.fromValues(values.error);\n    return Object.assign(new _DeviceDetails(), values);\n  }\n  static fromLocalDevice(device) {\n    return Object.assign(new _DeviceDetails(), device);\n  }\n  static fromValuesArray(values) {\n    const count = values.length, result = new Array(count);\n    for (let i = 0; i < count; i++)\n      result[i] = _DeviceDetails.fromValues(values[i]);\n    return result;\n  }\n};\nvar devicedetails_default = DeviceDetails;\n\n// src/common/lib/client/resource.ts\nasync function withAuthDetails(client, headers, params, opCallback) {\n  if (client.http.supportsAuthHeaders) {\n    const authHeaders = await client.auth.getAuthHeaders();\n    return opCallback(mixin(authHeaders, headers), params);\n  } else {\n    const authParams = await client.auth.getAuthParams();\n    return opCallback(headers, mixin(authParams, params));\n  }\n}\nfunction unenvelope(result, MsgPack, format) {\n  if (result.err && !result.body) {\n    return { err: result.err };\n  }\n  if (result.statusCode === HttpStatusCodes_default.NoContent) {\n    return __spreadProps(__spreadValues({}, result), { body: [], unpacked: true });\n  }\n  let body = result.body;\n  if (!result.unpacked) {\n    try {\n      body = decodeBody(body, MsgPack, format);\n    } catch (e) {\n      if (isErrorInfoOrPartialErrorInfo(e)) {\n        return { err: e };\n      } else {\n        return { err: new PartialErrorInfo(inspectError(e), null) };\n      }\n    }\n  }\n  if (!body) {\n    return { err: new PartialErrorInfo(\"unenvelope(): Response body is missing\", null) };\n  }\n  const { statusCode: wrappedStatusCode, response, headers: wrappedHeaders } = body;\n  if (wrappedStatusCode === void 0) {\n    return __spreadProps(__spreadValues({}, result), { body, unpacked: true });\n  }\n  if (wrappedStatusCode < 200 || wrappedStatusCode >= 300) {\n    let wrappedErr = response && response.error || result.err;\n    if (!wrappedErr) {\n      wrappedErr = new Error(\"Error in unenveloping \" + body);\n      wrappedErr.statusCode = wrappedStatusCode;\n    }\n    return { err: wrappedErr, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\n  }\n  return { err: result.err, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\n}\nfunction logResult2(result, method, path, params, logger) {\n  if (result.err) {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Resource.\" + method + \"()\",\n      \"Received Error; \" + appendingParams(path, params) + \"; Error: \" + inspectError(result.err)\n    );\n  } else {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Resource.\" + method + \"()\",\n      \"Received; \" + appendingParams(path, params) + \"; Headers: \" + paramString(result.headers) + \"; StatusCode: \" + result.statusCode + \"; Body: \" + (Platform.BufferUtils.isBuffer(result.body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(result.body) : \": \" + Platform.Config.inspect(result.body))\n    );\n  }\n}\nvar Resource = class _Resource {\n  static async get(client, path, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Get, client, path, null, headers, params, envelope, throwError != null ? throwError : false);\n  }\n  static async delete(client, path, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Delete, client, path, null, headers, params, envelope, throwError);\n  }\n  static async post(client, path, body, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Post, client, path, body, headers, params, envelope, throwError);\n  }\n  static async patch(client, path, body, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Patch, client, path, body, headers, params, envelope, throwError);\n  }\n  static async put(client, path, body, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Put, client, path, body, headers, params, envelope, throwError);\n  }\n  static async do(method, client, path, body, headers, params, envelope, throwError) {\n    if (envelope) {\n      (params = params || {})[\"envelope\"] = envelope;\n    }\n    const logger = client.logger;\n    async function doRequest(headers2, params2) {\n      var _a2;\n      if (logger.shouldLog(logger_default.LOG_MICRO)) {\n        let decodedBody = body;\n        if (((_a2 = headers2[\"content-type\"]) == null ? void 0 : _a2.indexOf(\"msgpack\")) > 0) {\n          try {\n            if (!client._MsgPack) {\n              throwMissingPluginError(\"MsgPack\");\n            }\n            decodedBody = client._MsgPack.decode(body);\n          } catch (decodeErr) {\n            logger_default.logAction(\n              logger,\n              logger_default.LOG_MICRO,\n              \"Resource.\" + method + \"()\",\n              \"Sending MsgPack Decoding Error: \" + inspectError(decodeErr)\n            );\n          }\n        }\n        logger_default.logAction(\n          logger,\n          logger_default.LOG_MICRO,\n          \"Resource.\" + method + \"()\",\n          \"Sending; \" + appendingParams(path, params2) + \"; Body: \" + decodedBody\n        );\n      }\n      const httpResult = await client.http.do(method, path, headers2, body, params2);\n      if (httpResult.error && auth_default.isTokenErr(httpResult.error)) {\n        await client.auth.authorize(null, null);\n        return withAuthDetails(client, headers2, params2, doRequest);\n      }\n      return {\n        err: httpResult.error,\n        body: httpResult.body,\n        headers: httpResult.headers,\n        unpacked: httpResult.unpacked,\n        statusCode: httpResult.statusCode\n      };\n    }\n    let result = await withAuthDetails(client, headers, params, doRequest);\n    if (envelope) {\n      result = unenvelope(result, client._MsgPack, envelope);\n    }\n    if (logger.shouldLog(logger_default.LOG_MICRO)) {\n      logResult2(result, method, path, params, logger);\n    }\n    if (throwError) {\n      if (result.err) {\n        throw result.err;\n      } else {\n        const response = __spreadValues({}, result);\n        delete response.err;\n        return response;\n      }\n    }\n    return result;\n  }\n};\nvar resource_default = Resource;\n\n// src/common/lib/client/paginatedresource.ts\nfunction getRelParams(linkUrl) {\n  const urlMatch = linkUrl.match(/^\\.\\/(\\w+)\\?(.*)$/);\n  return urlMatch && urlMatch[2] && parseQueryString(urlMatch[2]);\n}\nfunction parseRelLinks(linkHeader) {\n  if (typeof linkHeader == \"string\")\n    linkHeader = linkHeader.split(\",\");\n  const relParams = {};\n  for (let i = 0; i < linkHeader.length; i++) {\n    const linkMatch = linkHeader[i].match(/^\\s*<(.+)>;\\s*rel=\"(\\w+)\"$/);\n    if (linkMatch) {\n      const params = getRelParams(linkMatch[1]);\n      if (params)\n        relParams[linkMatch[2]] = params;\n    }\n  }\n  return relParams;\n}\nfunction returnErrOnly(err, body, useHPR) {\n  return !(useHPR && (body || typeof err.code === \"number\"));\n}\nvar PaginatedResource = class {\n  constructor(client, path, headers, envelope, bodyHandler, useHttpPaginatedResponse) {\n    this.client = client;\n    this.path = path;\n    this.headers = headers;\n    this.envelope = envelope != null ? envelope : null;\n    this.bodyHandler = bodyHandler;\n    this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;\n  }\n  get logger() {\n    return this.client.logger;\n  }\n  async get(params) {\n    const result = await resource_default.get(this.client, this.path, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async delete(params) {\n    const result = await resource_default.delete(this.client, this.path, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async post(params, body) {\n    const result = await resource_default.post(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async put(params, body) {\n    const result = await resource_default.put(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async patch(params, body) {\n    const result = await resource_default.patch(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async handlePage(result) {\n    if (result.err && returnErrOnly(result.err, result.body, this.useHttpPaginatedResponse)) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"PaginatedResource.handlePage()\",\n        \"Unexpected error getting resource: err = \" + inspectError(result.err)\n      );\n      throw result.err;\n    }\n    let items, linkHeader, relParams;\n    try {\n      items = result.statusCode == HttpStatusCodes_default.NoContent ? [] : await this.bodyHandler(result.body, result.headers || {}, result.unpacked);\n    } catch (e) {\n      throw result.err || e;\n    }\n    if (result.headers && (linkHeader = result.headers[\"Link\"] || result.headers[\"link\"])) {\n      relParams = parseRelLinks(linkHeader);\n    }\n    if (this.useHttpPaginatedResponse) {\n      return new HttpPaginatedResponse(\n        this,\n        items,\n        result.headers || {},\n        result.statusCode,\n        relParams,\n        result.err\n      );\n    } else {\n      return new PaginatedResult(this, items, relParams);\n    }\n  }\n};\nvar PaginatedResult = class {\n  constructor(resource, items, relParams) {\n    this.resource = resource;\n    this.items = items;\n    this._relParams = relParams;\n  }\n  async first() {\n    if (this.hasFirst()) {\n      return this.get(this._relParams.first);\n    }\n    throw new ErrorInfo(\"No link to the first page of results\", 40400, 404);\n  }\n  async current() {\n    if (this.hasCurrent()) {\n      return this.get(this._relParams.current);\n    }\n    throw new ErrorInfo(\"No link to the current page of results\", 40400, 404);\n  }\n  async next() {\n    if (this.hasNext()) {\n      return this.get(this._relParams.next);\n    }\n    return null;\n  }\n  hasFirst() {\n    return this._relParams != null && \"first\" in this._relParams;\n  }\n  hasCurrent() {\n    return this._relParams != null && \"current\" in this._relParams;\n  }\n  hasNext() {\n    return this._relParams != null && \"next\" in this._relParams;\n  }\n  isLast() {\n    return !this.hasNext();\n  }\n  /* We assume that only the initial request can be a POST, and that accessing\n   * the rest of a multipage set of results can always be done with GET */\n  async get(params) {\n    const res = this.resource;\n    const result = await resource_default.get(res.client, res.path, res.headers, params, res.envelope, false);\n    return res.handlePage(result);\n  }\n};\nvar HttpPaginatedResponse = class extends PaginatedResult {\n  constructor(resource, items, headers, statusCode, relParams, err) {\n    super(resource, items, relParams);\n    this.statusCode = statusCode;\n    this.success = statusCode < 300 && statusCode >= 200;\n    this.headers = headers;\n    this.errorCode = err && err.code;\n    this.errorMessage = err && err.message;\n  }\n  toJSON() {\n    return {\n      items: this.items,\n      statusCode: this.statusCode,\n      success: this.success,\n      headers: this.headers,\n      errorCode: this.errorCode,\n      errorMessage: this.errorMessage\n    };\n  }\n};\nvar paginatedresource_default = PaginatedResource;\n\n// src/common/lib/types/pushchannelsubscription.ts\nvar _PushChannelSubscription = class _PushChannelSubscription {\n  /**\n   * Overload toJSON() to intercept JSON.stringify()\n   * @return {*}\n   */\n  toJSON() {\n    return {\n      channel: this.channel,\n      deviceId: this.deviceId,\n      clientId: this.clientId\n    };\n  }\n  toString() {\n    let result = \"[PushChannelSubscription\";\n    if (this.channel)\n      result += \"; channel=\" + this.channel;\n    if (this.deviceId)\n      result += \"; deviceId=\" + this.deviceId;\n    if (this.clientId)\n      result += \"; clientId=\" + this.clientId;\n    result += \"]\";\n    return result;\n  }\n  static fromResponseBody(body, MsgPack, format) {\n    if (format) {\n      body = decodeBody(body, MsgPack, format);\n    }\n    if (Array.isArray(body)) {\n      return _PushChannelSubscription.fromValuesArray(body);\n    } else {\n      return _PushChannelSubscription.fromValues(body);\n    }\n  }\n  static fromValues(values) {\n    return Object.assign(new _PushChannelSubscription(), values);\n  }\n  static fromValuesArray(values) {\n    const count = values.length, result = new Array(count);\n    for (let i = 0; i < count; i++)\n      result[i] = _PushChannelSubscription.fromValues(values[i]);\n    return result;\n  }\n};\n_PushChannelSubscription.toRequestBody = encodeBody;\nvar PushChannelSubscription = _PushChannelSubscription;\nvar pushchannelsubscription_default = PushChannelSubscription;\n\n// src/common/lib/client/push.ts\nvar Push = class {\n  constructor(client) {\n    var _a2;\n    this.client = client;\n    this.admin = new Admin(client);\n    if (Platform.Config.push && ((_a2 = client.options.plugins) == null ? void 0 : _a2.Push)) {\n      this.stateMachine = new client.options.plugins.Push.ActivationStateMachine(client);\n      this.LocalDevice = client.options.plugins.Push.localDeviceFactory(devicedetails_default);\n    }\n  }\n  async activate(registerCallback, updateFailedCallback) {\n    await new Promise((resolve, reject) => {\n      var _a2;\n      if (!((_a2 = this.client.options.plugins) == null ? void 0 : _a2.Push)) {\n        reject(createMissingPluginError(\"Push\"));\n        return;\n      }\n      if (!this.stateMachine) {\n        reject(new ErrorInfo(\"This platform is not supported as a target of push notifications\", 4e4, 400));\n        return;\n      }\n      if (this.stateMachine.activatedCallback) {\n        reject(new ErrorInfo(\"Activation already in progress\", 4e4, 400));\n        return;\n      }\n      this.stateMachine.activatedCallback = (err) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve();\n      };\n      this.stateMachine.updateFailedCallback = updateFailedCallback;\n      this.stateMachine.handleEvent(\n        new this.client.options.plugins.Push.CalledActivate(this.stateMachine, registerCallback)\n      );\n    });\n  }\n  async deactivate(deregisterCallback) {\n    await new Promise((resolve, reject) => {\n      var _a2;\n      if (!((_a2 = this.client.options.plugins) == null ? void 0 : _a2.Push)) {\n        reject(createMissingPluginError(\"Push\"));\n        return;\n      }\n      if (!this.stateMachine) {\n        reject(new ErrorInfo(\"This platform is not supported as a target of push notifications\", 4e4, 400));\n        return;\n      }\n      if (this.stateMachine.deactivatedCallback) {\n        reject(new ErrorInfo(\"Deactivation already in progress\", 4e4, 400));\n        return;\n      }\n      this.stateMachine.deactivatedCallback = (err) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve();\n      };\n      this.stateMachine.handleEvent(\n        new this.client.options.plugins.Push.CalledDeactivate(this.stateMachine, deregisterCallback)\n      );\n    });\n  }\n};\nvar Admin = class {\n  constructor(client) {\n    this.client = client;\n    this.deviceRegistrations = new DeviceRegistrations(client);\n    this.channelSubscriptions = new ChannelSubscriptions(client);\n  }\n  async publish(recipient, payload) {\n    const client = this.client;\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options, { format }), params = {};\n    const body = mixin({ recipient }, payload);\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    const requestBody = encodeBody(body, client._MsgPack, format);\n    await resource_default.post(client, \"/push/publish\", requestBody, headers, params, null, true);\n  }\n};\nvar DeviceRegistrations = class {\n  constructor(client) {\n    this.client = client;\n  }\n  async save(device) {\n    const client = this.client;\n    const body = devicedetails_default.fromValues(device);\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options, { format }), params = {};\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    const requestBody = encodeBody(body, client._MsgPack, format);\n    const response = await resource_default.put(\n      client,\n      \"/push/deviceRegistrations/\" + encodeURIComponent(device.id),\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n    return devicedetails_default.fromResponseBody(\n      response.body,\n      client._MsgPack,\n      response.unpacked ? void 0 : format\n    );\n  }\n  async get(deviceIdOrDetails) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format }), deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\n    if (typeof deviceId !== \"string\" || !deviceId.length) {\n      throw new ErrorInfo(\n        \"First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails\",\n        4e4,\n        400\n      );\n    }\n    mixin(headers, client.options.headers);\n    const response = await resource_default.get(\n      client,\n      \"/push/deviceRegistrations/\" + encodeURIComponent(deviceId),\n      headers,\n      {},\n      null,\n      true\n    );\n    return devicedetails_default.fromResponseBody(\n      response.body,\n      client._MsgPack,\n      response.unpacked ? void 0 : format\n    );\n  }\n  async list(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(client, \"/push/deviceRegistrations\", headers, envelope, async function(body, headers2, unpacked) {\n      return devicedetails_default.fromResponseBody(\n        body,\n        client._MsgPack,\n        unpacked ? void 0 : format\n      );\n    }).get(params);\n  }\n  async remove(deviceIdOrDetails) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format }), params = {}, deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\n    if (typeof deviceId !== \"string\" || !deviceId.length) {\n      throw new ErrorInfo(\n        \"First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails\",\n        4e4,\n        400\n      );\n    }\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    await resource_default[\"delete\"](\n      client,\n      \"/push/deviceRegistrations/\" + encodeURIComponent(deviceId),\n      headers,\n      params,\n      null,\n      true\n    );\n  }\n  async removeWhere(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    await resource_default[\"delete\"](client, \"/push/deviceRegistrations\", headers, params, null, true);\n  }\n};\nvar ChannelSubscriptions = class _ChannelSubscriptions {\n  constructor(client) {\n    /* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */\n    this.remove = _ChannelSubscriptions.prototype.removeWhere;\n    this.client = client;\n  }\n  async save(subscription) {\n    const client = this.client;\n    const body = pushchannelsubscription_default.fromValues(subscription);\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options, { format }), params = {};\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    const requestBody = encodeBody(body, client._MsgPack, format);\n    const response = await resource_default.post(\n      client,\n      \"/push/channelSubscriptions\",\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n    return pushchannelsubscription_default.fromResponseBody(\n      response.body,\n      client._MsgPack,\n      response.unpacked ? void 0 : format\n    );\n  }\n  async list(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(client, \"/push/channelSubscriptions\", headers, envelope, async function(body, headers2, unpacked) {\n      return pushchannelsubscription_default.fromResponseBody(\n        body,\n        client._MsgPack,\n        unpacked ? void 0 : format\n      );\n    }).get(params);\n  }\n  async removeWhere(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    await resource_default[\"delete\"](client, \"/push/channelSubscriptions\", headers, params, null, true);\n  }\n  async listChannels(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    return new paginatedresource_default(client, \"/push/channels\", headers, envelope, async function(body, headers2, unpacked) {\n      const parsedBody = !unpacked && format ? decodeBody(body, client._MsgPack, format) : body;\n      for (let i = 0; i < parsedBody.length; i++) {\n        parsedBody[i] = String(parsedBody[i]);\n      }\n      return parsedBody;\n    }).get(params);\n  }\n};\nvar push_default = Push;\n\n// src/common/lib/types/presencemessage.ts\nvar actions2 = [\"absent\", \"present\", \"enter\", \"leave\", \"update\"];\nasync function fromEncoded(logger, Crypto2, encoded, inputOptions) {\n  const options = normalizeCipherOptions(Crypto2, logger, inputOptions != null ? inputOptions : null);\n  const wpm = WirePresenceMessage.fromValues(encoded);\n  return wpm.decode(options, logger);\n}\nasync function fromEncodedArray(logger, Crypto2, encodedArray, options) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return fromEncoded(logger, Crypto2, encoded, options);\n    })\n  );\n}\nasync function _fromEncoded(encoded, channel) {\n  return WirePresenceMessage.fromValues(encoded).decode(channel.channelOptions, channel.logger);\n}\nasync function _fromEncodedArray(encodedArray, channel) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return _fromEncoded(encoded, channel);\n    })\n  );\n}\nvar PresenceMessage = class _PresenceMessage extends BaseMessage {\n  /* Returns whether this presenceMessage is synthesized, i.e. was not actually\n   * sent by the connection (usually means a leave event sent 15s after a\n   * disconnection). This is useful because synthesized messages cannot be\n   * compared for newness by id lexicographically - RTP2b1\n   */\n  isSynthesized() {\n    if (!this.id || !this.connectionId) {\n      return true;\n    }\n    return this.id.substring(this.connectionId.length, 0) !== this.connectionId;\n  }\n  /* RTP2b2 */\n  parseId() {\n    if (!this.id)\n      throw new Error(\"parseId(): Presence message does not contain an id\");\n    const parts = this.id.split(\":\");\n    return {\n      connectionId: parts[0],\n      msgSerial: parseInt(parts[1], 10),\n      index: parseInt(parts[2], 10)\n    };\n  }\n  async encode(options) {\n    const res = Object.assign(new WirePresenceMessage(), this, {\n      action: actions2.indexOf(this.action || \"present\")\n    });\n    return encode(res, options);\n  }\n  static fromValues(values) {\n    return Object.assign(new _PresenceMessage(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _PresenceMessage.fromValues(v));\n  }\n  static fromData(data) {\n    if (data instanceof _PresenceMessage) {\n      return data;\n    }\n    return _PresenceMessage.fromValues({\n      data\n    });\n  }\n  toString() {\n    return strMsg(this, \"PresenceMessage\");\n  }\n};\nvar WirePresenceMessage = class _WirePresenceMessage extends BaseMessage {\n  toJSON(...args) {\n    return wireToJSON.call(this, ...args);\n  }\n  static fromValues(values) {\n    return Object.assign(new _WirePresenceMessage(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _WirePresenceMessage.fromValues(v));\n  }\n  async decode(channelOptions, logger) {\n    const res = Object.assign(new PresenceMessage(), __spreadProps(__spreadValues({}, this), {\n      action: actions2[this.action]\n    }));\n    try {\n      await decode(res, channelOptions);\n    } catch (e) {\n      logger_default.logAction(logger, logger_default.LOG_ERROR, \"WirePresenceMessage.decode()\", inspectError(e));\n    }\n    return res;\n  }\n  toString() {\n    return strMsg(this, \"WirePresenceMessage\");\n  }\n};\nvar presencemessage_default = PresenceMessage;\n\n// src/common/lib/client/restpresence.ts\nvar RestPresence = class {\n  constructor(channel) {\n    this.channel = channel;\n  }\n  get logger() {\n    return this.channel.logger;\n  }\n  async get(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestPresence.get()\", \"channel = \" + this.channel.name);\n    const client = this.channel.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(\n      client,\n      this.channel.client.rest.presenceMixin.basePath(this),\n      headers,\n      envelope,\n      async (body, headers2, unpacked) => {\n        const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n        return _fromEncodedArray(decoded, this.channel);\n      }\n    ).get(params);\n  }\n  async history(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestPresence.history()\", \"channel = \" + this.channel.name);\n    return this.channel.client.rest.presenceMixin.history(this, params);\n  }\n};\nvar restpresence_default = RestPresence;\n\n// src/common/lib/types/message.ts\nvar actions3 = [\"message.create\", \"message.update\", \"message.delete\", \"meta\", \"message.summary\"];\nfunction stringifyAction(action) {\n  return actions3[action || 0] || \"unknown\";\n}\nfunction getMessageSize(msg) {\n  let size = 0;\n  if (msg.name) {\n    size += msg.name.length;\n  }\n  if (msg.clientId) {\n    size += msg.clientId.length;\n  }\n  if (msg.extras) {\n    size += JSON.stringify(msg.extras).length;\n  }\n  if (msg.data) {\n    size += dataSizeBytes(msg.data);\n  }\n  return size;\n}\nasync function fromEncoded2(logger, Crypto2, encoded, inputOptions) {\n  const options = normalizeCipherOptions(Crypto2, logger, inputOptions != null ? inputOptions : null);\n  const wm = WireMessage.fromValues(encoded);\n  return wm.decode(options, logger);\n}\nasync function fromEncodedArray2(logger, Crypto2, encodedArray, options) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return fromEncoded2(logger, Crypto2, encoded, options);\n    })\n  );\n}\nasync function _fromEncoded2(encoded, channel) {\n  const wm = WireMessage.fromValues(encoded);\n  return wm.decode(channel.channelOptions, channel.logger);\n}\nasync function _fromEncodedArray2(encodedArray, channel) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return _fromEncoded2(encoded, channel);\n    })\n  );\n}\nasync function encodeArray(messages, options) {\n  return Promise.all(messages.map((message) => message.encode(options)));\n}\nvar serialize = encodeBody;\nfunction getMessagesSize(messages) {\n  let msg, total = 0;\n  for (let i = 0; i < messages.length; i++) {\n    msg = messages[i];\n    total += msg.size || (msg.size = getMessageSize(msg));\n  }\n  return total;\n}\nvar Message = class _Message extends BaseMessage {\n  expandFields() {\n    if (!this.version) {\n      this.version = {};\n    }\n    if (!this.version.serial && this.serial) {\n      this.version.serial = this.serial;\n    }\n    if (!this.version.timestamp && this.timestamp) {\n      this.version.timestamp = this.timestamp;\n    }\n    if (!this.annotations) {\n      this.annotations = {\n        summary: {}\n      };\n    } else if (!this.annotations.summary) {\n      this.annotations.summary = {};\n    }\n    if (this.annotations && this.annotations.summary) {\n      for (const [type, summaryEntry] of Object.entries(this.annotations.summary)) {\n        if (type.endsWith(\":distinct.v1\") || type.endsWith(\":unique.v1\") || type.endsWith(\":multiple.v1\")) {\n          for (const [, entry] of Object.entries(summaryEntry)) {\n            if (!entry.clipped) {\n              entry.clipped = false;\n            }\n          }\n        } else if (type.endsWith(\":flag.v1\")) {\n          if (!summaryEntry.clipped) {\n            summaryEntry.clipped = false;\n          }\n        }\n      }\n    }\n  }\n  async encode(options) {\n    const res = Object.assign(new WireMessage(), this, {\n      action: actions3.indexOf(this.action || \"message.create\")\n    });\n    return encode(res, options);\n  }\n  static fromValues(values) {\n    return Object.assign(new _Message(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _Message.fromValues(v));\n  }\n  toString() {\n    return strMsg(this, \"Message\");\n  }\n};\nvar WireMessage = class _WireMessage extends BaseMessage {\n  // Overload toJSON() to intercept JSON.stringify()\n  toJSON(...args) {\n    return wireToJSON.call(this, ...args);\n  }\n  static fromValues(values) {\n    return Object.assign(new _WireMessage(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _WireMessage.fromValues(v));\n  }\n  // for contexts where some decoding errors need to be handled specially by the caller\n  async decodeWithErr(inputContext, logger) {\n    const res = Object.assign(new Message(), __spreadProps(__spreadValues({}, this), {\n      action: stringifyAction(this.action)\n    }));\n    let err;\n    try {\n      await decode(res, inputContext);\n    } catch (e) {\n      logger_default.logAction(logger, logger_default.LOG_ERROR, \"WireMessage.decode()\", inspectError(e));\n      err = e;\n    }\n    res.expandFields();\n    return { decoded: res, err };\n  }\n  async decode(inputContext, logger) {\n    const { decoded } = await this.decodeWithErr(inputContext, logger);\n    return decoded;\n  }\n  toString() {\n    return strMsg(this, \"WireMessage\");\n  }\n};\nvar message_default = Message;\n\n// src/common/lib/client/restchannel.ts\nvar MSG_ID_ENTROPY_BYTES = 9;\nfunction allEmptyIds(messages) {\n  return messages.every(function(message) {\n    return !message.id;\n  });\n}\nvar RestChannel = class {\n  constructor(client, name, channelOptions) {\n    this._annotations = null;\n    var _a2, _b;\n    logger_default.logAction(client.logger, logger_default.LOG_MINOR, \"RestChannel()\", \"started; name = \" + name);\n    this.name = name;\n    this.client = client;\n    this.presence = new restpresence_default(this);\n    this.channelOptions = normaliseChannelOptions((_a2 = client._Crypto) != null ? _a2 : null, this.logger, channelOptions);\n    if ((_b = client.options.plugins) == null ? void 0 : _b.Push) {\n      this._push = new client.options.plugins.Push.PushChannel(this);\n    }\n    if (client._Annotations) {\n      this._annotations = new client._Annotations.RestAnnotations(this);\n    }\n  }\n  get annotations() {\n    if (!this._annotations) {\n      throwMissingPluginError(\"Annotations\");\n    }\n    return this._annotations;\n  }\n  get push() {\n    if (!this._push) {\n      throwMissingPluginError(\"Push\");\n    }\n    return this._push;\n  }\n  get logger() {\n    return this.client.logger;\n  }\n  setOptions(options) {\n    var _a2;\n    this.channelOptions = normaliseChannelOptions((_a2 = this.client._Crypto) != null ? _a2 : null, this.logger, options);\n  }\n  async history(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestChannel.history()\", \"channel = \" + this.name);\n    return this.client.rest.channelMixin.history(this, params);\n  }\n  async publish(...args) {\n    const first = args[0], second = args[1];\n    let messages;\n    let params;\n    if (typeof first === \"string\" || first === null) {\n      messages = [message_default.fromValues({ name: first, data: second })];\n      params = args[2];\n    } else if (isObject(first)) {\n      messages = [message_default.fromValues(first)];\n      params = args[1];\n    } else if (Array.isArray(first)) {\n      messages = message_default.fromValuesArray(first);\n      params = args[1];\n    } else {\n      throw new ErrorInfo(\n        \"The single-argument form of publish() expects a message object or an array of message objects\",\n        40013,\n        400\n      );\n    }\n    if (!params) {\n      params = {};\n    }\n    const client = this.client, options = client.options, format = options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, idempotentRestPublishing = client.options.idempotentRestPublishing, headers = defaults_default.defaultPostHeaders(client.options, { format });\n    mixin(headers, options.headers);\n    if (idempotentRestPublishing && allEmptyIds(messages)) {\n      const msgIdBase = await randomString(MSG_ID_ENTROPY_BYTES);\n      messages.forEach(function(message, index) {\n        message.id = msgIdBase + \":\" + index.toString();\n      });\n    }\n    const wireMessages = await encodeArray(messages, this.channelOptions);\n    const size = getMessagesSize(wireMessages), maxMessageSize = options.maxMessageSize;\n    if (size > maxMessageSize) {\n      throw new ErrorInfo(\n        `Maximum size of messages that can be published at once exceeded (was ${size} bytes; limit is ${maxMessageSize} bytes)`,\n        40009,\n        400\n      );\n    }\n    await this._publish(serialize(wireMessages, client._MsgPack, format), headers, params);\n  }\n  async _publish(requestBody, headers, params) {\n    await resource_default.post(\n      this.client,\n      this.client.rest.channelMixin.basePath(this) + \"/messages\",\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n  }\n  async status() {\n    return this.client.rest.channelMixin.status(this);\n  }\n};\nvar restchannel_default = RestChannel;\n\n// src/common/lib/types/stats.ts\nvar Stats = class _Stats {\n  constructor(values) {\n    this.entries = values && values.entries || void 0;\n    this.schema = values && values.schema || void 0;\n    this.appId = values && values.appId || void 0;\n    this.inProgress = values && values.inProgress || void 0;\n    this.unit = values && values.unit || void 0;\n    this.intervalId = values && values.intervalId || void 0;\n  }\n  static fromValues(values) {\n    return new _Stats(values);\n  }\n};\nvar stats_default = Stats;\n\n// src/common/lib/client/restchannelmixin.ts\nvar RestChannelMixin = class {\n  static basePath(channel) {\n    return \"/channels/\" + encodeURIComponent(channel.name);\n  }\n  static history(channel, params) {\n    const client = channel.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(client, this.basePath(channel) + \"/messages\", headers, envelope, async function(body, headers2, unpacked) {\n      const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n      return _fromEncodedArray2(decoded, channel);\n    }).get(params);\n  }\n  static async status(channel) {\n    const format = channel.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n    const headers = defaults_default.defaultPostHeaders(channel.client.options, { format });\n    const response = await resource_default.get(\n      channel.client,\n      this.basePath(channel),\n      headers,\n      {},\n      format,\n      true\n    );\n    return response.body;\n  }\n};\n\n// src/common/lib/client/restpresencemixin.ts\nvar RestPresenceMixin = class {\n  static basePath(presence) {\n    return RestChannelMixin.basePath(presence.channel) + \"/presence\";\n  }\n  static async history(presence, params) {\n    const client = presence.channel.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = presence.channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(\n      client,\n      this.basePath(presence) + \"/history\",\n      headers,\n      envelope,\n      async (body, headers2, unpacked) => {\n        const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n        return _fromEncodedArray(decoded, presence.channel);\n      }\n    ).get(params);\n  }\n};\n\n// src/common/lib/client/rest.ts\nvar Rest = class {\n  constructor(client) {\n    this.channelMixin = RestChannelMixin;\n    this.presenceMixin = RestPresenceMixin;\n    // exposed for plugins but shouldn't be bundled with minimal realtime\n    this.Resource = resource_default;\n    this.PaginatedResource = paginatedresource_default;\n    this.DeviceDetails = devicedetails_default;\n    this.PushChannelSubscription = pushchannelsubscription_default;\n    this.client = client;\n    this.channels = new Channels(this.client);\n    this.push = new push_default(this.client);\n  }\n  async stats(params) {\n    const headers = defaults_default.defaultGetHeaders(this.client.options), format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format;\n    mixin(headers, this.client.options.headers);\n    return new paginatedresource_default(this.client, \"/stats\", headers, envelope, function(body, headers2, unpacked) {\n      const statsValues = unpacked ? body : JSON.parse(body);\n      for (let i = 0; i < statsValues.length; i++)\n        statsValues[i] = stats_default.fromValues(statsValues[i]);\n      return statsValues;\n    }).get(params);\n  }\n  async time(params) {\n    const headers = defaults_default.defaultGetHeaders(this.client.options);\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const timeUri = (host) => {\n      return this.client.baseUri(host) + \"/time\";\n    };\n    let { error, body, unpacked } = await this.client.http.do(\n      HttpMethods_default.Get,\n      timeUri,\n      headers,\n      null,\n      params\n    );\n    if (error) {\n      throw error;\n    }\n    if (!unpacked)\n      body = JSON.parse(body);\n    const time = body[0];\n    if (!time) {\n      throw new ErrorInfo(\"Internal error (unexpected result type from GET /time)\", 5e4, 500);\n    }\n    this.client.serverTimeOffset = time - Date.now();\n    return time;\n  }\n  async request(method, path, version2, params, body, customHeaders) {\n    var _a2;\n    const [encoder, decoder, format] = (() => {\n      if (this.client.options.useBinaryProtocol) {\n        if (!this.client._MsgPack) {\n          throwMissingPluginError(\"MsgPack\");\n        }\n        return [this.client._MsgPack.encode, this.client._MsgPack.decode, \"msgpack\" /* msgpack */];\n      } else {\n        return [JSON.stringify, JSON.parse, \"json\" /* json */];\n      }\n    })();\n    const envelope = this.client.http.supportsLinkHeaders ? void 0 : format;\n    params = params || {};\n    const _method = method.toLowerCase();\n    const headers = _method == \"get\" ? defaults_default.defaultGetHeaders(this.client.options, { format, protocolVersion: version2 }) : defaults_default.defaultPostHeaders(this.client.options, { format, protocolVersion: version2 });\n    if (typeof body !== \"string\") {\n      body = (_a2 = encoder(body)) != null ? _a2 : null;\n    }\n    mixin(headers, this.client.options.headers);\n    if (customHeaders) {\n      mixin(headers, customHeaders);\n    }\n    const paginatedResource = new paginatedresource_default(\n      this.client,\n      path,\n      headers,\n      envelope,\n      async function(resbody, headers2, unpacked) {\n        return ensureArray(unpacked ? resbody : decoder(resbody));\n      },\n      /* useHttpPaginatedResponse: */\n      true\n    );\n    if (!Platform.Http.methods.includes(_method)) {\n      throw new ErrorInfo(\"Unsupported method \" + _method, 40500, 405);\n    }\n    if (Platform.Http.methodsWithBody.includes(_method)) {\n      return paginatedResource[_method](params, body);\n    } else {\n      return paginatedResource[_method](params);\n    }\n  }\n  async batchPublish(specOrSpecs) {\n    let requestBodyDTO;\n    let singleSpecMode;\n    if (Array.isArray(specOrSpecs)) {\n      requestBodyDTO = specOrSpecs;\n      singleSpecMode = false;\n    } else {\n      requestBodyDTO = [specOrSpecs];\n      singleSpecMode = true;\n    }\n    const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(this.client.options, { format });\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const requestBody = encodeBody(requestBodyDTO, this.client._MsgPack, format);\n    const response = await resource_default.post(this.client, \"/messages\", requestBody, headers, {}, null, true);\n    const batchResults = response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n    if (singleSpecMode) {\n      return batchResults[0];\n    } else {\n      return batchResults;\n    }\n  }\n  async batchPresence(channels) {\n    const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(this.client.options, { format });\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const channelsParam = channels.join(\",\");\n    const response = await resource_default.get(this.client, \"/presence\", headers, { channels: channelsParam }, null, true);\n    return response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n  }\n  async revokeTokens(specifiers, options) {\n    if (useTokenAuth(this.client.options)) {\n      throw new ErrorInfo(\"Cannot revoke tokens when using token auth\", 40162, 401);\n    }\n    const keyName = this.client.options.keyName;\n    let resolvedOptions = options != null ? options : {};\n    const requestBodyDTO = __spreadValues({\n      targets: specifiers.map((specifier) => `${specifier.type}:${specifier.value}`)\n    }, resolvedOptions);\n    const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(this.client.options, { format });\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const requestBody = encodeBody(requestBodyDTO, this.client._MsgPack, format);\n    const response = await resource_default.post(\n      this.client,\n      `/keys/${keyName}/revokeTokens`,\n      requestBody,\n      headers,\n      {},\n      null,\n      true\n    );\n    return response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n  }\n};\nvar Channels = class {\n  constructor(client) {\n    this.client = client;\n    this.all = /* @__PURE__ */ Object.create(null);\n  }\n  get(name, channelOptions) {\n    name = String(name);\n    let channel = this.all[name];\n    if (!channel) {\n      this.all[name] = channel = new restchannel_default(this.client, name, channelOptions);\n    } else if (channelOptions) {\n      channel.setOptions(channelOptions);\n    }\n    return channel;\n  }\n  /* Included to support certain niche use-cases; most users should ignore this.\n   * Please do not use this unless you know what you're doing */\n  release(name) {\n    delete this.all[String(name)];\n  }\n};\n\n// src/common/lib/client/baserest.ts\nvar BaseRest = class extends baseclient_default {\n  /*\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\n   *\n   * 1. passes a string (which is quite likely if they’re e.g. migrating from the default variant to the modular variant)\n   * 2. passes no argument at all\n   *\n   * tell the compiler that these cases are possible so that it forces us to handle them.\n   */\n  constructor(options) {\n    super(defaults_default.objectifyOptions(options, false, \"BaseRest\", logger_default.defaultLogger, { Rest }));\n  }\n};\n\n// src/common/lib/client/modularplugins.ts\nvar allCommonModularPlugins = { Rest };\n\n// src/common/lib/types/defaultmessage.ts\nvar DefaultMessage = class extends message_default {\n  static async fromEncoded(encoded, inputOptions) {\n    return fromEncoded2(logger_default.defaultLogger, Platform.Crypto, encoded, inputOptions);\n  }\n  static async fromEncodedArray(encodedArray, options) {\n    return fromEncodedArray2(logger_default.defaultLogger, Platform.Crypto, encodedArray, options);\n  }\n  static fromValues(values) {\n    return message_default.fromValues(values);\n  }\n};\n\n// src/common/lib/types/defaultpresencemessage.ts\nvar DefaultPresenceMessage = class extends presencemessage_default {\n  static async fromEncoded(encoded, inputOptions) {\n    return fromEncoded(logger_default.defaultLogger, Platform.Crypto, encoded, inputOptions);\n  }\n  static async fromEncodedArray(encodedArray, options) {\n    return fromEncodedArray(logger_default.defaultLogger, Platform.Crypto, encodedArray, options);\n  }\n  static fromValues(values) {\n    return presencemessage_default.fromValues(values);\n  }\n};\n\n// src/common/lib/types/annotation.ts\nvar actions4 = [\"annotation.create\", \"annotation.delete\"];\nasync function fromEncoded3(logger, encoded, options) {\n  const wa = WireAnnotation.fromValues(encoded);\n  return wa.decode(options || {}, logger);\n}\nasync function fromEncodedArray3(logger, encodedArray, options) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return fromEncoded3(logger, encoded, options);\n    })\n  );\n}\nasync function _fromEncoded3(encoded, channel) {\n  return WireAnnotation.fromValues(encoded).decode(channel.channelOptions, channel.logger);\n}\nasync function _fromEncodedArray3(encodedArray, channel) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return _fromEncoded3(encoded, channel);\n    })\n  );\n}\nvar Annotation = class _Annotation extends BaseMessage {\n  async encode() {\n    const res = Object.assign(new WireAnnotation(), this, {\n      action: actions4.indexOf(this.action || \"annotation.create\")\n    });\n    return encode(res, {});\n  }\n  static fromValues(values) {\n    return Object.assign(new _Annotation(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _Annotation.fromValues(v));\n  }\n  toString() {\n    return strMsg(this, \"Annotation\");\n  }\n};\nvar WireAnnotation = class _WireAnnotation extends BaseMessage {\n  toJSON(...args) {\n    return wireToJSON.call(this, ...args);\n  }\n  static fromValues(values) {\n    return Object.assign(new _WireAnnotation(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _WireAnnotation.fromValues(v));\n  }\n  async decode(channelOptions, logger) {\n    const res = Object.assign(new Annotation(), __spreadProps(__spreadValues({}, this), {\n      action: actions4[this.action]\n    }));\n    try {\n      await decode(res, channelOptions);\n    } catch (e) {\n      logger_default.logAction(logger, logger_default.LOG_ERROR, \"WireAnnotation.decode()\", inspectError(e));\n    }\n    return res;\n  }\n  toString() {\n    return strMsg(this, \"WireAnnotation\");\n  }\n};\nvar annotation_default = Annotation;\n\n// src/common/lib/types/defaultannotation.ts\nvar DefaultAnnotation = class extends annotation_default {\n  static async fromEncoded(encoded, inputOptions) {\n    return fromEncoded3(logger_default.defaultLogger, encoded, inputOptions);\n  }\n  static async fromEncodedArray(encodedArray, options) {\n    return fromEncodedArray3(logger_default.defaultLogger, encodedArray, options);\n  }\n  static fromValues(values) {\n    return annotation_default.fromValues(values);\n  }\n};\n\n// src/common/lib/client/restannotations.ts\nfunction serialFromMsgOrSerial(msgOrSerial) {\n  let messageSerial;\n  switch (typeof msgOrSerial) {\n    case \"string\":\n      messageSerial = msgOrSerial;\n      break;\n    case \"object\":\n      messageSerial = msgOrSerial.serial;\n      break;\n  }\n  if (!messageSerial || typeof messageSerial !== \"string\") {\n    throw new ErrorInfo(\n      \"First argument of annotations.publish() must be either a Message (or at least an object with a string `serial` property) or a message serial (string)\",\n      40003,\n      400\n    );\n  }\n  return messageSerial;\n}\nfunction constructValidateAnnotation(msgOrSerial, annotationValues) {\n  const messageSerial = serialFromMsgOrSerial(msgOrSerial);\n  if (!annotationValues || typeof annotationValues !== \"object\") {\n    throw new ErrorInfo(\n      \"Second argument of annotations.publish() must be an object (the intended annotation to publish)\",\n      40003,\n      400\n    );\n  }\n  const annotation = annotation_default.fromValues(annotationValues);\n  annotation.messageSerial = messageSerial;\n  if (!annotation.action) {\n    annotation.action = \"annotation.create\";\n  }\n  return annotation;\n}\nfunction basePathForSerial(channel, serial) {\n  return channel.client.rest.channelMixin.basePath(channel) + \"/messages/\" + encodeURIComponent(serial) + \"/annotations\";\n}\nvar RestAnnotations = class {\n  constructor(channel) {\n    this.channel = channel;\n  }\n  async publish(msgOrSerial, annotationValues) {\n    const annotation = constructValidateAnnotation(msgOrSerial, annotationValues);\n    const wireAnnotation = await annotation.encode();\n    const client = this.channel.client, options = client.options, format = options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options, { format }), params = {};\n    mixin(headers, client.options.headers);\n    const requestBody = encodeBody([wireAnnotation], client._MsgPack, format);\n    await resource_default.post(\n      client,\n      basePathForSerial(this.channel, annotation.messageSerial),\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n  }\n  async delete(msgOrSerial, annotationValues) {\n    annotationValues.action = \"annotation.delete\";\n    return this.publish(msgOrSerial, annotationValues);\n  }\n  async get(msgOrSerial, params) {\n    const client = this.channel.client, messageSerial = serialFromMsgOrSerial(msgOrSerial), format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(\n      client,\n      basePathForSerial(this.channel, messageSerial),\n      headers,\n      envelope,\n      async (body, _, unpacked) => {\n        const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n        return _fromEncodedArray3(decoded, this.channel);\n      }\n    ).get(params);\n  }\n};\nvar restannotations_default = RestAnnotations;\n\n// src/common/lib/types/protocolmessage.ts\nvar serialize2 = encodeBody;\nfunction toStringArray(array) {\n  const result = [];\n  if (array) {\n    for (let i = 0; i < array.length; i++) {\n      result.push(array[i].toString());\n    }\n  }\n  return \"[ \" + result.join(\", \") + \" ]\";\n}\nfunction deserialize(serialized, MsgPack, presenceMessagePlugin, annotationsPlugin, objectsPlugin, format) {\n  const deserialized = decodeBody(serialized, MsgPack, format);\n  return fromDeserialized(deserialized, presenceMessagePlugin, annotationsPlugin, objectsPlugin);\n}\nfunction fromDeserialized(deserialized, presenceMessagePlugin, annotationsPlugin, objectsPlugin) {\n  let error;\n  if (deserialized.error) {\n    error = ErrorInfo.fromValues(deserialized.error);\n  }\n  let messages;\n  if (deserialized.messages) {\n    messages = WireMessage.fromValuesArray(deserialized.messages);\n  }\n  let presence;\n  if (presenceMessagePlugin && deserialized.presence) {\n    presence = presenceMessagePlugin.WirePresenceMessage.fromValuesArray(\n      deserialized.presence\n    );\n  }\n  let annotations;\n  if (annotationsPlugin && deserialized.annotations) {\n    annotations = annotationsPlugin.WireAnnotation.fromValuesArray(\n      deserialized.annotations\n    );\n  }\n  let state;\n  if (objectsPlugin && deserialized.state) {\n    state = objectsPlugin.WireObjectMessage.fromValuesArray(\n      deserialized.state,\n      utils_exports,\n      MessageEncoding\n    );\n  }\n  return Object.assign(new ProtocolMessage(), __spreadProps(__spreadValues({}, deserialized), { presence, messages, annotations, state, error }));\n}\nfunction makeFromDeserializedWithDependencies(dependencies) {\n  return (deserialized) => {\n    var _a2;\n    return fromDeserialized(\n      deserialized,\n      {\n        PresenceMessage: presencemessage_default,\n        WirePresenceMessage\n      },\n      { Annotation: annotation_default, WireAnnotation, RealtimeAnnotations: realtimeannotations_default, RestAnnotations: restannotations_default },\n      (_a2 = dependencies == null ? void 0 : dependencies.ObjectsPlugin) != null ? _a2 : null\n    );\n  };\n}\nfunction fromValues(values) {\n  return Object.assign(new ProtocolMessage(), values);\n}\nfunction stringify(msg, presenceMessagePlugin, annotationsPlugin, objectsPlugin) {\n  let result = \"[ProtocolMessage\";\n  if (msg.action !== void 0)\n    result += \"; action=\" + ActionName[msg.action] || 0;\n  const simpleAttributes = [\"id\", \"channel\", \"channelSerial\", \"connectionId\", \"count\", \"msgSerial\", \"timestamp\"];\n  let attribute;\n  for (let attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {\n    attribute = simpleAttributes[attribIndex];\n    if (msg[attribute] !== void 0)\n      result += \"; \" + attribute + \"=\" + msg[attribute];\n  }\n  if (msg.messages)\n    result += \"; messages=\" + toStringArray(WireMessage.fromValuesArray(msg.messages));\n  if (msg.presence && presenceMessagePlugin)\n    result += \"; presence=\" + toStringArray(presenceMessagePlugin.WirePresenceMessage.fromValuesArray(msg.presence));\n  if (msg.annotations && annotationsPlugin) {\n    result += \"; annotations=\" + toStringArray(annotationsPlugin.WireAnnotation.fromValuesArray(msg.annotations));\n  }\n  if (msg.state && objectsPlugin) {\n    result += \"; state=\" + toStringArray(objectsPlugin.WireObjectMessage.fromValuesArray(msg.state, utils_exports, MessageEncoding));\n  }\n  if (msg.error)\n    result += \"; error=\" + ErrorInfo.fromValues(msg.error).toString();\n  if (msg.auth && msg.auth.accessToken)\n    result += \"; token=\" + msg.auth.accessToken;\n  if (msg.flags)\n    result += \"; flags=\" + flagNames.filter(msg.hasFlag).join(\",\");\n  if (msg.params) {\n    let stringifiedParams = \"\";\n    forInOwnNonNullProperties(msg.params, function(prop) {\n      if (stringifiedParams.length > 0) {\n        stringifiedParams += \"; \";\n      }\n      stringifiedParams += prop + \"=\" + msg.params[prop];\n    });\n    if (stringifiedParams.length > 0) {\n      result += \"; params=[\" + stringifiedParams + \"]\";\n    }\n  }\n  result += \"]\";\n  return result;\n}\nvar ProtocolMessage = class {\n  constructor() {\n    this.hasFlag = (flag) => {\n      return (this.flags & flags[flag]) > 0;\n    };\n  }\n  setFlag(flag) {\n    return this.flags = this.flags | flags[flag];\n  }\n  getMode() {\n    return (this.flags || 0) & flags.MODE_ALL;\n  }\n  encodeModesToFlags(modes) {\n    modes.forEach((mode) => this.setFlag(mode));\n  }\n  decodeModesFromFlags() {\n    const modes = [];\n    channelModes.forEach((mode) => {\n      if (this.hasFlag(mode)) {\n        modes.push(mode);\n      }\n    });\n    return modes.length > 0 ? modes : void 0;\n  }\n};\nvar protocolmessage_default = ProtocolMessage;\n\n// src/common/lib/client/channelstatechange.ts\nvar ChannelStateChange = class {\n  constructor(previous, current, resumed, hasBacklog, reason) {\n    this.previous = previous;\n    this.current = current;\n    if (current === \"attached\") {\n      this.resumed = resumed;\n      this.hasBacklog = hasBacklog;\n    }\n    if (reason)\n      this.reason = reason;\n  }\n};\nvar channelstatechange_default = ChannelStateChange;\n\n// src/common/lib/client/realtimechannel.ts\nvar noop = function() {\n};\nfunction validateChannelOptions(options) {\n  if (options && \"params\" in options && !isObject(options.params)) {\n    return new ErrorInfo(\"options.params must be an object\", 4e4, 400);\n  }\n  if (options && \"modes\" in options) {\n    if (!Array.isArray(options.modes)) {\n      return new ErrorInfo(\"options.modes must be an array\", 4e4, 400);\n    }\n    for (let i = 0; i < options.modes.length; i++) {\n      const currentMode = options.modes[i];\n      if (!currentMode || typeof currentMode !== \"string\" || !channelModes.includes(String.prototype.toUpperCase.call(currentMode))) {\n        return new ErrorInfo(\"Invalid channel mode: \" + currentMode, 4e4, 400);\n      }\n    }\n  }\n}\nvar RealtimeChannel = class _RealtimeChannel extends eventemitter_default {\n  constructor(client, name, options) {\n    var _a2, _b, _c;\n    super(client.logger);\n    this._annotations = null;\n    this._mode = 0;\n    this.retryCount = 0;\n    this.history = async function(params) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.history()\", \"channel = \" + this.name);\n      const restMixin = this.client.rest.channelMixin;\n      if (params && params.untilAttach) {\n        if (this.state !== \"attached\") {\n          throw new ErrorInfo(\"option untilAttach requires the channel to be attached\", 4e4, 400);\n        }\n        if (!this.properties.attachSerial) {\n          throw new ErrorInfo(\n            \"untilAttach was specified and channel is attached, but attachSerial is not defined\",\n            4e4,\n            400\n          );\n        }\n        delete params.untilAttach;\n        params.from_serial = this.properties.attachSerial;\n      }\n      return restMixin.history(this, params);\n    };\n    this.whenState = (state) => {\n      return eventemitter_default.prototype.whenState.call(this, state, this.state);\n    };\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"RealtimeChannel()\", \"started; name = \" + name);\n    this.name = name;\n    this.channelOptions = normaliseChannelOptions((_a2 = client._Crypto) != null ? _a2 : null, this.logger, options);\n    this.client = client;\n    this._presence = client._RealtimePresence ? new client._RealtimePresence.RealtimePresence(this) : null;\n    if (client._Annotations) {\n      this._annotations = new client._Annotations.RealtimeAnnotations(this);\n    }\n    this.connectionManager = client.connection.connectionManager;\n    this.state = \"initialized\";\n    this.subscriptions = new eventemitter_default(this.logger);\n    this.syncChannelSerial = void 0;\n    this.properties = {\n      attachSerial: void 0,\n      channelSerial: void 0\n    };\n    this.setOptions(options);\n    this.errorReason = null;\n    this._attachResume = false;\n    this._decodingContext = {\n      channelOptions: this.channelOptions,\n      plugins: client.options.plugins || {},\n      baseEncodedPreviousPayload: void 0\n    };\n    this._lastPayload = {\n      messageId: null,\n      protocolMessageChannelSerial: null,\n      decodeFailureRecoveryInProgress: null\n    };\n    this._allChannelChanges = new eventemitter_default(this.logger);\n    if ((_b = client.options.plugins) == null ? void 0 : _b.Push) {\n      this._push = new client.options.plugins.Push.PushChannel(this);\n    }\n    if ((_c = client.options.plugins) == null ? void 0 : _c.Objects) {\n      this._objects = new client.options.plugins.Objects.Objects(this);\n    }\n  }\n  get presence() {\n    if (!this._presence) {\n      throwMissingPluginError(\"RealtimePresence\");\n    }\n    return this._presence;\n  }\n  get annotations() {\n    if (!this._annotations) {\n      throwMissingPluginError(\"Annotations\");\n    }\n    return this._annotations;\n  }\n  get push() {\n    if (!this._push) {\n      throwMissingPluginError(\"Push\");\n    }\n    return this._push;\n  }\n  /** @spec RTL27 */\n  get objects() {\n    if (!this._objects) {\n      throwMissingPluginError(\"Objects\");\n    }\n    return this._objects;\n  }\n  invalidStateError() {\n    return new ErrorInfo(\n      \"Channel operation failed as channel state is \" + this.state,\n      90001,\n      400,\n      this.errorReason || void 0\n    );\n  }\n  static processListenerArgs(args) {\n    args = Array.prototype.slice.call(args);\n    if (typeof args[0] === \"function\") {\n      args.unshift(null);\n    }\n    return args;\n  }\n  async setOptions(options) {\n    var _a2;\n    const previousChannelOptions = this.channelOptions;\n    const err = validateChannelOptions(options);\n    if (err) {\n      throw err;\n    }\n    this.channelOptions = normaliseChannelOptions((_a2 = this.client._Crypto) != null ? _a2 : null, this.logger, options);\n    if (this._decodingContext)\n      this._decodingContext.channelOptions = this.channelOptions;\n    if (this._shouldReattachToSetOptions(options, previousChannelOptions)) {\n      this.attachImpl();\n      return new Promise((resolve, reject) => {\n        this._allChannelChanges.once(\n          [\"attached\", \"update\", \"detached\", \"failed\"],\n          function(stateChange) {\n            switch (this.event) {\n              case \"update\":\n              case \"attached\":\n                resolve();\n                break;\n              default:\n                reject(stateChange.reason);\n            }\n          }\n        );\n      });\n    }\n  }\n  _shouldReattachToSetOptions(options, prevOptions) {\n    if (!(this.state === \"attached\" || this.state === \"attaching\")) {\n      return false;\n    }\n    if (options == null ? void 0 : options.params) {\n      const requestedParams = omitAgent(options.params);\n      const existingParams = omitAgent(prevOptions.params);\n      if (Object.keys(requestedParams).length !== Object.keys(existingParams).length) {\n        return true;\n      }\n      if (!shallowEquals(existingParams, requestedParams)) {\n        return true;\n      }\n    }\n    if (options == null ? void 0 : options.modes) {\n      if (!prevOptions.modes || !arrEquals(options.modes, prevOptions.modes)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  async publish(...args) {\n    let messages;\n    let argCount = args.length;\n    if (argCount == 1) {\n      if (isObject(args[0])) {\n        messages = [message_default.fromValues(args[0])];\n      } else if (Array.isArray(args[0])) {\n        messages = message_default.fromValuesArray(args[0]);\n      } else {\n        throw new ErrorInfo(\n          \"The single-argument form of publish() expects a message object or an array of message objects\",\n          40013,\n          400\n        );\n      }\n    } else {\n      messages = [message_default.fromValues({ name: args[0], data: args[1] })];\n    }\n    const maxMessageSize = this.client.options.maxMessageSize;\n    const wireMessages = await encodeArray(messages, this.channelOptions);\n    const size = getMessagesSize(wireMessages);\n    if (size > maxMessageSize) {\n      throw new ErrorInfo(\n        `Maximum size of messages that can be published at once exceeded (was ${size} bytes; limit is ${maxMessageSize} bytes)`,\n        40009,\n        400\n      );\n    }\n    this.throwIfUnpublishableState();\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeChannel.publish()\",\n      \"sending message; channel state is \" + this.state + \", message count = \" + wireMessages.length\n    );\n    const pm = fromValues({ action: actions.MESSAGE, channel: this.name, messages: wireMessages });\n    return this.sendMessage(pm);\n  }\n  throwIfUnpublishableState() {\n    if (!this.connectionManager.activeState()) {\n      throw this.connectionManager.getError();\n    }\n    if (this.state === \"failed\" || this.state === \"suspended\") {\n      throw this.invalidStateError();\n    }\n  }\n  onEvent(messages) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.onEvent()\", \"received message\");\n    const subscriptions = this.subscriptions;\n    for (let i = 0; i < messages.length; i++) {\n      const message = messages[i];\n      subscriptions.emit(message.name, message);\n    }\n  }\n  async attach() {\n    if (this.state === \"attached\") {\n      return null;\n    }\n    return new Promise((resolve, reject) => {\n      this._attach(false, null, (err, result) => err ? reject(err) : resolve(result));\n    });\n  }\n  _attach(forceReattach, attachReason, callback) {\n    if (!callback) {\n      callback = (err) => {\n        if (err) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"RealtimeChannel._attach()\",\n            \"Channel attach failed: \" + err.toString()\n          );\n        }\n      };\n    }\n    const connectionManager = this.connectionManager;\n    if (!connectionManager.activeState()) {\n      callback(connectionManager.getError());\n      return;\n    }\n    if (this.state !== \"attaching\" || forceReattach) {\n      this.requestState(\"attaching\", attachReason);\n    }\n    this.once(function(stateChange) {\n      switch (this.event) {\n        case \"attached\":\n          callback == null ? void 0 : callback(null, stateChange);\n          break;\n        case \"detached\":\n        case \"suspended\":\n        case \"failed\":\n          callback == null ? void 0 : callback(\n            stateChange.reason || connectionManager.getError() || new ErrorInfo(\"Unable to attach; reason unknown; state = \" + this.event, 9e4, 500)\n          );\n          break;\n        case \"detaching\":\n          callback == null ? void 0 : callback(new ErrorInfo(\"Attach request superseded by a subsequent detach request\", 9e4, 409));\n          break;\n      }\n    });\n  }\n  attachImpl() {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.attachImpl()\", \"sending ATTACH message\");\n    const attachMsg = fromValues({\n      action: actions.ATTACH,\n      channel: this.name,\n      params: this.channelOptions.params,\n      // RTL4c1: Includes the channel serial to resume from a previous message\n      // or attachment.\n      channelSerial: this.properties.channelSerial\n    });\n    if (this.channelOptions.modes) {\n      attachMsg.encodeModesToFlags(allToUpperCase(this.channelOptions.modes));\n    }\n    if (this._attachResume) {\n      attachMsg.setFlag(\"ATTACH_RESUME\");\n    }\n    if (this._lastPayload.decodeFailureRecoveryInProgress) {\n      attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;\n    }\n    this.sendMessage(attachMsg).catch(noop);\n  }\n  async detach() {\n    const connectionManager = this.connectionManager;\n    if (!connectionManager.activeState()) {\n      throw connectionManager.getError();\n    }\n    switch (this.state) {\n      case \"suspended\":\n        this.notifyState(\"detached\");\n        return;\n      case \"detached\":\n        return;\n      case \"failed\":\n        throw new ErrorInfo(\"Unable to detach; channel state = failed\", 90001, 400);\n      default:\n        this.requestState(\"detaching\");\n      case \"detaching\":\n        return new Promise((resolve, reject) => {\n          this.once(function(stateChange) {\n            switch (this.event) {\n              case \"detached\":\n                resolve();\n                break;\n              case \"attached\":\n              case \"suspended\":\n              case \"failed\":\n                reject(\n                  stateChange.reason || connectionManager.getError() || new ErrorInfo(\"Unable to detach; reason unknown; state = \" + this.event, 9e4, 500)\n                );\n                break;\n              case \"attaching\":\n                reject(new ErrorInfo(\"Detach request superseded by a subsequent attach request\", 9e4, 409));\n                break;\n            }\n          });\n        });\n    }\n  }\n  detachImpl() {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.detach()\", \"sending DETACH message\");\n    const msg = fromValues({ action: actions.DETACH, channel: this.name });\n    this.sendMessage(msg).catch(noop);\n  }\n  async subscribe(...args) {\n    const [event, listener] = _RealtimeChannel.processListenerArgs(args);\n    if (this.state === \"failed\") {\n      throw ErrorInfo.fromValues(this.invalidStateError());\n    }\n    if (event && typeof event === \"object\" && !Array.isArray(event)) {\n      this.client._FilteredSubscriptions.subscribeFilter(this, event, listener);\n    } else {\n      this.subscriptions.on(event, listener);\n    }\n    if (this.channelOptions.attachOnSubscribe !== false) {\n      return this.attach();\n    } else {\n      return null;\n    }\n  }\n  unsubscribe(...args) {\n    var _a2;\n    const [event, listener] = _RealtimeChannel.processListenerArgs(args);\n    if (typeof event === \"object\" && !listener || ((_a2 = this.filteredSubscriptions) == null ? void 0 : _a2.has(listener))) {\n      this.client._FilteredSubscriptions.getAndDeleteFilteredSubscriptions(this, event, listener).forEach((l) => this.subscriptions.off(l));\n      return;\n    }\n    this.subscriptions.off(event, listener);\n  }\n  sync() {\n    switch (this.state) {\n      case \"initialized\":\n      case \"detaching\":\n      case \"detached\":\n        throw new PartialErrorInfo(\"Unable to sync to channel; not attached\", 4e4);\n      default:\n    }\n    const connectionManager = this.connectionManager;\n    if (!connectionManager.activeState()) {\n      throw connectionManager.getError();\n    }\n    const syncMessage = fromValues({ action: actions.SYNC, channel: this.name });\n    if (this.syncChannelSerial) {\n      syncMessage.channelSerial = this.syncChannelSerial;\n    }\n    connectionManager.send(syncMessage);\n  }\n  async sendMessage(msg) {\n    return new Promise((resolve, reject) => {\n      this.connectionManager.send(msg, this.client.options.queueMessages, (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n  async sendPresence(presence) {\n    const msg = fromValues({\n      action: actions.PRESENCE,\n      channel: this.name,\n      presence\n    });\n    return this.sendMessage(msg);\n  }\n  sendState(objectMessages) {\n    const msg = fromValues({\n      action: actions.OBJECT,\n      channel: this.name,\n      state: objectMessages\n    });\n    return this.sendMessage(msg);\n  }\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage, in order to synchronise access to the state stored in _decodingContext.\n  async processMessage(message) {\n    if (message.action === actions.ATTACHED || message.action === actions.MESSAGE || message.action === actions.PRESENCE || message.action === actions.OBJECT || message.action === actions.ANNOTATION) {\n      this.setChannelSerial(message.channelSerial);\n    }\n    let syncChannelSerial, isSync = false;\n    switch (message.action) {\n      case actions.ATTACHED: {\n        this.properties.attachSerial = message.channelSerial;\n        this._mode = message.getMode();\n        this.params = message.params || {};\n        const modesFromFlags = message.decodeModesFromFlags();\n        this.modes = modesFromFlags && allToLowerCase(modesFromFlags) || void 0;\n        const resumed = message.hasFlag(\"RESUMED\");\n        const hasPresence = message.hasFlag(\"HAS_PRESENCE\");\n        const hasBacklog = message.hasFlag(\"HAS_BACKLOG\");\n        const hasObjects = message.hasFlag(\"HAS_OBJECTS\");\n        if (this.state === \"attached\") {\n          if (!resumed) {\n            if (this._presence) {\n              this._presence.onAttached(hasPresence);\n            }\n            if (this._objects) {\n              this._objects.onAttached(hasObjects);\n            }\n          }\n          const change = new channelstatechange_default(this.state, this.state, resumed, hasBacklog, message.error);\n          this._allChannelChanges.emit(\"update\", change);\n          if (!resumed || this.channelOptions.updateOnAttached) {\n            this.emit(\"update\", change);\n          }\n        } else if (this.state === \"detaching\") {\n          this.checkPendingState();\n        } else {\n          this.notifyState(\"attached\", message.error, resumed, hasPresence, hasBacklog, hasObjects);\n        }\n        break;\n      }\n      case actions.DETACHED: {\n        const detachErr = message.error ? ErrorInfo.fromValues(message.error) : new ErrorInfo(\"Channel detached\", 90001, 404);\n        if (this.state === \"detaching\") {\n          this.notifyState(\"detached\", detachErr);\n        } else if (this.state === \"attaching\") {\n          this.notifyState(\"suspended\", detachErr);\n        } else if (this.state === \"attached\" || this.state === \"suspended\") {\n          this.requestState(\"attaching\", detachErr);\n        }\n        break;\n      }\n      case actions.SYNC:\n        isSync = true;\n        syncChannelSerial = this.syncChannelSerial = message.channelSerial;\n        if (!message.presence)\n          break;\n      case actions.PRESENCE: {\n        if (!message.presence) {\n          break;\n        }\n        populateFieldsFromParent(message);\n        const options = this.channelOptions;\n        if (this._presence) {\n          const presenceMessages = await Promise.all(\n            message.presence.map((wpm) => {\n              return wpm.decode(options, this.logger);\n            })\n          );\n          this._presence.setPresence(presenceMessages, isSync, syncChannelSerial);\n        }\n        break;\n      }\n      case actions.OBJECT:\n      case actions.OBJECT_SYNC: {\n        if (!this._objects || !message.state) {\n          return;\n        }\n        populateFieldsFromParent(message);\n        const format = this.client.connection.connectionManager.getActiveTransportFormat();\n        const objectMessages = message.state.map((om) => om.decode(this.client, format));\n        if (message.action === actions.OBJECT) {\n          this._objects.handleObjectMessages(objectMessages);\n        } else {\n          this._objects.handleObjectSyncMessages(objectMessages, message.channelSerial);\n        }\n        break;\n      }\n      case actions.MESSAGE: {\n        if (this.state !== \"attached\") {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"RealtimeChannel.processMessage()\",\n            'Message \"' + message.id + '\" skipped as this channel \"' + this.name + '\" state is not \"attached\" (state is \"' + this.state + '\").'\n          );\n          return;\n        }\n        populateFieldsFromParent(message);\n        const encoded = message.messages, firstMessage = encoded[0], lastMessage = encoded[encoded.length - 1];\n        if (firstMessage.extras && firstMessage.extras.delta && firstMessage.extras.delta.from !== this._lastPayload.messageId) {\n          const msg = 'Delta message decode failure - previous message not available for message \"' + message.id + '\" on this channel \"' + this.name + '\".';\n          logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"RealtimeChannel.processMessage()\", msg);\n          this._startDecodeFailureRecovery(new ErrorInfo(msg, 40018, 400));\n          break;\n        }\n        let messages = [];\n        for (let i = 0; i < encoded.length; i++) {\n          const { decoded, err } = await encoded[i].decodeWithErr(this._decodingContext, this.logger);\n          messages[i] = decoded;\n          if (err) {\n            switch (err.code) {\n              case 40018:\n                this._startDecodeFailureRecovery(err);\n                return;\n              case 40019:\n              case 40021:\n                this.notifyState(\"failed\", err);\n                return;\n              default:\n            }\n          }\n        }\n        this._lastPayload.messageId = lastMessage.id;\n        this._lastPayload.protocolMessageChannelSerial = message.channelSerial;\n        this.onEvent(messages);\n        break;\n      }\n      case actions.ANNOTATION: {\n        populateFieldsFromParent(message);\n        const options = this.channelOptions;\n        if (this._annotations) {\n          const annotations = await Promise.all(\n            (message.annotations || []).map((wpm) => {\n              return wpm.decode(options, this.logger);\n            })\n          );\n          this._annotations._processIncoming(annotations);\n        }\n        break;\n      }\n      case actions.ERROR: {\n        const err = message.error;\n        if (err && err.code == 80016) {\n          this.checkPendingState();\n        } else {\n          this.notifyState(\"failed\", ErrorInfo.fromValues(err));\n        }\n        break;\n      }\n      default:\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MAJOR,\n          \"RealtimeChannel.processMessage()\",\n          \"Protocol error: unrecognised message action (\" + message.action + \")\"\n        );\n    }\n  }\n  _startDecodeFailureRecovery(reason) {\n    if (!this._lastPayload.decodeFailureRecoveryInProgress) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MAJOR,\n        \"RealtimeChannel.processMessage()\",\n        \"Starting decode failure recovery process.\"\n      );\n      this._lastPayload.decodeFailureRecoveryInProgress = true;\n      this._attach(true, reason, () => {\n        this._lastPayload.decodeFailureRecoveryInProgress = false;\n      });\n    }\n  }\n  onAttached() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimeChannel.onAttached\",\n      \"activating channel; name = \" + this.name\n    );\n  }\n  notifyState(state, reason, resumed, hasPresence, hasBacklog, hasObjects) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeChannel.notifyState\",\n      \"name = \" + this.name + \", current state = \" + this.state + \", notifying state \" + state\n    );\n    this.clearStateTimer();\n    if ([\"detached\", \"suspended\", \"failed\"].includes(state)) {\n      this.properties.channelSerial = null;\n    }\n    if (state === this.state) {\n      return;\n    }\n    if (this._presence) {\n      this._presence.actOnChannelState(state, hasPresence, reason);\n    }\n    if (this._objects) {\n      this._objects.actOnChannelState(state, hasObjects);\n    }\n    if (state === \"suspended\" && this.connectionManager.state.sendEvents) {\n      this.startRetryTimer();\n    } else {\n      this.cancelRetryTimer();\n    }\n    if (reason) {\n      this.errorReason = reason;\n    }\n    const change = new channelstatechange_default(this.state, state, resumed, hasBacklog, reason);\n    const action = 'Channel state for channel \"' + this.name + '\"';\n    const message = state + (reason ? \"; reason: \" + reason : \"\");\n    if (state === \"failed\") {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, action, message);\n    } else {\n      logger_default.logAction(this.logger, logger_default.LOG_MAJOR, action, message);\n    }\n    if (state !== \"attaching\" && state !== \"suspended\") {\n      this.retryCount = 0;\n    }\n    if (state === \"attached\") {\n      this.onAttached();\n    }\n    if (state === \"attached\") {\n      this._attachResume = true;\n    } else if (state === \"detaching\" || state === \"failed\") {\n      this._attachResume = false;\n    }\n    this.state = state;\n    this._allChannelChanges.emit(state, change);\n    this.emit(state, change);\n  }\n  requestState(state, reason) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimeChannel.requestState\",\n      \"name = \" + this.name + \", state = \" + state\n    );\n    this.notifyState(state, reason);\n    this.checkPendingState();\n  }\n  checkPendingState() {\n    const cmState = this.connectionManager.state;\n    if (!cmState.sendEvents) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"RealtimeChannel.checkPendingState\",\n        \"sendEvents is false; state is \" + this.connectionManager.state.state\n      );\n      return;\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimeChannel.checkPendingState\",\n      \"name = \" + this.name + \", state = \" + this.state\n    );\n    switch (this.state) {\n      case \"attaching\":\n        this.startStateTimerIfNotRunning();\n        this.attachImpl();\n        break;\n      case \"detaching\":\n        this.startStateTimerIfNotRunning();\n        this.detachImpl();\n        break;\n      case \"attached\":\n        this.sync();\n        break;\n      default:\n        break;\n    }\n  }\n  timeoutPendingState() {\n    switch (this.state) {\n      case \"attaching\": {\n        const err = new ErrorInfo(\"Channel attach timed out\", 90007, 408);\n        this.notifyState(\"suspended\", err);\n        break;\n      }\n      case \"detaching\": {\n        const err = new ErrorInfo(\"Channel detach timed out\", 90007, 408);\n        this.notifyState(\"attached\", err);\n        break;\n      }\n      default:\n        this.checkPendingState();\n        break;\n    }\n  }\n  startStateTimerIfNotRunning() {\n    if (!this.stateTimer) {\n      this.stateTimer = setTimeout(() => {\n        logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"RealtimeChannel.startStateTimerIfNotRunning\", \"timer expired\");\n        this.stateTimer = null;\n        this.timeoutPendingState();\n      }, this.client.options.timeouts.realtimeRequestTimeout);\n    }\n  }\n  clearStateTimer() {\n    const stateTimer = this.stateTimer;\n    if (stateTimer) {\n      clearTimeout(stateTimer);\n      this.stateTimer = null;\n    }\n  }\n  startRetryTimer() {\n    if (this.retryTimer)\n      return;\n    this.retryCount++;\n    const retryDelay = getRetryTime(this.client.options.timeouts.channelRetryTimeout, this.retryCount);\n    this.retryTimer = setTimeout(() => {\n      if (this.state === \"suspended\" && this.connectionManager.state.sendEvents) {\n        this.retryTimer = null;\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"RealtimeChannel retry timer expired\",\n          \"attempting a new attach\"\n        );\n        this.requestState(\"attaching\");\n      }\n    }, retryDelay);\n  }\n  cancelRetryTimer() {\n    if (this.retryTimer) {\n      clearTimeout(this.retryTimer);\n      this.retryTimer = null;\n    }\n  }\n  /* @returns null (if can safely be released) | ErrorInfo (if cannot) */\n  getReleaseErr() {\n    const s = this.state;\n    if (s === \"initialized\" || s === \"detached\" || s === \"failed\") {\n      return null;\n    }\n    return new ErrorInfo(\n      \"Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was \" + s,\n      90001,\n      400\n    );\n  }\n  setChannelSerial(channelSerial) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeChannel.setChannelSerial()\",\n      \"Updating channel serial; serial = \" + channelSerial + \"; previous = \" + this.properties.channelSerial\n    );\n    if (channelSerial) {\n      this.properties.channelSerial = channelSerial;\n    }\n  }\n  async status() {\n    return this.client.rest.channelMixin.status(this);\n  }\n};\nfunction omitAgent(channelParams) {\n  const _a2 = channelParams || {}, { agent: _ } = _a2, paramsWithoutAgent = __objRest(_a2, [\"agent\"]);\n  return paramsWithoutAgent;\n}\nvar realtimechannel_default = RealtimeChannel;\n\n// src/common/lib/client/realtimeannotations.ts\nvar RealtimeAnnotations = class {\n  constructor(channel) {\n    this.channel = channel;\n    this.logger = channel.logger;\n    this.subscriptions = new eventemitter_default(this.logger);\n  }\n  async publish(msgOrSerial, annotationValues) {\n    const channelName = this.channel.name;\n    const annotation = constructValidateAnnotation(msgOrSerial, annotationValues);\n    const wireAnnotation = await annotation.encode();\n    this.channel.throwIfUnpublishableState();\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeAnnotations.publish()\",\n      \"channelName = \" + channelName + \", sending annotation with messageSerial = \" + annotation.messageSerial + \", type = \" + annotation.type\n    );\n    const pm = fromValues({\n      action: actions.ANNOTATION,\n      channel: channelName,\n      annotations: [wireAnnotation]\n    });\n    return this.channel.sendMessage(pm);\n  }\n  async delete(msgOrSerial, annotationValues) {\n    annotationValues.action = \"annotation.delete\";\n    return this.publish(msgOrSerial, annotationValues);\n  }\n  async subscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    const channel = this.channel;\n    if (channel.state === \"failed\") {\n      throw ErrorInfo.fromValues(channel.invalidStateError());\n    }\n    this.subscriptions.on(event, listener);\n    if (this.channel.channelOptions.attachOnSubscribe !== false) {\n      await channel.attach();\n    }\n    if ((this.channel.state === \"attached\" && this.channel._mode & flags.ANNOTATION_SUBSCRIBE) === 0) {\n      throw new ErrorInfo(\n        \"You are trying to add an annotation listener, but you haven't requested the annotation_subscribe channel mode in ChannelOptions, so this won't do anything (we only deliver annotations to clients who have explicitly requested them)\",\n        93001,\n        400\n      );\n    }\n  }\n  unsubscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    this.subscriptions.off(event, listener);\n  }\n  _processIncoming(annotations) {\n    for (const annotation of annotations) {\n      this.subscriptions.emit(annotation.type || \"\", annotation);\n    }\n  }\n  async get(msgOrSerial, params) {\n    return restannotations_default.prototype.get.call(this, msgOrSerial, params);\n  }\n};\nvar realtimeannotations_default = RealtimeAnnotations;\n\n// src/common/lib/client/defaultrest.ts\nvar _DefaultRest = class _DefaultRest extends BaseRest {\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\n  constructor(options) {\n    var _a2, _b;\n    const MsgPack = _DefaultRest._MsgPack;\n    if (!MsgPack) {\n      throw new Error(\"Expected DefaultRest._MsgPack to have been set\");\n    }\n    super(\n      defaults_default.objectifyOptions(options, true, \"Rest\", logger_default.defaultLogger, __spreadProps(__spreadValues({}, allCommonModularPlugins), {\n        Crypto: (_a2 = _DefaultRest.Crypto) != null ? _a2 : void 0,\n        MsgPack: (_b = _DefaultRest._MsgPack) != null ? _b : void 0,\n        Annotations: {\n          Annotation: annotation_default,\n          WireAnnotation,\n          RealtimeAnnotations: realtimeannotations_default,\n          RestAnnotations: restannotations_default\n        }\n      }))\n    );\n  }\n  static get Crypto() {\n    if (this._Crypto === null) {\n      throw new Error(\"Encryption not enabled; use ably.encryption.js instead\");\n    }\n    return this._Crypto;\n  }\n  static set Crypto(newValue) {\n    this._Crypto = newValue;\n  }\n};\n_DefaultRest._Crypto = null;\n_DefaultRest.Message = DefaultMessage;\n_DefaultRest.PresenceMessage = DefaultPresenceMessage;\n_DefaultRest.Annotation = DefaultAnnotation;\n_DefaultRest._MsgPack = null;\n// Used by tests\n_DefaultRest._Http = Http;\nvar DefaultRest = _DefaultRest;\n\n// src/common/lib/transport/messagequeue.ts\nvar MessageQueue = class extends eventemitter_default {\n  constructor(logger) {\n    super(logger);\n    this.messages = [];\n  }\n  count() {\n    return this.messages.length;\n  }\n  push(message) {\n    this.messages.push(message);\n  }\n  shift() {\n    return this.messages.shift();\n  }\n  last() {\n    return this.messages[this.messages.length - 1];\n  }\n  copyAll() {\n    return this.messages.slice();\n  }\n  append(messages) {\n    this.messages.push.apply(this.messages, messages);\n  }\n  prepend(messages) {\n    this.messages.unshift.apply(this.messages, messages);\n  }\n  completeMessages(serial, count, err) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"MessageQueue.completeMessages()\",\n      \"serial = \" + serial + \"; count = \" + count\n    );\n    err = err || null;\n    const messages = this.messages;\n    if (messages.length === 0) {\n      throw new Error(\"MessageQueue.completeMessages(): completeMessages called on any empty MessageQueue\");\n    }\n    const first = messages[0];\n    if (first) {\n      const startSerial = first.message.msgSerial;\n      const endSerial = serial + count;\n      if (endSerial > startSerial) {\n        const completeMessages = messages.splice(0, endSerial - startSerial);\n        for (const message of completeMessages) {\n          message.callback(err);\n        }\n      }\n      if (messages.length == 0)\n        this.emit(\"idle\");\n    }\n  }\n  completeAllMessages(err) {\n    this.completeMessages(0, Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, err);\n  }\n  resetSendAttempted() {\n    for (let msg of this.messages) {\n      msg.sendAttempted = false;\n    }\n  }\n  clear() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"MessageQueue.clear()\",\n      \"clearing \" + this.messages.length + \" messages\"\n    );\n    this.messages = [];\n    this.emit(\"idle\");\n  }\n};\nvar messagequeue_default = MessageQueue;\n\n// src/common/lib/transport/protocol.ts\nvar PendingMessage = class {\n  constructor(message, callback) {\n    this.message = message;\n    this.callback = callback;\n    this.merged = false;\n    const action = message.action;\n    this.sendAttempted = false;\n    this.ackRequired = typeof action === \"number\" && [actions.MESSAGE, actions.PRESENCE, actions.ANNOTATION, actions.OBJECT].includes(action);\n  }\n};\nvar Protocol = class extends eventemitter_default {\n  constructor(transport) {\n    super(transport.logger);\n    this.transport = transport;\n    this.messageQueue = new messagequeue_default(this.logger);\n    transport.on(\"ack\", (serial, count) => {\n      this.onAck(serial, count);\n    });\n    transport.on(\"nack\", (serial, count, err) => {\n      this.onNack(serial, count, err);\n    });\n  }\n  onAck(serial, count) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"Protocol.onAck()\", \"serial = \" + serial + \"; count = \" + count);\n    this.messageQueue.completeMessages(serial, count);\n  }\n  onNack(serial, count, err) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_ERROR,\n      \"Protocol.onNack()\",\n      \"serial = \" + serial + \"; count = \" + count + \"; err = \" + inspectError(err)\n    );\n    if (!err) {\n      err = new ErrorInfo(\"Unable to send message; channel not responding\", 50001, 500);\n    }\n    this.messageQueue.completeMessages(serial, count, err);\n  }\n  onceIdle(listener) {\n    const messageQueue = this.messageQueue;\n    if (messageQueue.count() === 0) {\n      listener();\n      return;\n    }\n    messageQueue.once(\"idle\", listener);\n  }\n  send(pendingMessage) {\n    if (pendingMessage.ackRequired) {\n      this.messageQueue.push(pendingMessage);\n    }\n    if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n      logger_default.logActionNoStrip(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"Protocol.send()\",\n        \"sending msg; \" + stringify(\n          pendingMessage.message,\n          this.transport.connectionManager.realtime._RealtimePresence,\n          this.transport.connectionManager.realtime._Annotations,\n          this.transport.connectionManager.realtime._objectsPlugin\n        )\n      );\n    }\n    pendingMessage.sendAttempted = true;\n    this.transport.send(pendingMessage.message);\n  }\n  getTransport() {\n    return this.transport;\n  }\n  getPendingMessages() {\n    return this.messageQueue.copyAll();\n  }\n  clearPendingMessages() {\n    return this.messageQueue.clear();\n  }\n  finish() {\n    const transport = this.transport;\n    this.onceIdle(function() {\n      transport.disconnect();\n    });\n  }\n};\nvar protocol_default = Protocol;\n\n// src/common/lib/client/connectionstatechange.ts\nvar ConnectionStateChange = class {\n  constructor(previous, current, retryIn, reason) {\n    this.previous = previous;\n    this.current = current;\n    if (retryIn)\n      this.retryIn = retryIn;\n    if (reason)\n      this.reason = reason;\n  }\n};\nvar connectionstatechange_default = ConnectionStateChange;\n\n// src/common/lib/transport/connectionerrors.ts\nvar ConnectionErrorCodes = {\n  DISCONNECTED: 80003,\n  SUSPENDED: 80002,\n  FAILED: 8e4,\n  CLOSING: 80017,\n  CLOSED: 80017,\n  UNKNOWN_CONNECTION_ERR: 50002,\n  UNKNOWN_CHANNEL_ERR: 50001\n};\nvar ConnectionErrors = {\n  disconnected: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.DISCONNECTED,\n    message: \"Connection to server temporarily unavailable\"\n  }),\n  suspended: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.SUSPENDED,\n    message: \"Connection to server unavailable\"\n  }),\n  failed: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.FAILED,\n    message: \"Connection failed or disconnected by server\"\n  }),\n  closing: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.CLOSING,\n    message: \"Connection closing\"\n  }),\n  closed: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.CLOSED,\n    message: \"Connection closed\"\n  }),\n  unknownConnectionErr: () => ErrorInfo.fromValues({\n    statusCode: 500,\n    code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n    message: \"Internal connection error\"\n  }),\n  unknownChannelErr: () => ErrorInfo.fromValues({\n    statusCode: 500,\n    code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n    message: \"Internal channel error\"\n  })\n};\nfunction isRetriable(err) {\n  if (!err.statusCode || !err.code || err.statusCode >= 500) {\n    return true;\n  }\n  return Object.values(ConnectionErrorCodes).includes(err.code);\n}\nvar connectionerrors_default = ConnectionErrors;\n\n// src/common/lib/transport/transport.ts\nvar closeMessage = fromValues({ action: actions.CLOSE });\nvar disconnectMessage = fromValues({ action: actions.DISCONNECT });\nvar Transport = class extends eventemitter_default {\n  constructor(connectionManager, auth, params, forceJsonProtocol) {\n    super(connectionManager.logger);\n    if (forceJsonProtocol) {\n      params.format = void 0;\n      params.heartbeats = true;\n    }\n    this.connectionManager = connectionManager;\n    this.auth = auth;\n    this.params = params;\n    this.timeouts = params.options.timeouts;\n    this.format = params.format;\n    this.isConnected = false;\n    this.isFinished = false;\n    this.isDisposed = false;\n    this.maxIdleInterval = null;\n    this.idleTimer = null;\n    this.lastActivity = null;\n  }\n  connect() {\n  }\n  close() {\n    if (this.isConnected) {\n      this.requestClose();\n    }\n    this.finish(\"closed\", connectionerrors_default.closed());\n  }\n  disconnect(err) {\n    if (this.isConnected) {\n      this.requestDisconnect();\n    }\n    this.finish(\"disconnected\", err || connectionerrors_default.disconnected());\n  }\n  fail(err) {\n    if (this.isConnected) {\n      this.requestDisconnect();\n    }\n    this.finish(\"failed\", err || connectionerrors_default.failed());\n  }\n  finish(event, err) {\n    var _a2;\n    if (this.isFinished) {\n      return;\n    }\n    this.isFinished = true;\n    this.isConnected = false;\n    this.maxIdleInterval = null;\n    clearTimeout((_a2 = this.idleTimer) != null ? _a2 : void 0);\n    this.idleTimer = null;\n    this.emit(event, err);\n    this.dispose();\n  }\n  onProtocolMessage(message) {\n    if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n      logger_default.logActionNoStrip(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"Transport.onProtocolMessage()\",\n        \"received on \" + this.shortName + \": \" + stringify(\n          message,\n          this.connectionManager.realtime._RealtimePresence,\n          this.connectionManager.realtime._Annotations,\n          this.connectionManager.realtime._objectsPlugin\n        ) + \"; connectionId = \" + this.connectionManager.connectionId\n      );\n    }\n    this.onActivity();\n    switch (message.action) {\n      case actions.HEARTBEAT:\n        logger_default.logActionNoStrip(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"Transport.onProtocolMessage()\",\n          this.shortName + \" heartbeat; connectionId = \" + this.connectionManager.connectionId\n        );\n        this.emit(\"heartbeat\", message.id);\n        break;\n      case actions.CONNECTED:\n        this.onConnect(message);\n        this.emit(\"connected\", message.error, message.connectionId, message.connectionDetails, message);\n        break;\n      case actions.CLOSED:\n        this.onClose(message);\n        break;\n      case actions.DISCONNECTED:\n        this.onDisconnect(message);\n        break;\n      case actions.ACK:\n        this.emit(\"ack\", message.msgSerial, message.count);\n        break;\n      case actions.NACK:\n        this.emit(\"nack\", message.msgSerial, message.count, message.error);\n        break;\n      case actions.SYNC:\n        this.connectionManager.onChannelMessage(message, this);\n        break;\n      case actions.ACTIVATE:\n        break;\n      case actions.AUTH:\n        whenPromiseSettles(this.auth.authorize(), (err) => {\n          if (err) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_ERROR,\n              \"Transport.onProtocolMessage()\",\n              \"Ably requested re-authentication, but unable to obtain a new token: \" + inspectError(err)\n            );\n          }\n        });\n        break;\n      case actions.ERROR:\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"Transport.onProtocolMessage()\",\n          \"received error action; connectionId = \" + this.connectionManager.connectionId + \"; err = \" + Platform.Config.inspect(message.error) + (message.channel ? \", channel: \" + message.channel : \"\")\n        );\n        if (message.channel === void 0) {\n          this.onFatalError(message);\n          break;\n        }\n        this.connectionManager.onChannelMessage(message, this);\n        break;\n      default:\n        this.connectionManager.onChannelMessage(message, this);\n    }\n  }\n  onConnect(message) {\n    this.isConnected = true;\n    if (!message.connectionDetails) {\n      throw new Error(\"Transport.onConnect(): Connect message recieved without connectionDetails\");\n    }\n    const maxPromisedIdle = message.connectionDetails.maxIdleInterval;\n    if (maxPromisedIdle) {\n      this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;\n      this.onActivity();\n    }\n  }\n  onDisconnect(message) {\n    const err = message && message.error;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.onDisconnect()\", \"err = \" + inspectError(err));\n    this.finish(\"disconnected\", err);\n  }\n  onFatalError(message) {\n    const err = message && message.error;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.onFatalError()\", \"err = \" + inspectError(err));\n    this.finish(\"failed\", err);\n  }\n  onClose(message) {\n    const err = message && message.error;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.onClose()\", \"err = \" + inspectError(err));\n    this.finish(\"closed\", err);\n  }\n  requestClose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.requestClose()\", \"\");\n    this.send(closeMessage);\n  }\n  requestDisconnect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.requestDisconnect()\", \"\");\n    this.send(disconnectMessage);\n  }\n  ping(id) {\n    const msg = { action: actions.HEARTBEAT };\n    if (id)\n      msg.id = id;\n    this.send(fromValues(msg));\n  }\n  dispose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.dispose()\", \"\");\n    this.isDisposed = true;\n    this.off();\n  }\n  onActivity() {\n    if (!this.maxIdleInterval) {\n      return;\n    }\n    this.lastActivity = this.connectionManager.lastActivity = Date.now();\n    this.setIdleTimer(this.maxIdleInterval + 100);\n  }\n  setIdleTimer(timeout) {\n    if (!this.idleTimer) {\n      this.idleTimer = setTimeout(() => {\n        this.onIdleTimerExpire();\n      }, timeout);\n    }\n  }\n  onIdleTimerExpire() {\n    if (!this.lastActivity || !this.maxIdleInterval) {\n      throw new Error(\"Transport.onIdleTimerExpire(): lastActivity/maxIdleInterval not set\");\n    }\n    this.idleTimer = null;\n    const sinceLast = Date.now() - this.lastActivity;\n    const timeRemaining = this.maxIdleInterval - sinceLast;\n    if (timeRemaining <= 0) {\n      const msg = \"No activity seen from realtime in \" + sinceLast + \"ms; assuming connection has dropped\";\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Transport.onIdleTimerExpire()\", msg);\n      this.disconnect(new ErrorInfo(msg, 80003, 408));\n    } else {\n      this.setIdleTimer(timeRemaining + 100);\n    }\n  }\n  static tryConnect(transportCtor, connectionManager, auth, transportParams, callback) {\n    const transport = new transportCtor(connectionManager, auth, transportParams);\n    let transportAttemptTimer;\n    const errorCb = function(err) {\n      clearTimeout(transportAttemptTimer);\n      callback({ event: this.event, error: err });\n    };\n    const realtimeRequestTimeout = connectionManager.options.timeouts.realtimeRequestTimeout;\n    transportAttemptTimer = setTimeout(() => {\n      transport.off([\"preconnect\", \"disconnected\", \"failed\"]);\n      transport.dispose();\n      errorCb.call(\n        { event: \"disconnected\" },\n        new ErrorInfo(\"Timeout waiting for transport to indicate itself viable\", 5e4, 500)\n      );\n    }, realtimeRequestTimeout);\n    transport.on([\"failed\", \"disconnected\"], errorCb);\n    transport.on(\"preconnect\", function() {\n      logger_default.logAction(\n        connectionManager.logger,\n        logger_default.LOG_MINOR,\n        \"Transport.tryConnect()\",\n        \"viable transport \" + transport\n      );\n      clearTimeout(transportAttemptTimer);\n      transport.off([\"failed\", \"disconnected\"], errorCb);\n      callback(null, transport);\n    });\n    transport.connect();\n    return transport;\n  }\n  static isAvailable() {\n    throw new ErrorInfo(\"isAvailable not implemented for transport\", 5e4, 500);\n  }\n};\nvar transport_default = Transport;\n\n// src/common/constants/TransportName.ts\nvar TransportNames;\n((TransportNames2) => {\n  TransportNames2.WebSocket = \"web_socket\";\n  TransportNames2.Comet = \"comet\";\n  TransportNames2.XhrPolling = \"xhr_polling\";\n})(TransportNames || (TransportNames = {}));\n\n// src/common/lib/transport/connectionmanager.ts\nvar globalObject2 = typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof window !== \"undefined\" ? window : self;\nvar haveWebStorage = () => {\n  var _a2;\n  return typeof Platform.WebStorage !== \"undefined\" && ((_a2 = Platform.WebStorage) == null ? void 0 : _a2.localSupported);\n};\nvar haveSessionStorage = () => {\n  var _a2;\n  return typeof Platform.WebStorage !== \"undefined\" && ((_a2 = Platform.WebStorage) == null ? void 0 : _a2.sessionSupported);\n};\nvar noop2 = function() {\n};\nvar transportPreferenceName = \"ably-transport-preference\";\nfunction bundleWith(dest, src, maxSize) {\n  let action;\n  if (dest.channel !== src.channel) {\n    return false;\n  }\n  if ((action = dest.action) !== actions.PRESENCE && action !== actions.MESSAGE) {\n    return false;\n  }\n  if (action !== src.action) {\n    return false;\n  }\n  const kind = action === actions.PRESENCE ? \"presence\" : \"messages\", proposed = dest[kind].concat(src[kind]), size = getMessagesSize(proposed);\n  if (size > maxSize) {\n    return false;\n  }\n  if (!allSame(proposed, \"clientId\")) {\n    return false;\n  }\n  if (!proposed.every(function(msg) {\n    return !msg.id;\n  })) {\n    return false;\n  }\n  dest[kind] = proposed;\n  return true;\n}\nfunction decodeRecoveryKey(recoveryKey) {\n  try {\n    return JSON.parse(recoveryKey);\n  } catch (e) {\n    return null;\n  }\n}\nvar TransportParams = class {\n  constructor(options, host, mode, connectionKey) {\n    this.options = options;\n    this.host = host;\n    this.mode = mode;\n    this.connectionKey = connectionKey;\n    this.format = options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n  }\n  getConnectParams(authParams) {\n    const params = authParams ? copy(authParams) : {};\n    const options = this.options;\n    switch (this.mode) {\n      case \"resume\":\n        params.resume = this.connectionKey;\n        break;\n      case \"recover\": {\n        const recoveryContext = decodeRecoveryKey(options.recover);\n        if (recoveryContext) {\n          params.recover = recoveryContext.connectionKey;\n        }\n        break;\n      }\n      default:\n    }\n    if (options.clientId !== void 0) {\n      params.clientId = options.clientId;\n    }\n    if (options.echoMessages === false) {\n      params.echo = \"false\";\n    }\n    if (this.format !== void 0) {\n      params.format = this.format;\n    }\n    if (this.stream !== void 0) {\n      params.stream = this.stream;\n    }\n    if (this.heartbeats !== void 0) {\n      params.heartbeats = this.heartbeats;\n    }\n    params.v = defaults_default.protocolVersion;\n    params.agent = getAgentString(this.options);\n    if (options.transportParams !== void 0) {\n      mixin(params, options.transportParams);\n    }\n    return params;\n  }\n  toString() {\n    let result = \"[mode=\" + this.mode;\n    if (this.host) {\n      result += \",host=\" + this.host;\n    }\n    if (this.connectionKey) {\n      result += \",connectionKey=\" + this.connectionKey;\n    }\n    if (this.format) {\n      result += \",format=\" + this.format;\n    }\n    result += \"]\";\n    return result;\n  }\n};\nvar ConnectionManager = class _ConnectionManager extends eventemitter_default {\n  constructor(realtime, options) {\n    super(realtime.logger);\n    this.supportedTransports = {};\n    this.disconnectedRetryCount = 0;\n    this.pendingChannelMessagesState = { isProcessing: false, queue: [] };\n    this.realtime = realtime;\n    this.initTransports();\n    this.options = options;\n    const timeouts = options.timeouts;\n    const connectingTimeout = timeouts.webSocketConnectTimeout + timeouts.realtimeRequestTimeout;\n    this.states = {\n      initialized: {\n        state: \"initialized\",\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        failState: \"disconnected\"\n      },\n      connecting: {\n        state: \"connecting\",\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        retryDelay: connectingTimeout,\n        failState: \"disconnected\"\n      },\n      connected: {\n        state: \"connected\",\n        terminal: false,\n        queueEvents: false,\n        sendEvents: true,\n        failState: \"disconnected\"\n      },\n      disconnected: {\n        state: \"disconnected\",\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        retryDelay: timeouts.disconnectedRetryTimeout,\n        failState: \"disconnected\"\n      },\n      suspended: {\n        state: \"suspended\",\n        terminal: false,\n        queueEvents: false,\n        sendEvents: false,\n        retryDelay: timeouts.suspendedRetryTimeout,\n        failState: \"suspended\"\n      },\n      closing: {\n        state: \"closing\",\n        terminal: false,\n        queueEvents: false,\n        sendEvents: false,\n        retryDelay: timeouts.realtimeRequestTimeout,\n        failState: \"closed\"\n      },\n      closed: { state: \"closed\", terminal: true, queueEvents: false, sendEvents: false, failState: \"closed\" },\n      failed: { state: \"failed\", terminal: true, queueEvents: false, sendEvents: false, failState: \"failed\" }\n    };\n    this.state = this.states.initialized;\n    this.errorReason = null;\n    this.queuedMessages = new messagequeue_default(this.logger);\n    this.msgSerial = 0;\n    this.connectionDetails = void 0;\n    this.connectionId = void 0;\n    this.connectionKey = void 0;\n    this.connectionStateTtl = timeouts.connectionStateTtl;\n    this.maxIdleInterval = null;\n    this.transports = intersect(options.transports || defaults_default.defaultTransports, this.supportedTransports);\n    this.transportPreference = null;\n    if (this.transports.includes(TransportNames.WebSocket)) {\n      this.webSocketTransportAvailable = true;\n    }\n    if (this.transports.includes(TransportNames.XhrPolling)) {\n      this.baseTransport = TransportNames.XhrPolling;\n    } else if (this.transports.includes(TransportNames.Comet)) {\n      this.baseTransport = TransportNames.Comet;\n    }\n    this.domains = defaults_default.getHosts(options);\n    this.activeProtocol = null;\n    this.host = null;\n    this.lastAutoReconnectAttempt = null;\n    this.lastActivity = null;\n    this.forceFallbackHost = false;\n    this.connectCounter = 0;\n    this.wsCheckResult = null;\n    this.webSocketSlowTimer = null;\n    this.webSocketGiveUpTimer = null;\n    this.abandonedWebSocket = false;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime.ConnectionManager()\", \"started\");\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"Realtime.ConnectionManager()\",\n      \"requested transports = [\" + (options.transports || defaults_default.defaultTransports) + \"]\"\n    );\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"Realtime.ConnectionManager()\",\n      \"available transports = [\" + this.transports + \"]\"\n    );\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"Realtime.ConnectionManager()\",\n      \"http domains = [\" + this.domains + \"]\"\n    );\n    if (!this.transports.length) {\n      const msg = \"no requested transports available\";\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"realtime.ConnectionManager()\", msg);\n      throw new Error(msg);\n    }\n    const addEventListener = Platform.Config.addEventListener;\n    if (addEventListener) {\n      if (haveSessionStorage() && typeof options.recover === \"function\") {\n        addEventListener(\"beforeunload\", this.persistConnection.bind(this));\n      }\n      if (options.closeOnUnload === true) {\n        addEventListener(\"beforeunload\", () => {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"Realtime.ConnectionManager()\",\n            \"beforeunload event has triggered the connection to close as closeOnUnload is true\"\n          );\n          this.requestState({ state: \"closing\" });\n        });\n      }\n      addEventListener(\"online\", () => {\n        var _a2;\n        if (this.state == this.states.disconnected || this.state == this.states.suspended) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager caught browser \\u2018online\\u2019 event\",\n            \"reattempting connection\"\n          );\n          this.requestState({ state: \"connecting\" });\n        } else if (this.state == this.states.connecting) {\n          (_a2 = this.pendingTransport) == null ? void 0 : _a2.off();\n          this.disconnectAllTransports();\n          this.startConnect();\n        }\n      });\n      addEventListener(\"offline\", () => {\n        if (this.state == this.states.connected) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager caught browser \\u2018offline\\u2019 event\",\n            \"disconnecting active transport\"\n          );\n          this.disconnectAllTransports();\n        }\n      });\n    }\n  }\n  /*********************\n   * transport management\n   *********************/\n  // Used by tests\n  static supportedTransports(additionalImplementations) {\n    const storage = { supportedTransports: {} };\n    this.initTransports(additionalImplementations, storage);\n    return storage.supportedTransports;\n  }\n  static initTransports(additionalImplementations, storage) {\n    const implementations = __spreadValues(__spreadValues({}, Platform.Transports.bundledImplementations), additionalImplementations);\n    [TransportNames.WebSocket, ...Platform.Transports.order].forEach((transportName) => {\n      const transport = implementations[transportName];\n      if (transport && transport.isAvailable()) {\n        storage.supportedTransports[transportName] = transport;\n      }\n    });\n  }\n  initTransports() {\n    _ConnectionManager.initTransports(this.realtime._additionalTransportImplementations, this);\n  }\n  createTransportParams(host, mode) {\n    return new TransportParams(this.options, host, mode, this.connectionKey);\n  }\n  getTransportParams(callback) {\n    const decideMode = (modeCb) => {\n      if (this.connectionKey) {\n        modeCb(\"resume\");\n        return;\n      }\n      if (typeof this.options.recover === \"string\") {\n        modeCb(\"recover\");\n        return;\n      }\n      const recoverFn = this.options.recover, lastSessionData = this.getSessionRecoverData(), sessionRecoveryName = this.sessionRecoveryName();\n      if (lastSessionData && typeof recoverFn === \"function\") {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager.getTransportParams()\",\n          \"Calling clientOptions-provided recover function with last session data (recovery scope: \" + sessionRecoveryName + \")\"\n        );\n        recoverFn(lastSessionData, (shouldRecover) => {\n          if (shouldRecover) {\n            this.options.recover = lastSessionData.recoveryKey;\n            modeCb(\"recover\");\n          } else {\n            modeCb(\"clean\");\n          }\n        });\n        return;\n      }\n      modeCb(\"clean\");\n    };\n    decideMode((mode) => {\n      const transportParams = this.createTransportParams(null, mode);\n      if (mode === \"recover\") {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager.getTransportParams()\",\n          \"Transport recovery mode = recover; recoveryKey = \" + this.options.recover\n        );\n        const recoveryContext = decodeRecoveryKey(this.options.recover);\n        if (recoveryContext) {\n          this.msgSerial = recoveryContext.msgSerial;\n        }\n      } else {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager.getTransportParams()\",\n          \"Transport params = \" + transportParams.toString()\n        );\n      }\n      callback(transportParams);\n    });\n  }\n  /**\n   * Attempt to connect using a given transport\n   * @param transportParams\n   * @param candidate, the transport to try\n   * @param callback\n   */\n  tryATransport(transportParams, candidate, callback) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.tryATransport()\", \"trying \" + candidate);\n    this.proposedTransport = transport_default.tryConnect(\n      this.supportedTransports[candidate],\n      this,\n      this.realtime.auth,\n      transportParams,\n      (wrappedErr, transport) => {\n        const state = this.state;\n        if (state == this.states.closing || state == this.states.closed || state == this.states.failed) {\n          if (transport) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MINOR,\n              \"ConnectionManager.tryATransport()\",\n              \"connection \" + state.state + \" while we were attempting the transport; closing \" + transport\n            );\n            transport.close();\n          }\n          callback(true);\n          return;\n        }\n        if (wrappedErr) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager.tryATransport()\",\n            \"transport \" + candidate + \" \" + wrappedErr.event + \", err: \" + wrappedErr.error.toString()\n          );\n          if (auth_default.isTokenErr(wrappedErr.error) && !(this.errorReason && auth_default.isTokenErr(this.errorReason))) {\n            this.errorReason = wrappedErr.error;\n            whenPromiseSettles(this.realtime.auth._forceNewToken(null, null), (err) => {\n              if (err) {\n                this.actOnErrorFromAuthorize(err);\n                return;\n              }\n              this.tryATransport(transportParams, candidate, callback);\n            });\n          } else if (wrappedErr.event === \"failed\") {\n            this.notifyState({ state: \"failed\", error: wrappedErr.error });\n            callback(true);\n          } else if (wrappedErr.event === \"disconnected\") {\n            if (!isRetriable(wrappedErr.error)) {\n              this.notifyState({ state: this.states.connecting.failState, error: wrappedErr.error });\n              callback(true);\n            } else {\n              callback(false);\n            }\n          }\n          return;\n        }\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.tryATransport()\",\n          \"viable transport \" + candidate + \"; setting pending\"\n        );\n        this.setTransportPending(transport, transportParams);\n        callback(null, transport);\n      }\n    );\n  }\n  /**\n   * Called when a transport is indicated to be viable, and the ConnectionManager\n   * expects to activate this transport as soon as it is connected.\n   * @param transport\n   * @param transportParams\n   */\n  setTransportPending(transport, transportParams) {\n    const mode = transportParams.mode;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.setTransportPending()\",\n      \"transport = \" + transport + \"; mode = \" + mode\n    );\n    this.pendingTransport = transport;\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    transport.once(\"connected\", (error, connectionId, connectionDetails) => {\n      this.activateTransport(error, transport, connectionId, connectionDetails);\n      if (mode === \"recover\" && this.options.recover) {\n        delete this.options.recover;\n        this.unpersistConnection();\n      }\n    });\n    const self2 = this;\n    transport.on([\"disconnected\", \"closed\", \"failed\"], function(error) {\n      self2.deactivateTransport(transport, this.event, error);\n    });\n    this.emit(\"transport.pending\", transport);\n  }\n  /**\n   * Called when a transport is connected, and the connectionmanager decides that\n   * it will now be the active transport. Returns whether or not it activated\n   * the transport (if the connection is closing/closed it will choose not to).\n   * @param transport the transport instance\n   * @param connectionId the id of the new active connection\n   * @param connectionDetails the details of the new active connection\n   */\n  activateTransport(error, transport, connectionId, connectionDetails) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.activateTransport()\",\n      \"transport = \" + transport\n    );\n    if (error) {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.activateTransport()\", \"error = \" + error);\n    }\n    if (connectionId) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.activateTransport()\",\n        \"connectionId =  \" + connectionId\n      );\n    }\n    if (connectionDetails) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.activateTransport()\",\n        \"connectionDetails =  \" + JSON.stringify(connectionDetails)\n      );\n    }\n    this.persistTransportPreference(transport);\n    const existingState = this.state, connectedState = this.states.connected.state;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.activateTransport()\",\n      \"current state = \" + existingState.state\n    );\n    if (existingState.state == this.states.closing.state || existingState.state == this.states.closed.state || existingState.state == this.states.failed.state) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.activateTransport()\",\n        \"Disconnecting transport and abandoning\"\n      );\n      transport.disconnect();\n      return false;\n    }\n    delete this.pendingTransport;\n    if (!transport.isConnected) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.activateTransport()\",\n        \"Declining to activate transport \" + transport + \" since it appears to no longer be connected\"\n      );\n      return false;\n    }\n    const existingActiveProtocol = this.activeProtocol;\n    this.activeProtocol = new protocol_default(transport);\n    this.host = transport.params.host;\n    const connectionKey = connectionDetails.connectionKey;\n    if (connectionKey && this.connectionKey != connectionKey) {\n      this.setConnection(connectionId, connectionDetails, !!error);\n    }\n    this.onConnectionDetailsUpdate(connectionDetails, transport);\n    Platform.Config.nextTick(() => {\n      transport.on(\n        \"connected\",\n        (connectedErr, _connectionId, connectionDetails2) => {\n          this.onConnectionDetailsUpdate(connectionDetails2, transport);\n          this.emit(\"update\", new connectionstatechange_default(connectedState, connectedState, null, connectedErr));\n        }\n      );\n    });\n    if (existingState.state === this.states.connected.state) {\n      if (error) {\n        this.errorReason = this.realtime.connection.errorReason = error;\n        this.emit(\"update\", new connectionstatechange_default(connectedState, connectedState, null, error));\n      }\n    } else {\n      this.notifyState({ state: \"connected\", error });\n      this.errorReason = this.realtime.connection.errorReason = error || null;\n    }\n    this.emit(\"transport.active\", transport);\n    if (existingActiveProtocol) {\n      if (existingActiveProtocol.messageQueue.count() > 0) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"ConnectionManager.activateTransport()\",\n          \"Previous active protocol (for transport \" + existingActiveProtocol.transport.shortName + \", new one is \" + transport.shortName + \") finishing with \" + existingActiveProtocol.messageQueue.count() + \" messages still pending\"\n        );\n      }\n      if (existingActiveProtocol.transport === transport) {\n        const msg = \"Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = \" + transport.shortName + \"; stack = \" + new Error().stack;\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.activateTransport()\", msg);\n      } else {\n        existingActiveProtocol.finish();\n      }\n    }\n    return true;\n  }\n  /**\n   * Called when a transport is no longer the active transport. This can occur\n   * in any transport connection state.\n   * @param transport\n   */\n  deactivateTransport(transport, state, error) {\n    const currentProtocol = this.activeProtocol, wasActive = currentProtocol && currentProtocol.getTransport() === transport, wasPending = transport === this.pendingTransport, noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.deactivateTransport()\",\n      \"transport = \" + transport\n    );\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.deactivateTransport()\",\n      \"state = \" + state + (wasActive ? \"; was active\" : wasPending ? \"; was pending\" : \"\") + (noTransportsScheduledForActivation ? \"\" : \"; another transport is scheduled for activation\")\n    );\n    if (error && error.message)\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.deactivateTransport()\",\n        \"reason =  \" + error.message\n      );\n    if (wasActive) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.deactivateTransport()\",\n        \"Getting, clearing, and requeuing \" + this.activeProtocol.messageQueue.count() + \" pending messages\"\n      );\n      this.queuePendingMessages(currentProtocol.getPendingMessages());\n      currentProtocol.clearPendingMessages();\n      this.activeProtocol = this.host = null;\n    }\n    this.emit(\"transport.inactive\", transport);\n    if (wasActive && noTransportsScheduledForActivation || wasActive && state === \"failed\" || state === \"closed\" || currentProtocol === null && wasPending) {\n      if (state === \"disconnected\" && error && error.statusCode > 500 && this.domains.length > 1) {\n        this.unpersistTransportPreference();\n        this.forceFallbackHost = true;\n        this.notifyState({ state, error, retryImmediately: true });\n        return;\n      }\n      const newConnectionState = state === \"failed\" && auth_default.isTokenErr(error) ? \"disconnected\" : state;\n      this.notifyState({ state: newConnectionState, error });\n      return;\n    }\n  }\n  /* Helper that returns true if there are no transports which are pending,\n   * have been connected, and are just waiting for onceNoPending to fire before\n   * being activated */\n  noTransportsScheduledForActivation() {\n    return !this.pendingTransport || !this.pendingTransport.isConnected;\n  }\n  setConnection(connectionId, connectionDetails, hasConnectionError) {\n    const prevConnId = this.connectionId, connIdChanged = prevConnId && prevConnId !== connectionId, recoverFailure = !prevConnId && hasConnectionError;\n    if (connIdChanged || recoverFailure) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.setConnection()\", \"Resetting msgSerial\");\n      this.msgSerial = 0;\n      this.queuedMessages.resetSendAttempted();\n    }\n    if (this.connectionId !== connectionId) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.setConnection()\",\n        \"New connectionId; reattaching any attached channels\"\n      );\n    }\n    this.realtime.connection.id = this.connectionId = connectionId;\n    this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;\n  }\n  clearConnection() {\n    this.realtime.connection.id = this.connectionId = void 0;\n    this.realtime.connection.key = this.connectionKey = void 0;\n    this.msgSerial = 0;\n    this.unpersistConnection();\n  }\n  createRecoveryKey() {\n    if (!this.connectionKey) {\n      return null;\n    }\n    return JSON.stringify({\n      connectionKey: this.connectionKey,\n      msgSerial: this.msgSerial,\n      channelSerials: this.realtime.channels.channelSerials()\n    });\n  }\n  checkConnectionStateFreshness() {\n    if (!this.lastActivity || !this.connectionId) {\n      return;\n    }\n    const sinceLast = Date.now() - this.lastActivity;\n    if (sinceLast > this.connectionStateTtl + this.maxIdleInterval) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.checkConnectionStateFreshness()\",\n        \"Last known activity from realtime was \" + sinceLast + \"ms ago; discarding connection state\"\n      );\n      this.clearConnection();\n      this.states.connecting.failState = \"suspended\";\n    }\n  }\n  /**\n   * Called when the connectionmanager wants to persist transport\n   * state for later recovery. Only applicable in the browser context.\n   */\n  persistConnection() {\n    if (haveSessionStorage()) {\n      const recoveryKey = this.createRecoveryKey();\n      if (recoveryKey) {\n        this.setSessionRecoverData({\n          recoveryKey,\n          disconnectedAt: Date.now(),\n          location: globalObject2.location,\n          clientId: this.realtime.auth.clientId\n        });\n      }\n    }\n  }\n  /**\n   * Called when the connectionmanager wants to persist transport\n   * state for later recovery. Only applicable in the browser context.\n   */\n  unpersistConnection() {\n    this.clearSessionRecoverData();\n  }\n  getActiveTransportFormat() {\n    var _a2;\n    return (_a2 = this.activeProtocol) == null ? void 0 : _a2.getTransport().format;\n  }\n  /*********************\n   * state management\n   *********************/\n  getError() {\n    if (this.errorReason) {\n      const newError = PartialErrorInfo.fromValues(this.errorReason);\n      newError.cause = this.errorReason;\n      return newError;\n    }\n    return this.getStateError();\n  }\n  getStateError() {\n    var _a2, _b;\n    return (_b = (_a2 = connectionerrors_default)[this.state.state]) == null ? void 0 : _b.call(_a2);\n  }\n  activeState() {\n    return this.state.queueEvents || this.state.sendEvents;\n  }\n  enactStateChange(stateChange) {\n    const action = \"Connection state\";\n    const message = stateChange.current + (stateChange.reason ? \"; reason: \" + stateChange.reason : \"\");\n    if (stateChange.current === \"failed\") {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, action, message);\n    } else {\n      logger_default.logAction(this.logger, logger_default.LOG_MAJOR, action, message);\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.enactStateChange\",\n      \"setting new state: \" + stateChange.current + \"; reason = \" + (stateChange.reason && stateChange.reason.message)\n    );\n    const newState = this.state = this.states[stateChange.current];\n    if (stateChange.reason) {\n      this.errorReason = stateChange.reason;\n      this.realtime.connection.errorReason = stateChange.reason;\n    }\n    if (newState.terminal || newState.state === \"suspended\") {\n      this.clearConnection();\n    }\n    this.emit(\"connectionstate\", stateChange);\n  }\n  /****************************************\n   * ConnectionManager connection lifecycle\n   ****************************************/\n  startTransitionTimer(transitionState) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.startTransitionTimer()\",\n      \"transitionState: \" + transitionState.state\n    );\n    if (this.transitionTimer) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.startTransitionTimer()\",\n        \"clearing already-running timer\"\n      );\n      clearTimeout(this.transitionTimer);\n    }\n    this.transitionTimer = setTimeout(() => {\n      if (this.transitionTimer) {\n        this.transitionTimer = null;\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager \" + transitionState.state + \" timer expired\",\n          \"requesting new state: \" + transitionState.failState\n        );\n        this.notifyState({ state: transitionState.failState });\n      }\n    }, transitionState.retryDelay);\n  }\n  cancelTransitionTimer() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.cancelTransitionTimer()\", \"\");\n    if (this.transitionTimer) {\n      clearTimeout(this.transitionTimer);\n      this.transitionTimer = null;\n    }\n  }\n  startSuspendTimer() {\n    if (this.suspendTimer)\n      return;\n    this.suspendTimer = setTimeout(() => {\n      if (this.suspendTimer) {\n        this.suspendTimer = null;\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager suspend timer expired\",\n          \"requesting new state: suspended\"\n        );\n        this.states.connecting.failState = \"suspended\";\n        this.notifyState({ state: \"suspended\" });\n      }\n    }, this.connectionStateTtl);\n  }\n  checkSuspendTimer(state) {\n    if (state !== \"disconnected\" && state !== \"suspended\" && state !== \"connecting\")\n      this.cancelSuspendTimer();\n  }\n  cancelSuspendTimer() {\n    this.states.connecting.failState = \"disconnected\";\n    if (this.suspendTimer) {\n      clearTimeout(this.suspendTimer);\n      this.suspendTimer = null;\n    }\n  }\n  startRetryTimer(interval) {\n    this.retryTimer = setTimeout(() => {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager retry timer expired\", \"retrying\");\n      this.retryTimer = null;\n      this.requestState({ state: \"connecting\" });\n    }, interval);\n  }\n  cancelRetryTimer() {\n    if (this.retryTimer) {\n      clearTimeout(this.retryTimer);\n      this.retryTimer = null;\n    }\n  }\n  startWebSocketSlowTimer() {\n    this.webSocketSlowTimer = setTimeout(() => {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager WebSocket slow timer\",\n        \"checking connectivity\"\n      );\n      this.checkWsConnectivity().then(() => {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager WebSocket slow timer\",\n          \"ws connectivity check succeeded\"\n        );\n        this.wsCheckResult = true;\n      }).catch(() => {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MAJOR,\n          \"ConnectionManager WebSocket slow timer\",\n          \"ws connectivity check failed\"\n        );\n        this.wsCheckResult = false;\n      });\n      if (this.realtime.http.checkConnectivity) {\n        whenPromiseSettles(this.realtime.http.checkConnectivity(), (err, connectivity) => {\n          if (err || !connectivity) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MAJOR,\n              \"ConnectionManager WebSocket slow timer\",\n              \"http connectivity check failed\"\n            );\n            this.cancelWebSocketGiveUpTimer();\n            this.notifyState({\n              state: \"disconnected\",\n              error: new ErrorInfo(\"Unable to connect (network unreachable)\", 80003, 404)\n            });\n          } else {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MINOR,\n              \"ConnectionManager WebSocket slow timer\",\n              \"http connectivity check succeeded\"\n            );\n          }\n        });\n      }\n    }, this.options.timeouts.webSocketSlowTimeout);\n  }\n  cancelWebSocketSlowTimer() {\n    if (this.webSocketSlowTimer) {\n      clearTimeout(this.webSocketSlowTimer);\n      this.webSocketSlowTimer = null;\n    }\n  }\n  startWebSocketGiveUpTimer(transportParams) {\n    this.webSocketGiveUpTimer = setTimeout(() => {\n      var _a2, _b;\n      if (!this.wsCheckResult) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager WebSocket give up timer\",\n          \"websocket connection took more than 10s; \" + (this.baseTransport ? \"trying base transport\" : \"\")\n        );\n        if (this.baseTransport) {\n          this.abandonedWebSocket = true;\n          (_a2 = this.proposedTransport) == null ? void 0 : _a2.dispose();\n          (_b = this.pendingTransport) == null ? void 0 : _b.dispose();\n          this.connectBase(transportParams, ++this.connectCounter);\n        } else {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"ConnectionManager WebSocket give up timer\",\n            \"websocket connectivity appears to be unavailable but no other transports to try\"\n          );\n        }\n      }\n    }, this.options.timeouts.webSocketConnectTimeout);\n  }\n  cancelWebSocketGiveUpTimer() {\n    if (this.webSocketGiveUpTimer) {\n      clearTimeout(this.webSocketGiveUpTimer);\n      this.webSocketGiveUpTimer = null;\n    }\n  }\n  notifyState(indicated) {\n    var _a2, _b;\n    const state = indicated.state;\n    const retryImmediately = state === \"disconnected\" && (this.state === this.states.connected || indicated.retryImmediately || this.state === this.states.connecting && indicated.error && auth_default.isTokenErr(indicated.error) && !(this.errorReason && auth_default.isTokenErr(this.errorReason)));\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.notifyState()\",\n      \"new state: \" + state + (retryImmediately ? \"; will retry connection immediately\" : \"\")\n    );\n    if (state == this.state.state)\n      return;\n    this.cancelTransitionTimer();\n    this.cancelRetryTimer();\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    this.checkSuspendTimer(indicated.state);\n    if (state === \"suspended\" || state === \"connected\") {\n      this.disconnectedRetryCount = 0;\n    }\n    if (this.state.terminal)\n      return;\n    const newState = this.states[indicated.state];\n    let retryDelay = newState.retryDelay;\n    if (newState.state === \"disconnected\") {\n      this.disconnectedRetryCount++;\n      retryDelay = getRetryTime(newState.retryDelay, this.disconnectedRetryCount);\n    }\n    const change = new connectionstatechange_default(\n      this.state.state,\n      newState.state,\n      retryDelay,\n      indicated.error || ((_b = (_a2 = connectionerrors_default)[newState.state]) == null ? void 0 : _b.call(_a2))\n    );\n    if (retryImmediately) {\n      const autoReconnect = () => {\n        if (this.state === this.states.disconnected) {\n          this.lastAutoReconnectAttempt = Date.now();\n          this.requestState({ state: \"connecting\" });\n        }\n      };\n      const sinceLast = this.lastAutoReconnectAttempt && Date.now() - this.lastAutoReconnectAttempt + 1;\n      if (sinceLast && sinceLast < 1e3) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.notifyState()\",\n          \"Last reconnect attempt was only \" + sinceLast + \"ms ago, waiting another \" + (1e3 - sinceLast) + \"ms before trying again\"\n        );\n        setTimeout(autoReconnect, 1e3 - sinceLast);\n      } else {\n        Platform.Config.nextTick(autoReconnect);\n      }\n    } else if (state === \"disconnected\" || state === \"suspended\") {\n      this.startRetryTimer(retryDelay);\n    }\n    if (state === \"disconnected\" && !retryImmediately || state === \"suspended\" || newState.terminal) {\n      Platform.Config.nextTick(() => {\n        this.disconnectAllTransports();\n      });\n    }\n    if (state == \"connected\" && !this.activeProtocol) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"ConnectionManager.notifyState()\",\n        \"Broken invariant: attempted to go into connected state, but there is no active protocol\"\n      );\n    }\n    this.enactStateChange(change);\n    if (this.state.sendEvents) {\n      this.sendQueuedMessages();\n    } else if (!this.state.queueEvents) {\n      this.realtime.channels.propogateConnectionInterruption(state, change.reason);\n      this.failQueuedMessages(change.reason);\n    }\n  }\n  requestState(request) {\n    var _a2, _b;\n    const state = request.state;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.requestState()\",\n      \"requested state: \" + state + \"; current state: \" + this.state.state\n    );\n    if (state == this.state.state)\n      return;\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    this.cancelTransitionTimer();\n    this.cancelRetryTimer();\n    this.checkSuspendTimer(state);\n    if (state == \"connecting\" && this.state.state == \"connected\")\n      return;\n    if (state == \"closing\" && this.state.state == \"closed\")\n      return;\n    const newState = this.states[state], change = new connectionstatechange_default(\n      this.state.state,\n      newState.state,\n      null,\n      request.error || ((_b = (_a2 = connectionerrors_default)[newState.state]) == null ? void 0 : _b.call(_a2))\n    );\n    this.enactStateChange(change);\n    if (state == \"connecting\") {\n      Platform.Config.nextTick(() => {\n        this.startConnect();\n      });\n    }\n    if (state == \"closing\") {\n      this.closeImpl();\n    }\n  }\n  startConnect() {\n    if (this.state !== this.states.connecting) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.startConnect()\",\n        \"Must be in connecting state to connect, but was \" + this.state.state\n      );\n      return;\n    }\n    const auth = this.realtime.auth;\n    const connectCount = ++this.connectCounter;\n    const connect = () => {\n      this.checkConnectionStateFreshness();\n      this.getTransportParams((transportParams) => {\n        if (transportParams.mode === \"recover\" && transportParams.options.recover) {\n          const recoveryContext = decodeRecoveryKey(transportParams.options.recover);\n          if (recoveryContext) {\n            this.realtime.channels.recoverChannels(recoveryContext.channelSerials);\n          }\n        }\n        if (connectCount !== this.connectCounter) {\n          return;\n        }\n        this.connectImpl(transportParams, connectCount);\n      });\n    };\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.startConnect()\", \"starting connection\");\n    this.startSuspendTimer();\n    this.startTransitionTimer(this.states.connecting);\n    if (auth.method === \"basic\") {\n      connect();\n    } else {\n      const authCb = (err) => {\n        if (connectCount !== this.connectCounter) {\n          return;\n        }\n        if (err) {\n          this.actOnErrorFromAuthorize(err);\n        } else {\n          connect();\n        }\n      };\n      if (this.errorReason && auth_default.isTokenErr(this.errorReason)) {\n        whenPromiseSettles(auth._forceNewToken(null, null), authCb);\n      } else {\n        whenPromiseSettles(auth._ensureValidAuthCredentials(false), authCb);\n      }\n    }\n  }\n  /*\n   * there are, at most, two transports available with which a connection may\n   * be attempted: web_socket and/or a base transport (xhr_polling in browsers,\n   * comet in nodejs). web_socket is always preferred, and the base transport is\n   * only used in case web_socket connectivity appears to be unavailable.\n   *\n   * connectImpl begins the transport selection process by checking which transports\n   * are available, and if there is a cached preference. It then defers to the\n   * transport-specific connect methods: connectWs and connectBase.\n   *\n   * It is also responsible for invalidating the cache in the case that a base\n   * transport preference is stored but web socket connectivity is now available.\n   *\n   * handling of the case where we need to failover from web_socket to the base\n   * transport is implemented in the connectWs method.\n   */\n  connectImpl(transportParams, connectCount) {\n    const state = this.state.state;\n    if (state !== this.states.connecting.state) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.connectImpl()\",\n        \"Must be in connecting state to connect, but was \" + state\n      );\n      return;\n    }\n    const transportPreference = this.getTransportPreference();\n    if (transportPreference && transportPreference === this.baseTransport && this.webSocketTransportAvailable) {\n      this.checkWsConnectivity().then(() => {\n        this.unpersistTransportPreference();\n        if (this.state === this.states.connecting) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager.connectImpl():\",\n            \"web socket connectivity available, cancelling connection attempt with \" + this.baseTransport\n          );\n          this.disconnectAllTransports();\n          this.connectWs(transportParams, ++this.connectCounter);\n        }\n      }).catch(noop2);\n    }\n    if (transportPreference && transportPreference === this.baseTransport || this.baseTransport && !this.webSocketTransportAvailable) {\n      this.connectBase(transportParams, connectCount);\n    } else {\n      this.connectWs(transportParams, connectCount);\n    }\n  }\n  /*\n   * connectWs starts two timers to monitor the success of a web_socket connection attempt:\n   * - webSocketSlowTimer: if this timer fires before the connection succeeds,\n   *   cm will simultaneously check websocket and http/xhr connectivity. if the http\n   *   connectivity check fails, we give up the connection sequence entirely and\n   *   transition to disconnected. if the websocket connectivity check fails then\n   *   we assume no ws connectivity and failover to base transport. in the case that\n   *   the checks succeed, we continue with websocket and wait for it to try fallback hosts\n   *   and, if unsuccessful, ultimately transition to disconnected.\n   * - webSocketGiveUpTimer: if this timer fires, and the preceding websocket\n   *   connectivity check is still pending then we assume that there is an issue\n   *   with the transport and fallback to base transport.\n   */\n  connectWs(transportParams, connectCount) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.connectWs()\");\n    this.wsCheckResult = null;\n    this.abandonedWebSocket = false;\n    this.startWebSocketSlowTimer();\n    this.startWebSocketGiveUpTimer(transportParams);\n    this.tryTransportWithFallbacks(\"web_socket\", transportParams, true, connectCount, () => {\n      return this.wsCheckResult !== false && !this.abandonedWebSocket;\n    });\n  }\n  connectBase(transportParams, connectCount) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.connectBase()\");\n    if (this.baseTransport) {\n      this.tryTransportWithFallbacks(this.baseTransport, transportParams, false, connectCount, () => true);\n    } else {\n      this.notifyState({\n        state: \"disconnected\",\n        error: new ErrorInfo(\"No transports left to try\", 8e4, 404)\n      });\n    }\n  }\n  tryTransportWithFallbacks(transportName, transportParams, ws, connectCount, shouldContinue) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"ConnectionManager.tryTransportWithFallbacks()\",\n      transportName\n    );\n    const giveUp = (err) => {\n      this.notifyState({ state: this.states.connecting.failState, error: err });\n    };\n    const candidateHosts = this.domains.slice();\n    const hostAttemptCb = (fatal, transport) => {\n      if (connectCount !== this.connectCounter) {\n        return;\n      }\n      if (!shouldContinue()) {\n        if (transport) {\n          transport.dispose();\n        }\n        return;\n      }\n      if (!transport && !fatal) {\n        tryFallbackHosts();\n      }\n    };\n    const host = candidateHosts.shift();\n    if (!host) {\n      giveUp(new ErrorInfo(\"Unable to connect (no available host)\", 80003, 404));\n      return;\n    }\n    transportParams.host = host;\n    const tryFallbackHosts = () => {\n      if (!candidateHosts.length) {\n        giveUp(new ErrorInfo(\"Unable to connect (and no more fallback hosts to try)\", 80003, 404));\n        return;\n      }\n      if (!this.realtime.http.checkConnectivity) {\n        giveUp(new PartialErrorInfo(\"Internal error: Http.checkConnectivity not set\", null, 500));\n        return;\n      }\n      whenPromiseSettles(\n        this.realtime.http.checkConnectivity(),\n        (err, connectivity) => {\n          if (connectCount !== this.connectCounter) {\n            return;\n          }\n          if (!shouldContinue()) {\n            return;\n          }\n          if (err) {\n            giveUp(err);\n            return;\n          }\n          if (!connectivity) {\n            giveUp(new ErrorInfo(\"Unable to connect (network unreachable)\", 80003, 404));\n            return;\n          }\n          transportParams.host = arrPopRandomElement(candidateHosts);\n          this.tryATransport(transportParams, transportName, hostAttemptCb);\n        }\n      );\n    };\n    if (this.forceFallbackHost && candidateHosts.length) {\n      this.forceFallbackHost = false;\n      tryFallbackHosts();\n      return;\n    }\n    this.tryATransport(transportParams, transportName, hostAttemptCb);\n  }\n  closeImpl() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.closeImpl()\", \"closing connection\");\n    this.cancelSuspendTimer();\n    this.startTransitionTimer(this.states.closing);\n    if (this.pendingTransport) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.closeImpl()\",\n        \"Closing pending transport: \" + this.pendingTransport\n      );\n      this.pendingTransport.close();\n    }\n    if (this.activeProtocol) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.closeImpl()\",\n        \"Closing active transport: \" + this.activeProtocol.getTransport()\n      );\n      this.activeProtocol.getTransport().close();\n    }\n    this.notifyState({ state: \"closed\" });\n  }\n  onAuthUpdated(tokenDetails, callback) {\n    var _a2;\n    switch (this.state.state) {\n      case \"connected\": {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.onAuthUpdated()\",\n          \"Sending AUTH message on active transport\"\n        );\n        const activeTransport = (_a2 = this.activeProtocol) == null ? void 0 : _a2.getTransport();\n        if (activeTransport && activeTransport.onAuthUpdated) {\n          activeTransport.onAuthUpdated(tokenDetails);\n        }\n        const authMsg = fromValues({\n          action: actions.AUTH,\n          auth: {\n            accessToken: tokenDetails.token\n          }\n        });\n        this.send(authMsg);\n        const successListener = () => {\n          this.off(failureListener);\n          callback(null, tokenDetails);\n        };\n        const failureListener = (stateChange) => {\n          if (stateChange.current === \"failed\") {\n            this.off(successListener);\n            this.off(failureListener);\n            callback(stateChange.reason || this.getStateError());\n          }\n        };\n        this.once(\"connectiondetails\", successListener);\n        this.on(\"connectionstate\", failureListener);\n        break;\n      }\n      case \"connecting\":\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.onAuthUpdated()\",\n          \"Aborting current connection attempts in order to start again with the new auth details\"\n        );\n        this.disconnectAllTransports();\n      default: {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.onAuthUpdated()\",\n          \"Connection state is \" + this.state.state + \"; waiting until either connected or failed\"\n        );\n        const listener = (stateChange) => {\n          switch (stateChange.current) {\n            case \"connected\":\n              this.off(listener);\n              callback(null, tokenDetails);\n              break;\n            case \"failed\":\n            case \"closed\":\n            case \"suspended\":\n              this.off(listener);\n              callback(stateChange.reason || this.getStateError());\n              break;\n            default:\n              break;\n          }\n        };\n        this.on(\"connectionstate\", listener);\n        if (this.state.state === \"connecting\") {\n          this.startConnect();\n        } else {\n          this.requestState({ state: \"connecting\" });\n        }\n      }\n    }\n  }\n  disconnectAllTransports() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.disconnectAllTransports()\",\n      \"Disconnecting all transports\"\n    );\n    this.connectCounter++;\n    if (this.pendingTransport) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.disconnectAllTransports()\",\n        \"Disconnecting pending transport: \" + this.pendingTransport\n      );\n      this.pendingTransport.disconnect();\n    }\n    delete this.pendingTransport;\n    if (this.proposedTransport) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.disconnectAllTransports()\",\n        \"Disconnecting proposed transport: \" + this.pendingTransport\n      );\n      this.proposedTransport.disconnect();\n    }\n    delete this.pendingTransport;\n    if (this.activeProtocol) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.disconnectAllTransports()\",\n        \"Disconnecting active transport: \" + this.activeProtocol.getTransport()\n      );\n      this.activeProtocol.getTransport().disconnect();\n    }\n  }\n  /******************\n   * event queueing\n   ******************/\n  send(msg, queueEvent, callback) {\n    callback = callback || noop2;\n    const state = this.state;\n    if (state.sendEvents) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.send()\", \"sending event\");\n      this.sendImpl(new PendingMessage(msg, callback));\n      return;\n    }\n    const shouldQueue = queueEvent && state.queueEvents;\n    if (!shouldQueue) {\n      const err = \"rejecting event, queueEvent was \" + queueEvent + \", state was \" + state.state;\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.send()\", err);\n      callback(this.errorReason || new ErrorInfo(err, 9e4, 400));\n      return;\n    }\n    if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.send()\",\n        \"queueing msg; \" + stringify(\n          msg,\n          this.realtime._RealtimePresence,\n          this.realtime._Annotations,\n          this.realtime._objectsPlugin\n        )\n      );\n    }\n    this.queue(msg, callback);\n  }\n  sendImpl(pendingMessage) {\n    const msg = pendingMessage.message;\n    if (pendingMessage.ackRequired && !pendingMessage.sendAttempted) {\n      msg.msgSerial = this.msgSerial++;\n    }\n    try {\n      this.activeProtocol.send(pendingMessage);\n    } catch (e) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"ConnectionManager.sendImpl()\",\n        \"Unexpected exception in transport.send(): \" + e.stack\n      );\n    }\n  }\n  queue(msg, callback) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.queue()\", \"queueing event\");\n    const lastQueued = this.queuedMessages.last();\n    const maxSize = this.options.maxMessageSize;\n    if (lastQueued && !lastQueued.sendAttempted && bundleWith(lastQueued.message, msg, maxSize)) {\n      if (!lastQueued.merged) {\n        lastQueued.callback = multicaster_default.create(this.logger, [lastQueued.callback]);\n        lastQueued.merged = true;\n      }\n      lastQueued.callback.push(callback);\n    } else {\n      this.queuedMessages.push(new PendingMessage(msg, callback));\n    }\n  }\n  sendQueuedMessages() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"ConnectionManager.sendQueuedMessages()\",\n      \"sending \" + this.queuedMessages.count() + \" queued messages\"\n    );\n    let pendingMessage;\n    while (pendingMessage = this.queuedMessages.shift())\n      this.sendImpl(pendingMessage);\n  }\n  queuePendingMessages(pendingMessages) {\n    if (pendingMessages && pendingMessages.length) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.queuePendingMessages()\",\n        \"queueing \" + pendingMessages.length + \" pending messages\"\n      );\n      this.queuedMessages.prepend(pendingMessages);\n    }\n  }\n  failQueuedMessages(err) {\n    const numQueued = this.queuedMessages.count();\n    if (numQueued > 0) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"ConnectionManager.failQueuedMessages()\",\n        \"failing \" + numQueued + \" queued messages, err = \" + inspectError(err)\n      );\n      this.queuedMessages.completeAllMessages(err);\n    }\n  }\n  onChannelMessage(message, transport) {\n    this.pendingChannelMessagesState.queue.push({ message, transport });\n    if (!this.pendingChannelMessagesState.isProcessing) {\n      this.processNextPendingChannelMessage();\n    }\n  }\n  processNextPendingChannelMessage() {\n    if (this.pendingChannelMessagesState.queue.length > 0) {\n      this.pendingChannelMessagesState.isProcessing = true;\n      const pendingChannelMessage = this.pendingChannelMessagesState.queue.shift();\n      this.processChannelMessage(pendingChannelMessage.message).catch((err) => {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"ConnectionManager.processNextPendingChannelMessage() received error \",\n          err\n        );\n      }).finally(() => {\n        this.pendingChannelMessagesState.isProcessing = false;\n        this.processNextPendingChannelMessage();\n      });\n    }\n  }\n  async processChannelMessage(message) {\n    await this.realtime.channels.processChannelMessage(message);\n  }\n  async ping() {\n    var _a2;\n    if (this.state.state !== \"connected\") {\n      throw new ErrorInfo(\"Unable to ping service; not connected\", 4e4, 400);\n    }\n    const transport = (_a2 = this.activeProtocol) == null ? void 0 : _a2.getTransport();\n    if (!transport) {\n      throw this.getStateError();\n    }\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.ping()\", \"transport = \" + transport);\n    const pingStart = Date.now();\n    const id = cheapRandStr();\n    return withTimeoutAsync(\n      new Promise((resolve) => {\n        const onHeartbeat = (responseId) => {\n          if (responseId === id) {\n            transport.off(\"heartbeat\", onHeartbeat);\n            resolve(Date.now() - pingStart);\n          }\n        };\n        transport.on(\"heartbeat\", onHeartbeat);\n        transport.ping(id);\n      }),\n      this.options.timeouts.realtimeRequestTimeout,\n      \"Timeout waiting for heartbeat response\"\n    );\n  }\n  abort(error) {\n    this.activeProtocol.getTransport().fail(error);\n  }\n  getTransportPreference() {\n    var _a2, _b;\n    return this.transportPreference || haveWebStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.get) == null ? void 0 : _b.call(_a2, transportPreferenceName));\n  }\n  persistTransportPreference(transport) {\n    var _a2, _b;\n    this.transportPreference = transport.shortName;\n    if (haveWebStorage()) {\n      (_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.set) == null ? void 0 : _b.call(_a2, transportPreferenceName, transport.shortName);\n    }\n  }\n  unpersistTransportPreference() {\n    var _a2, _b;\n    this.transportPreference = null;\n    if (haveWebStorage()) {\n      (_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.remove) == null ? void 0 : _b.call(_a2, transportPreferenceName);\n    }\n  }\n  /* This method is only used during connection attempts, so implements RSA4c1, RSA4c2,\n   * and RSA4d. It is generally not invoked for serverside-triggered reauths or manual\n   * reauths, so RSA4c3 does not apply, except (per per RSA4d1) in the case that the auth\n   * server returns 403. */\n  actOnErrorFromAuthorize(err) {\n    if (err.code === 40171) {\n      this.notifyState({ state: \"failed\", error: err });\n    } else if (err.code === 40102) {\n      this.notifyState({ state: \"failed\", error: err });\n    } else if (err.statusCode === HttpStatusCodes_default.Forbidden) {\n      const msg = \"Client configured authentication provider returned 403; failing the connection\";\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.actOnErrorFromAuthorize()\", msg);\n      this.notifyState({ state: \"failed\", error: new ErrorInfo(msg, 80019, 403, err) });\n    } else {\n      const msg = \"Client configured authentication provider request failed\";\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.actOnErrorFromAuthorize\", msg);\n      this.notifyState({ state: this.state.failState, error: new ErrorInfo(msg, 80019, 401, err) });\n    }\n  }\n  onConnectionDetailsUpdate(connectionDetails, transport) {\n    if (!connectionDetails) {\n      return;\n    }\n    this.connectionDetails = connectionDetails;\n    if (connectionDetails.maxMessageSize) {\n      this.options.maxMessageSize = connectionDetails.maxMessageSize;\n    }\n    const clientId = connectionDetails.clientId;\n    if (clientId) {\n      const err = this.realtime.auth._uncheckedSetClientId(clientId);\n      if (err) {\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.onConnectionDetailsUpdate()\", err.message);\n        transport.fail(err);\n        return;\n      }\n    }\n    const connectionStateTtl = connectionDetails.connectionStateTtl;\n    if (connectionStateTtl) {\n      this.connectionStateTtl = connectionStateTtl;\n    }\n    this.maxIdleInterval = connectionDetails.maxIdleInterval;\n    this.emit(\"connectiondetails\", connectionDetails);\n  }\n  checkWsConnectivity() {\n    const wsConnectivityCheckUrl = this.options.wsConnectivityCheckUrl || defaults_default.wsConnectivityCheckUrl;\n    const ws = new Platform.Config.WebSocket(wsConnectivityCheckUrl);\n    return new Promise((resolve, reject) => {\n      let finished = false;\n      ws.onopen = () => {\n        if (!finished) {\n          finished = true;\n          resolve();\n          ws.close();\n        }\n      };\n      ws.onclose = ws.onerror = () => {\n        if (!finished) {\n          finished = true;\n          reject();\n        }\n      };\n    });\n  }\n  sessionRecoveryName() {\n    return this.options.recoveryKeyStorageName || \"ably-connection-recovery\";\n  }\n  getSessionRecoverData() {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.getSession) == null ? void 0 : _b.call(_a2, this.sessionRecoveryName()));\n  }\n  setSessionRecoverData(value) {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.setSession) == null ? void 0 : _b.call(_a2, this.sessionRecoveryName(), value));\n  }\n  clearSessionRecoverData() {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.removeSession) == null ? void 0 : _b.call(_a2, this.sessionRecoveryName()));\n  }\n};\nvar connectionmanager_default = ConnectionManager;\n\n// src/common/lib/client/connection.ts\nvar Connection = class extends eventemitter_default {\n  constructor(ably, options) {\n    super(ably.logger);\n    this.whenState = (state) => {\n      return eventemitter_default.prototype.whenState.call(this, state, this.state);\n    };\n    this.ably = ably;\n    this.connectionManager = new connectionmanager_default(ably, options);\n    this.state = this.connectionManager.state.state;\n    this.key = void 0;\n    this.id = void 0;\n    this.errorReason = null;\n    this.connectionManager.on(\"connectionstate\", (stateChange) => {\n      const state = this.state = stateChange.current;\n      Platform.Config.nextTick(() => {\n        this.emit(state, stateChange);\n      });\n    });\n    this.connectionManager.on(\"update\", (stateChange) => {\n      Platform.Config.nextTick(() => {\n        this.emit(\"update\", stateChange);\n      });\n    });\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Connection.connect()\", \"\");\n    this.connectionManager.requestState({ state: \"connecting\" });\n  }\n  async ping() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Connection.ping()\", \"\");\n    return this.connectionManager.ping();\n  }\n  close() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Connection.close()\", \"connectionKey = \" + this.key);\n    this.connectionManager.requestState({ state: \"closing\" });\n  }\n  get recoveryKey() {\n    this.logger.deprecationWarning(\n      \"The `Connection.recoveryKey` attribute has been replaced by the `Connection.createRecoveryKey()` method. Replace your usage of `recoveryKey` with the return value of `createRecoveryKey()`. `recoveryKey` will be removed in a future version.\"\n    );\n    return this.createRecoveryKey();\n  }\n  createRecoveryKey() {\n    return this.connectionManager.createRecoveryKey();\n  }\n};\nvar connection_default = Connection;\n\n// src/common/lib/client/baserealtime.ts\nvar _BaseRealtime = class _BaseRealtime extends baseclient_default {\n  /*\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\n   *\n   * 1. passes a string (which is quite likely if they’re e.g. migrating from the default variant to the modular variant)\n   * 2. passes no argument at all\n   *\n   * tell the compiler that these cases are possible so that it forces us to handle them.\n   */\n  constructor(options) {\n    var _a2, _b, _c, _d;\n    super(defaults_default.objectifyOptions(options, false, \"BaseRealtime\", logger_default.defaultLogger));\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime()\", \"\");\n    if (typeof EdgeRuntime === \"string\") {\n      throw new ErrorInfo(\n        `Ably.Realtime instance cannot be used in Vercel Edge runtime. If you are running Vercel Edge functions, please replace your \"new Ably.Realtime()\" with \"new Ably.Rest()\" and use Ably Rest API instead of the Realtime API. If you are server-rendering your application in the Vercel Edge runtime, please use the condition \"if (typeof EdgeRuntime === 'string')\" to prevent instantiating Ably.Realtime instance during SSR in the Vercel Edge runtime.`,\n        4e4,\n        400\n      );\n    }\n    this._additionalTransportImplementations = _BaseRealtime.transportImplementationsFromPlugins(this.options.plugins);\n    this._RealtimePresence = (_b = (_a2 = this.options.plugins) == null ? void 0 : _a2.RealtimePresence) != null ? _b : null;\n    this._objectsPlugin = (_d = (_c = this.options.plugins) == null ? void 0 : _c.Objects) != null ? _d : null;\n    this.connection = new connection_default(this, this.options);\n    this._channels = new Channels2(this);\n    if (this.options.autoConnect !== false)\n      this.connect();\n  }\n  static transportImplementationsFromPlugins(plugins) {\n    const transports = {};\n    if (plugins == null ? void 0 : plugins.WebSocketTransport) {\n      transports[TransportNames.WebSocket] = plugins.WebSocketTransport;\n    }\n    if (plugins == null ? void 0 : plugins.XHRPolling) {\n      transports[TransportNames.XhrPolling] = plugins.XHRPolling;\n    }\n    return transports;\n  }\n  get channels() {\n    return this._channels;\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime.connect()\", \"\");\n    this.connection.connect();\n  }\n  close() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime.close()\", \"\");\n    this.connection.close();\n  }\n};\n// internal API to make EventEmitter usable in other SDKs\n_BaseRealtime.EventEmitter = eventemitter_default;\nvar BaseRealtime = _BaseRealtime;\nvar Channels2 = class extends eventemitter_default {\n  constructor(realtime) {\n    super(realtime.logger);\n    this.realtime = realtime;\n    this.all = /* @__PURE__ */ Object.create(null);\n    realtime.connection.connectionManager.on(\"transport.active\", () => {\n      this.onTransportActive();\n    });\n  }\n  channelSerials() {\n    let serials = {};\n    for (const name of keysArray(this.all, true)) {\n      const channel = this.all[name];\n      if (channel.properties.channelSerial) {\n        serials[name] = channel.properties.channelSerial;\n      }\n    }\n    return serials;\n  }\n  // recoverChannels gets the given channels and sets their channel serials.\n  recoverChannels(channelSerials) {\n    for (const name of keysArray(channelSerials, true)) {\n      const channel = this.get(name);\n      channel.properties.channelSerial = channelSerials[name];\n    }\n  }\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage.\n  async processChannelMessage(msg) {\n    const channelName = msg.channel;\n    if (channelName === void 0) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"Channels.processChannelMessage()\",\n        \"received event unspecified channel, action = \" + msg.action\n      );\n      return;\n    }\n    const channel = this.all[channelName];\n    if (!channel) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"Channels.processChannelMessage()\",\n        \"received event for non-existent channel: \" + channelName\n      );\n      return;\n    }\n    await channel.processMessage(msg);\n  }\n  /* called when a transport becomes connected; reattempt attach/detach\n   * for channels that are attaching or detaching. */\n  onTransportActive() {\n    for (const channelName in this.all) {\n      const channel = this.all[channelName];\n      if (channel.state === \"attaching\" || channel.state === \"detaching\") {\n        channel.checkPendingState();\n      } else if (channel.state === \"suspended\") {\n        channel._attach(false, null);\n      } else if (channel.state === \"attached\") {\n        channel.requestState(\"attaching\");\n      }\n    }\n  }\n  /* Connection interruptions (ie when the connection will no longer queue\n   * events) imply connection state changes for any channel which is either\n   * attached, pending, or will attempt to become attached in the future */\n  propogateConnectionInterruption(connectionState, reason) {\n    const connectionStateToChannelState = {\n      closing: \"detached\",\n      closed: \"detached\",\n      failed: \"failed\",\n      suspended: \"suspended\"\n    };\n    const fromChannelStates = [\"attaching\", \"attached\", \"detaching\", \"suspended\"];\n    const toChannelState = connectionStateToChannelState[connectionState];\n    for (const channelId in this.all) {\n      const channel = this.all[channelId];\n      if (fromChannelStates.includes(channel.state)) {\n        channel.notifyState(toChannelState, reason);\n      }\n    }\n  }\n  get(name, channelOptions) {\n    name = String(name);\n    let channel = this.all[name];\n    if (!channel) {\n      channel = this.all[name] = new realtimechannel_default(this.realtime, name, channelOptions);\n    } else if (channelOptions) {\n      if (channel._shouldReattachToSetOptions(channelOptions, channel.channelOptions)) {\n        throw new ErrorInfo(\n          \"Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.\",\n          4e4,\n          400\n        );\n      }\n      channel.setOptions(channelOptions);\n    }\n    return channel;\n  }\n  getDerived(name, deriveOptions, channelOptions) {\n    if (deriveOptions.filter) {\n      const filter = toBase64(deriveOptions.filter);\n      const match = matchDerivedChannel(name);\n      name = `[filter=${filter}${match.qualifierParam}]${match.channelName}`;\n    }\n    return this.get(name, channelOptions);\n  }\n  /* Included to support certain niche use-cases; most users should ignore this.\n   * Please do not use this unless you know what you're doing */\n  release(name) {\n    name = String(name);\n    const channel = this.all[name];\n    if (!channel) {\n      return;\n    }\n    const releaseErr = channel.getReleaseErr();\n    if (releaseErr) {\n      throw releaseErr;\n    }\n    delete this.all[name];\n  }\n};\nvar baserealtime_default = BaseRealtime;\n\n// src/common/lib/client/presencemap.ts\nfunction newerThan(item, existing) {\n  if (item.isSynthesized() || existing.isSynthesized()) {\n    return item.timestamp >= existing.timestamp;\n  }\n  const itemOrderings = item.parseId(), existingOrderings = existing.parseId();\n  if (itemOrderings.msgSerial === existingOrderings.msgSerial) {\n    return itemOrderings.index > existingOrderings.index;\n  } else {\n    return itemOrderings.msgSerial > existingOrderings.msgSerial;\n  }\n}\nvar PresenceMap = class extends eventemitter_default {\n  constructor(presence, memberKey, newer = newerThan) {\n    super(presence.logger);\n    this.presence = presence;\n    this.map = /* @__PURE__ */ Object.create(null);\n    this.syncInProgress = false;\n    this.residualMembers = null;\n    this.memberKey = memberKey;\n    this.newerThan = newer;\n  }\n  get(key) {\n    return this.map[key];\n  }\n  getClient(clientId) {\n    const map = this.map, result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.clientId == clientId && item.action != \"absent\")\n        result.push(item);\n    }\n    return result;\n  }\n  list(params) {\n    const map = this.map, clientId = params && params.clientId, connectionId = params && params.connectionId, result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.action === \"absent\")\n        continue;\n      if (clientId && clientId != item.clientId)\n        continue;\n      if (connectionId && connectionId != item.connectionId)\n        continue;\n      result.push(item);\n    }\n    return result;\n  }\n  put(item) {\n    if (item.action === \"enter\" || item.action === \"update\") {\n      item = presencemessage_default.fromValues(item);\n      item.action = \"present\";\n    }\n    const map = this.map, key = this.memberKey(item);\n    if (this.residualMembers)\n      delete this.residualMembers[key];\n    const existingItem = map[key];\n    if (existingItem && !this.newerThan(item, existingItem)) {\n      return false;\n    }\n    map[key] = item;\n    return true;\n  }\n  values() {\n    const map = this.map, result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.action != \"absent\")\n        result.push(item);\n    }\n    return result;\n  }\n  remove(item) {\n    const map = this.map, key = this.memberKey(item);\n    const existingItem = map[key];\n    if (existingItem && !this.newerThan(item, existingItem)) {\n      return false;\n    }\n    if (this.syncInProgress) {\n      item = presencemessage_default.fromValues(item);\n      item.action = \"absent\";\n      map[key] = item;\n    } else {\n      delete map[key];\n    }\n    return !!existingItem;\n  }\n  startSync() {\n    const map = this.map, syncInProgress = this.syncInProgress;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"PresenceMap.startSync()\",\n      \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress\n    );\n    if (!this.syncInProgress) {\n      this.residualMembers = copy(map);\n      this.setInProgress(true);\n    }\n  }\n  endSync() {\n    const map = this.map, syncInProgress = this.syncInProgress;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"PresenceMap.endSync()\",\n      \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress\n    );\n    if (syncInProgress) {\n      for (const memberKey in map) {\n        const entry = map[memberKey];\n        if (entry.action === \"absent\") {\n          delete map[memberKey];\n        }\n      }\n      this.presence._synthesizeLeaves(valuesArray(this.residualMembers));\n      for (const memberKey in this.residualMembers) {\n        delete map[memberKey];\n      }\n      this.residualMembers = null;\n      this.setInProgress(false);\n    }\n    this.emit(\"sync\");\n  }\n  waitSync(callback) {\n    const syncInProgress = this.syncInProgress;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"PresenceMap.waitSync()\",\n      \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress\n    );\n    if (!syncInProgress) {\n      callback();\n      return;\n    }\n    this.once(\"sync\", callback);\n  }\n  clear() {\n    this.map = {};\n    this.setInProgress(false);\n    this.residualMembers = null;\n  }\n  setInProgress(inProgress) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"PresenceMap.setInProgress()\", \"inProgress = \" + inProgress);\n    this.syncInProgress = inProgress;\n    this.presence.syncComplete = !inProgress;\n  }\n};\n\n// src/common/lib/client/realtimepresence.ts\nfunction getClientId(realtimePresence) {\n  return realtimePresence.channel.client.auth.clientId;\n}\nfunction isAnonymousOrWildcard(realtimePresence) {\n  const realtime = realtimePresence.channel.client;\n  const clientId = realtime.auth.clientId;\n  return (!clientId || clientId === \"*\") && realtime.connection.state === \"connected\";\n}\nfunction waitAttached(channel, callback, action) {\n  switch (channel.state) {\n    case \"attached\":\n    case \"suspended\":\n      action();\n      break;\n    case \"initialized\":\n    case \"detached\":\n    case \"detaching\":\n    case \"attaching\":\n      whenPromiseSettles(channel.attach(), function(err) {\n        if (err)\n          callback(err);\n        else\n          action();\n      });\n      break;\n    default:\n      callback(ErrorInfo.fromValues(channel.invalidStateError()));\n  }\n}\nvar RealtimePresence = class extends eventemitter_default {\n  constructor(channel) {\n    super(channel.logger);\n    this.channel = channel;\n    this.syncComplete = false;\n    this.members = new PresenceMap(this, (item) => item.clientId + \":\" + item.connectionId);\n    this._myMembers = new PresenceMap(this, (item) => item.clientId);\n    this.subscriptions = new eventemitter_default(this.logger);\n    this.pendingPresence = [];\n  }\n  async enter(data) {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo(\"clientId must be specified to enter a presence channel\", 40012, 400);\n    }\n    return this._enterOrUpdateClient(void 0, void 0, data, \"enter\");\n  }\n  async update(data) {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo(\"clientId must be specified to update presence data\", 40012, 400);\n    }\n    return this._enterOrUpdateClient(void 0, void 0, data, \"update\");\n  }\n  async enterClient(clientId, data) {\n    return this._enterOrUpdateClient(void 0, clientId, data, \"enter\");\n  }\n  async updateClient(clientId, data) {\n    return this._enterOrUpdateClient(void 0, clientId, data, \"update\");\n  }\n  async _enterOrUpdateClient(id, clientId, data, action) {\n    const channel = this.channel;\n    if (!channel.connectionManager.activeState()) {\n      throw channel.connectionManager.getError();\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimePresence.\" + action + \"Client()\",\n      \"channel = \" + channel.name + \", id = \" + id + \", client = \" + (clientId || \"(implicit) \" + getClientId(this))\n    );\n    const presence = presencemessage_default.fromData(data);\n    presence.action = action;\n    if (id) {\n      presence.id = id;\n    }\n    if (clientId) {\n      presence.clientId = clientId;\n    }\n    const wirePresMsg = await presence.encode(channel.channelOptions);\n    switch (channel.state) {\n      case \"attached\":\n        return channel.sendPresence([wirePresMsg]);\n      case \"initialized\":\n      case \"detached\":\n        channel.attach();\n      case \"attaching\":\n        return new Promise((resolve, reject) => {\n          this.pendingPresence.push({\n            presence: wirePresMsg,\n            callback: (err) => err ? reject(err) : resolve()\n          });\n        });\n      default: {\n        const err = new PartialErrorInfo(\n          \"Unable to \" + action + \" presence channel while in \" + channel.state + \" state\",\n          90001\n        );\n        err.code = 90001;\n        throw err;\n      }\n    }\n  }\n  async leave(data) {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo(\"clientId must have been specified to enter or leave a presence channel\", 40012, 400);\n    }\n    return this.leaveClient(void 0, data);\n  }\n  async leaveClient(clientId, data) {\n    const channel = this.channel;\n    if (!channel.connectionManager.activeState()) {\n      throw channel.connectionManager.getError();\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimePresence.leaveClient()\",\n      \"leaving; channel = \" + this.channel.name + \", client = \" + clientId\n    );\n    const presence = presencemessage_default.fromData(data);\n    presence.action = \"leave\";\n    if (clientId) {\n      presence.clientId = clientId;\n    }\n    const wirePresMsg = await presence.encode(channel.channelOptions);\n    switch (channel.state) {\n      case \"attached\":\n        return channel.sendPresence([wirePresMsg]);\n      case \"attaching\":\n        return new Promise((resolve, reject) => {\n          this.pendingPresence.push({\n            presence: wirePresMsg,\n            callback: (err) => err ? reject(err) : resolve()\n          });\n        });\n      case \"initialized\":\n      case \"failed\": {\n        throw new PartialErrorInfo(\"Unable to leave presence channel (incompatible state)\", 90001);\n      }\n      default:\n        throw channel.invalidStateError();\n    }\n  }\n  async get(params) {\n    const waitForSync = !params || (\"waitForSync\" in params ? params.waitForSync : true);\n    return new Promise((resolve, reject) => {\n      function returnMembers(members) {\n        resolve(params ? members.list(params) : members.values());\n      }\n      if (this.channel.state === \"suspended\") {\n        if (waitForSync) {\n          reject(\n            ErrorInfo.fromValues({\n              statusCode: 400,\n              code: 91005,\n              message: \"Presence state is out of sync due to channel being in the SUSPENDED state\"\n            })\n          );\n        } else {\n          returnMembers(this.members);\n        }\n        return;\n      }\n      waitAttached(\n        this.channel,\n        (err) => reject(err),\n        () => {\n          const members = this.members;\n          if (waitForSync) {\n            members.waitSync(function() {\n              returnMembers(members);\n            });\n          } else {\n            returnMembers(members);\n          }\n        }\n      );\n    });\n  }\n  async history(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimePresence.history()\", \"channel = \" + this.name);\n    const restMixin = this.channel.client.rest.presenceMixin;\n    if (params && params.untilAttach) {\n      if (this.channel.state === \"attached\") {\n        delete params.untilAttach;\n        params.from_serial = this.channel.properties.attachSerial;\n      } else {\n        throw new ErrorInfo(\n          \"option untilAttach requires the channel to be attached, was: \" + this.channel.state,\n          4e4,\n          400\n        );\n      }\n    }\n    return restMixin.history(this, params);\n  }\n  setPresence(presenceSet, isSync, syncChannelSerial) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimePresence.setPresence()\",\n      \"received presence for \" + presenceSet.length + \" participants; syncChannelSerial = \" + syncChannelSerial\n    );\n    let syncCursor, match;\n    const members = this.members, myMembers = this._myMembers, broadcastMessages = [], connId = this.channel.connectionManager.connectionId;\n    if (isSync) {\n      this.members.startSync();\n      if (syncChannelSerial && (match = syncChannelSerial.match(/^[\\w-]+:(.*)$/))) {\n        syncCursor = match[1];\n      }\n    }\n    for (let presence of presenceSet) {\n      switch (presence.action) {\n        case \"leave\":\n          if (members.remove(presence)) {\n            broadcastMessages.push(presence);\n          }\n          if (presence.connectionId === connId && !presence.isSynthesized()) {\n            myMembers.remove(presence);\n          }\n          break;\n        case \"enter\":\n        case \"present\":\n        case \"update\":\n          if (members.put(presence)) {\n            broadcastMessages.push(presence);\n          }\n          if (presence.connectionId === connId) {\n            myMembers.put(presence);\n          }\n          break;\n      }\n    }\n    if (isSync && !syncCursor) {\n      members.endSync();\n      this.channel.syncChannelSerial = null;\n    }\n    for (let i = 0; i < broadcastMessages.length; i++) {\n      const presence = broadcastMessages[i];\n      this.subscriptions.emit(presence.action, presence);\n    }\n  }\n  onAttached(hasPresence) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimePresence.onAttached()\",\n      \"channel = \" + this.channel.name + \", hasPresence = \" + hasPresence\n    );\n    if (hasPresence) {\n      this.members.startSync();\n    } else {\n      this._synthesizeLeaves(this.members.values());\n      this.members.clear();\n    }\n    this._ensureMyMembersPresent();\n    const pendingPresence = this.pendingPresence, pendingPresCount = pendingPresence.length;\n    if (pendingPresCount) {\n      this.pendingPresence = [];\n      const presenceArray = [];\n      const multicaster = multicaster_default.create(this.logger);\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"RealtimePresence.onAttached\",\n        \"sending \" + pendingPresCount + \" queued presence messages\"\n      );\n      for (let i = 0; i < pendingPresCount; i++) {\n        const event = pendingPresence[i];\n        presenceArray.push(event.presence);\n        multicaster.push(event.callback);\n      }\n      this.channel.sendPresence(presenceArray).then(() => multicaster()).catch((err) => multicaster(err));\n    }\n  }\n  actOnChannelState(state, hasPresence, err) {\n    switch (state) {\n      case \"attached\":\n        this.onAttached(hasPresence);\n        break;\n      case \"detached\":\n      case \"failed\":\n        this._clearMyMembers();\n        this.members.clear();\n      case \"suspended\":\n        this.failPendingPresence(err);\n        break;\n    }\n  }\n  failPendingPresence(err) {\n    if (this.pendingPresence.length) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"RealtimeChannel.failPendingPresence\",\n        \"channel; name = \" + this.channel.name + \", err = \" + inspectError(err)\n      );\n      for (let i = 0; i < this.pendingPresence.length; i++)\n        try {\n          this.pendingPresence[i].callback(err);\n        } catch (e) {\n        }\n      this.pendingPresence = [];\n    }\n  }\n  _clearMyMembers() {\n    this._myMembers.clear();\n  }\n  _ensureMyMembersPresent() {\n    const myMembers = this._myMembers;\n    const connId = this.channel.connectionManager.connectionId;\n    for (const memberKey in myMembers.map) {\n      const entry = myMembers.map[memberKey];\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"RealtimePresence._ensureMyMembersPresent()\",\n        'Auto-reentering clientId \"' + entry.clientId + '\" into the presence set'\n      );\n      const id = entry.connectionId === connId ? entry.id : void 0;\n      this._enterOrUpdateClient(id, entry.clientId, entry.data, \"enter\").catch((err) => {\n        const wrappedErr = new ErrorInfo(\"Presence auto re-enter failed\", 91004, 400, err);\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"RealtimePresence._ensureMyMembersPresent()\",\n          \"Presence auto re-enter failed; reason = \" + inspectError(err)\n        );\n        const change = new channelstatechange_default(this.channel.state, this.channel.state, true, false, wrappedErr);\n        this.channel.emit(\"update\", change);\n      });\n    }\n  }\n  _synthesizeLeaves(items) {\n    const subscriptions = this.subscriptions;\n    items.forEach(function(item) {\n      const presence = presencemessage_default.fromValues({\n        action: \"leave\",\n        connectionId: item.connectionId,\n        clientId: item.clientId,\n        data: item.data,\n        encoding: item.encoding,\n        timestamp: Date.now()\n      });\n      subscriptions.emit(\"leave\", presence);\n    });\n  }\n  async subscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    const channel = this.channel;\n    if (channel.state === \"failed\") {\n      throw ErrorInfo.fromValues(channel.invalidStateError());\n    }\n    this.subscriptions.on(event, listener);\n    if (channel.channelOptions.attachOnSubscribe !== false) {\n      await channel.attach();\n    }\n  }\n  unsubscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    this.subscriptions.off(event, listener);\n  }\n};\nvar realtimepresence_default = RealtimePresence;\n\n// src/common/lib/transport/websockettransport.ts\nvar shortName = TransportNames.WebSocket;\nfunction isNodeWebSocket(ws) {\n  return !!ws.on;\n}\nvar WebSocketTransport = class extends transport_default {\n  constructor(connectionManager, auth, params) {\n    super(connectionManager, auth, params);\n    this.shortName = shortName;\n    params.heartbeats = Platform.Config.useProtocolHeartbeats;\n    this.wsHost = params.host;\n  }\n  static isAvailable() {\n    return !!Platform.Config.WebSocket;\n  }\n  createWebSocket(uri, connectParams) {\n    this.uri = uri + toQueryString(connectParams);\n    return new Platform.Config.WebSocket(this.uri);\n  }\n  toString() {\n    return \"WebSocketTransport; uri=\" + this.uri;\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.connect()\", \"starting\");\n    transport_default.prototype.connect.call(this);\n    const self2 = this, params = this.params, options = params.options;\n    const wsScheme = options.tls ? \"wss://\" : \"ws://\";\n    const wsUri = wsScheme + this.wsHost + \":\" + defaults_default.getPort(options) + \"/\";\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.connect()\", \"uri: \" + wsUri);\n    whenPromiseSettles(\n      this.auth.getAuthParams(),\n      function(err, authParams) {\n        if (self2.isDisposed) {\n          return;\n        }\n        let paramStr = \"\";\n        for (const param in authParams)\n          paramStr += \" \" + param + \": \" + authParams[param] + \";\";\n        logger_default.logAction(\n          self2.logger,\n          logger_default.LOG_MINOR,\n          \"WebSocketTransport.connect()\",\n          \"authParams:\" + paramStr + \" err: \" + err\n        );\n        if (err) {\n          self2.disconnect(err);\n          return;\n        }\n        const connectParams = params.getConnectParams(authParams);\n        try {\n          const wsConnection = self2.wsConnection = self2.createWebSocket(wsUri, connectParams);\n          wsConnection.binaryType = Platform.Config.binaryType;\n          wsConnection.onopen = function() {\n            self2.onWsOpen();\n          };\n          wsConnection.onclose = function(ev) {\n            self2.onWsClose(ev);\n          };\n          wsConnection.onmessage = function(ev) {\n            self2.onWsData(ev.data);\n          };\n          wsConnection.onerror = function(ev) {\n            self2.onWsError(ev);\n          };\n          if (isNodeWebSocket(wsConnection)) {\n            wsConnection.on(\"ping\", function() {\n              self2.onActivity();\n            });\n          }\n        } catch (e) {\n          logger_default.logAction(\n            self2.logger,\n            logger_default.LOG_ERROR,\n            \"WebSocketTransport.connect()\",\n            \"Unexpected exception creating websocket: err = \" + (e.stack || e.message)\n          );\n          self2.disconnect(e);\n        }\n      }\n    );\n  }\n  send(message) {\n    const wsConnection = this.wsConnection;\n    if (!wsConnection) {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"WebSocketTransport.send()\", \"No socket connection\");\n      return;\n    }\n    try {\n      wsConnection.send(\n        serialize2(message, this.connectionManager.realtime._MsgPack, this.params.format)\n      );\n    } catch (e) {\n      const msg = \"Exception from ws connection when trying to send: \" + inspectError(e);\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"WebSocketTransport.send()\", msg);\n      this.finish(\"disconnected\", new ErrorInfo(msg, 5e4, 500));\n    }\n  }\n  onWsData(data) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"WebSocketTransport.onWsData()\",\n      \"data received; length = \" + data.length + \"; type = \" + typeof data\n    );\n    try {\n      this.onProtocolMessage(\n        deserialize(\n          data,\n          this.connectionManager.realtime._MsgPack,\n          this.connectionManager.realtime._RealtimePresence,\n          this.connectionManager.realtime._Annotations,\n          this.connectionManager.realtime._objectsPlugin,\n          this.format\n        )\n      );\n    } catch (e) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"WebSocketTransport.onWsData()\",\n        \"Unexpected exception handing channel message: \" + e.stack\n      );\n    }\n  }\n  onWsOpen() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.onWsOpen()\", \"opened WebSocket\");\n    this.emit(\"preconnect\");\n  }\n  onWsClose(ev) {\n    let wasClean, code;\n    if (typeof ev == \"object\") {\n      code = ev.code;\n      wasClean = ev.wasClean || code === 1e3;\n    } else {\n      code = ev;\n      wasClean = code == 1e3;\n    }\n    delete this.wsConnection;\n    if (wasClean) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.onWsClose()\", \"Cleanly closed WebSocket\");\n      const err = new ErrorInfo(\"Websocket closed\", 80003, 400);\n      this.finish(\"disconnected\", err);\n    } else {\n      const msg = \"Unclean disconnection of WebSocket ; code = \" + code, err = new ErrorInfo(msg, 80003, 400);\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.onWsClose()\", msg);\n      this.finish(\"disconnected\", err);\n    }\n    this.emit(\"disposed\");\n  }\n  onWsError(err) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"WebSocketTransport.onError()\",\n      \"Error from WebSocket: \" + err.message\n    );\n    Platform.Config.nextTick(() => {\n      this.disconnect(Error(err.message));\n    });\n  }\n  dispose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.dispose()\", \"\");\n    this.isDisposed = true;\n    const wsConnection = this.wsConnection;\n    if (wsConnection) {\n      wsConnection.onmessage = function() {\n      };\n      delete this.wsConnection;\n      Platform.Config.nextTick(() => {\n        logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"WebSocketTransport.dispose()\", \"closing websocket\");\n        if (!wsConnection) {\n          throw new Error(\"WebSocketTransport.dispose(): wsConnection is not defined\");\n        }\n        wsConnection.close();\n      });\n    }\n  }\n};\nvar websockettransport_default = WebSocketTransport;\n\n// src/common/lib/client/filteredsubscriptions.ts\nvar FilteredSubscriptions = class {\n  static subscribeFilter(channel, filter, listener) {\n    const filteredListener = (m) => {\n      var _a2, _b, _c, _d, _e, _f;\n      const mapping = {\n        name: m.name,\n        refTimeserial: (_b = (_a2 = m.extras) == null ? void 0 : _a2.ref) == null ? void 0 : _b.timeserial,\n        refType: (_d = (_c = m.extras) == null ? void 0 : _c.ref) == null ? void 0 : _d.type,\n        isRef: !!((_f = (_e = m.extras) == null ? void 0 : _e.ref) == null ? void 0 : _f.timeserial),\n        clientId: m.clientId\n      };\n      if (Object.entries(filter).find(\n        ([key, value]) => value !== void 0 ? mapping[key] !== value : false\n      )) {\n        return;\n      }\n      listener(m);\n    };\n    this.addFilteredSubscription(channel, filter, listener, filteredListener);\n    channel.subscriptions.on(filteredListener);\n  }\n  // Adds a new filtered subscription\n  static addFilteredSubscription(channel, filter, realListener, filteredListener) {\n    var _a2;\n    if (!channel.filteredSubscriptions) {\n      channel.filteredSubscriptions = /* @__PURE__ */ new Map();\n    }\n    if (channel.filteredSubscriptions.has(realListener)) {\n      const realListenerMap = channel.filteredSubscriptions.get(realListener);\n      realListenerMap.set(filter, ((_a2 = realListenerMap == null ? void 0 : realListenerMap.get(filter)) == null ? void 0 : _a2.concat(filteredListener)) || [filteredListener]);\n    } else {\n      channel.filteredSubscriptions.set(\n        realListener,\n        /* @__PURE__ */ new Map([[filter, [filteredListener]]])\n      );\n    }\n  }\n  static getAndDeleteFilteredSubscriptions(channel, filter, realListener) {\n    if (!channel.filteredSubscriptions) {\n      return [];\n    }\n    if (!realListener && filter) {\n      return Array.from(channel.filteredSubscriptions.entries()).map(([key, filterMaps]) => {\n        var _a2;\n        let listenerMaps = filterMaps.get(filter);\n        filterMaps.delete(filter);\n        if (filterMaps.size === 0) {\n          (_a2 = channel.filteredSubscriptions) == null ? void 0 : _a2.delete(key);\n        }\n        return listenerMaps;\n      }).reduce(\n        (prev, cur) => cur ? prev.concat(...cur) : prev,\n        []\n      );\n    }\n    if (!realListener || !channel.filteredSubscriptions.has(realListener)) {\n      return [];\n    }\n    const realListenerMap = channel.filteredSubscriptions.get(realListener);\n    if (!filter) {\n      const listeners2 = Array.from(realListenerMap.values()).reduce((prev, cur) => prev.concat(...cur), []);\n      channel.filteredSubscriptions.delete(realListener);\n      return listeners2;\n    }\n    let listeners = realListenerMap.get(filter);\n    realListenerMap.delete(filter);\n    return listeners || [];\n  }\n};\n\n// src/common/lib/client/defaultrealtime.ts\nvar _DefaultRealtime = class _DefaultRealtime extends baserealtime_default {\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\n  constructor(options) {\n    var _a2;\n    const MsgPack = _DefaultRealtime._MsgPack;\n    if (!MsgPack) {\n      throw new Error(\"Expected DefaultRealtime._MsgPack to have been set\");\n    }\n    super(\n      defaults_default.objectifyOptions(options, true, \"Realtime\", logger_default.defaultLogger, __spreadProps(__spreadValues({}, allCommonModularPlugins), {\n        Crypto: (_a2 = _DefaultRealtime.Crypto) != null ? _a2 : void 0,\n        MsgPack,\n        RealtimePresence: {\n          RealtimePresence: realtimepresence_default,\n          PresenceMessage: presencemessage_default,\n          WirePresenceMessage\n        },\n        Annotations: {\n          Annotation: annotation_default,\n          WireAnnotation,\n          RealtimeAnnotations: realtimeannotations_default,\n          RestAnnotations: restannotations_default\n        },\n        WebSocketTransport: websockettransport_default,\n        MessageInteractions: FilteredSubscriptions\n      }))\n    );\n  }\n  static get Crypto() {\n    if (this._Crypto === null) {\n      throw new Error(\"Encryption not enabled; use ably.encryption.js instead\");\n    }\n    return this._Crypto;\n  }\n  static set Crypto(newValue) {\n    this._Crypto = newValue;\n  }\n};\n_DefaultRealtime.Utils = utils_exports;\n_DefaultRealtime.ConnectionManager = connectionmanager_default;\n_DefaultRealtime.ProtocolMessage = protocolmessage_default;\n_DefaultRealtime._Crypto = null;\n_DefaultRealtime.Message = DefaultMessage;\n_DefaultRealtime.PresenceMessage = DefaultPresenceMessage;\n_DefaultRealtime.Annotation = DefaultAnnotation;\n_DefaultRealtime._MsgPack = null;\n// Used by tests\n_DefaultRealtime._Http = Http;\n_DefaultRealtime._PresenceMap = PresenceMap;\n_DefaultRealtime._MessageEncoding = MessageEncoding;\nvar DefaultRealtime = _DefaultRealtime;\n\n// src/platform/web/lib/util/hmac-sha256.ts\nvar uint8Array = Uint8Array;\nvar uint32Array = Uint32Array;\nvar pow = Math.pow;\nvar DEFAULT_STATE = new uint32Array(8);\nvar ROUND_CONSTANTS = [];\nvar M = new uint32Array(64);\nfunction getFractionalBits(n2) {\n  return (n2 - (n2 | 0)) * pow(2, 32) | 0;\n}\nvar n = 2;\nvar nPrime = 0;\nwhile (nPrime < 64) {\n  isPrime = true;\n  for (factor = 2; factor <= n / 2; factor++) {\n    if (n % factor === 0) {\n      isPrime = false;\n    }\n  }\n  if (isPrime) {\n    if (nPrime < 8) {\n      DEFAULT_STATE[nPrime] = getFractionalBits(pow(n, 1 / 2));\n    }\n    ROUND_CONSTANTS[nPrime] = getFractionalBits(pow(n, 1 / 3));\n    nPrime++;\n  }\n  n++;\n}\nvar isPrime;\nvar factor;\nvar LittleEndian = !!new uint8Array(new uint32Array([1]).buffer)[0];\nfunction convertEndian(word) {\n  if (LittleEndian) {\n    return (\n      // byte 1 -> byte 4\n      word >>> 24 | // byte 2 -> byte 3\n      (word >>> 16 & 255) << 8 | // byte 3 -> byte 2\n      (word & 65280) << 8 | // byte 4 -> byte 1\n      word << 24\n    );\n  } else {\n    return word;\n  }\n}\nfunction rightRotate(word, bits) {\n  return word >>> bits | word << 32 - bits;\n}\nfunction sha256(data) {\n  var STATE = DEFAULT_STATE.slice();\n  var legth = data.length;\n  var bitLength = legth * 8;\n  var newBitLength = 512 - (bitLength + 64) % 512 - 1 + bitLength + 65;\n  var bytes = new uint8Array(newBitLength / 8);\n  var words = new uint32Array(bytes.buffer);\n  bytes.set(data, 0);\n  bytes[legth] = 128;\n  words[words.length - 1] = convertEndian(bitLength);\n  var round;\n  for (var block = 0; block < newBitLength / 32; block += 16) {\n    var workingState = STATE.slice();\n    for (round = 0; round < 64; round++) {\n      var MRound;\n      if (round < 16) {\n        MRound = convertEndian(words[block + round]);\n      } else {\n        var gamma0x = M[round - 15];\n        var gamma1x = M[round - 2];\n        MRound = M[round - 7] + M[round - 16] + (rightRotate(gamma0x, 7) ^ rightRotate(gamma0x, 18) ^ gamma0x >>> 3) + (rightRotate(gamma1x, 17) ^ rightRotate(gamma1x, 19) ^ gamma1x >>> 10);\n      }\n      M[round] = MRound |= 0;\n      var t1 = (rightRotate(workingState[4], 6) ^ rightRotate(workingState[4], 11) ^ rightRotate(workingState[4], 25)) + (workingState[4] & workingState[5] ^ ~workingState[4] & workingState[6]) + workingState[7] + MRound + ROUND_CONSTANTS[round];\n      var t2 = (rightRotate(workingState[0], 2) ^ rightRotate(workingState[0], 13) ^ rightRotate(workingState[0], 22)) + (workingState[0] & workingState[1] ^ workingState[2] & (workingState[0] ^ workingState[1]));\n      for (var i = 7; i > 0; i--) {\n        workingState[i] = workingState[i - 1];\n      }\n      workingState[0] = t1 + t2 | 0;\n      workingState[4] = workingState[4] + t1 | 0;\n    }\n    for (round = 0; round < 8; round++) {\n      STATE[round] = STATE[round] + workingState[round] | 0;\n    }\n  }\n  return new uint8Array(\n    new uint32Array(\n      STATE.map(function(val) {\n        return convertEndian(val);\n      })\n    ).buffer\n  );\n}\nfunction hmac2(key, data) {\n  if (key.length > 64)\n    key = sha256(key);\n  if (key.length < 64) {\n    const tmp = new Uint8Array(64);\n    tmp.set(key, 0);\n    key = tmp;\n  }\n  var innerKey = new Uint8Array(64);\n  var outerKey = new Uint8Array(64);\n  for (var i = 0; i < 64; i++) {\n    innerKey[i] = 54 ^ key[i];\n    outerKey[i] = 92 ^ key[i];\n  }\n  var msg = new Uint8Array(data.length + 64);\n  msg.set(innerKey, 0);\n  msg.set(data, 64);\n  var result = new Uint8Array(64 + 32);\n  result.set(outerKey, 0);\n  result.set(sha256(msg), 64);\n  return sha256(result);\n}\n\n// src/platform/web/lib/util/bufferutils.ts\nvar BufferUtils = class {\n  constructor() {\n    this.base64CharSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    this.hexCharSet = \"0123456789abcdef\";\n  }\n  // https://gist.githubusercontent.com/jonleighton/958841/raw/f200e30dfe95212c0165ccf1ae000ca51e9de803/gistfile1.js\n  uint8ViewToBase64(bytes) {\n    let base64 = \"\";\n    const encodings = this.base64CharSet;\n    const byteLength = bytes.byteLength;\n    const byteRemainder = byteLength % 3;\n    const mainLength = byteLength - byteRemainder;\n    let a, b, c, d;\n    let chunk;\n    for (let i = 0; i < mainLength; i = i + 3) {\n      chunk = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];\n      a = (chunk & 16515072) >> 18;\n      b = (chunk & 258048) >> 12;\n      c = (chunk & 4032) >> 6;\n      d = chunk & 63;\n      base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];\n    }\n    if (byteRemainder == 1) {\n      chunk = bytes[mainLength];\n      a = (chunk & 252) >> 2;\n      b = (chunk & 3) << 4;\n      base64 += encodings[a] + encodings[b] + \"==\";\n    } else if (byteRemainder == 2) {\n      chunk = bytes[mainLength] << 8 | bytes[mainLength + 1];\n      a = (chunk & 64512) >> 10;\n      b = (chunk & 1008) >> 4;\n      c = (chunk & 15) << 2;\n      base64 += encodings[a] + encodings[b] + encodings[c] + \"=\";\n    }\n    return base64;\n  }\n  base64ToArrayBuffer(base64) {\n    const binary_string = atob == null ? void 0 : atob(base64);\n    const len = binary_string.length;\n    const bytes = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n      const ascii = binary_string.charCodeAt(i);\n      bytes[i] = ascii;\n    }\n    return this.toArrayBuffer(bytes);\n  }\n  isBuffer(buffer) {\n    return buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer);\n  }\n  toBuffer(buffer) {\n    if (!ArrayBuffer) {\n      throw new Error(\"Can't convert to Buffer: browser does not support the necessary types\");\n    }\n    if (buffer instanceof ArrayBuffer) {\n      return new Uint8Array(buffer);\n    }\n    if (ArrayBuffer.isView(buffer)) {\n      return new Uint8Array(this.toArrayBuffer(buffer));\n    }\n    throw new Error(\"BufferUtils.toBuffer expected an ArrayBuffer or a view onto one\");\n  }\n  toArrayBuffer(buffer) {\n    if (!ArrayBuffer) {\n      throw new Error(\"Can't convert to ArrayBuffer: browser does not support the necessary types\");\n    }\n    if (buffer instanceof ArrayBuffer) {\n      return buffer;\n    }\n    if (ArrayBuffer.isView(buffer)) {\n      return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\n    }\n    throw new Error(\"BufferUtils.toArrayBuffer expected an ArrayBuffer or a view onto one\");\n  }\n  base64Encode(buffer) {\n    return this.uint8ViewToBase64(this.toBuffer(buffer));\n  }\n  base64UrlEncode(buffer) {\n    return this.base64Encode(buffer).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n  }\n  base64Decode(str) {\n    if (ArrayBuffer && Platform.Config.atob) {\n      return this.base64ToArrayBuffer(str);\n    } else {\n      throw new Error(\"Expected ArrayBuffer to exist and Platform.Config.atob to be configured\");\n    }\n  }\n  hexEncode(buffer) {\n    const uint8Array2 = this.toBuffer(buffer);\n    return uint8Array2.reduce((accum, byte) => accum + byte.toString(16).padStart(2, \"0\"), \"\");\n  }\n  hexDecode(hexEncodedBytes) {\n    if (hexEncodedBytes.length % 2 !== 0) {\n      throw new Error(\"Can't create a byte array from a hex string of odd length\");\n    }\n    const uint8Array2 = new Uint8Array(hexEncodedBytes.length / 2);\n    for (let i = 0; i < uint8Array2.length; i++) {\n      uint8Array2[i] = parseInt(hexEncodedBytes.slice(2 * i, 2 * (i + 1)), 16);\n    }\n    return this.toArrayBuffer(uint8Array2);\n  }\n  utf8Encode(string) {\n    if (Platform.Config.TextEncoder) {\n      const encodedByteArray = new Platform.Config.TextEncoder().encode(string);\n      return this.toArrayBuffer(encodedByteArray);\n    } else {\n      throw new Error(\"Expected TextEncoder to be configured\");\n    }\n  }\n  /* For utf8 decoding we apply slightly stricter input validation than to\n   * hexEncode/base64Encode/etc: in those we accept anything that Buffer.from\n   * can take (in particular allowing strings, which are just interpreted as\n   * binary); here we ensure that the input is actually a buffer since trying\n   * to utf8-decode a string to another string is almost certainly a mistake */\n  utf8Decode(buffer) {\n    if (!this.isBuffer(buffer)) {\n      throw new Error(\"Expected input of utf8decode to be an arraybuffer or typed array\");\n    }\n    if (TextDecoder) {\n      return new TextDecoder().decode(buffer);\n    } else {\n      throw new Error(\"Expected TextDecoder to be configured\");\n    }\n  }\n  areBuffersEqual(buffer1, buffer2) {\n    if (!buffer1 || !buffer2)\n      return false;\n    const arrayBuffer1 = this.toArrayBuffer(buffer1);\n    const arrayBuffer2 = this.toArrayBuffer(buffer2);\n    if (arrayBuffer1.byteLength != arrayBuffer2.byteLength)\n      return false;\n    const bytes1 = new Uint8Array(arrayBuffer1);\n    const bytes2 = new Uint8Array(arrayBuffer2);\n    for (var i = 0; i < bytes1.length; i++) {\n      if (bytes1[i] != bytes2[i])\n        return false;\n    }\n    return true;\n  }\n  byteLength(buffer) {\n    if (buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer)) {\n      return buffer.byteLength;\n    }\n    return -1;\n  }\n  arrayBufferViewToBuffer(arrayBufferView) {\n    return this.toArrayBuffer(arrayBufferView);\n  }\n  concat(buffers) {\n    const sumLength = buffers.reduce((acc, v) => acc + v.byteLength, 0);\n    const result = new Uint8Array(sumLength);\n    let offset = 0;\n    for (const buffer of buffers) {\n      const uint8Array2 = this.toBuffer(buffer);\n      result.set(uint8Array2, offset);\n      offset += uint8Array2.byteLength;\n    }\n    return result.buffer;\n  }\n  sha256(message) {\n    const hash = sha256(this.toBuffer(message));\n    return this.toArrayBuffer(hash);\n  }\n  hmacSha256(message, key) {\n    const hash = hmac2(this.toBuffer(key), this.toBuffer(message));\n    return this.toArrayBuffer(hash);\n  }\n};\nvar bufferutils_default = new BufferUtils();\n\n// src/platform/web/lib/util/crypto.ts\nvar createCryptoClass = function(config, bufferUtils) {\n  var DEFAULT_ALGORITHM = \"aes\";\n  var DEFAULT_KEYLENGTH = 256;\n  var DEFAULT_MODE = \"cbc\";\n  var DEFAULT_BLOCKLENGTH = 16;\n  function validateCipherParams(params) {\n    if (params.algorithm === \"aes\" && params.mode === \"cbc\") {\n      if (params.keyLength === 128 || params.keyLength === 256) {\n        return;\n      }\n      throw new Error(\n        \"Unsupported key length \" + params.keyLength + \" for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)\"\n      );\n    }\n  }\n  function normaliseBase64(string) {\n    return string.replace(\"_\", \"/\").replace(\"-\", \"+\");\n  }\n  function isCipherParams(params) {\n    return params instanceof CipherParams;\n  }\n  class CipherParams {\n    constructor(algorithm, keyLength, mode, key) {\n      this.algorithm = algorithm;\n      this.keyLength = keyLength;\n      this.mode = mode;\n      this.key = key;\n    }\n  }\n  class Crypto2 {\n    /**\n     * Obtain a complete CipherParams instance from the provided params, filling\n     * in any not provided with default values, calculating a keyLength from\n     * the supplied key, and validating the result.\n     * @param params an object containing at a minimum a `key` key with value the\n     * key, as either a binary or a base64-encoded string.\n     * May optionally also contain: algorithm (defaults to AES),\n     * mode (defaults to 'cbc')\n     */\n    static getDefaultParams(params) {\n      var key;\n      if (!params.key) {\n        throw new Error(\"Crypto.getDefaultParams: a key is required\");\n      }\n      if (typeof params.key === \"string\") {\n        key = bufferUtils.toArrayBuffer(bufferUtils.base64Decode(normaliseBase64(params.key)));\n      } else if (params.key instanceof ArrayBuffer) {\n        key = params.key;\n      } else {\n        key = bufferUtils.toArrayBuffer(params.key);\n      }\n      var algorithm = params.algorithm || DEFAULT_ALGORITHM;\n      var keyLength = key.byteLength * 8;\n      var mode = params.mode || DEFAULT_MODE;\n      var cipherParams = new CipherParams(algorithm, keyLength, mode, key);\n      if (params.keyLength && params.keyLength !== cipherParams.keyLength) {\n        throw new Error(\n          \"Crypto.getDefaultParams: a keyLength of \" + params.keyLength + \" was specified, but the key actually has length \" + cipherParams.keyLength\n        );\n      }\n      validateCipherParams(cipherParams);\n      return cipherParams;\n    }\n    /**\n     * Generate a random encryption key from the supplied keylength (or the\n     * default keyLength if none supplied) as an ArrayBuffer\n     * @param keyLength (optional) the required keyLength in bits\n     */\n    static async generateRandomKey(keyLength) {\n      try {\n        return config.getRandomArrayBuffer((keyLength || DEFAULT_KEYLENGTH) / 8);\n      } catch (err) {\n        throw new ErrorInfo(\"Failed to generate random key: \" + err.message, 400, 5e4, err);\n      }\n    }\n    /**\n     * Internal; get a ChannelCipher instance based on the given cipherParams\n     * @param params either a CipherParams instance or some subset of its\n     * fields that includes a key\n     */\n    static getCipher(params, logger) {\n      var _a2;\n      var cipherParams = isCipherParams(params) ? params : this.getDefaultParams(params);\n      return {\n        cipherParams,\n        cipher: new CBCCipher(cipherParams, (_a2 = params.iv) != null ? _a2 : null, logger)\n      };\n    }\n  }\n  Crypto2.CipherParams = CipherParams;\n  Crypto2;\n  class CBCCipher {\n    constructor(params, iv, logger) {\n      this.logger = logger;\n      if (!crypto.subtle) {\n        if (isSecureContext) {\n          throw new Error(\n            \"Crypto operations are not possible since the browser\\u2019s SubtleCrypto class is unavailable (reason unknown).\"\n          );\n        } else {\n          throw new Error(\n            \"Crypto operations are is not possible since the current environment is a non-secure context and hence the browser\\u2019s SubtleCrypto class is not available.\"\n          );\n        }\n      }\n      this.algorithm = params.algorithm + \"-\" + String(params.keyLength) + \"-\" + params.mode;\n      this.webCryptoAlgorithm = params.algorithm + \"-\" + params.mode;\n      this.key = bufferUtils.toArrayBuffer(params.key);\n      this.iv = iv ? bufferUtils.toArrayBuffer(iv) : null;\n    }\n    concat(buffer1, buffer2) {\n      const output = new ArrayBuffer(buffer1.byteLength + buffer2.byteLength);\n      const outputView = new DataView(output);\n      const buffer1View = new DataView(bufferUtils.toArrayBuffer(buffer1));\n      for (let i = 0; i < buffer1View.byteLength; i++) {\n        outputView.setInt8(i, buffer1View.getInt8(i));\n      }\n      const buffer2View = new DataView(bufferUtils.toArrayBuffer(buffer2));\n      for (let i = 0; i < buffer2View.byteLength; i++) {\n        outputView.setInt8(buffer1View.byteLength + i, buffer2View.getInt8(i));\n      }\n      return output;\n    }\n    async encrypt(plaintext) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"CBCCipher.encrypt()\", \"\");\n      const iv = await this.getIv();\n      const cryptoKey = await crypto.subtle.importKey(\"raw\", this.key, this.webCryptoAlgorithm, false, [\"encrypt\"]);\n      const ciphertext = await crypto.subtle.encrypt({ name: this.webCryptoAlgorithm, iv }, cryptoKey, plaintext);\n      return this.concat(iv, ciphertext);\n    }\n    async decrypt(ciphertext) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"CBCCipher.decrypt()\", \"\");\n      const ciphertextArrayBuffer = bufferUtils.toArrayBuffer(ciphertext);\n      const iv = ciphertextArrayBuffer.slice(0, DEFAULT_BLOCKLENGTH);\n      const ciphertextBody = ciphertextArrayBuffer.slice(DEFAULT_BLOCKLENGTH);\n      const cryptoKey = await crypto.subtle.importKey(\"raw\", this.key, this.webCryptoAlgorithm, false, [\"decrypt\"]);\n      return crypto.subtle.decrypt({ name: this.webCryptoAlgorithm, iv }, cryptoKey, ciphertextBody);\n    }\n    async getIv() {\n      if (this.iv) {\n        var iv = this.iv;\n        this.iv = null;\n        return iv;\n      }\n      const randomBlock = await config.getRandomArrayBuffer(DEFAULT_BLOCKLENGTH);\n      return bufferUtils.toArrayBuffer(randomBlock);\n    }\n  }\n  return Crypto2;\n};\n\n// src/common/constants/XHRStates.ts\nvar XHRStates = /* @__PURE__ */ ((XHRStates2) => {\n  XHRStates2[XHRStates2[\"REQ_SEND\"] = 0] = \"REQ_SEND\";\n  XHRStates2[XHRStates2[\"REQ_RECV\"] = 1] = \"REQ_RECV\";\n  XHRStates2[XHRStates2[\"REQ_RECV_POLL\"] = 2] = \"REQ_RECV_POLL\";\n  XHRStates2[XHRStates2[\"REQ_RECV_STREAM\"] = 3] = \"REQ_RECV_STREAM\";\n  return XHRStates2;\n})(XHRStates || {});\nvar XHRStates_default = XHRStates;\n\n// src/platform/web/lib/http/http.ts\nfunction createMissingImplementationError() {\n  return new ErrorInfo(\n    \"No HTTP request plugin provided. Provide at least one of the FetchRequest or XHRRequest plugins.\",\n    400,\n    4e4\n  );\n}\nvar _a;\nvar Http2 = (_a = class {\n  constructor(client) {\n    this.checksInProgress = null;\n    this.checkConnectivity = void 0;\n    this.supportsAuthHeaders = false;\n    this.supportsLinkHeaders = false;\n    var _a2;\n    this.client = client != null ? client : null;\n    const connectivityCheckUrl = (client == null ? void 0 : client.options.connectivityCheckUrl) || defaults_default.connectivityCheckUrl;\n    const connectivityCheckParams = (_a2 = client == null ? void 0 : client.options.connectivityCheckParams) != null ? _a2 : null;\n    const connectivityUrlIsDefault = !(client == null ? void 0 : client.options.connectivityCheckUrl);\n    const requestImplementations = __spreadValues(__spreadValues({}, Http2.bundledRequestImplementations), client == null ? void 0 : client._additionalHTTPRequestImplementations);\n    const xhrRequestImplementation = requestImplementations.XHRRequest;\n    const fetchRequestImplementation = requestImplementations.FetchRequest;\n    const hasImplementation = !!(xhrRequestImplementation || fetchRequestImplementation);\n    if (!hasImplementation) {\n      throw createMissingImplementationError();\n    }\n    if (Platform.Config.xhrSupported && xhrRequestImplementation) {\n      this.supportsAuthHeaders = true;\n      this.Request = async function(method, uri, headers, params, body) {\n        return new Promise((resolve) => {\n          var _a3;\n          const req = xhrRequestImplementation.createRequest(\n            uri,\n            headers,\n            params,\n            body,\n            XHRStates_default.REQ_SEND,\n            (_a3 = client && client.options.timeouts) != null ? _a3 : null,\n            this.logger,\n            method\n          );\n          req.once(\n            \"complete\",\n            (error, body2, headers2, unpacked, statusCode) => resolve({ error, body: body2, headers: headers2, unpacked, statusCode })\n          );\n          req.exec();\n        });\n      };\n      if (client == null ? void 0 : client.options.disableConnectivityCheck) {\n        this.checkConnectivity = async function() {\n          return true;\n        };\n      } else {\n        this.checkConnectivity = async function() {\n          var _a3;\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MICRO,\n            \"(XHRRequest)Http.checkConnectivity()\",\n            \"Sending; \" + connectivityCheckUrl\n          );\n          const requestResult = await this.doUri(\n            HttpMethods_default.Get,\n            connectivityCheckUrl,\n            null,\n            null,\n            connectivityCheckParams\n          );\n          let result = false;\n          if (!connectivityUrlIsDefault) {\n            result = !requestResult.error && isSuccessCode(requestResult.statusCode);\n          } else {\n            result = !requestResult.error && ((_a3 = requestResult.body) == null ? void 0 : _a3.replace(/\\n/, \"\")) == \"yes\";\n          }\n          logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"(XHRRequest)Http.checkConnectivity()\", \"Result: \" + result);\n          return result;\n        };\n      }\n    } else if (Platform.Config.fetchSupported && fetchRequestImplementation) {\n      this.supportsAuthHeaders = true;\n      this.Request = async (method, uri, headers, params, body) => {\n        return fetchRequestImplementation(method, client != null ? client : null, uri, headers, params, body);\n      };\n      if (client == null ? void 0 : client.options.disableConnectivityCheck) {\n        this.checkConnectivity = async function() {\n          return true;\n        };\n      } else {\n        this.checkConnectivity = async function() {\n          var _a3;\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MICRO,\n            \"(Fetch)Http.checkConnectivity()\",\n            \"Sending; \" + connectivityCheckUrl\n          );\n          const requestResult = await this.doUri(HttpMethods_default.Get, connectivityCheckUrl, null, null, null);\n          const result = !requestResult.error && ((_a3 = requestResult.body) == null ? void 0 : _a3.replace(/\\n/, \"\")) == \"yes\";\n          logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"(Fetch)Http.checkConnectivity()\", \"Result: \" + result);\n          return result;\n        };\n      }\n    } else {\n      this.Request = async () => {\n        const error = hasImplementation ? new PartialErrorInfo(\"no supported HTTP transports available\", null, 400) : createMissingImplementationError();\n        return { error };\n      };\n    }\n  }\n  get logger() {\n    var _a2, _b;\n    return (_b = (_a2 = this.client) == null ? void 0 : _a2.logger) != null ? _b : logger_default.defaultLogger;\n  }\n  async doUri(method, uri, headers, body, params) {\n    if (!this.Request) {\n      return { error: new PartialErrorInfo(\"Request invoked before assigned to\", null, 500) };\n    }\n    return this.Request(method, uri, headers, params, body);\n  }\n  shouldFallback(errorInfo) {\n    const statusCode = errorInfo.statusCode;\n    return statusCode === 408 && !errorInfo.code || statusCode === 400 && !errorInfo.code || statusCode >= 500 && statusCode <= 504;\n  }\n}, _a.methods = [HttpMethods_default.Get, HttpMethods_default.Delete, HttpMethods_default.Post, HttpMethods_default.Put, HttpMethods_default.Patch], _a.methodsWithoutBody = [HttpMethods_default.Get, HttpMethods_default.Delete], _a.methodsWithBody = [HttpMethods_default.Post, HttpMethods_default.Put, HttpMethods_default.Patch], _a);\nvar http_default = Http2;\n\n// src/platform/web/lib/util/webstorage.ts\nvar test = \"ablyjs-storage-test\";\nvar globalObject3 = typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof window !== \"undefined\" ? window : self;\nvar Webstorage = class {\n  constructor() {\n    try {\n      globalObject3.sessionStorage.setItem(test, test);\n      globalObject3.sessionStorage.removeItem(test);\n      this.sessionSupported = true;\n    } catch (e) {\n      this.sessionSupported = false;\n    }\n    try {\n      globalObject3.localStorage.setItem(test, test);\n      globalObject3.localStorage.removeItem(test);\n      this.localSupported = true;\n    } catch (e) {\n      this.localSupported = false;\n    }\n  }\n  get(name) {\n    return this._get(name, false);\n  }\n  getSession(name) {\n    return this._get(name, true);\n  }\n  remove(name) {\n    return this._remove(name, false);\n  }\n  removeSession(name) {\n    return this._remove(name, true);\n  }\n  set(name, value, ttl) {\n    return this._set(name, value, ttl, false);\n  }\n  setSession(name, value, ttl) {\n    return this._set(name, value, ttl, true);\n  }\n  _set(name, value, ttl, session) {\n    const wrappedValue = { value };\n    if (ttl) {\n      wrappedValue.expires = Date.now() + ttl;\n    }\n    return this.storageInterface(session).setItem(name, JSON.stringify(wrappedValue));\n  }\n  _get(name, session) {\n    if (session && !this.sessionSupported)\n      throw new Error(\"Session Storage not supported\");\n    if (!session && !this.localSupported)\n      throw new Error(\"Local Storage not supported\");\n    const rawItem = this.storageInterface(session).getItem(name);\n    if (!rawItem)\n      return null;\n    const wrappedValue = JSON.parse(rawItem);\n    if (wrappedValue.expires && wrappedValue.expires < Date.now()) {\n      this.storageInterface(session).removeItem(name);\n      return null;\n    }\n    return wrappedValue.value;\n  }\n  _remove(name, session) {\n    return this.storageInterface(session).removeItem(name);\n  }\n  storageInterface(session) {\n    return session ? globalObject3.sessionStorage : globalObject3.localStorage;\n  }\n};\nvar webstorage_default = new Webstorage();\n\n// src/platform/web/config.ts\nvar globalObject4 = getGlobalObject();\nvar isVercelEdgeRuntime = typeof EdgeRuntime === \"string\";\nif (typeof Window === \"undefined\" && typeof WorkerGlobalScope === \"undefined\" && !isVercelEdgeRuntime) {\n  console.log(\n    \"Warning: this distribution of Ably is intended for browsers. On nodejs, please use the 'ably' package on npm\"\n  );\n}\nfunction allowComet() {\n  const loc = globalObject4.location;\n  return !globalObject4.WebSocket || !loc || !loc.origin || loc.origin.indexOf(\"http\") > -1;\n}\nfunction isWebWorkerContext() {\n  if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n    return true;\n  } else {\n    return false;\n  }\n}\nvar userAgent = globalObject4.navigator && globalObject4.navigator.userAgent.toString();\nvar currentUrl = globalObject4.location && globalObject4.location.href;\nvar Config = {\n  agent: \"browser\",\n  logTimestamps: true,\n  userAgent,\n  currentUrl,\n  binaryType: \"arraybuffer\",\n  WebSocket: globalObject4.WebSocket,\n  fetchSupported: !!globalObject4.fetch,\n  xhrSupported: globalObject4.XMLHttpRequest && \"withCredentials\" in new XMLHttpRequest(),\n  allowComet: allowComet(),\n  useProtocolHeartbeats: true,\n  supportsBinary: !!globalObject4.TextDecoder,\n  /* Per Paddy (https://ably-real-time.slack.com/archives/CURL4U2FP/p1705674537763479) web intentionally prefers JSON to MessagePack:\n   *\n   * > browsers' support for binary types in general was historically poor, and JSON transport performance is significantly better in a browser than msgpack. In modern browsers then binary is supported consistently, but I'd still expect that JSON encode/decode performance is dramatically better than msgpack in a browser.\n   */\n  preferBinary: false,\n  ArrayBuffer: globalObject4.ArrayBuffer,\n  atob: globalObject4.atob,\n  nextTick: typeof globalObject4.queueMicrotask === \"function\" ? (f) => globalObject4.queueMicrotask(f) : (f) => Promise.resolve().then(f),\n  addEventListener: globalObject4.addEventListener,\n  inspect: JSON.stringify,\n  stringByteSize: function(str) {\n    return globalObject4.TextDecoder && new globalObject4.TextEncoder().encode(str).length || str.length;\n  },\n  TextEncoder: globalObject4.TextEncoder,\n  TextDecoder: globalObject4.TextDecoder,\n  getRandomArrayBuffer: async function(byteLength) {\n    const byteArray = new Uint8Array(byteLength);\n    globalObject4.crypto.getRandomValues(byteArray);\n    return byteArray.buffer;\n  },\n  isWebworker: isWebWorkerContext(),\n  push: {\n    platform: \"browser\" /* Browser */,\n    formFactor: \"desktop\" /* Desktop */,\n    storage: webstorage_default\n  }\n};\nvar config_default = Config;\n\n// src/common/lib/transport/comettransport.ts\nfunction shouldBeErrorAction(err) {\n  const UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];\n  if (err.code) {\n    if (auth_default.isTokenErr(err))\n      return false;\n    if (UNRESOLVABLE_ERROR_CODES.includes(err.code))\n      return true;\n    return err.code >= 4e4 && err.code < 5e4;\n  } else {\n    return false;\n  }\n}\nfunction protocolMessageFromRawError(err) {\n  if (shouldBeErrorAction(err)) {\n    return [fromValues({ action: actions.ERROR, error: err })];\n  } else {\n    return [fromValues({ action: actions.DISCONNECTED, error: err })];\n  }\n}\nvar CometTransport = class extends transport_default {\n  constructor(connectionManager, auth, params) {\n    super(\n      connectionManager,\n      auth,\n      params,\n      /* binary not supported for comet so force JSON protocol */\n      true\n    );\n    /* Historical comment, back from when we supported JSONP:\n     *\n     * > For comet, we could do the auth update by aborting the current recv and\n     * > starting a new one with the new token, that'd be sufficient for realtime.\n     * > Problem is JSONP - you can't cancel truly abort a recv once started. So\n     * > we need to send an AUTH for jsonp. In which case it's simpler to keep all\n     * > comet transports the same and do it for all of them. So we send the AUTH\n     * > instead, and don't need to abort the recv\n     *\n     * Now that we’ve dropped JSONP support, we may be able to revisit the above;\n     * see https://github.com/ably/ably-js/issues/1214.\n     */\n    this.onAuthUpdated = (tokenDetails) => {\n      this.authParams = { access_token: tokenDetails.token };\n    };\n    this.stream = \"stream\" in params ? params.stream : true;\n    this.sendRequest = null;\n    this.recvRequest = null;\n    this.pendingCallback = null;\n    this.pendingItems = null;\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.connect()\", \"starting\");\n    transport_default.prototype.connect.call(this);\n    const params = this.params;\n    const options = params.options;\n    const host = params.host || options.primaryDomain;\n    const port = defaults_default.getPort(options);\n    const cometScheme = options.tls ? \"https://\" : \"http://\";\n    this.baseUri = cometScheme + host + \":\" + port + \"/comet/\";\n    const connectUri = this.baseUri + \"connect\";\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.connect()\", \"uri: \" + connectUri);\n    whenPromiseSettles(this.auth.getAuthParams(), (err, authParams) => {\n      if (err) {\n        this.disconnect(err);\n        return;\n      }\n      if (this.isDisposed) {\n        return;\n      }\n      this.authParams = authParams;\n      const connectParams = this.params.getConnectParams(authParams);\n      if (\"stream\" in connectParams)\n        this.stream = connectParams.stream;\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"CometTransport.connect()\",\n        \"connectParams:\" + toQueryString(connectParams)\n      );\n      let preconnected = false;\n      const connectRequest = this.recvRequest = this.createRequest(\n        connectUri,\n        null,\n        connectParams,\n        null,\n        this.stream ? XHRStates_default.REQ_RECV_STREAM : XHRStates_default.REQ_RECV\n      );\n      connectRequest.on(\"data\", (data) => {\n        if (!this.recvRequest) {\n          return;\n        }\n        if (!preconnected) {\n          preconnected = true;\n          this.emit(\"preconnect\");\n        }\n        this.onData(data);\n      });\n      connectRequest.on(\"complete\", (err2) => {\n        if (!this.recvRequest) {\n          err2 = err2 || new ErrorInfo(\"Request cancelled\", 80003, 400);\n        }\n        this.recvRequest = null;\n        if (!preconnected && !err2) {\n          preconnected = true;\n          this.emit(\"preconnect\");\n        }\n        this.onActivity();\n        if (err2) {\n          if (err2.code) {\n            this.onData(protocolMessageFromRawError(err2));\n          } else {\n            this.disconnect(err2);\n          }\n          return;\n        }\n        Platform.Config.nextTick(() => {\n          this.recv();\n        });\n      });\n      connectRequest.exec();\n    });\n  }\n  requestClose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.requestClose()\");\n    this._requestCloseOrDisconnect(true);\n  }\n  requestDisconnect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.requestDisconnect()\");\n    this._requestCloseOrDisconnect(false);\n  }\n  _requestCloseOrDisconnect(closing) {\n    const closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;\n    if (closeOrDisconnectUri) {\n      const request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, XHRStates_default.REQ_SEND);\n      request.on(\"complete\", (err) => {\n        if (err) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"CometTransport.request\" + (closing ? \"Close()\" : \"Disconnect()\"),\n            \"request returned err = \" + inspectError(err)\n          );\n          this.finish(\"disconnected\", err);\n        }\n      });\n      request.exec();\n    }\n  }\n  dispose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.dispose()\", \"\");\n    if (!this.isDisposed) {\n      this.isDisposed = true;\n      if (this.recvRequest) {\n        logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.dispose()\", \"aborting recv request\");\n        this.recvRequest.abort();\n        this.recvRequest = null;\n      }\n      this.finish(\"disconnected\", connectionerrors_default.disconnected());\n      Platform.Config.nextTick(() => {\n        this.emit(\"disposed\");\n      });\n    }\n  }\n  onConnect(message) {\n    var _a2;\n    if (this.isDisposed) {\n      return;\n    }\n    const connectionStr = (_a2 = message.connectionDetails) == null ? void 0 : _a2.connectionKey;\n    transport_default.prototype.onConnect.call(this, message);\n    const baseConnectionUri = this.baseUri + connectionStr;\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"CometTransport.onConnect()\", \"baseUri = \" + baseConnectionUri);\n    this.sendUri = baseConnectionUri + \"/send\";\n    this.recvUri = baseConnectionUri + \"/recv\";\n    this.closeUri = baseConnectionUri + \"/close\";\n    this.disconnectUri = baseConnectionUri + \"/disconnect\";\n  }\n  send(message) {\n    if (this.sendRequest) {\n      this.pendingItems = this.pendingItems || [];\n      this.pendingItems.push(message);\n      return;\n    }\n    const pendingItems = this.pendingItems || [];\n    pendingItems.push(message);\n    this.pendingItems = null;\n    this.sendItems(pendingItems);\n  }\n  sendAnyPending() {\n    const pendingItems = this.pendingItems;\n    if (!pendingItems) {\n      return;\n    }\n    this.pendingItems = null;\n    this.sendItems(pendingItems);\n  }\n  sendItems(items) {\n    const sendRequest = this.sendRequest = this.createRequest(\n      this.sendUri,\n      null,\n      this.authParams,\n      this.encodeRequest(items),\n      XHRStates_default.REQ_SEND\n    );\n    sendRequest.on(\"complete\", (err, data) => {\n      if (err)\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"CometTransport.sendItems()\",\n          \"on complete: err = \" + inspectError(err)\n        );\n      this.sendRequest = null;\n      if (err) {\n        if (err.code) {\n          this.onData(protocolMessageFromRawError(err));\n        } else {\n          this.disconnect(err);\n        }\n        return;\n      }\n      if (data) {\n        this.onData(data);\n      }\n      if (this.pendingItems) {\n        Platform.Config.nextTick(() => {\n          if (!this.sendRequest) {\n            this.sendAnyPending();\n          }\n        });\n      }\n    });\n    sendRequest.exec();\n  }\n  recv() {\n    if (this.recvRequest)\n      return;\n    if (!this.isConnected)\n      return;\n    const recvRequest = this.recvRequest = this.createRequest(\n      this.recvUri,\n      null,\n      this.authParams,\n      null,\n      this.stream ? XHRStates_default.REQ_RECV_STREAM : XHRStates_default.REQ_RECV_POLL\n    );\n    recvRequest.on(\"data\", (data) => {\n      this.onData(data);\n    });\n    recvRequest.on(\"complete\", (err) => {\n      this.recvRequest = null;\n      this.onActivity();\n      if (err) {\n        if (err.code) {\n          this.onData(protocolMessageFromRawError(err));\n        } else {\n          this.disconnect(err);\n        }\n        return;\n      }\n      Platform.Config.nextTick(() => {\n        this.recv();\n      });\n    });\n    recvRequest.exec();\n  }\n  onData(responseData) {\n    try {\n      const items = this.decodeResponse(responseData);\n      if (items && items.length)\n        for (let i = 0; i < items.length; i++)\n          this.onProtocolMessage(\n            fromDeserialized(\n              items[i],\n              this.connectionManager.realtime._RealtimePresence,\n              this.connectionManager.realtime._Annotations,\n              this.connectionManager.realtime._objectsPlugin\n            )\n          );\n    } catch (e) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"CometTransport.onData()\",\n        \"Unexpected exception handing channel event: \" + e.stack\n      );\n    }\n  }\n  encodeRequest(requestItems) {\n    return JSON.stringify(requestItems);\n  }\n  decodeResponse(responseData) {\n    if (typeof responseData == \"string\")\n      return JSON.parse(responseData);\n    return responseData;\n  }\n};\nvar comettransport_default = CometTransport;\n\n// src/platform/web/lib/http/request/xhrrequest.ts\nfunction isAblyError(responseBody, headers) {\n  return allToLowerCase(keysArray(headers)).includes(\"x-ably-errorcode\");\n}\nfunction getAblyError(responseBody, headers) {\n  if (isAblyError(responseBody, headers)) {\n    return responseBody.error && ErrorInfo.fromValues(responseBody.error);\n  }\n}\nvar noop3 = function() {\n};\nvar idCounter = 0;\nvar pendingRequests = {};\nfunction getHeader(xhr, header) {\n  return xhr.getResponseHeader && xhr.getResponseHeader(header);\n}\nfunction isEncodingChunked(xhr) {\n  return xhr.getResponseHeader && (xhr.getResponseHeader(\"transfer-encoding\") || !xhr.getResponseHeader(\"content-length\"));\n}\nfunction getHeadersAsObject(xhr) {\n  const headerPairs = xhr.getAllResponseHeaders().trim().split(\"\\r\\n\");\n  const headers = {};\n  for (let i = 0; i < headerPairs.length; i++) {\n    const parts = headerPairs[i].split(\":\").map((x) => x.trim());\n    headers[parts[0].toLowerCase()] = parts[1];\n  }\n  return headers;\n}\nvar XHRRequest = class _XHRRequest extends eventemitter_default {\n  constructor(uri, headers, params, body, requestMode, timeouts, logger, method) {\n    super(logger);\n    params = params || {};\n    params.rnd = cheapRandStr();\n    this.uri = uri + toQueryString(params);\n    this.headers = headers || {};\n    this.body = body;\n    this.method = method ? method.toUpperCase() : isNil(body) ? \"GET\" : \"POST\";\n    this.requestMode = requestMode;\n    this.timeouts = timeouts;\n    this.timedOut = false;\n    this.requestComplete = false;\n    this.id = String(++idCounter);\n    pendingRequests[this.id] = this;\n  }\n  static createRequest(uri, headers, params, body, requestMode, timeouts, logger, method) {\n    const _timeouts = timeouts || defaults_default.TIMEOUTS;\n    return new _XHRRequest(\n      uri,\n      headers,\n      copy(params),\n      body,\n      requestMode,\n      _timeouts,\n      logger,\n      method\n    );\n  }\n  complete(err, body, headers, unpacked, statusCode) {\n    if (!this.requestComplete) {\n      this.requestComplete = true;\n      if (!err && body) {\n        this.emit(\"data\", body);\n      }\n      this.emit(\"complete\", err, body, headers, unpacked, statusCode);\n      this.dispose();\n    }\n  }\n  abort() {\n    this.dispose();\n  }\n  exec() {\n    let headers = this.headers;\n    const timeout = this.requestMode == XHRStates_default.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout, timer = this.timer = setTimeout(() => {\n      this.timedOut = true;\n      xhr.abort();\n    }, timeout), method = this.method, xhr = this.xhr = new XMLHttpRequest(), accept = headers[\"accept\"];\n    let body = this.body;\n    let responseType = \"text\";\n    if (!accept) {\n      headers[\"accept\"] = \"application/json\";\n    } else if (accept.indexOf(\"application/x-msgpack\") === 0) {\n      responseType = \"arraybuffer\";\n    }\n    if (body) {\n      const contentType = headers[\"content-type\"] || (headers[\"content-type\"] = \"application/json\");\n      if (contentType.indexOf(\"application/json\") > -1 && typeof body != \"string\")\n        body = JSON.stringify(body);\n    }\n    xhr.open(method, this.uri, true);\n    xhr.responseType = responseType;\n    if (\"authorization\" in headers) {\n      xhr.withCredentials = true;\n    }\n    for (const h in headers)\n      xhr.setRequestHeader(h, headers[h]);\n    const errorHandler = (errorEvent, message, code, statusCode2) => {\n      var _a2;\n      let errorMessage = message + \" (event type: \" + errorEvent.type + \")\";\n      if ((_a2 = this == null ? void 0 : this.xhr) == null ? void 0 : _a2.statusText)\n        errorMessage += \", current statusText is \" + this.xhr.statusText;\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Request.on\" + errorEvent.type + \"()\", errorMessage);\n      this.complete(new PartialErrorInfo(errorMessage, code, statusCode2));\n    };\n    xhr.onerror = (errorEvent) => {\n      errorHandler(errorEvent, \"XHR error occurred\", null, 400);\n    };\n    xhr.onabort = (errorEvent) => {\n      if (this.timedOut) {\n        errorHandler(errorEvent, \"Request aborted due to request timeout expiring\", null, 408);\n      } else {\n        errorHandler(errorEvent, \"Request cancelled\", null, 400);\n      }\n    };\n    xhr.ontimeout = (errorEvent) => {\n      errorHandler(errorEvent, \"Request timed out\", null, 408);\n    };\n    let streaming;\n    let statusCode;\n    let successResponse;\n    let streamPos = 0;\n    let unpacked = false;\n    const onResponse = () => {\n      clearTimeout(timer);\n      successResponse = statusCode < 400;\n      if (statusCode == 204) {\n        this.complete(null, null, null, null, statusCode);\n        return;\n      }\n      streaming = this.requestMode == XHRStates_default.REQ_RECV_STREAM && successResponse && isEncodingChunked(xhr);\n    };\n    const onEnd = () => {\n      let parsedResponse;\n      try {\n        const contentType = getHeader(xhr, \"content-type\");\n        const json = contentType ? contentType.indexOf(\"application/json\") >= 0 : xhr.responseType == \"text\";\n        if (json) {\n          const jsonResponseBody = xhr.responseType === \"arraybuffer\" ? Platform.BufferUtils.utf8Decode(xhr.response) : String(xhr.responseText);\n          if (jsonResponseBody.length) {\n            parsedResponse = JSON.parse(jsonResponseBody);\n          } else {\n            parsedResponse = jsonResponseBody;\n          }\n          unpacked = true;\n        } else {\n          parsedResponse = xhr.response;\n        }\n        if (parsedResponse.response !== void 0) {\n          statusCode = parsedResponse.statusCode;\n          successResponse = statusCode < 400;\n          headers = parsedResponse.headers;\n          parsedResponse = parsedResponse.response;\n        } else {\n          headers = getHeadersAsObject(xhr);\n        }\n      } catch (e) {\n        this.complete(new PartialErrorInfo(\"Malformed response body from server: \" + e.message, null, 400));\n        return;\n      }\n      if (successResponse || Array.isArray(parsedResponse)) {\n        this.complete(null, parsedResponse, headers, unpacked, statusCode);\n        return;\n      }\n      let err = getAblyError(parsedResponse, headers);\n      if (!err) {\n        err = new PartialErrorInfo(\n          \"Error response received from server: \" + statusCode + \" body was: \" + Platform.Config.inspect(parsedResponse),\n          null,\n          statusCode\n        );\n      }\n      this.complete(err, parsedResponse, headers, unpacked, statusCode);\n    };\n    function onProgress() {\n      const responseText = xhr.responseText;\n      const bodyEnd = responseText.length - 1;\n      let idx, chunk;\n      while (streamPos < bodyEnd && (idx = responseText.indexOf(\"\\n\", streamPos)) > -1) {\n        chunk = responseText.slice(streamPos, idx);\n        streamPos = idx + 1;\n        onChunk(chunk);\n      }\n    }\n    const onChunk = (chunk) => {\n      try {\n        chunk = JSON.parse(chunk);\n      } catch (e) {\n        this.complete(new PartialErrorInfo(\"Malformed response body from server: \" + e.message, null, 400));\n        return;\n      }\n      this.emit(\"data\", chunk);\n    };\n    const onStreamEnd = () => {\n      onProgress();\n      this.streamComplete = true;\n      Platform.Config.nextTick(() => {\n        this.complete();\n      });\n    };\n    xhr.onreadystatechange = () => {\n      const readyState = xhr.readyState;\n      if (readyState < 3)\n        return;\n      if (xhr.status !== 0) {\n        if (statusCode === void 0) {\n          statusCode = xhr.status;\n          onResponse();\n        }\n        if (readyState == 3 && streaming) {\n          onProgress();\n        } else if (readyState == 4) {\n          if (streaming)\n            onStreamEnd();\n          else\n            onEnd();\n        }\n      }\n    };\n    xhr.send(body);\n  }\n  dispose() {\n    const xhr = this.xhr;\n    if (xhr) {\n      xhr.onreadystatechange = xhr.onerror = xhr.onabort = xhr.ontimeout = noop3;\n      this.xhr = null;\n      const timer = this.timer;\n      if (timer) {\n        clearTimeout(timer);\n        this.timer = null;\n      }\n      if (!this.requestComplete)\n        xhr.abort();\n    }\n    delete pendingRequests[this.id];\n  }\n};\nvar xhrrequest_default = XHRRequest;\n\n// src/platform/web/lib/transport/xhrpollingtransport.ts\nvar shortName2 = TransportNames.XhrPolling;\nvar XHRPollingTransport = class extends comettransport_default {\n  constructor(connectionManager, auth, params) {\n    super(connectionManager, auth, params);\n    this.shortName = shortName2;\n    params.stream = false;\n    this.shortName = shortName2;\n  }\n  static isAvailable() {\n    return !!(Platform.Config.xhrSupported && Platform.Config.allowComet);\n  }\n  toString() {\n    return \"XHRPollingTransport; uri=\" + this.baseUri + \"; isConnected=\" + this.isConnected;\n  }\n  createRequest(uri, headers, params, body, requestMode) {\n    return xhrrequest_default.createRequest(uri, headers, params, body, requestMode, this.timeouts, this.logger);\n  }\n};\nvar xhrpollingtransport_default = XHRPollingTransport;\n\n// src/platform/web/lib/transport/index.ts\nvar order = [\"xhr_polling\"];\nvar defaultTransports = {\n  order,\n  bundledImplementations: {\n    web_socket: websockettransport_default,\n    xhr_polling: xhrpollingtransport_default\n  }\n};\nvar transport_default2 = defaultTransports;\n\n// src/platform/web/lib/util/defaults.ts\nvar Defaults2 = {\n  connectivityCheckUrl: \"https://internet-up.ably-realtime.com/is-the-internet-up.txt\",\n  wsConnectivityCheckUrl: \"wss://ws-up.ably-realtime.com\",\n  /* Order matters here: the base transport is the leftmost one in the\n   * intersection of baseTransportOrder and the transports clientOption that's\n   * supported. */\n  defaultTransports: [TransportNames.XhrPolling, TransportNames.WebSocket]\n};\nvar defaults_default2 = Defaults2;\n\n// src/platform/web/lib/util/msgpack.ts\nfunction inspect(buffer) {\n  if (buffer === void 0)\n    return \"undefined\";\n  let view;\n  let type;\n  if (buffer instanceof ArrayBuffer) {\n    type = \"ArrayBuffer\";\n    view = new DataView(buffer);\n  } else if (buffer instanceof DataView) {\n    type = \"DataView\";\n    view = buffer;\n  }\n  if (!view)\n    return JSON.stringify(buffer);\n  const bytes = [];\n  for (let i = 0; i < buffer.byteLength; i++) {\n    if (i > 20) {\n      bytes.push(\"...\");\n      break;\n    }\n    let byte_ = view.getUint8(i).toString(16);\n    if (byte_.length === 1)\n      byte_ = \"0\" + byte_;\n    bytes.push(byte_);\n  }\n  return \"<\" + type + \" \" + bytes.join(\" \") + \">\";\n}\nfunction utf8Write(view, offset, string) {\n  for (let i = 0, l = string.length; i < l; i++) {\n    const codePoint = string.charCodeAt(i);\n    if (codePoint < 128) {\n      view.setUint8(offset++, codePoint >>> 0 & 127 | 0);\n      continue;\n    }\n    if (codePoint < 2048) {\n      view.setUint8(offset++, codePoint >>> 6 & 31 | 192);\n      view.setUint8(offset++, codePoint >>> 0 & 63 | 128);\n      continue;\n    }\n    if (codePoint < 65536) {\n      view.setUint8(offset++, codePoint >>> 12 & 15 | 224);\n      view.setUint8(offset++, codePoint >>> 6 & 63 | 128);\n      view.setUint8(offset++, codePoint >>> 0 & 63 | 128);\n      continue;\n    }\n    if (codePoint < 1114112) {\n      view.setUint8(offset++, codePoint >>> 18 & 7 | 240);\n      view.setUint8(offset++, codePoint >>> 12 & 63 | 128);\n      view.setUint8(offset++, codePoint >>> 6 & 63 | 128);\n      view.setUint8(offset++, codePoint >>> 0 & 63 | 128);\n      continue;\n    }\n    throw new Error(\"bad codepoint \" + codePoint);\n  }\n}\nfunction utf8Read(view, offset, length) {\n  let string = \"\";\n  for (let i = offset, end = offset + length; i < end; i++) {\n    const byte_ = view.getUint8(i);\n    if ((byte_ & 128) === 0) {\n      string += String.fromCharCode(byte_);\n      continue;\n    }\n    if ((byte_ & 224) === 192) {\n      string += String.fromCharCode((byte_ & 15) << 6 | view.getUint8(++i) & 63);\n      continue;\n    }\n    if ((byte_ & 240) === 224) {\n      string += String.fromCharCode(\n        (byte_ & 15) << 12 | (view.getUint8(++i) & 63) << 6 | (view.getUint8(++i) & 63) << 0\n      );\n      continue;\n    }\n    if ((byte_ & 248) === 240) {\n      string += String.fromCharCode(\n        (byte_ & 7) << 18 | (view.getUint8(++i) & 63) << 12 | (view.getUint8(++i) & 63) << 6 | (view.getUint8(++i) & 63) << 0\n      );\n      continue;\n    }\n    throw new Error(\"Invalid byte \" + byte_.toString(16));\n  }\n  return string;\n}\nfunction utf8ByteCount(string) {\n  let count = 0;\n  for (let i = 0, l = string.length; i < l; i++) {\n    const codePoint = string.charCodeAt(i);\n    if (codePoint < 128) {\n      count += 1;\n      continue;\n    }\n    if (codePoint < 2048) {\n      count += 2;\n      continue;\n    }\n    if (codePoint < 65536) {\n      count += 3;\n      continue;\n    }\n    if (codePoint < 1114112) {\n      count += 4;\n      continue;\n    }\n    throw new Error(\"bad codepoint \" + codePoint);\n  }\n  return count;\n}\nfunction encode2(value, sparse) {\n  const size = sizeof(value, sparse);\n  if (size === 0)\n    return void 0;\n  const buffer = new ArrayBuffer(size);\n  const view = new DataView(buffer);\n  _encode(value, view, 0, sparse);\n  return buffer;\n}\nvar SH_L_32 = (1 << 16) * (1 << 16);\nvar SH_R_32 = 1 / SH_L_32;\nfunction getInt64(view, offset) {\n  offset = offset || 0;\n  return view.getInt32(offset) * SH_L_32 + view.getUint32(offset + 4);\n}\nfunction getUint64(view, offset) {\n  offset = offset || 0;\n  return view.getUint32(offset) * SH_L_32 + view.getUint32(offset + 4);\n}\nfunction setInt64(view, offset, val) {\n  if (val < 9223372036854776e3) {\n    view.setInt32(offset, Math.floor(val * SH_R_32));\n    view.setInt32(offset + 4, val & -1);\n  } else {\n    view.setUint32(offset, 2147483647);\n    view.setUint32(offset + 4, 2147483647);\n  }\n}\nfunction setUint64(view, offset, val) {\n  if (val < 18446744073709552e3) {\n    view.setUint32(offset, Math.floor(val * SH_R_32));\n    view.setInt32(offset + 4, val & -1);\n  } else {\n    view.setUint32(offset, 4294967295);\n    view.setUint32(offset + 4, 4294967295);\n  }\n}\nvar Decoder = class {\n  constructor(view, offset) {\n    this.map = (length) => {\n      const value = {};\n      for (let i = 0; i < length; i++) {\n        const key = this.parse();\n        value[key] = this.parse();\n      }\n      return value;\n    };\n    this.bin = (length) => {\n      const value = new ArrayBuffer(length);\n      new Uint8Array(value).set(new Uint8Array(this.view.buffer, this.offset, length), 0);\n      this.offset += length;\n      return value;\n    };\n    this.buf = this.bin;\n    this.str = (length) => {\n      const value = utf8Read(this.view, this.offset, length);\n      this.offset += length;\n      return value;\n    };\n    this.array = (length) => {\n      const value = new Array(length);\n      for (let i = 0; i < length; i++) {\n        value[i] = this.parse();\n      }\n      return value;\n    };\n    this.ext = (length) => {\n      this.offset += length;\n      return {\n        type: this.view.getInt8(this.offset),\n        data: this.buf(length)\n      };\n    };\n    this.parse = () => {\n      const type = this.view.getUint8(this.offset);\n      let value, length;\n      if ((type & 128) === 0) {\n        this.offset++;\n        return type;\n      }\n      if ((type & 240) === 128) {\n        length = type & 15;\n        this.offset++;\n        return this.map(length);\n      }\n      if ((type & 240) === 144) {\n        length = type & 15;\n        this.offset++;\n        return this.array(length);\n      }\n      if ((type & 224) === 160) {\n        length = type & 31;\n        this.offset++;\n        return this.str(length);\n      }\n      if ((type & 224) === 224) {\n        value = this.view.getInt8(this.offset);\n        this.offset++;\n        return value;\n      }\n      switch (type) {\n        case 192:\n          this.offset++;\n          return null;\n        case 193:\n          this.offset++;\n          return void 0;\n        case 194:\n          this.offset++;\n          return false;\n        case 195:\n          this.offset++;\n          return true;\n        case 196:\n          length = this.view.getUint8(this.offset + 1);\n          this.offset += 2;\n          return this.bin(length);\n        case 197:\n          length = this.view.getUint16(this.offset + 1);\n          this.offset += 3;\n          return this.bin(length);\n        case 198:\n          length = this.view.getUint32(this.offset + 1);\n          this.offset += 5;\n          return this.bin(length);\n        case 199:\n          length = this.view.getUint8(this.offset + 1);\n          this.offset += 2;\n          return this.ext(length);\n        case 200:\n          length = this.view.getUint16(this.offset + 1);\n          this.offset += 3;\n          return this.ext(length);\n        case 201:\n          length = this.view.getUint32(this.offset + 1);\n          this.offset += 5;\n          return this.ext(length);\n        case 202:\n          value = this.view.getFloat32(this.offset + 1);\n          this.offset += 5;\n          return value;\n        case 203:\n          value = this.view.getFloat64(this.offset + 1);\n          this.offset += 9;\n          return value;\n        case 204:\n          value = this.view.getUint8(this.offset + 1);\n          this.offset += 2;\n          return value;\n        case 205:\n          value = this.view.getUint16(this.offset + 1);\n          this.offset += 3;\n          return value;\n        case 206:\n          value = this.view.getUint32(this.offset + 1);\n          this.offset += 5;\n          return value;\n        case 207:\n          value = getUint64(this.view, this.offset + 1);\n          this.offset += 9;\n          return value;\n        case 208:\n          value = this.view.getInt8(this.offset + 1);\n          this.offset += 2;\n          return value;\n        case 209:\n          value = this.view.getInt16(this.offset + 1);\n          this.offset += 3;\n          return value;\n        case 210:\n          value = this.view.getInt32(this.offset + 1);\n          this.offset += 5;\n          return value;\n        case 211:\n          value = getInt64(this.view, this.offset + 1);\n          this.offset += 9;\n          return value;\n        case 212:\n          length = 1;\n          this.offset++;\n          return this.ext(length);\n        case 213:\n          length = 2;\n          this.offset++;\n          return this.ext(length);\n        case 214:\n          length = 4;\n          this.offset++;\n          return this.ext(length);\n        case 215:\n          length = 8;\n          this.offset++;\n          return this.ext(length);\n        case 216:\n          length = 16;\n          this.offset++;\n          return this.ext(length);\n        case 217:\n          length = this.view.getUint8(this.offset + 1);\n          this.offset += 2;\n          return this.str(length);\n        case 218:\n          length = this.view.getUint16(this.offset + 1);\n          this.offset += 3;\n          return this.str(length);\n        case 219:\n          length = this.view.getUint32(this.offset + 1);\n          this.offset += 5;\n          return this.str(length);\n        case 220:\n          length = this.view.getUint16(this.offset + 1);\n          this.offset += 3;\n          return this.array(length);\n        case 221:\n          length = this.view.getUint32(this.offset + 1);\n          this.offset += 5;\n          return this.array(length);\n        case 222:\n          length = this.view.getUint16(this.offset + 1);\n          this.offset += 3;\n          return this.map(length);\n        case 223:\n          length = this.view.getUint32(this.offset + 1);\n          this.offset += 5;\n          return this.map(length);\n      }\n      throw new Error(\"Unknown type 0x\" + type.toString(16));\n    };\n    this.offset = offset || 0;\n    this.view = view;\n  }\n};\nfunction decode2(buffer) {\n  const view = new DataView(buffer);\n  const decoder = new Decoder(view);\n  const value = decoder.parse();\n  if (decoder.offset !== buffer.byteLength)\n    throw new Error(buffer.byteLength - decoder.offset + \" trailing bytes\");\n  return value;\n}\nfunction encodeableKeys(value, sparse) {\n  return Object.keys(value).filter(function(e) {\n    const val = value[e], type = typeof val;\n    return (!sparse || val !== void 0 && val !== null) && (\"function\" !== type || !!val.toJSON);\n  });\n}\nfunction _encode(value, view, offset, sparse) {\n  const type = typeof value;\n  if (typeof value === \"string\") {\n    const length = utf8ByteCount(value);\n    if (length < 32) {\n      view.setUint8(offset, length | 160);\n      utf8Write(view, offset + 1, value);\n      return 1 + length;\n    }\n    if (length < 256) {\n      view.setUint8(offset, 217);\n      view.setUint8(offset + 1, length);\n      utf8Write(view, offset + 2, value);\n      return 2 + length;\n    }\n    if (length < 65536) {\n      view.setUint8(offset, 218);\n      view.setUint16(offset + 1, length);\n      utf8Write(view, offset + 3, value);\n      return 3 + length;\n    }\n    if (length < 4294967296) {\n      view.setUint8(offset, 219);\n      view.setUint32(offset + 1, length);\n      utf8Write(view, offset + 5, value);\n      return 5 + length;\n    }\n  }\n  if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {\n    value = value.buffer;\n  }\n  if (value instanceof ArrayBuffer) {\n    const length = value.byteLength;\n    if (length < 256) {\n      view.setUint8(offset, 196);\n      view.setUint8(offset + 1, length);\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 2);\n      return 2 + length;\n    }\n    if (length < 65536) {\n      view.setUint8(offset, 197);\n      view.setUint16(offset + 1, length);\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 3);\n      return 3 + length;\n    }\n    if (length < 4294967296) {\n      view.setUint8(offset, 198);\n      view.setUint32(offset + 1, length);\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 5);\n      return 5 + length;\n    }\n  }\n  if (typeof value === \"number\") {\n    if (Math.floor(value) !== value) {\n      view.setUint8(offset, 203);\n      view.setFloat64(offset + 1, value);\n      return 9;\n    }\n    if (value >= 0) {\n      if (value < 128) {\n        view.setUint8(offset, value);\n        return 1;\n      }\n      if (value < 256) {\n        view.setUint8(offset, 204);\n        view.setUint8(offset + 1, value);\n        return 2;\n      }\n      if (value < 65536) {\n        view.setUint8(offset, 205);\n        view.setUint16(offset + 1, value);\n        return 3;\n      }\n      if (value < 4294967296) {\n        view.setUint8(offset, 206);\n        view.setUint32(offset + 1, value);\n        return 5;\n      }\n      if (value < 18446744073709552e3) {\n        view.setUint8(offset, 207);\n        setUint64(view, offset + 1, value);\n        return 9;\n      }\n      throw new Error(\"Number too big 0x\" + value.toString(16));\n    }\n    if (value >= -32) {\n      view.setInt8(offset, value);\n      return 1;\n    }\n    if (value >= -128) {\n      view.setUint8(offset, 208);\n      view.setInt8(offset + 1, value);\n      return 2;\n    }\n    if (value >= -32768) {\n      view.setUint8(offset, 209);\n      view.setInt16(offset + 1, value);\n      return 3;\n    }\n    if (value >= -2147483648) {\n      view.setUint8(offset, 210);\n      view.setInt32(offset + 1, value);\n      return 5;\n    }\n    if (value >= -9223372036854776e3) {\n      view.setUint8(offset, 211);\n      setInt64(view, offset + 1, value);\n      return 9;\n    }\n    throw new Error(\"Number too small -0x\" + (-value).toString(16).substr(1));\n  }\n  if (type === \"undefined\") {\n    if (sparse)\n      return 0;\n    view.setUint8(offset, 212);\n    view.setUint8(offset + 1, 0);\n    view.setUint8(offset + 2, 0);\n    return 3;\n  }\n  if (value === null) {\n    if (sparse)\n      return 0;\n    view.setUint8(offset, 192);\n    return 1;\n  }\n  if (type === \"boolean\") {\n    view.setUint8(offset, value ? 195 : 194);\n    return 1;\n  }\n  if (\"function\" === typeof value.toJSON)\n    return _encode(value.toJSON(), view, offset, sparse);\n  if (type === \"object\") {\n    let length, size = 0;\n    let keys;\n    const isArray = Array.isArray(value);\n    if (isArray) {\n      length = value.length;\n    } else {\n      keys = encodeableKeys(value, sparse);\n      length = keys.length;\n    }\n    if (length < 16) {\n      view.setUint8(offset, length | (isArray ? 144 : 128));\n      size = 1;\n    } else if (length < 65536) {\n      view.setUint8(offset, isArray ? 220 : 222);\n      view.setUint16(offset + 1, length);\n      size = 3;\n    } else if (length < 4294967296) {\n      view.setUint8(offset, isArray ? 221 : 223);\n      view.setUint32(offset + 1, length);\n      size = 5;\n    }\n    if (isArray) {\n      for (let i = 0; i < length; i++) {\n        size += _encode(value[i], view, offset + size, sparse);\n      }\n    } else if (keys) {\n      for (let i = 0; i < length; i++) {\n        const key = keys[i];\n        size += _encode(key, view, offset + size);\n        size += _encode(value[key], view, offset + size, sparse);\n      }\n    }\n    return size;\n  }\n  if (type === \"function\")\n    return 0;\n  throw new Error(\"Unknown type \" + type);\n}\nfunction sizeof(value, sparse) {\n  const type = typeof value;\n  if (type === \"string\") {\n    const length = utf8ByteCount(value);\n    if (length < 32) {\n      return 1 + length;\n    }\n    if (length < 256) {\n      return 2 + length;\n    }\n    if (length < 65536) {\n      return 3 + length;\n    }\n    if (length < 4294967296) {\n      return 5 + length;\n    }\n  }\n  if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {\n    value = value.buffer;\n  }\n  if (value instanceof ArrayBuffer) {\n    const length = value.byteLength;\n    if (length < 256) {\n      return 2 + length;\n    }\n    if (length < 65536) {\n      return 3 + length;\n    }\n    if (length < 4294967296) {\n      return 5 + length;\n    }\n  }\n  if (typeof value === \"number\") {\n    if (Math.floor(value) !== value)\n      return 9;\n    if (value >= 0) {\n      if (value < 128)\n        return 1;\n      if (value < 256)\n        return 2;\n      if (value < 65536)\n        return 3;\n      if (value < 4294967296)\n        return 5;\n      if (value < 18446744073709552e3)\n        return 9;\n      throw new Error(\"Number too big 0x\" + value.toString(16));\n    }\n    if (value >= -32)\n      return 1;\n    if (value >= -128)\n      return 2;\n    if (value >= -32768)\n      return 3;\n    if (value >= -2147483648)\n      return 5;\n    if (value >= -9223372036854776e3)\n      return 9;\n    throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n  }\n  if (type === \"boolean\")\n    return 1;\n  if (value === null)\n    return sparse ? 0 : 1;\n  if (value === void 0)\n    return sparse ? 0 : 3;\n  if (\"function\" === typeof value.toJSON)\n    return sizeof(value.toJSON(), sparse);\n  if (type === \"object\") {\n    let length, size = 0;\n    if (Array.isArray(value)) {\n      length = value.length;\n      for (let i = 0; i < length; i++) {\n        size += sizeof(value[i], sparse);\n      }\n    } else {\n      const keys = encodeableKeys(value, sparse);\n      length = keys.length;\n      for (let i = 0; i < length; i++) {\n        const key = keys[i];\n        size += sizeof(key) + sizeof(value[key], sparse);\n      }\n    }\n    if (length < 16) {\n      return 1 + size;\n    }\n    if (length < 65536) {\n      return 3 + size;\n    }\n    if (length < 4294967296) {\n      return 5 + size;\n    }\n    throw new Error(\"Array or object too long 0x\" + length.toString(16));\n  }\n  if (type === \"function\")\n    return 0;\n  throw new Error(\"Unknown type \" + type);\n}\nvar msgpack_default = {\n  encode: encode2,\n  decode: decode2,\n  inspect,\n  utf8Write,\n  utf8Read,\n  utf8ByteCount\n};\n\n// src/platform/web/lib/http/request/fetchrequest.ts\nfunction isAblyError2(responseBody, headers) {\n  return !!headers.get(\"x-ably-errorcode\");\n}\nfunction getAblyError2(responseBody, headers) {\n  if (isAblyError2(responseBody, headers)) {\n    return responseBody.error && ErrorInfo.fromValues(responseBody.error);\n  }\n}\nfunction convertHeaders(headers) {\n  const result = {};\n  headers.forEach((value, key) => {\n    result[key] = value;\n  });\n  return result;\n}\nasync function fetchRequest(method, client, uri, headers, params, body) {\n  const fetchHeaders = new Headers(headers || {});\n  const _method = method ? method.toUpperCase() : isNil(body) ? \"GET\" : \"POST\";\n  const controller = new AbortController();\n  let timeout;\n  const timeoutPromise = new Promise((resolve) => {\n    timeout = setTimeout(\n      () => {\n        controller.abort();\n        resolve({ error: new PartialErrorInfo(\"Request timed out\", null, 408) });\n      },\n      client ? client.options.timeouts.httpRequestTimeout : defaults_default.TIMEOUTS.httpRequestTimeout\n    );\n  });\n  const requestInit = {\n    method: _method,\n    headers: fetchHeaders,\n    body,\n    signal: controller.signal\n  };\n  if (!Platform.Config.isWebworker) {\n    requestInit.credentials = fetchHeaders.has(\"authorization\") ? \"include\" : \"same-origin\";\n  }\n  const resultPromise = (async () => {\n    try {\n      const urlParams = new URLSearchParams(params || {});\n      urlParams.set(\"rnd\", cheapRandStr());\n      const preparedURI = uri + \"?\" + urlParams;\n      const res = await getGlobalObject().fetch(preparedURI, requestInit);\n      clearTimeout(timeout);\n      if (res.status == 204) {\n        return { error: null, statusCode: res.status };\n      }\n      const contentType = res.headers.get(\"Content-Type\");\n      let body2;\n      if (contentType && contentType.indexOf(\"application/x-msgpack\") > -1) {\n        body2 = await res.arrayBuffer();\n      } else if (contentType && contentType.indexOf(\"application/json\") > -1) {\n        body2 = await res.json();\n      } else {\n        body2 = await res.text();\n      }\n      const unpacked = !!contentType && contentType.indexOf(\"application/x-msgpack\") === -1;\n      const headers2 = convertHeaders(res.headers);\n      if (!res.ok) {\n        const error = getAblyError2(body2, res.headers) || new PartialErrorInfo(\n          \"Error response received from server: \" + res.status + \" body was: \" + Platform.Config.inspect(body2),\n          null,\n          res.status\n        );\n        return { error, body: body2, headers: headers2, unpacked, statusCode: res.status };\n      } else {\n        return { error: null, body: body2, headers: headers2, unpacked, statusCode: res.status };\n      }\n    } catch (error) {\n      clearTimeout(timeout);\n      return { error };\n    }\n  })();\n  return Promise.race([timeoutPromise, resultPromise]);\n}\n\n// src/platform/web/lib/http/request/index.ts\nvar defaultBundledRequestImplementations = {\n  XHRRequest: xhrrequest_default,\n  FetchRequest: fetchRequest\n};\n\n// src/platform/web/index.ts\nvar Crypto = createCryptoClass(config_default, bufferutils_default);\nPlatform.Crypto = Crypto;\nPlatform.BufferUtils = bufferutils_default;\nPlatform.Http = http_default;\nPlatform.Config = config_default;\nPlatform.Transports = transport_default2;\nPlatform.WebStorage = webstorage_default;\nfor (const clientClass of [DefaultRest, DefaultRealtime]) {\n  clientClass.Crypto = Crypto;\n  clientClass._MsgPack = msgpack_default;\n}\nhttp_default.bundledRequestImplementations = defaultBundledRequestImplementations;\nlogger_default.initLogHandlers();\nPlatform.Defaults = getDefaults(defaults_default2);\nif (Platform.Config.agent) {\n  Platform.Defaults.agent += \" \" + Platform.Config.agent;\n}\nvar web_default = {\n  ErrorInfo,\n  Rest: DefaultRest,\n  Realtime: DefaultRealtime,\n  msgpack: msgpack_default,\n  makeProtocolMessageFromDeserialized: makeFromDeserializedWithDependencies\n};\nif (typeof module.exports == \"object\" && typeof exports == \"object\") {\n  var __cp = (to, from, except, desc) => {\n    if ((from && typeof from === \"object\") || typeof from === \"function\") {\n      for (let key of Object.getOwnPropertyNames(from)) {\n        if (!Object.prototype.hasOwnProperty.call(to, key) && key !== except)\n        Object.defineProperty(to, key, {\n          get: () => from[key],\n          enumerable: !(desc = Object.getOwnPropertyDescriptor(from, key)) || desc.enumerable,\n        });\n      }\n    }\n    return to;\n  };\n  module.exports = __cp(module.exports, exports);\n}\nreturn module.exports;\n}))\n//# sourceMappingURL=ably.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hYmx5L2J1aWxkL2FibHkuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBdUQ7QUFDL0Q7QUFDQSxNQUFNLEtBQUssRUFNTjtBQUNMLEdBQUc7QUFDSDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLHFCQUFNLG1CQUFtQixxQkFBTTtBQUN6RDtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhLHlEQUF5RCxJQUFJO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVEseUNBQXlDLFFBQVEsdUNBQXVDLFFBQVEsZ0JBQWdCLFFBQVE7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVUsY0FBYyxRQUFRLGtDQUFrQyxRQUFRLHVDQUF1QyxRQUFRLGdCQUFnQixRQUFRO0FBQzVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFFBQVE7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb1FBQW9RLHdCQUF3QjtBQUM1UjtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELG1CQUFtQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUI7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTyxtQ0FBbUMsWUFBWTtBQUN0RjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0IseUJBQXlCLFVBQVUsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUE4QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFFBQVE7QUFDUixxQkFBcUI7QUFDckIsUUFBUTtBQUNSLHFCQUFxQjtBQUNyQjtBQUNBLE1BQU07QUFDTixtQkFBbUI7QUFDbkIsTUFBTTtBQUNOLG1CQUFtQjtBQUNuQixNQUFNO0FBQ04sbUJBQW1CO0FBQ25CLE1BQU07QUFDTixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdKQUF3SixxQkFBcUIsZUFBZTtBQUM1TDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QzdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJRQUEyUSxRQUFRO0FBQ25SO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUMsa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpS0FBaUs7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdDQUFnQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxJQUFJLFdBQVc7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SDtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrSEFBa0g7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQXVCO0FBQ3ZEO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsdUJBQXVCO0FBQ3ZELHFDQUFxQyw0QkFBNEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNERBQTREO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7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QUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFEQUFxRDtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOEJBQThCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9CQUFvQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2QkFBNkI7QUFDdEQsTUFBTTtBQUNOLHlCQUF5Qiw2QkFBNkI7QUFDdEQsTUFBTTtBQUNOLDJFQUEyRTtBQUMzRTtBQUNBLHlCQUF5Qiw2REFBNkQ7QUFDdEYsTUFBTTtBQUNOO0FBQ0E7QUFDQSx5QkFBeUIseUVBQXlFO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHFCQUFxQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrQkFBa0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU8sRUFBRSxxQkFBcUIsR0FBRyxrQkFBa0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4QkFBOEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxtQ0FBbUM7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxtQ0FBbUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsNkRBQTZEO0FBQ3JJO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixxQkFBTSxtQkFBbUIscUJBQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQ0FBbUM7QUFDNUQsSUFBSTtBQUNKLHlCQUF5QiwwQ0FBMEM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMEJBQTBCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZEQUE2RDtBQUMvRSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixRQUFRO0FBQ1IsaUJBQWlCO0FBQ2pCO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL25vZGVfbW9kdWxlcy9hYmx5L2J1aWxkL2FibHkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypAbGljZW5zZSBDb3B5cmlnaHQgMjAxNS0yMDIyIEFibHkgUmVhbC10aW1lIEx0ZCAoYWJseS5jb20pXG5cbkFibHkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYyLjE0LjBcbmh0dHBzOi8vZ2l0aHViLmNvbS9hYmx5L2FibHktanNcblxuUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbmNlIHYyLjAqLyhmdW5jdGlvbiAoZywgZikge1xuICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBleHBvcnRzICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIG1vZHVsZSkge1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmKCk7XG4gICAgfSBlbHNlIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICBkZWZpbmUoW10sIGYpO1xuICAgIH0gZWxzZSBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cykge1xuICAgICAgZXhwb3J0c1tcIkFibHlcIl0gPSBmKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdbXCJBYmx5XCJdID0gZigpO1xuICAgIH1cbiAgfSh0aGlzLCAoKSA9PiB7XG52YXIgZXhwb3J0cyA9IHt9O1xudmFyIG1vZHVsZSA9IHsgZXhwb3J0cyB9O1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xudmFyIF9fb2JqUmVzdCA9IChzb3VyY2UsIGV4Y2x1ZGUpID0+IHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoc291cmNlLCBwcm9wKSAmJiBleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwKVxuICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICBpZiAoc291cmNlICE9IG51bGwgJiYgX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoc291cmNlKSkge1xuICAgICAgaWYgKGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDAgJiYgX19wcm9wSXNFbnVtLmNhbGwoc291cmNlLCBwcm9wKSlcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9pbmRleC50c1xudmFyIHdlYl9leHBvcnRzID0ge307XG5fX2V4cG9ydCh3ZWJfZXhwb3J0cywge1xuICBFcnJvckluZm86ICgpID0+IEVycm9ySW5mbyxcbiAgUmVhbHRpbWU6ICgpID0+IERlZmF1bHRSZWFsdGltZSxcbiAgUmVzdDogKCkgPT4gRGVmYXVsdFJlc3QsXG4gIGRlZmF1bHQ6ICgpID0+IHdlYl9kZWZhdWx0LFxuICBtYWtlUHJvdG9jb2xNZXNzYWdlRnJvbURlc2VyaWFsaXplZDogKCkgPT4gbWFrZUZyb21EZXNlcmlhbGl6ZWRXaXRoRGVwZW5kZW5jaWVzLFxuICBtc2dwYWNrOiAoKSA9PiBtc2dwYWNrX2RlZmF1bHRcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMod2ViX2V4cG9ydHMpO1xuXG4vLyBzcmMvY29tbW9uL3BsYXRmb3JtLnRzXG52YXIgUGxhdGZvcm0gPSBjbGFzcyB7XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi91dGlsL2xvZ2dlci50c1xudmFyIGdsb2JhbE9iamVjdCA9IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogc2VsZjtcbmZ1bmN0aW9uIHBhZCh0aW1lU2VnbWVudCwgdGhyZWUpIHtcbiAgcmV0dXJuIGAke3RpbWVTZWdtZW50fWAucGFkU3RhcnQodGhyZWUgPyAzIDogMiwgXCIwXCIpO1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlcihsb2dnZXIpIHtcbiAgcmV0dXJuIFBsYXRmb3JtLkNvbmZpZy5sb2dUaW1lc3RhbXBzID8gZnVuY3Rpb24obXNnKSB7XG4gICAgY29uc3QgdGltZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIGxvZ2dlcihcbiAgICAgIHBhZCh0aW1lLmdldEhvdXJzKCkpICsgXCI6XCIgKyBwYWQodGltZS5nZXRNaW51dGVzKCkpICsgXCI6XCIgKyBwYWQodGltZS5nZXRTZWNvbmRzKCkpICsgXCIuXCIgKyBwYWQodGltZS5nZXRNaWxsaXNlY29uZHMoKSwgMSkgKyBcIiBcIiArIG1zZ1xuICAgICk7XG4gIH0gOiBmdW5jdGlvbihtc2cpIHtcbiAgICBsb2dnZXIobXNnKTtcbiAgfTtcbn1cbnZhciBnZXREZWZhdWx0TG9nZ2VycyA9ICgpID0+IHtcbiAgdmFyIF9hMjtcbiAgbGV0IGNvbnNvbGVMb2dnZXI7XG4gIGxldCBlcnJvckxvZ2dlcjtcbiAgaWYgKHR5cGVvZiAoKF9hMiA9IGdsb2JhbE9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogZ2xvYmFsT2JqZWN0LmNvbnNvbGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubG9nKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc29sZUxvZ2dlciA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgIH07XG4gICAgZXJyb3JMb2dnZXIgPSBjb25zb2xlLndhcm4gPyBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgfSA6IGNvbnNvbGVMb2dnZXI7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZUxvZ2dlciA9IGVycm9yTG9nZ2VyID0gZnVuY3Rpb24oKSB7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gW2NvbnNvbGVMb2dnZXIsIGVycm9yTG9nZ2VyXS5tYXAoZ2V0SGFuZGxlcik7XG59O1xudmFyIF9Mb2dnZXIgPSBjbGFzcyBfTG9nZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kZXByZWNhdGVkID0gKGRlc2NyaXB0aW9uLCBtc2cpID0+IHtcbiAgICAgIHRoaXMuZGVwcmVjYXRpb25XYXJuaW5nKGAke2Rlc2NyaXB0aW9ufSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gJHttc2d9YCk7XG4gICAgfTtcbiAgICAvKiBXaGVyZSBhIGxvZ2dpbmcgb3BlcmF0aW9uIGlzIGV4cGVuc2l2ZSwgc3VjaCBhcyBzZXJpYWxpc2F0aW9uIG9mIGRhdGEsIHVzZSBzaG91bGRMb2cgd2lsbCBwcmV2ZW50XG4gICAgICB0aGUgb2JqZWN0IGJlaW5nIHNlcmlhbGlzZWQgaWYgdGhlIGxvZyBsZXZlbCB3aWxsIG5vdCBvdXRwdXQgdGhlIG1lc3NhZ2UgKi9cbiAgICB0aGlzLnNob3VsZExvZyA9IChsZXZlbCkgPT4ge1xuICAgICAgcmV0dXJuIGxldmVsIDw9IHRoaXMubG9nTGV2ZWw7XG4gICAgfTtcbiAgICB0aGlzLnNldExvZyA9IChsZXZlbCwgaGFuZGxlcikgPT4ge1xuICAgICAgaWYgKGxldmVsICE9PSB2b2lkIDApXG4gICAgICAgIHRoaXMubG9nTGV2ZWwgPSBsZXZlbDtcbiAgICAgIGlmIChoYW5kbGVyICE9PSB2b2lkIDApXG4gICAgICAgIHRoaXMubG9nSGFuZGxlciA9IHRoaXMubG9nRXJyb3JIYW5kbGVyID0gaGFuZGxlcjtcbiAgICB9O1xuICAgIHRoaXMubG9nTGV2ZWwgPSBfTG9nZ2VyLmRlZmF1bHRMb2dMZXZlbDtcbiAgICB0aGlzLmxvZ0hhbmRsZXIgPSBfTG9nZ2VyLmRlZmF1bHRMb2dIYW5kbGVyO1xuICAgIHRoaXMubG9nRXJyb3JIYW5kbGVyID0gX0xvZ2dlci5kZWZhdWx0TG9nRXJyb3JIYW5kbGVyO1xuICB9XG4gIHN0YXRpYyBpbml0TG9nSGFuZGxlcnMoKSB7XG4gICAgY29uc3QgW2xvZ0hhbmRsZXIsIGxvZ0Vycm9ySGFuZGxlcl0gPSBnZXREZWZhdWx0TG9nZ2VycygpO1xuICAgIHRoaXMuZGVmYXVsdExvZ0hhbmRsZXIgPSBsb2dIYW5kbGVyO1xuICAgIHRoaXMuZGVmYXVsdExvZ0Vycm9ySGFuZGxlciA9IGxvZ0Vycm9ySGFuZGxlcjtcbiAgICB0aGlzLmRlZmF1bHRMb2dnZXIgPSBuZXcgX0xvZ2dlcigpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxscyB0byB0aGlzIG1ldGhvZCBhcmUgbmV2ZXIgc3RyaXBwZWQgYnkgdGhlIGBzdHJpcExvZ3NgIGVzYnVpbGQgcGx1Z2luLiBVc2UgaXQgZm9yIGxvZyBzdGF0ZW1lbnRzIHRoYXQgeW91IHdpc2ggdG8gYWx3YXlzIGJlIGluY2x1ZGVkIGluIHRoZSBtb2R1bGFyIHZhcmlhbnQgb2YgdGhlIFNESy5cbiAgICovXG4gIHN0YXRpYyBsb2dBY3Rpb25Ob1N0cmlwKGxvZ2dlciwgbGV2ZWwsIGFjdGlvbiwgbWVzc2FnZSkge1xuICAgIGxvZ2dlci5sb2dBY3Rpb24obGV2ZWwsIGFjdGlvbiwgbWVzc2FnZSk7XG4gIH1cbiAgbG9nQWN0aW9uKGxldmVsLCBhY3Rpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5zaG91bGRMb2cobGV2ZWwpKSB7XG4gICAgICAobGV2ZWwgPT09IDEgLyogRXJyb3IgKi8gPyB0aGlzLmxvZ0Vycm9ySGFuZGxlciA6IHRoaXMubG9nSGFuZGxlcikoXCJBYmx5OiBcIiArIGFjdGlvbiArIFwiOiBcIiArIG1lc3NhZ2UsIGxldmVsKTtcbiAgICB9XG4gIH1cbiAgcmVuYW1lZENsaWVudE9wdGlvbihvbGROYW1lLCBuZXdOYW1lKSB7XG4gICAgdGhpcy5kZXByZWNhdGlvbldhcm5pbmcoXG4gICAgICBgVGhlIFxcYCR7b2xkTmFtZX1cXGAgY2xpZW50IG9wdGlvbiBoYXMgYmVlbiByZW5hbWVkIHRvIFxcYCR7bmV3TmFtZX1cXGAuIFBsZWFzZSB1cGRhdGUgeW91ciBjb2RlIHRvIHVzZSBcXGAke25ld05hbWV9XFxgIGluc3RlYWQuIFxcYCR7b2xkTmFtZX1cXGAgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uYFxuICAgICk7XG4gIH1cbiAgcmVuYW1lZE1ldGhvZChjbGFzc05hbWUsIG9sZE5hbWUsIG5ld05hbWUpIHtcbiAgICB0aGlzLmRlcHJlY2F0aW9uV2FybmluZyhcbiAgICAgIGBcXGAke2NsYXNzTmFtZX1cXGBcXHUyMDE5cyBcXGAke29sZE5hbWV9XFxgIG1ldGhvZCBoYXMgYmVlbiByZW5hbWVkIHRvIFxcYCR7bmV3TmFtZX1cXGAuIFBsZWFzZSB1cGRhdGUgeW91ciBjb2RlIHRvIHVzZSBcXGAke25ld05hbWV9XFxgIGluc3RlYWQuIFxcYCR7b2xkTmFtZX1cXGAgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uYFxuICAgICk7XG4gIH1cbiAgZGVwcmVjYXRpb25XYXJuaW5nKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5zaG91bGRMb2coMSAvKiBFcnJvciAqLykpIHtcbiAgICAgIHRoaXMubG9nRXJyb3JIYW5kbGVyKGBBYmx5OiBEZXByZWNhdGlvbiB3YXJuaW5nIC0gJHttZXNzYWdlfWAsIDEgLyogRXJyb3IgKi8pO1xuICAgIH1cbiAgfVxufTtcbl9Mb2dnZXIuZGVmYXVsdExvZ0xldmVsID0gMSAvKiBFcnJvciAqLztcbi8vIHB1YmxpYyBjb25zdGFudHNcbl9Mb2dnZXIuTE9HX05PTkUgPSAwIC8qIE5vbmUgKi87XG5fTG9nZ2VyLkxPR19FUlJPUiA9IDEgLyogRXJyb3IgKi87XG5fTG9nZ2VyLkxPR19NQUpPUiA9IDIgLyogTWFqb3IgKi87XG5fTG9nZ2VyLkxPR19NSU5PUiA9IDMgLyogTWlub3IgKi87XG5fTG9nZ2VyLkxPR19NSUNSTyA9IDQgLyogTWljcm8gKi87XG4vKiBwdWJsaWMgc3RhdGljIGZ1bmN0aW9ucyAqL1xuLyoqXG4gKiBJbiB0aGUgbW9kdWxhciB2YXJpYW50IG9mIHRoZSBTREssIHRoZSBgc3RyaXBMb2dzYCBlc2J1aWxkIHBsdWdpbiBzdHJpcHMgb3V0IGFsbCBjYWxscyB0byB0aGlzIG1ldGhvZCAod2hlbiBpbnZva2VkIGFzIGBMb2dnZXIubG9nQWN0aW9uKC4uLilgKSBleGNlcHQgd2hlbiBjYWxsZWQgd2l0aCBsZXZlbCBgTG9nZ2VyLkxPR19FUlJPUmAuIElmIHlvdSB3aXNoIGZvciBhIGxvZyBzdGF0ZW1lbnQgdG8gbmV2ZXIgYmUgc3RyaXBwZWQsIHVzZSB0aGUge0BsaW5rIGxvZ0FjdGlvbk5vU3RyaXB9IG1ldGhvZCBpbnN0ZWFkLlxuICpcbiAqIFRoZSBhZm9yZW1lbnRpb25lZCBwbHVnaW4gZXhwZWN0cyBgbGV2ZWxgIHRvIGJlIGFuIGV4cHJlc3Npb24gb2YgdGhlIGZvcm0gYExvZ2dlci5MT0dfKmA7IHRoYXQgaXMsIHlvdSBjYW7igJl0IGR5bmFtaWNhbGx5IHNwZWNpZnkgdGhlIGxvZyBsZXZlbC5cbiAqL1xuX0xvZ2dlci5sb2dBY3Rpb24gPSAobG9nZ2VyLCBsZXZlbCwgYWN0aW9uLCBtZXNzYWdlKSA9PiB7XG4gIF9Mb2dnZXIubG9nQWN0aW9uTm9TdHJpcChsb2dnZXIsIGxldmVsLCBhY3Rpb24sIG1lc3NhZ2UpO1xufTtcbnZhciBMb2dnZXIgPSBfTG9nZ2VyO1xudmFyIGxvZ2dlcl9kZWZhdWx0ID0gTG9nZ2VyO1xuXG4vLyBzcmMvY29tbW9uL2xpYi91dGlsL3V0aWxzLnRzXG52YXIgdXRpbHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodXRpbHNfZXhwb3J0cywge1xuICBGb3JtYXQ6ICgpID0+IEZvcm1hdCxcbiAgYWxsU2FtZTogKCkgPT4gYWxsU2FtZSxcbiAgYWxsVG9Mb3dlckNhc2U6ICgpID0+IGFsbFRvTG93ZXJDYXNlLFxuICBhbGxUb1VwcGVyQ2FzZTogKCkgPT4gYWxsVG9VcHBlckNhc2UsXG4gIGFyckNob29zZU46ICgpID0+IGFyckNob29zZU4sXG4gIGFyckRlbGV0ZVZhbHVlOiAoKSA9PiBhcnJEZWxldGVWYWx1ZSxcbiAgYXJyRXF1YWxzOiAoKSA9PiBhcnJFcXVhbHMsXG4gIGFyckludGVyc2VjdDogKCkgPT4gYXJySW50ZXJzZWN0LFxuICBhcnJJbnRlcnNlY3RPYjogKCkgPT4gYXJySW50ZXJzZWN0T2IsXG4gIGFyclBvcFJhbmRvbUVsZW1lbnQ6ICgpID0+IGFyclBvcFJhbmRvbUVsZW1lbnQsXG4gIGFycldpdGhvdXRWYWx1ZTogKCkgPT4gYXJyV2l0aG91dFZhbHVlLFxuICBjaGVhcFJhbmRTdHI6ICgpID0+IGNoZWFwUmFuZFN0cixcbiAgY29udGFpbnNWYWx1ZTogKCkgPT4gY29udGFpbnNWYWx1ZSxcbiAgY29weTogKCkgPT4gY29weSxcbiAgY3JlYXRlTWlzc2luZ1BsdWdpbkVycm9yOiAoKSA9PiBjcmVhdGVNaXNzaW5nUGx1Z2luRXJyb3IsXG4gIGRhdGFTaXplQnl0ZXM6ICgpID0+IGRhdGFTaXplQnl0ZXMsXG4gIGRlY29kZUJvZHk6ICgpID0+IGRlY29kZUJvZHksXG4gIGVuY29kZUJvZHk6ICgpID0+IGVuY29kZUJvZHksXG4gIGVuc3VyZUFycmF5OiAoKSA9PiBlbnN1cmVBcnJheSxcbiAgZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllczogKCkgPT4gZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllcyxcbiAgZ2V0QmFja29mZkNvZWZmaWNpZW50OiAoKSA9PiBnZXRCYWNrb2ZmQ29lZmZpY2llbnQsXG4gIGdldEdsb2JhbE9iamVjdDogKCkgPT4gZ2V0R2xvYmFsT2JqZWN0LFxuICBnZXRKaXR0ZXJDb2VmZmljaWVudDogKCkgPT4gZ2V0Sml0dGVyQ29lZmZpY2llbnQsXG4gIGdldFJldHJ5VGltZTogKCkgPT4gZ2V0UmV0cnlUaW1lLFxuICBpbmhlcml0czogKCkgPT4gaW5oZXJpdHMsXG4gIGluc3BlY3RCb2R5OiAoKSA9PiBpbnNwZWN0Qm9keSxcbiAgaW5zcGVjdEVycm9yOiAoKSA9PiBpbnNwZWN0RXJyb3IsXG4gIGludGVyc2VjdDogKCkgPT4gaW50ZXJzZWN0LFxuICBpc0VtcHR5OiAoKSA9PiBpc0VtcHR5LFxuICBpc0Vycm9ySW5mb09yUGFydGlhbEVycm9ySW5mbzogKCkgPT4gaXNFcnJvckluZm9PclBhcnRpYWxFcnJvckluZm8sXG4gIGlzTmlsOiAoKSA9PiBpc05pbCxcbiAgaXNPYmplY3Q6ICgpID0+IGlzT2JqZWN0LFxuICBrZXlzQXJyYXk6ICgpID0+IGtleXNBcnJheSxcbiAgbWF0Y2hEZXJpdmVkQ2hhbm5lbDogKCkgPT4gbWF0Y2hEZXJpdmVkQ2hhbm5lbCxcbiAgbWl4aW46ICgpID0+IG1peGluLFxuICBwYXJzZVF1ZXJ5U3RyaW5nOiAoKSA9PiBwYXJzZVF1ZXJ5U3RyaW5nLFxuICBwcm90b3R5cGljYWxDbG9uZTogKCkgPT4gcHJvdG90eXBpY2FsQ2xvbmUsXG4gIHJhbmRvbVN0cmluZzogKCkgPT4gcmFuZG9tU3RyaW5nLFxuICBzaGFsbG93Q2xvbmU6ICgpID0+IHNoYWxsb3dDbG9uZSxcbiAgc2hhbGxvd0VxdWFsczogKCkgPT4gc2hhbGxvd0VxdWFscyxcbiAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3I6ICgpID0+IHRocm93TWlzc2luZ1BsdWdpbkVycm9yLFxuICB0b0Jhc2U2NDogKCkgPT4gdG9CYXNlNjQsXG4gIHRvUXVlcnlTdHJpbmc6ICgpID0+IHRvUXVlcnlTdHJpbmcsXG4gIHZhbHVlc0FycmF5OiAoKSA9PiB2YWx1ZXNBcnJheSxcbiAgd2hlblByb21pc2VTZXR0bGVzOiAoKSA9PiB3aGVuUHJvbWlzZVNldHRsZXMsXG4gIHdpdGhUaW1lb3V0QXN5bmM6ICgpID0+IHdpdGhUaW1lb3V0QXN5bmNcbn0pO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9lcnJvcmluZm8udHNcbmZ1bmN0aW9uIHRvU3RyaW5nKGVycikge1xuICBsZXQgcmVzdWx0ID0gXCJbXCIgKyBlcnIuY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKGVyci5tZXNzYWdlKVxuICAgIHJlc3VsdCArPSBcIjogXCIgKyBlcnIubWVzc2FnZTtcbiAgaWYgKGVyci5zdGF0dXNDb2RlKVxuICAgIHJlc3VsdCArPSBcIjsgc3RhdHVzQ29kZT1cIiArIGVyci5zdGF0dXNDb2RlO1xuICBpZiAoZXJyLmNvZGUpXG4gICAgcmVzdWx0ICs9IFwiOyBjb2RlPVwiICsgZXJyLmNvZGU7XG4gIGlmIChlcnIuY2F1c2UpXG4gICAgcmVzdWx0ICs9IFwiOyBjYXVzZT1cIiArIGluc3BlY3RFcnJvcihlcnIuY2F1c2UpO1xuICBpZiAoZXJyLmhyZWYgJiYgIShlcnIubWVzc2FnZSAmJiBlcnIubWVzc2FnZS5pbmRleE9mKFwiaGVscC5hYmx5LmlvXCIpID4gLTEpKVxuICAgIHJlc3VsdCArPSBcIjsgc2VlIFwiICsgZXJyLmhyZWYgKyBcIiBcIjtcbiAgcmVzdWx0ICs9IFwiXVwiO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIEVycm9ySW5mbyA9IGNsYXNzIF9FcnJvckluZm8gZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgaWYgKHR5cGVvZiBPYmplY3Quc2V0UHJvdG90eXBlT2YgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBfRXJyb3JJbmZvLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nKHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIGNvbnN0IHsgbWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSB9ID0gdmFsdWVzO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgY29kZSAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2Ygc3RhdHVzQ29kZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3JJbmZvLmZyb21WYWx1ZXMoKTogaW52YWxpZCB2YWx1ZXM6IFwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QodmFsdWVzKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24obmV3IF9FcnJvckluZm8obWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSksIHZhbHVlcyk7XG4gICAgaWYgKHJlc3VsdC5jb2RlICYmICFyZXN1bHQuaHJlZikge1xuICAgICAgcmVzdWx0LmhyZWYgPSBcImh0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yL1wiICsgcmVzdWx0LmNvZGU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG52YXIgUGFydGlhbEVycm9ySW5mbyA9IGNsYXNzIF9QYXJ0aWFsRXJyb3JJbmZvIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlLCBjYXVzZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIGlmICh0eXBlb2YgT2JqZWN0LnNldFByb3RvdHlwZU9mICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgX1BhcnRpYWxFcnJvckluZm8ucHJvdG90eXBlKTtcbiAgICB9XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcodGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gICAgY29uc3QgeyBtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlIH0gPSB2YWx1ZXM7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiIHx8ICFpc05pbChjb2RlKSAmJiB0eXBlb2YgY29kZSAhPT0gXCJudW1iZXJcIiB8fCAhaXNOaWwoc3RhdHVzQ29kZSkgJiYgdHlwZW9mIHN0YXR1c0NvZGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcnRpYWxFcnJvckluZm8uZnJvbVZhbHVlcygpOiBpbnZhbGlkIHZhbHVlczogXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdCh2YWx1ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbihuZXcgX1BhcnRpYWxFcnJvckluZm8obWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSksIHZhbHVlcyk7XG4gICAgaWYgKHJlc3VsdC5jb2RlICYmICFyZXN1bHQuaHJlZikge1xuICAgICAgcmVzdWx0LmhyZWYgPSBcImh0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yL1wiICsgcmVzdWx0LmNvZGU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tb24vbGliL3V0aWwvdXRpbHMudHNcbmZ1bmN0aW9uIHJhbmRvbVBvc24oYXJyT3JTdHIpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFyck9yU3RyLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBtaXhpbih0YXJnZXQsIC4uLmFyZ3MpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc291cmNlID0gYXJnc1tpXTtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGNvcHkoc3JjKSB7XG4gIHJldHVybiBtaXhpbih7fSwgc3JjKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUFycmF5KG9iaikge1xuICBpZiAoaXNOaWwob2JqKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICByZXR1cm4gW29ial07XG59XG5mdW5jdGlvbiBpc09iamVjdChvYikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iKSA9PSBcIltvYmplY3QgT2JqZWN0XVwiO1xufVxuZnVuY3Rpb24gaXNFbXB0eShvYikge1xuICBmb3IgKGNvbnN0IHByb3AgaW4gb2IpXG4gICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzTmlsKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5mdW5jdGlvbiBzaGFsbG93Q2xvbmUob2IpIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE9iamVjdCgpO1xuICBmb3IgKGNvbnN0IHByb3AgaW4gb2IpXG4gICAgcmVzdWx0W3Byb3BdID0gb2JbcHJvcF07XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwcm90b3R5cGljYWxDbG9uZShvYiwgb3duUHJvcGVydGllcykge1xuICBjbGFzcyBGIHtcbiAgfVxuICBGLnByb3RvdHlwZSA9IG9iO1xuICBjb25zdCByZXN1bHQgPSBuZXcgRigpO1xuICBpZiAob3duUHJvcGVydGllcylcbiAgICBtaXhpbihyZXN1bHQsIG93blByb3BlcnRpZXMpO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24oY3Rvciwgc3VwZXJDdG9yKSB7XG4gIGlmIChQbGF0Zm9ybS5Db25maWcuaW5oZXJpdHMpIHtcbiAgICBQbGF0Zm9ybS5Db25maWcuaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gIGN0b3IucHJvdG90eXBlID0gcHJvdG90eXBpY2FsQ2xvbmUoc3VwZXJDdG9yLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogY3RvciB9KTtcbn07XG5mdW5jdGlvbiBjb250YWluc1ZhbHVlKG9iLCB2YWwpIHtcbiAgZm9yIChjb25zdCBpIGluIG9iKSB7XG4gICAgaWYgKG9iW2ldID09IHZhbClcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdChhcnIsIG9iKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG9iKSA/IGFyckludGVyc2VjdChhcnIsIG9iKSA6IGFyckludGVyc2VjdE9iKGFyciwgb2IpO1xufVxuZnVuY3Rpb24gYXJySW50ZXJzZWN0KGFycjEsIGFycjIpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1lbWJlciA9IGFycjFbaV07XG4gICAgaWYgKGFycjIuaW5kZXhPZihtZW1iZXIpICE9IC0xKVxuICAgICAgcmVzdWx0LnB1c2gobWVtYmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYXJySW50ZXJzZWN0T2IoYXJyLCBvYikge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtZW1iZXIgPSBhcnJbaV07XG4gICAgaWYgKG1lbWJlciBpbiBvYilcbiAgICAgIHJlc3VsdC5wdXNoKG1lbWJlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFyckRlbGV0ZVZhbHVlKGFyciwgdmFsKSB7XG4gIGNvbnN0IGlkeCA9IGFyci5pbmRleE9mKHZhbCk7XG4gIGNvbnN0IHJlcyA9IGlkeCAhPSAtMTtcbiAgaWYgKHJlcylcbiAgICBhcnIuc3BsaWNlKGlkeCwgMSk7XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBhcnJXaXRob3V0VmFsdWUoYXJyLCB2YWwpIHtcbiAgY29uc3QgbmV3QXJyID0gYXJyLnNsaWNlKCk7XG4gIGFyckRlbGV0ZVZhbHVlKG5ld0FyciwgdmFsKTtcbiAgcmV0dXJuIG5ld0Fycjtcbn1cbmZ1bmN0aW9uIGtleXNBcnJheShvYiwgb3duT25seSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChjb25zdCBwcm9wIGluIG9iKSB7XG4gICAgaWYgKG93bk9ubHkgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYiwgcHJvcCkpXG4gICAgICBjb250aW51ZTtcbiAgICByZXN1bHQucHVzaChwcm9wKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsdWVzQXJyYXkob2IsIG93bk9ubHkpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAoY29uc3QgcHJvcCBpbiBvYikge1xuICAgIGlmIChvd25Pbmx5ICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2IsIHByb3ApKVxuICAgICAgY29udGludWU7XG4gICAgcmVzdWx0LnB1c2gob2JbcHJvcF0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmb3JJbk93bk5vbk51bGxQcm9wZXJ0aWVzKG9iLCBmbikge1xuICBmb3IgKGNvbnN0IHByb3AgaW4gb2IpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iLCBwcm9wKSAmJiBvYltwcm9wXSkge1xuICAgICAgZm4ocHJvcCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhbGxTYW1lKGFyciwgcHJvcCkge1xuICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGZpcnN0ID0gYXJyWzBdW3Byb3BdO1xuICByZXR1cm4gYXJyLmV2ZXJ5KGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbVtwcm9wXSA9PT0gZmlyc3Q7XG4gIH0pO1xufVxudmFyIEZvcm1hdCA9IC8qIEBfX1BVUkVfXyAqLyAoKEZvcm1hdDIpID0+IHtcbiAgRm9ybWF0MltcIm1zZ3BhY2tcIl0gPSBcIm1zZ3BhY2tcIjtcbiAgRm9ybWF0MltcImpzb25cIl0gPSBcImpzb25cIjtcbiAgcmV0dXJuIEZvcm1hdDI7XG59KShGb3JtYXQgfHwge30pO1xuZnVuY3Rpb24gYXJyUG9wUmFuZG9tRWxlbWVudChhcnIpIHtcbiAgcmV0dXJuIGFyci5zcGxpY2UocmFuZG9tUG9zbihhcnIpLCAxKVswXTtcbn1cbmZ1bmN0aW9uIHRvUXVlcnlTdHJpbmcocGFyYW1zKSB7XG4gIGNvbnN0IHBhcnRzID0gW107XG4gIGlmIChwYXJhbXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpXG4gICAgICBwYXJ0cy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1zW2tleV0pKTtcbiAgfVxuICByZXR1cm4gcGFydHMubGVuZ3RoID8gXCI/XCIgKyBwYXJ0cy5qb2luKFwiJlwiKSA6IFwiXCI7XG59XG5mdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nKHF1ZXJ5KSB7XG4gIGxldCBtYXRjaDtcbiAgY29uc3Qgc2VhcmNoID0gLyhbXj8mPV0rKT0/KFteJl0qKS9nO1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgd2hpbGUgKG1hdGNoID0gc2VhcmNoLmV4ZWMocXVlcnkpKVxuICAgIHJlc3VsdFtkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMV0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFsyXSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc0Vycm9ySW5mb09yUGFydGlhbEVycm9ySW5mbyhlcnIpIHtcbiAgcmV0dXJuIHR5cGVvZiBlcnIgPT0gXCJvYmplY3RcIiAmJiBlcnIgIT09IG51bGwgJiYgKGVyciBpbnN0YW5jZW9mIEVycm9ySW5mbyB8fCBlcnIgaW5zdGFuY2VvZiBQYXJ0aWFsRXJyb3JJbmZvKTtcbn1cbmZ1bmN0aW9uIGluc3BlY3RFcnJvcihlcnIpIHtcbiAgdmFyIF9hMiwgX2I7XG4gIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciB8fCAoKF9hMiA9IGVyciA9PSBudWxsID8gdm9pZCAwIDogZXJyLmNvbnN0cnVjdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLm5hbWUpID09PSBcIkVycm9ySW5mb1wiIHx8ICgoX2IgPSBlcnIgPT0gbnVsbCA/IHZvaWQgMCA6IGVyci5jb25zdHJ1Y3RvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm5hbWUpID09PSBcIlBhcnRpYWxFcnJvckluZm9cIilcbiAgICByZXR1cm4gZXJyLnRvU3RyaW5nKCk7XG4gIHJldHVybiBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChlcnIpO1xufVxuZnVuY3Rpb24gaW5zcGVjdEJvZHkoYm9keSkge1xuICBpZiAoUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIoYm9keSkpIHtcbiAgICByZXR1cm4gYm9keS50b1N0cmluZygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGJvZHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGJvZHkpO1xuICB9XG59XG5mdW5jdGlvbiBkYXRhU2l6ZUJ5dGVzKGRhdGEpIHtcbiAgaWYgKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgcmV0dXJuIFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmJ5dGVMZW5ndGgoZGF0YSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFBsYXRmb3JtLkNvbmZpZy5zdHJpbmdCeXRlU2l6ZShkYXRhKTtcbiAgfVxuICBpZiAodHlwZW9mIGRhdGEgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gODtcbiAgfVxuICBpZiAodHlwZW9mIGRhdGEgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBFeHBlY3RlZCBpbnB1dCBvZiBVdGlscy5kYXRhU2l6ZUJ5dGVzIHRvIGJlIGEgc3RyaW5nLCBhIG51bWJlciwgYSBib29sZWFuIG9yIGEgYnVmZmVyLCBidXQgd2FzOiAke3R5cGVvZiBkYXRhfWBcbiAgKTtcbn1cbmZ1bmN0aW9uIGNoZWFwUmFuZFN0cigpIHtcbiAgcmV0dXJuIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zdWJzdHIoMik7XG59XG52YXIgcmFuZG9tU3RyaW5nID0gYXN5bmMgKG51bUJ5dGVzKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IFBsYXRmb3JtLkNvbmZpZy5nZXRSYW5kb21BcnJheUJ1ZmZlcihudW1CeXRlcyk7XG4gIHJldHVybiBQbGF0Zm9ybS5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUoYnVmZmVyKTtcbn07XG5mdW5jdGlvbiBhcnJDaG9vc2VOKGFyciwgbjIpIHtcbiAgY29uc3QgbnVtSXRlbXMgPSBNYXRoLm1pbihuMiwgYXJyLmxlbmd0aCksIG11dGFibGVBcnIgPSBhcnIuc2xpY2UoKSwgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtSXRlbXM7IGkrKykge1xuICAgIHJlc3VsdC5wdXNoKGFyclBvcFJhbmRvbUVsZW1lbnQobXV0YWJsZUFycikpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB3aGVuUHJvbWlzZVNldHRsZXMocHJvbWlzZSwgY2FsbGJhY2spIHtcbiAgcHJvbWlzZS50aGVuKChyZXN1bHQpID0+IHtcbiAgICBjYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgIGNhbGxiYWNrID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFjayhlcnIpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGRlY29kZUJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KSB7XG4gIGlmIChmb3JtYXQgPT0gXCJtc2dwYWNrXCIpIHtcbiAgICBpZiAoIU1zZ1BhY2spIHtcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiTXNnUGFja1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIE1zZ1BhY2suZGVjb2RlKGJvZHkpO1xuICB9XG4gIHJldHVybiBKU09OLnBhcnNlKFN0cmluZyhib2R5KSk7XG59XG5mdW5jdGlvbiBlbmNvZGVCb2R5KGJvZHksIE1zZ1BhY2ssIGZvcm1hdCkge1xuICBpZiAoZm9ybWF0ID09IFwibXNncGFja1wiKSB7XG4gICAgaWYgKCFNc2dQYWNrKSB7XG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIk1zZ1BhY2tcIik7XG4gICAgfVxuICAgIHJldHVybiBNc2dQYWNrLmVuY29kZShib2R5LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG59XG5mdW5jdGlvbiBhbGxUb0xvd2VyQ2FzZShhcnIpIHtcbiAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50ICYmIGVsZW1lbnQudG9Mb3dlckNhc2UoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhbGxUb1VwcGVyQ2FzZShhcnIpIHtcbiAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50ICYmIGVsZW1lbnQudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRCYWNrb2ZmQ29lZmZpY2llbnQoY291bnQpIHtcbiAgcmV0dXJuIE1hdGgubWluKChjb3VudCArIDIpIC8gMywgMik7XG59XG5mdW5jdGlvbiBnZXRKaXR0ZXJDb2VmZmljaWVudCgpIHtcbiAgcmV0dXJuIDEgLSBNYXRoLnJhbmRvbSgpICogMC4yO1xufVxuZnVuY3Rpb24gZ2V0UmV0cnlUaW1lKGluaXRpYWxUaW1lb3V0LCByZXRyeUF0dGVtcHQpIHtcbiAgcmV0dXJuIGluaXRpYWxUaW1lb3V0ICogZ2V0QmFja29mZkNvZWZmaWNpZW50KHJldHJ5QXR0ZW1wdCkgKiBnZXRKaXR0ZXJDb2VmZmljaWVudCgpO1xufVxuZnVuY3Rpb24gZ2V0R2xvYmFsT2JqZWN0KCkge1xuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBnbG9iYWw7XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gc2hhbGxvd0VxdWFscyhzb3VyY2UsIHRhcmdldCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoc291cmNlKS5ldmVyeSgoa2V5KSA9PiBzb3VyY2Vba2V5XSA9PT0gdGFyZ2V0W2tleV0pICYmIE9iamVjdC5rZXlzKHRhcmdldCkuZXZlcnkoKGtleSkgPT4gdGFyZ2V0W2tleV0gPT09IHNvdXJjZVtrZXldKTtcbn1cbmZ1bmN0aW9uIG1hdGNoRGVyaXZlZENoYW5uZWwobmFtZSkge1xuICBjb25zdCByZWdleCA9IC9eKFxcWyhbXj9dKikoPzooLiopKVxcXSk/KC4rKSQvO1xuICBjb25zdCBtYXRjaCA9IG5hbWUubWF0Y2gocmVnZXgpO1xuICBpZiAoIW1hdGNoIHx8ICFtYXRjaC5sZW5ndGggfHwgbWF0Y2gubGVuZ3RoIDwgNSkge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJyZWdleCBtYXRjaCBmYWlsZWRcIiwgNDAwLCA0MDAxMCk7XG4gIH1cbiAgaWYgKG1hdGNoWzJdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9ySW5mbyhgY2Fubm90IHVzZSBhIGRlcml2ZWQgb3B0aW9uIHdpdGggYSAke21hdGNoWzJdfSBjaGFubmVsYCwgNDAwLCA0MDAxMCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBxdWFsaWZpZXJQYXJhbTogbWF0Y2hbM10gfHwgXCJcIixcbiAgICBjaGFubmVsTmFtZTogbWF0Y2hbNF1cbiAgfTtcbn1cbmZ1bmN0aW9uIHRvQmFzZTY0KHN0cikge1xuICBjb25zdCBidWZmZXJVdGlscyA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzO1xuICBjb25zdCB0ZXh0QnVmZmVyID0gYnVmZmVyVXRpbHMudXRmOEVuY29kZShzdHIpO1xuICByZXR1cm4gYnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKHRleHRCdWZmZXIpO1xufVxuZnVuY3Rpb24gYXJyRXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uKHZhbCwgaSkge1xuICAgIHJldHVybiB2YWwgPT09IGJbaV07XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlTWlzc2luZ1BsdWdpbkVycm9yKHBsdWdpbk5hbWUpIHtcbiAgcmV0dXJuIG5ldyBFcnJvckluZm8oYCR7cGx1Z2luTmFtZX0gcGx1Z2luIG5vdCBwcm92aWRlZGAsIDQwMDE5LCA0MDApO1xufVxuZnVuY3Rpb24gdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IocGx1Z2luTmFtZSkge1xuICB0aHJvdyBjcmVhdGVNaXNzaW5nUGx1Z2luRXJyb3IocGx1Z2luTmFtZSk7XG59XG5hc3luYyBmdW5jdGlvbiB3aXRoVGltZW91dEFzeW5jKHByb21pc2UsIHRpbWVvdXQgPSA1ZTMsIGVyciA9IFwiVGltZW91dCBleHBpcmVkXCIpIHtcbiAgY29uc3QgZSA9IG5ldyBFcnJvckluZm8oZXJyLCA1ZTQsIDUwMCk7XG4gIHJldHVybiBQcm9taXNlLnJhY2UoW3Byb21pc2UsIG5ldyBQcm9taXNlKChfcmVzb2x2ZSwgcmVqZWN0KSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChlKSwgdGltZW91dCkpXSk7XG59XG5cbi8vIHBhY2thZ2UuanNvblxudmFyIHZlcnNpb24gPSBcIjIuMTQuMFwiO1xuXG4vLyBzcmMvY29tbW9uL2xpYi91dGlsL2RlZmF1bHRzLnRzXG52YXIgYWdlbnQgPSBcImFibHktanMvXCIgKyB2ZXJzaW9uO1xudmFyIERlZmF1bHRzID0ge1xuICBFTkRQT0lOVDogXCJtYWluXCIsXG4gIEVOVklST05NRU5UOiBcIlwiLFxuICBSRVNUX0hPU1Q6IFwicmVzdC5hYmx5LmlvXCIsXG4gIFJFQUxUSU1FX0hPU1Q6IFwicmVhbHRpbWUuYWJseS5pb1wiLFxuICBGQUxMQkFDS19IT1NUUzogW1xuICAgIFwibWFpbi5hLmZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tXCIsXG4gICAgXCJtYWluLmIuZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb21cIixcbiAgICBcIm1haW4uYy5mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbVwiLFxuICAgIFwibWFpbi5kLmZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tXCIsXG4gICAgXCJtYWluLmUuZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb21cIlxuICBdLFxuICBQT1JUOiA4MCxcbiAgVExTX1BPUlQ6IDQ0MyxcbiAgVElNRU9VVFM6IHtcbiAgICAvKiBEb2N1bWVudGVkIGFzIG9wdGlvbnMgcGFyYW1zOiAqL1xuICAgIGRpc2Nvbm5lY3RlZFJldHJ5VGltZW91dDogMTVlMyxcbiAgICBzdXNwZW5kZWRSZXRyeVRpbWVvdXQ6IDNlNCxcbiAgICAvKiBVbmRvY3VtZW50ZWQsIGJ1dCBwYXJ0IG9mIHRoZSBhcGkgYW5kIGNhbiBiZSB1c2VkIGJ5IGN1c3RvbWVyczogKi9cbiAgICBodHRwUmVxdWVzdFRpbWVvdXQ6IDFlNCxcbiAgICBodHRwTWF4UmV0cnlEdXJhdGlvbjogMTVlMyxcbiAgICBjaGFubmVsUmV0cnlUaW1lb3V0OiAxNWUzLFxuICAgIGZhbGxiYWNrUmV0cnlUaW1lb3V0OiA2ZTUsXG4gICAgLyogRm9yIGludGVybmFsIC8gdGVzdCB1c2Ugb25seTogKi9cbiAgICBjb25uZWN0aW9uU3RhdGVUdGw6IDEyZTQsXG4gICAgcmVhbHRpbWVSZXF1ZXN0VGltZW91dDogMWU0LFxuICAgIHJlY3ZUaW1lb3V0OiA5ZTQsXG4gICAgd2ViU29ja2V0Q29ubmVjdFRpbWVvdXQ6IDFlNCxcbiAgICB3ZWJTb2NrZXRTbG93VGltZW91dDogNGUzXG4gIH0sXG4gIGh0dHBNYXhSZXRyeUNvdW50OiAzLFxuICBtYXhNZXNzYWdlU2l6ZTogNjU1MzYsXG4gIHZlcnNpb24sXG4gIHByb3RvY29sVmVyc2lvbjogNCxcbiAgYWdlbnQsXG4gIGdldFBvcnQsXG4gIGdldEh0dHBTY2hlbWUsXG4gIGdldFByaW1hcnlEb21haW5Gcm9tRW5kcG9pbnQsXG4gIGdldEVuZHBvaW50RmFsbGJhY2tIb3N0cyxcbiAgZ2V0RmFsbGJhY2tIb3N0cyxcbiAgZ2V0SG9zdHMsXG4gIGNoZWNrSG9zdCxcbiAgb2JqZWN0aWZ5T3B0aW9ucyxcbiAgbm9ybWFsaXNlT3B0aW9ucyxcbiAgZGVmYXVsdEdldEhlYWRlcnMsXG4gIGRlZmF1bHRQb3N0SGVhZGVyc1xufTtcbmZ1bmN0aW9uIGdldFBvcnQob3B0aW9ucywgdGxzKSB7XG4gIHJldHVybiB0bHMgfHwgb3B0aW9ucy50bHMgPyBvcHRpb25zLnRsc1BvcnQgOiBvcHRpb25zLnBvcnQ7XG59XG5mdW5jdGlvbiBnZXRIdHRwU2NoZW1lKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMudGxzID8gXCJodHRwczovL1wiIDogXCJodHRwOi8vXCI7XG59XG5mdW5jdGlvbiBpc0ZxZG5JcE9yTG9jYWxob3N0KGVuZHBvaW50KSB7XG4gIHJldHVybiBlbmRwb2ludC5pbmNsdWRlcyhcIi5cIikgfHwgZW5kcG9pbnQuaW5jbHVkZXMoXCI6OlwiKSB8fCBlbmRwb2ludCA9PT0gXCJsb2NhbGhvc3RcIjtcbn1cbmZ1bmN0aW9uIGdldFByaW1hcnlEb21haW5Gcm9tRW5kcG9pbnQoZW5kcG9pbnQpIHtcbiAgaWYgKGlzRnFkbklwT3JMb2NhbGhvc3QoZW5kcG9pbnQpKVxuICAgIHJldHVybiBlbmRwb2ludDtcbiAgaWYgKGVuZHBvaW50LnN0YXJ0c1dpdGgoXCJub25wcm9kOlwiKSkge1xuICAgIGNvbnN0IHJvdXRpbmdQb2xpY3lJZCA9IGVuZHBvaW50LnJlcGxhY2UoXCJub25wcm9kOlwiLCBcIlwiKTtcbiAgICByZXR1cm4gYCR7cm91dGluZ1BvbGljeUlkfS5yZWFsdGltZS5hYmx5LW5vbnByb2QubmV0YDtcbiAgfVxuICByZXR1cm4gYCR7ZW5kcG9pbnR9LnJlYWx0aW1lLmFibHkubmV0YDtcbn1cbmZ1bmN0aW9uIGdldEVuZHBvaW50RmFsbGJhY2tIb3N0cyhlbmRwb2ludCkge1xuICBpZiAoaXNGcWRuSXBPckxvY2FsaG9zdChlbmRwb2ludCkpXG4gICAgcmV0dXJuIFtdO1xuICBpZiAoZW5kcG9pbnQuc3RhcnRzV2l0aChcIm5vbnByb2Q6XCIpKSB7XG4gICAgY29uc3Qgcm91dGluZ1BvbGljeUlkID0gZW5kcG9pbnQucmVwbGFjZShcIm5vbnByb2Q6XCIsIFwiXCIpO1xuICAgIHJldHVybiBlbmRwb2ludEZhbGxiYWNrcyhyb3V0aW5nUG9saWN5SWQsIFwiYWJseS1yZWFsdGltZS1ub25wcm9kLmNvbVwiKTtcbiAgfVxuICByZXR1cm4gZW5kcG9pbnRGYWxsYmFja3MoZW5kcG9pbnQsIFwiYWJseS1yZWFsdGltZS5jb21cIik7XG59XG5mdW5jdGlvbiBlbmRwb2ludEZhbGxiYWNrcyhyb3V0aW5nUG9saWN5SWQsIGRvbWFpbikge1xuICByZXR1cm4gW1wiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBcImVcIl0ubWFwKChpZCkgPT4gYCR7cm91dGluZ1BvbGljeUlkfS4ke2lkfS5mYWxsYmFjay4ke2RvbWFpbn1gKTtcbn1cbmZ1bmN0aW9uIGdldEZhbGxiYWNrSG9zdHMob3B0aW9ucykge1xuICBjb25zdCBmYWxsYmFja0hvc3RzID0gb3B0aW9ucy5mYWxsYmFja0hvc3RzLCBodHRwTWF4UmV0cnlDb3VudCA9IHR5cGVvZiBvcHRpb25zLmh0dHBNYXhSZXRyeUNvdW50ICE9PSBcInVuZGVmaW5lZFwiID8gb3B0aW9ucy5odHRwTWF4UmV0cnlDb3VudCA6IERlZmF1bHRzLmh0dHBNYXhSZXRyeUNvdW50O1xuICByZXR1cm4gZmFsbGJhY2tIb3N0cyA/IGFyckNob29zZU4oZmFsbGJhY2tIb3N0cywgaHR0cE1heFJldHJ5Q291bnQpIDogW107XG59XG5mdW5jdGlvbiBnZXRIb3N0cyhvcHRpb25zKSB7XG4gIHJldHVybiBbb3B0aW9ucy5wcmltYXJ5RG9tYWluXS5jb25jYXQoZ2V0RmFsbGJhY2tIb3N0cyhvcHRpb25zKSk7XG59XG5mdW5jdGlvbiBjaGVja0hvc3QoaG9zdCkge1xuICBpZiAodHlwZW9mIGhvc3QgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiaG9zdCBtdXN0IGJlIGEgc3RyaW5nOyB3YXMgYSBcIiArIHR5cGVvZiBob3N0LCA0ZTQsIDQwMCk7XG4gIH1cbiAgaWYgKCFob3N0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJob3N0IG11c3Qgbm90IGJlIHplcm8tbGVuZ3RoXCIsIDRlNCwgNDAwKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VGltZW91dHMob3B0aW9ucykge1xuICBjb25zdCB0aW1lb3V0cyA9IHt9O1xuICBmb3IgKGNvbnN0IHByb3AgaW4gRGVmYXVsdHMuVElNRU9VVFMpIHtcbiAgICB0aW1lb3V0c1twcm9wXSA9IG9wdGlvbnNbcHJvcF0gfHwgRGVmYXVsdHMuVElNRU9VVFNbcHJvcF07XG4gIH1cbiAgcmV0dXJuIHRpbWVvdXRzO1xufVxuZnVuY3Rpb24gZ2V0QWdlbnRTdHJpbmcob3B0aW9ucykge1xuICBsZXQgYWdlbnRTdHIgPSBEZWZhdWx0cy5hZ2VudDtcbiAgaWYgKG9wdGlvbnMuYWdlbnRzKSB7XG4gICAgZm9yICh2YXIgYWdlbnQyIGluIG9wdGlvbnMuYWdlbnRzKSB7XG4gICAgICBhZ2VudFN0ciArPSBcIiBcIiArIGFnZW50MiArIFwiL1wiICsgb3B0aW9ucy5hZ2VudHNbYWdlbnQyXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFnZW50U3RyO1xufVxuZnVuY3Rpb24gb2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zLCBhbGxvd0tleU9yVG9rZW4sIHNvdXJjZUZvckVycm9yTWVzc2FnZSwgbG9nZ2VyLCBtb2R1bGFyUGx1Z2luc1RvSW5jbHVkZSkge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgY29uc3QgbXNnID0gYWxsb3dLZXlPclRva2VuID8gYCR7c291cmNlRm9yRXJyb3JNZXNzYWdlfSBtdXN0IGJlIGluaXRpYWxpemVkIHdpdGggZWl0aGVyIGEgY2xpZW50IG9wdGlvbnMgb2JqZWN0LCBhbiBBYmx5IEFQSSBrZXksIG9yIGFuIEFibHkgVG9rZW5gIDogYCR7c291cmNlRm9yRXJyb3JNZXNzYWdlfSBtdXN0IGJlIGluaXRpYWxpemVkIHdpdGggYSBjbGllbnQgb3B0aW9ucyBvYmplY3RgO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgYCR7c291cmNlRm9yRXJyb3JNZXNzYWdlfSgpYCwgbXNnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfVxuICBsZXQgb3B0aW9uc09iajtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKG9wdGlvbnMuaW5kZXhPZihcIjpcIikgPT0gLTEpIHtcbiAgICAgIGlmICghYWxsb3dLZXlPclRva2VuKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGAke3NvdXJjZUZvckVycm9yTWVzc2FnZX0gY2Fubm90IGJlIGluaXRpYWxpemVkIHdpdGgganVzdCBhbiBBYmx5IFRva2VuOyB5b3UgbXVzdCBwcm92aWRlIGEgY2xpZW50IG9wdGlvbnMgb2JqZWN0IHdpdGggYSBcXGBwbHVnaW5zXFxgIHByb3BlcnR5LiAoU2V0IHRoaXMgQWJseSBUb2tlbiBhcyB0aGUgb2JqZWN0XFx1MjAxOXMgXFxgdG9rZW5cXGAgcHJvcGVydHkuKWA7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgYCR7c291cmNlRm9yRXJyb3JNZXNzYWdlfSgpYCwgbXNnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zT2JqID0geyB0b2tlbjogb3B0aW9ucyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWFsbG93S2V5T3JUb2tlbikge1xuICAgICAgICBjb25zdCBtc2cgPSBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9IGNhbm5vdCBiZSBpbml0aWFsaXplZCB3aXRoIGp1c3QgYW4gQWJseSBBUEkga2V5OyB5b3UgbXVzdCBwcm92aWRlIGEgY2xpZW50IG9wdGlvbnMgb2JqZWN0IHdpdGggYSBcXGBwbHVnaW5zXFxgIHByb3BlcnR5LiAoU2V0IHRoaXMgQWJseSBBUEkga2V5IGFzIHRoZSBvYmplY3RcXHUyMDE5cyBcXGBrZXlcXGAgcHJvcGVydHkuKWA7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgYCR7c291cmNlRm9yRXJyb3JNZXNzYWdlfSgpYCwgbXNnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zT2JqID0geyBrZXk6IG9wdGlvbnMgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9uc09iaiA9IG9wdGlvbnM7XG4gIH1cbiAgaWYgKG1vZHVsYXJQbHVnaW5zVG9JbmNsdWRlKSB7XG4gICAgb3B0aW9uc09iaiA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnNPYmopLCB7IHBsdWdpbnM6IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBtb2R1bGFyUGx1Z2luc1RvSW5jbHVkZSksIG9wdGlvbnNPYmoucGx1Z2lucykgfSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNPYmo7XG59XG5mdW5jdGlvbiBjaGVja0lmQ2xpZW50T3B0aW9uc0FyZVZhbGlkKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuZW5kcG9pbnQgJiYgKG9wdGlvbnMuZW52aXJvbm1lbnQgfHwgb3B0aW9ucy5yZXN0SG9zdCB8fCBvcHRpb25zLnJlYWx0aW1lSG9zdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgXCJUaGUgYGVuZHBvaW50YCBvcHRpb24gY2Fubm90IGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgYGVudmlyb25tZW50YCwgYHJlc3RIb3N0YCwgb3IgYHJlYWx0aW1lSG9zdGAgb3B0aW9ucy5cIixcbiAgICAgIDQwMTA2LFxuICAgICAgNDAwXG4gICAgKTtcbiAgfVxuICBpZiAob3B0aW9ucy5lbnZpcm9ubWVudCAmJiAob3B0aW9ucy5yZXN0SG9zdCB8fCBvcHRpb25zLnJlYWx0aW1lSG9zdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgXCJUaGUgYGVudmlyb25tZW50YCBvcHRpb24gY2Fubm90IGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgYHJlc3RIb3N0YCwgb3IgYHJlYWx0aW1lSG9zdGAgb3B0aW9ucy5cIixcbiAgICAgIDQwMTA2LFxuICAgICAgNDAwXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXNlT3B0aW9ucyhvcHRpb25zLCBNc2dQYWNrLCBsb2dnZXIpIHtcbiAgY29uc3QgbG9nZ2VyVG9Vc2UgPSBsb2dnZXIgIT0gbnVsbCA/IGxvZ2dlciA6IGxvZ2dlcl9kZWZhdWx0LmRlZmF1bHRMb2dnZXI7XG4gIGlmIChvcHRpb25zLmVudmlyb25tZW50KSB7XG4gICAgbG9nZ2VyVG9Vc2UuZGVwcmVjYXRlZChcIlRoZSBgZW52aXJvbm1lbnRgIGNsaWVudCBvcHRpb25cIiwgXCJVc2UgdGhlIGBlbmRwb2ludGAgY2xpZW50IG9wdGlvbiBpbnN0ZWFkLlwiKTtcbiAgfVxuICBpZiAob3B0aW9ucy5yZXN0SG9zdCkge1xuICAgIGxvZ2dlclRvVXNlLmRlcHJlY2F0ZWQoXCJUaGUgYHJlc3RIb3N0YCBjbGllbnQgb3B0aW9uXCIsIFwiVXNlIHRoZSBgZW5kcG9pbnRgIGNsaWVudCBvcHRpb24gaW5zdGVhZC5cIik7XG4gIH1cbiAgaWYgKG9wdGlvbnMucmVhbHRpbWVIb3N0KSB7XG4gICAgbG9nZ2VyVG9Vc2UuZGVwcmVjYXRlZChcIlRoZSBgcmVhbHRpbWVIb3N0YCBjbGllbnQgb3B0aW9uXCIsIFwiVXNlIHRoZSBgZW5kcG9pbnRgIGNsaWVudCBvcHRpb24gaW5zdGVhZC5cIik7XG4gIH1cbiAgY2hlY2tJZkNsaWVudE9wdGlvbnNBcmVWYWxpZChvcHRpb25zKTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLnJlY292ZXIgPT09IFwiZnVuY3Rpb25cIiAmJiBvcHRpb25zLmNsb3NlT25VbmxvYWQgPT09IHRydWUpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICBsb2dnZXJUb1VzZSxcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgIFwiRGVmYXVsdHMubm9ybWFsaXNlT3B0aW9uc1wiLFxuICAgICAgXCJjbG9zZU9uVW5sb2FkIHdhcyB0cnVlIGFuZCBhIHNlc3Npb24gcmVjb3ZlcnkgZnVuY3Rpb24gd2FzIHNldCAtIHRoZXNlIGFyZSBtdXR1YWxseSBleGNsdXNpdmUsIHNvIHVuc2V0dGluZyB0aGUgbGF0dGVyXCJcbiAgICApO1xuICAgIG9wdGlvbnMucmVjb3ZlciA9IHZvaWQgMDtcbiAgfVxuICBpZiAoIShcImNsb3NlT25VbmxvYWRcIiBpbiBvcHRpb25zKSkge1xuICAgIG9wdGlvbnMuY2xvc2VPblVubG9hZCA9ICFvcHRpb25zLnJlY292ZXI7XG4gIH1cbiAgaWYgKCEoXCJxdWV1ZU1lc3NhZ2VzXCIgaW4gb3B0aW9ucykpXG4gICAgb3B0aW9ucy5xdWV1ZU1lc3NhZ2VzID0gdHJ1ZTtcbiAgY29uc3QgZW5kcG9pbnQgPSBvcHRpb25zLmVuZHBvaW50IHx8IERlZmF1bHRzLkVORFBPSU5UO1xuICBpZiAoIW9wdGlvbnMuZmFsbGJhY2tIb3N0cyAmJiAhb3B0aW9ucy5yZXN0SG9zdCAmJiAhb3B0aW9ucy5yZWFsdGltZUhvc3QgJiYgIW9wdGlvbnMucG9ydCAmJiAhb3B0aW9ucy50bHNQb3J0KSB7XG4gICAgb3B0aW9ucy5mYWxsYmFja0hvc3RzID0gZ2V0RW5kcG9pbnRGYWxsYmFja0hvc3RzKG9wdGlvbnMuZW52aXJvbm1lbnQgfHwgZW5kcG9pbnQpO1xuICB9XG4gIGNvbnN0IHByaW1hcnlEb21haW5Gcm9tRW52aXJvbm1lbnQgPSBvcHRpb25zLmVudmlyb25tZW50ICYmIGAke29wdGlvbnMuZW52aXJvbm1lbnR9LnJlYWx0aW1lLmFibHkubmV0YDtcbiAgY29uc3QgcHJpbWFyeURvbWFpbkZyb21MZWdhY3lPcHRpb25zID0gb3B0aW9ucy5yZXN0SG9zdCB8fCBvcHRpb25zLnJlYWx0aW1lSG9zdCB8fCBwcmltYXJ5RG9tYWluRnJvbUVudmlyb25tZW50O1xuICBjb25zdCBwcmltYXJ5RG9tYWluID0gcHJpbWFyeURvbWFpbkZyb21MZWdhY3lPcHRpb25zIHx8IGdldFByaW1hcnlEb21haW5Gcm9tRW5kcG9pbnQoZW5kcG9pbnQpO1xuICAob3B0aW9ucy5mYWxsYmFja0hvc3RzIHx8IFtdKS5jb25jYXQocHJpbWFyeURvbWFpbikuZm9yRWFjaChjaGVja0hvc3QpO1xuICBvcHRpb25zLnBvcnQgPSBvcHRpb25zLnBvcnQgfHwgRGVmYXVsdHMuUE9SVDtcbiAgb3B0aW9ucy50bHNQb3J0ID0gb3B0aW9ucy50bHNQb3J0IHx8IERlZmF1bHRzLlRMU19QT1JUO1xuICBpZiAoIShcInRsc1wiIGluIG9wdGlvbnMpKVxuICAgIG9wdGlvbnMudGxzID0gdHJ1ZTtcbiAgY29uc3QgdGltZW91dHMgPSBnZXRUaW1lb3V0cyhvcHRpb25zKTtcbiAgaWYgKE1zZ1BhY2spIHtcbiAgICBpZiAoXCJ1c2VCaW5hcnlQcm90b2NvbFwiIGluIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPSBQbGF0Zm9ybS5Db25maWcuc3VwcG9ydHNCaW5hcnkgJiYgb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA9IFBsYXRmb3JtLkNvbmZpZy5wcmVmZXJCaW5hcnk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBoZWFkZXJzID0ge307XG4gIGlmIChvcHRpb25zLmNsaWVudElkKSB7XG4gICAgaGVhZGVyc1tcIlgtQWJseS1DbGllbnRJZFwiXSA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShQbGF0Zm9ybS5CdWZmZXJVdGlscy51dGY4RW5jb2RlKG9wdGlvbnMuY2xpZW50SWQpKTtcbiAgfVxuICBpZiAoIShcImlkZW1wb3RlbnRSZXN0UHVibGlzaGluZ1wiIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5pZGVtcG90ZW50UmVzdFB1Ymxpc2hpbmcgPSB0cnVlO1xuICB9XG4gIGxldCBjb25uZWN0aXZpdHlDaGVja1BhcmFtcyA9IG51bGw7XG4gIGxldCBjb25uZWN0aXZpdHlDaGVja1VybCA9IG9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tVcmw7XG4gIGlmIChvcHRpb25zLmNvbm5lY3Rpdml0eUNoZWNrVXJsKSB7XG4gICAgbGV0IFt1cmksIHFzXSA9IG9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tVcmwuc3BsaXQoXCI/XCIpO1xuICAgIGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zID0gcXMgPyBwYXJzZVF1ZXJ5U3RyaW5nKHFzKSA6IHt9O1xuICAgIGlmICh1cmkuaW5kZXhPZihcIjovL1wiKSA9PT0gLTEpIHtcbiAgICAgIHVyaSA9IFwiaHR0cHM6Ly9cIiArIHVyaTtcbiAgICB9XG4gICAgY29ubmVjdGl2aXR5Q2hlY2tVcmwgPSB1cmk7XG4gIH1cbiAgbGV0IHdzQ29ubmVjdGl2aXR5Q2hlY2tVcmwgPSBvcHRpb25zLndzQ29ubmVjdGl2aXR5Q2hlY2tVcmw7XG4gIGlmICh3c0Nvbm5lY3Rpdml0eUNoZWNrVXJsICYmIHdzQ29ubmVjdGl2aXR5Q2hlY2tVcmwuaW5kZXhPZihcIjovL1wiKSA9PT0gLTEpIHtcbiAgICB3c0Nvbm5lY3Rpdml0eUNoZWNrVXJsID0gXCJ3c3M6Ly9cIiArIHdzQ29ubmVjdGl2aXR5Q2hlY2tVcmw7XG4gIH1cbiAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgcHJpbWFyeURvbWFpbixcbiAgICBtYXhNZXNzYWdlU2l6ZTogb3B0aW9ucy5tYXhNZXNzYWdlU2l6ZSB8fCBEZWZhdWx0cy5tYXhNZXNzYWdlU2l6ZSxcbiAgICB0aW1lb3V0cyxcbiAgICBjb25uZWN0aXZpdHlDaGVja1BhcmFtcyxcbiAgICBjb25uZWN0aXZpdHlDaGVja1VybCxcbiAgICB3c0Nvbm5lY3Rpdml0eUNoZWNrVXJsLFxuICAgIGhlYWRlcnNcbiAgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpc2VDaGFubmVsT3B0aW9ucyhDcnlwdG8yLCBsb2dnZXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2hhbm5lbE9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoY2hhbm5lbE9wdGlvbnMuY2lwaGVyKSB7XG4gICAgaWYgKCFDcnlwdG8yKVxuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJDcnlwdG9cIik7XG4gICAgY29uc3QgY2lwaGVyID0gQ3J5cHRvMi5nZXRDaXBoZXIoY2hhbm5lbE9wdGlvbnMuY2lwaGVyLCBsb2dnZXIpO1xuICAgIGNoYW5uZWxPcHRpb25zLmNpcGhlciA9IGNpcGhlci5jaXBoZXJQYXJhbXM7XG4gICAgY2hhbm5lbE9wdGlvbnMuY2hhbm5lbENpcGhlciA9IGNpcGhlci5jaXBoZXI7XG4gIH0gZWxzZSBpZiAoXCJjaXBoZXJcIiBpbiBjaGFubmVsT3B0aW9ucykge1xuICAgIGNoYW5uZWxPcHRpb25zLmNpcGhlciA9IHZvaWQgMDtcbiAgICBjaGFubmVsT3B0aW9ucy5jaGFubmVsQ2lwaGVyID0gbnVsbDtcbiAgfVxuICByZXR1cm4gY2hhbm5lbE9wdGlvbnM7XG59XG52YXIgY29udGVudFR5cGVzID0ge1xuICBqc29uOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgeG1sOiBcImFwcGxpY2F0aW9uL3htbFwiLFxuICBodG1sOiBcInRleHQvaHRtbFwiLFxuICBtc2dwYWNrOiBcImFwcGxpY2F0aW9uL3gtbXNncGFja1wiLFxuICB0ZXh0OiBcInRleHQvcGxhaW5cIlxufTtcbnZhciBkZWZhdWx0SGVhZGVyc09wdGlvbnMgPSB7XG4gIGZvcm1hdDogXCJqc29uXCIgLyoganNvbiAqLyxcbiAgcHJvdG9jb2xWZXJzaW9uOiBEZWZhdWx0cy5wcm90b2NvbFZlcnNpb25cbn07XG5mdW5jdGlvbiBkZWZhdWx0R2V0SGVhZGVycyhvcHRpb25zLCB7XG4gIGZvcm1hdCA9IGRlZmF1bHRIZWFkZXJzT3B0aW9ucy5mb3JtYXQsXG4gIHByb3RvY29sVmVyc2lvbiA9IGRlZmF1bHRIZWFkZXJzT3B0aW9ucy5wcm90b2NvbFZlcnNpb25cbn0gPSB7fSkge1xuICBjb25zdCBhY2NlcHQgPSBjb250ZW50VHlwZXNbZm9ybWF0XTtcbiAgcmV0dXJuIHtcbiAgICBhY2NlcHQsXG4gICAgXCJYLUFibHktVmVyc2lvblwiOiBwcm90b2NvbFZlcnNpb24udG9TdHJpbmcoKSxcbiAgICBcIkFibHktQWdlbnRcIjogZ2V0QWdlbnRTdHJpbmcob3B0aW9ucylcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRQb3N0SGVhZGVycyhvcHRpb25zLCB7XG4gIGZvcm1hdCA9IGRlZmF1bHRIZWFkZXJzT3B0aW9ucy5mb3JtYXQsXG4gIHByb3RvY29sVmVyc2lvbiA9IGRlZmF1bHRIZWFkZXJzT3B0aW9ucy5wcm90b2NvbFZlcnNpb25cbn0gPSB7fSkge1xuICBsZXQgY29udGVudFR5cGU7XG4gIGNvbnN0IGFjY2VwdCA9IGNvbnRlbnRUeXBlID0gY29udGVudFR5cGVzW2Zvcm1hdF07XG4gIHJldHVybiB7XG4gICAgYWNjZXB0LFxuICAgIFwiY29udGVudC10eXBlXCI6IGNvbnRlbnRUeXBlLFxuICAgIFwiWC1BYmx5LVZlcnNpb25cIjogcHJvdG9jb2xWZXJzaW9uLnRvU3RyaW5nKCksXG4gICAgXCJBYmx5LUFnZW50XCI6IGdldEFnZW50U3RyaW5nKG9wdGlvbnMpXG4gIH07XG59XG52YXIgZGVmYXVsdHNfZGVmYXVsdCA9IERlZmF1bHRzO1xuZnVuY3Rpb24gZ2V0RGVmYXVsdHMocGxhdGZvcm1EZWZhdWx0cykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihEZWZhdWx0cywgcGxhdGZvcm1EZWZhdWx0cyk7XG59XG5cbi8vIHNyYy9jb21tb24vbGliL3V0aWwvbXVsdGljYXN0ZXIudHNcbnZhciBNdWx0aWNhc3RlciA9IGNsYXNzIF9NdWx0aWNhc3RlciB7XG4gIC8vIFByaXZhdGUgY29uc3RydWN0b3I7IHVzZSBzdGF0aWMgTXVsdGljYXN0ZXIuY3JlYXRlIGluc3RlYWRcbiAgY29uc3RydWN0b3IobG9nZ2VyLCBtZW1iZXJzKSB7XG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgdGhpcy5tZW1iZXJzID0gbWVtYmVycyB8fCBbXTtcbiAgfVxuICBjYWxsKGVyciwgcmVzdWx0KSB7XG4gICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdGhpcy5tZW1iZXJzKSB7XG4gICAgICBpZiAobWVtYmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbWVtYmVyKGVyciwgcmVzdWx0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgICAgXCJNdWx0aWNhc3RlciBtdWx0aXBsZSBjYWxsYmFjayBoYW5kbGVyXCIsXG4gICAgICAgICAgICBcIlVuZXhwZWN0ZWQgZXhjZXB0aW9uOiBcIiArIGUgKyBcIjsgc3RhY2sgPSBcIiArIGUuc3RhY2tcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHB1c2goLi4uYXJncykge1xuICAgIHRoaXMubWVtYmVycy5wdXNoKC4uLmFyZ3MpO1xuICB9XG4gIGNyZWF0ZVByb21pc2UoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucHVzaCgoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXNvbHZlQWxsKHJlc3VsdCkge1xuICAgIHRoaXMuY2FsbChudWxsLCByZXN1bHQpO1xuICB9XG4gIHJlamVjdEFsbChlcnIpIHtcbiAgICB0aGlzLmNhbGwoZXJyKTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKGxvZ2dlciwgbWVtYmVycykge1xuICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IF9NdWx0aWNhc3Rlcihsb2dnZXIsIG1lbWJlcnMpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKChlcnIsIHJlc3VsdCkgPT4gaW5zdGFuY2UuY2FsbChlcnIsIHJlc3VsdCksIHtcbiAgICAgIHB1c2g6IChmbikgPT4gaW5zdGFuY2UucHVzaChmbiksXG4gICAgICBjcmVhdGVQcm9taXNlOiAoKSA9PiBpbnN0YW5jZS5jcmVhdGVQcm9taXNlKCksXG4gICAgICByZXNvbHZlQWxsOiAocmVzdWx0KSA9PiBpbnN0YW5jZS5yZXNvbHZlQWxsKHJlc3VsdCksXG4gICAgICByZWplY3RBbGw6IChlcnIpID0+IGluc3RhbmNlLnJlamVjdEFsbChlcnIpXG4gICAgfSk7XG4gIH1cbn07XG52YXIgbXVsdGljYXN0ZXJfZGVmYXVsdCA9IE11bHRpY2FzdGVyO1xuXG4vLyBzcmMvY29tbW9uL2NvbnN0YW50cy9IdHRwTWV0aG9kcy50c1xudmFyIEh0dHBNZXRob2RzID0gLyogQF9fUFVSRV9fICovICgoSHR0cE1ldGhvZHMyKSA9PiB7XG4gIEh0dHBNZXRob2RzMltcIkdldFwiXSA9IFwiZ2V0XCI7XG4gIEh0dHBNZXRob2RzMltcIkRlbGV0ZVwiXSA9IFwiZGVsZXRlXCI7XG4gIEh0dHBNZXRob2RzMltcIlBvc3RcIl0gPSBcInBvc3RcIjtcbiAgSHR0cE1ldGhvZHMyW1wiUHV0XCJdID0gXCJwdXRcIjtcbiAgSHR0cE1ldGhvZHMyW1wiUGF0Y2hcIl0gPSBcInBhdGNoXCI7XG4gIHJldHVybiBIdHRwTWV0aG9kczI7XG59KShIdHRwTWV0aG9kcyB8fCB7fSk7XG52YXIgSHR0cE1ldGhvZHNfZGVmYXVsdCA9IEh0dHBNZXRob2RzO1xuXG4vLyBzcmMvY29tbW9uL2NvbnN0YW50cy9IdHRwU3RhdHVzQ29kZXMudHNcbnZhciBIdHRwU3RhdHVzQ29kZXMgPSAvKiBAX19QVVJFX18gKi8gKChIdHRwU3RhdHVzQ29kZXMyKSA9PiB7XG4gIEh0dHBTdGF0dXNDb2RlczJbSHR0cFN0YXR1c0NvZGVzMltcIlN1Y2Nlc3NcIl0gPSAyMDBdID0gXCJTdWNjZXNzXCI7XG4gIEh0dHBTdGF0dXNDb2RlczJbSHR0cFN0YXR1c0NvZGVzMltcIk5vQ29udGVudFwiXSA9IDIwNF0gPSBcIk5vQ29udGVudFwiO1xuICBIdHRwU3RhdHVzQ29kZXMyW0h0dHBTdGF0dXNDb2RlczJbXCJCYWRSZXF1ZXN0XCJdID0gNDAwXSA9IFwiQmFkUmVxdWVzdFwiO1xuICBIdHRwU3RhdHVzQ29kZXMyW0h0dHBTdGF0dXNDb2RlczJbXCJVbmF1dGhvcml6ZWRcIl0gPSA0MDFdID0gXCJVbmF1dGhvcml6ZWRcIjtcbiAgSHR0cFN0YXR1c0NvZGVzMltIdHRwU3RhdHVzQ29kZXMyW1wiRm9yYmlkZGVuXCJdID0gNDAzXSA9IFwiRm9yYmlkZGVuXCI7XG4gIEh0dHBTdGF0dXNDb2RlczJbSHR0cFN0YXR1c0NvZGVzMltcIlJlcXVlc3RUaW1lb3V0XCJdID0gNDA4XSA9IFwiUmVxdWVzdFRpbWVvdXRcIjtcbiAgSHR0cFN0YXR1c0NvZGVzMltIdHRwU3RhdHVzQ29kZXMyW1wiSW50ZXJuYWxTZXJ2ZXJFcnJvclwiXSA9IDUwMF0gPSBcIkludGVybmFsU2VydmVyRXJyb3JcIjtcbiAgcmV0dXJuIEh0dHBTdGF0dXNDb2RlczI7XG59KShIdHRwU3RhdHVzQ29kZXMgfHwge30pO1xuZnVuY3Rpb24gaXNTdWNjZXNzQ29kZShzdGF0dXNDb2RlKSB7XG4gIHJldHVybiBzdGF0dXNDb2RlID49IDIwMCAvKiBTdWNjZXNzICovICYmIHN0YXR1c0NvZGUgPCA0MDAgLyogQmFkUmVxdWVzdCAqLztcbn1cbnZhciBIdHRwU3RhdHVzQ29kZXNfZGVmYXVsdCA9IEh0dHBTdGF0dXNDb2RlcztcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L2F1dGgudHNcbnZhciBNQVhfVE9LRU5fTEVOR1RIID0gTWF0aC5wb3coMiwgMTcpO1xuZnVuY3Rpb24gcmFuZG9tKCkge1xuICByZXR1cm4gKFwiMDAwMDAwXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTE2KSkuc2xpY2UoLTE2KTtcbn1cbmZ1bmN0aW9uIGlzUmVhbHRpbWUoY2xpZW50KSB7XG4gIHJldHVybiAhIWNsaWVudC5jb25uZWN0aW9uO1xufVxuZnVuY3Rpb24gbm9ybWFsaXNlQXV0aGNhbGxiYWNrRXJyb3IoZXJyKSB7XG4gIGlmICghaXNFcnJvckluZm9PclBhcnRpYWxFcnJvckluZm8oZXJyKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3JJbmZvKGluc3BlY3RFcnJvcihlcnIpLCBlcnIuY29kZSB8fCA0MDE3MCwgZXJyLnN0YXR1c0NvZGUgfHwgNDAxKTtcbiAgfVxuICBpZiAoIWVyci5jb2RlKSB7XG4gICAgaWYgKGVyci5zdGF0dXNDb2RlID09PSA0MDMpIHtcbiAgICAgIGVyci5jb2RlID0gNDAzMDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVyci5jb2RlID0gNDAxNzA7XG4gICAgICBlcnIuc3RhdHVzQ29kZSA9IDQwMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVycjtcbn1cbnZhciBobWFjID0gKHRleHQsIGtleSkgPT4ge1xuICBjb25zdCBidWZmZXJVdGlscyA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzO1xuICBjb25zdCB0ZXh0QnVmZmVyID0gYnVmZmVyVXRpbHMudXRmOEVuY29kZSh0ZXh0KTtcbiAgY29uc3Qga2V5QnVmZmVyID0gYnVmZmVyVXRpbHMudXRmOEVuY29kZShrZXkpO1xuICBjb25zdCBkaWdlc3QgPSBidWZmZXJVdGlscy5obWFjU2hhMjU2KHRleHRCdWZmZXIsIGtleUJ1ZmZlcik7XG4gIHJldHVybiBidWZmZXJVdGlscy5iYXNlNjRFbmNvZGUoZGlnZXN0KTtcbn07XG5mdW5jdGlvbiBjMTRuKGNhcGFiaWxpdHkpIHtcbiAgaWYgKCFjYXBhYmlsaXR5KVxuICAgIHJldHVybiBcIlwiO1xuICBpZiAodHlwZW9mIGNhcGFiaWxpdHkgPT0gXCJzdHJpbmdcIilcbiAgICBjYXBhYmlsaXR5ID0gSlNPTi5wYXJzZShjYXBhYmlsaXR5KTtcbiAgY29uc3QgYzE0bkNhcGFiaWxpdHkgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3Qga2V5cyA9IGtleXNBcnJheShjYXBhYmlsaXR5LCB0cnVlKTtcbiAgaWYgKCFrZXlzKVxuICAgIHJldHVybiBcIlwiO1xuICBrZXlzLnNvcnQoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgYzE0bkNhcGFiaWxpdHlba2V5c1tpXV0gPSBjYXBhYmlsaXR5W2tleXNbaV1dLnNvcnQoKTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYzE0bkNhcGFiaWxpdHkpO1xufVxuZnVuY3Rpb24gbG9nQW5kVmFsaWRhdGVUb2tlbkF1dGhNZXRob2QoYXV0aE9wdGlvbnMsIGxvZ2dlcikge1xuICBpZiAoYXV0aE9wdGlvbnMuYXV0aENhbGxiYWNrKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGgoKVwiLCBcInVzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoQ2FsbGJhY2tcIik7XG4gIH0gZWxzZSBpZiAoYXV0aE9wdGlvbnMuYXV0aFVybCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoKClcIiwgXCJ1c2luZyB0b2tlbiBhdXRoIHdpdGggYXV0aFVybFwiKTtcbiAgfSBlbHNlIGlmIChhdXRoT3B0aW9ucy5rZXkpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQXV0aCgpXCIsIFwidXNpbmcgdG9rZW4gYXV0aCB3aXRoIGNsaWVudC1zaWRlIHNpZ25pbmdcIik7XG4gIH0gZWxzZSBpZiAoYXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGgoKVwiLCBcInVzaW5nIHRva2VuIGF1dGggd2l0aCBzdXBwbGllZCB0b2tlbiBvbmx5XCIpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1zZyA9IFwiYXV0aE9wdGlvbnMgbXVzdCBpbmNsdWRlIHZhbGlkIGF1dGhlbnRpY2F0aW9uIHBhcmFtZXRlcnNcIjtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiQXV0aCgpXCIsIG1zZyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJhc2ljQXV0aEZvcmNlZChvcHRpb25zKSB7XG4gIHJldHVybiBcInVzZVRva2VuQXV0aFwiIGluIG9wdGlvbnMgJiYgIW9wdGlvbnMudXNlVG9rZW5BdXRoO1xufVxuZnVuY3Rpb24gdXNlVG9rZW5BdXRoKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMudXNlVG9rZW5BdXRoIHx8ICFiYXNpY0F1dGhGb3JjZWQob3B0aW9ucykgJiYgKG9wdGlvbnMuYXV0aENhbGxiYWNrIHx8IG9wdGlvbnMuYXV0aFVybCB8fCBvcHRpb25zLnRva2VuIHx8IG9wdGlvbnMudG9rZW5EZXRhaWxzKTtcbn1cbmZ1bmN0aW9uIG5vV2F5VG9SZW5ldyhvcHRpb25zKSB7XG4gIHJldHVybiAhb3B0aW9ucy5rZXkgJiYgIW9wdGlvbnMuYXV0aENhbGxiYWNrICYmICFvcHRpb25zLmF1dGhVcmw7XG59XG52YXIgdHJJZCA9IDA7XG5mdW5jdGlvbiBnZXRUb2tlblJlcXVlc3RJZCgpIHtcbiAgcmV0dXJuIHRySWQrKztcbn1cbnZhciBBdXRoID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIG9wdGlvbnMpIHtcbiAgICAvLyBUaGlzIGluaXRpYWxpemF0aW9uIGlzIGFsd2F5cyBvdmVyd3JpdHRlbiBhbmQgb25seSB1c2VkIHRvIHByZXZlbnQgYSBUeXBlU2NyaXB0IGNvbXBpbGVyIGVycm9yXG4gICAgdGhpcy5hdXRoT3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMudG9rZW5QYXJhbXMgPSBvcHRpb25zLmRlZmF1bHRUb2tlblBhcmFtcyB8fCB7fTtcbiAgICB0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA9IG51bGw7XG4gICAgdGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAodXNlVG9rZW5BdXRoKG9wdGlvbnMpKSB7XG4gICAgICBpZiAobm9XYXlUb1JlbmV3KG9wdGlvbnMpKSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgXCJBdXRoKClcIixcbiAgICAgICAgICBcIldhcm5pbmc6IGxpYnJhcnkgaW5pdGlhbGl6ZWQgd2l0aCBhIHRva2VuIGxpdGVyYWwgd2l0aG91dCBhbnkgd2F5IHRvIHJlbmV3IHRoZSB0b2tlbiB3aGVuIGl0IGV4cGlyZXMgKG5vIGF1dGhVcmwsIGF1dGhDYWxsYmFjaywgb3Iga2V5KS4gU2VlIGh0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yLzQwMTcxIGZvciBoZWxwXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NhdmVUb2tlbk9wdGlvbnMob3B0aW9ucy5kZWZhdWx0VG9rZW5QYXJhbXMsIG9wdGlvbnMpO1xuICAgICAgbG9nQW5kVmFsaWRhdGVUb2tlbkF1dGhNZXRob2QodGhpcy5hdXRoT3B0aW9ucywgdGhpcy5sb2dnZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIW9wdGlvbnMua2V5KSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IFwiTm8gYXV0aGVudGljYXRpb24gb3B0aW9ucyBwcm92aWRlZDsgbmVlZCBvbmUgb2Y6IGtleSwgYXV0aFVybCwgb3IgYXV0aENhbGxiYWNrIChvciBmb3IgdGVzdGluZyBvbmx5LCB0b2tlbiBvciB0b2tlbkRldGFpbHMpXCI7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkF1dGgoKVwiLCBtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKG1zZywgNDAxNjAsIDQwMSk7XG4gICAgICB9XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoKClcIiwgXCJhbm9ueW1vdXMsIHVzaW5nIGJhc2ljIGF1dGhcIik7XG4gICAgICB0aGlzLl9zYXZlQmFzaWNPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBnZXQgbG9nZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5sb2dnZXI7XG4gIH1cbiAgYXN5bmMgYXV0aG9yaXplKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucykge1xuICAgIGlmIChhdXRoT3B0aW9ucyAmJiBhdXRoT3B0aW9ucy5rZXkgJiYgdGhpcy5hdXRoT3B0aW9ucy5rZXkgIT09IGF1dGhPcHRpb25zLmtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byB1cGRhdGUgYXV0aCBvcHRpb25zIHdpdGggaW5jb21wYXRpYmxlIGtleVwiLCA0MDEwMiwgNDAxKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCB0b2tlbkRldGFpbHMgPSBhd2FpdCB0aGlzLl9mb3JjZU5ld1Rva2VuKHRva2VuUGFyYW1zICE9IG51bGwgPyB0b2tlblBhcmFtcyA6IG51bGwsIGF1dGhPcHRpb25zICE9IG51bGwgPyBhdXRoT3B0aW9ucyA6IG51bGwpO1xuICAgICAgaWYgKGlzUmVhbHRpbWUodGhpcy5jbGllbnQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgdGhpcy5jbGllbnQuY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKFxuICAgICAgICAgICAgdG9rZW5EZXRhaWxzLFxuICAgICAgICAgICAgKGVyciwgdG9rZW5EZXRhaWxzMikgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHRva2VuRGV0YWlsczIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9rZW5EZXRhaWxzO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHRoaXMuY2xpZW50LmNvbm5lY3Rpb24gJiYgZXJyLnN0YXR1c0NvZGUgPT09IEh0dHBTdGF0dXNDb2Rlc19kZWZhdWx0LkZvcmJpZGRlbikge1xuICAgICAgICB0aGlzLmNsaWVudC5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKGVycik7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIC8qIEZvciBpbnRlcm5hbCB1c2UsIGVnIGJ5IGNvbm5lY3Rpb25NYW5hZ2VyIC0gdXNlZnVsIHdoZW4gd2FudCB0byBjYWxsIGJhY2tcbiAgICogYXMgc29vbiBhcyB3ZSBoYXZlIHRoZSBuZXcgdG9rZW4sIHJhdGhlciB0aGFuIHdhaXRpbmcgZm9yIGl0IHRvIHRha2VcbiAgICogZWZmZWN0IG9uIHRoZSBjb25uZWN0aW9uIGFzICNhdXRob3JpemUgZG9lcyAqL1xuICBhc3luYyBfZm9yY2VOZXdUb2tlbih0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMpIHtcbiAgICB0aGlzLnRva2VuRGV0YWlscyA9IG51bGw7XG4gICAgdGhpcy5fc2F2ZVRva2VuT3B0aW9ucyh0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMpO1xuICAgIGxvZ0FuZFZhbGlkYXRlVG9rZW5BdXRoTWV0aG9kKHRoaXMuYXV0aE9wdGlvbnMsIHRoaXMubG9nZ2VyKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKHRydWUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBkZWxldGUgdGhpcy50b2tlblBhcmFtcy50aW1lc3RhbXA7XG4gICAgICBkZWxldGUgdGhpcy5hdXRoT3B0aW9ucy5xdWVyeVRpbWU7XG4gICAgfVxuICB9XG4gIGFzeW5jIHJlcXVlc3RUb2tlbih0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMpIHtcbiAgICBjb25zdCByZXNvbHZlZEF1dGhPcHRpb25zID0gYXV0aE9wdGlvbnMgfHwgdGhpcy5hdXRoT3B0aW9ucztcbiAgICBjb25zdCByZXNvbHZlZFRva2VuUGFyYW1zID0gdG9rZW5QYXJhbXMgfHwgY29weSh0aGlzLnRva2VuUGFyYW1zKTtcbiAgICBsZXQgdG9rZW5SZXF1ZXN0Q2FsbGJhY2ssIGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgIGlmIChyZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhDYWxsYmFjaykge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKVwiLCBcInVzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoQ2FsbGJhY2tcIik7XG4gICAgICB0b2tlblJlcXVlc3RDYWxsYmFjayA9IHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aENhbGxiYWNrO1xuICAgIH0gZWxzZSBpZiAocmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoVXJsKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoLnJlcXVlc3RUb2tlbigpXCIsIFwidXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhVcmxcIik7XG4gICAgICB0b2tlblJlcXVlc3RDYWxsYmFjayA9IChwYXJhbXMsIGNiKSA9PiB7XG4gICAgICAgIGNvbnN0IGF1dGhIZWFkZXJzID0gbWl4aW4oXG4gICAgICAgICAgeyBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpblwiIH0sXG4gICAgICAgICAgcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoSGVhZGVyc1xuICAgICAgICApO1xuICAgICAgICBjb25zdCB1c2VQb3N0ID0gcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoTWV0aG9kICYmIHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aE1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcInBvc3RcIjtcbiAgICAgICAgbGV0IHByb3ZpZGVkUXNQYXJhbXM7XG4gICAgICAgIGNvbnN0IHF1ZXJ5SWR4ID0gcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoVXJsLmluZGV4T2YoXCI/XCIpO1xuICAgICAgICBpZiAocXVlcnlJZHggPiAtMSkge1xuICAgICAgICAgIHByb3ZpZGVkUXNQYXJhbXMgPSBwYXJzZVF1ZXJ5U3RyaW5nKHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFVybC5zbGljZShxdWVyeUlkeCkpO1xuICAgICAgICAgIHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFVybCA9IHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFVybC5zbGljZSgwLCBxdWVyeUlkeCk7XG4gICAgICAgICAgaWYgKCF1c2VQb3N0KSB7XG4gICAgICAgICAgICByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhQYXJhbXMgPSBtaXhpbihcbiAgICAgICAgICAgICAgcHJvdmlkZWRRc1BhcmFtcyxcbiAgICAgICAgICAgICAgcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoUGFyYW1zXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdXRoUGFyYW1zID0gbWl4aW4oe30sIHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFBhcmFtcyB8fCB7fSwgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgYXV0aFVybFJlcXVlc3RDYWxsYmFjayA9IChyZXN1bHQpID0+IHtcbiAgICAgICAgICB2YXIgX2EyLCBfYjtcbiAgICAgICAgICBsZXQgYm9keSA9IChfYTIgPSByZXN1bHQuYm9keSkgIT0gbnVsbCA/IF9hMiA6IG51bGw7XG4gICAgICAgICAgbGV0IGNvbnRlbnRUeXBlID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgICAgIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKS50b2tlblJlcXVlc3RDYWxsYmFja1wiLFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIEVycm9yOiBcIiArIGluc3BlY3RFcnJvcihyZXN1bHQuZXJyb3IpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZUhlYWRlck9ySGVhZGVycyA9IChfYiA9IHJlc3VsdC5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSAhPSBudWxsID8gX2IgOiBudWxsO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29udGVudFR5cGVIZWFkZXJPckhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gY29udGVudFR5cGVIZWFkZXJPckhlYWRlcnMuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGVudFR5cGUgPSBjb250ZW50VHlwZUhlYWRlck9ySGVhZGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICAgICAgXCJBdXRoLnJlcXVlc3RUb2tlbigpLnRva2VuUmVxdWVzdENhbGxiYWNrXCIsXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQ7IGNvbnRlbnQtdHlwZTogXCIgKyBjb250ZW50VHlwZSArIFwiOyBib2R5OiBcIiArIGluc3BlY3RCb2R5KGJvZHkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICBjYihyZXN1bHQuZXJyb3IsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0LnVucGFja2VkKSB7XG4gICAgICAgICAgICBjYihudWxsLCBib2R5KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGJvZHkpKVxuICAgICAgICAgICAgYm9keSA9IGJvZHkudG9TdHJpbmcoKTtcbiAgICAgICAgICBpZiAoIWNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICBjYihuZXcgRXJyb3JJbmZvKFwiYXV0aFVybCByZXNwb25zZSBpcyBtaXNzaW5nIGEgY29udGVudC10eXBlIGhlYWRlclwiLCA0MDE3MCwgNDAxKSwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGpzb24gPSBjb250ZW50VHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24vanNvblwiKSA+IC0xLCB0ZXh0ID0gY29udGVudFR5cGUuaW5kZXhPZihcInRleHQvcGxhaW5cIikgPiAtMSB8fCBjb250ZW50VHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24vand0XCIpID4gLTE7XG4gICAgICAgICAgaWYgKCFqc29uICYmICF0ZXh0KSB7XG4gICAgICAgICAgICBjYihcbiAgICAgICAgICAgICAgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICAgICAgICBcImF1dGhVcmwgcmVzcG9uZGVkIHdpdGggdW5hY2NlcHRhYmxlIGNvbnRlbnQtdHlwZSBcIiArIGNvbnRlbnRUeXBlICsgXCIsIHNob3VsZCBiZSBlaXRoZXIgdGV4dC9wbGFpbiwgYXBwbGljYXRpb24vand0IG9yIGFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICA0MDE3MCxcbiAgICAgICAgICAgICAgICA0MDFcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGpzb24pIHtcbiAgICAgICAgICAgIGlmIChib2R5Lmxlbmd0aCA+IE1BWF9UT0tFTl9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgY2IobmV3IEVycm9ySW5mbyhcImF1dGhVcmwgcmVzcG9uc2UgZXhjZWVkZWQgbWF4IHBlcm1pdHRlZCBsZW5ndGhcIiwgNDAxNzAsIDQwMSksIG51bGwpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY2IoXG4gICAgICAgICAgICAgICAgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBlcnJvciBwcm9jZXNzaW5nIGF1dGhVUkwgcmVzcG9uc2U7IGVyciA9IFwiICsgZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgNDAxNzAsXG4gICAgICAgICAgICAgICAgICA0MDFcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYihudWxsLCBib2R5LCBjb250ZW50VHlwZSk7XG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgXCJBdXRoLnJlcXVlc3RUb2tlbigpLnRva2VuUmVxdWVzdENhbGxiYWNrXCIsXG4gICAgICAgICAgXCJSZXF1ZXN0aW5nIHRva2VuIGZyb20gXCIgKyByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhVcmwgKyBcIjsgUGFyYW1zOiBcIiArIEpTT04uc3RyaW5naWZ5KGF1dGhQYXJhbXMpICsgXCI7IG1ldGhvZDogXCIgKyAodXNlUG9zdCA/IFwiUE9TVFwiIDogXCJHRVRcIilcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHVzZVBvc3QpIHtcbiAgICAgICAgICBjb25zdCBoZWFkZXJzID0gYXV0aEhlYWRlcnMgfHwge307XG4gICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI7XG4gICAgICAgICAgY29uc3QgYm9keSA9IHRvUXVlcnlTdHJpbmcoYXV0aFBhcmFtcykuc2xpY2UoMSk7XG4gICAgICAgICAgd2hlblByb21pc2VTZXR0bGVzKFxuICAgICAgICAgICAgdGhpcy5jbGllbnQuaHR0cC5kb1VyaShcbiAgICAgICAgICAgICAgSHR0cE1ldGhvZHNfZGVmYXVsdC5Qb3N0LFxuICAgICAgICAgICAgICByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhVcmwsXG4gICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgIHByb3ZpZGVkUXNQYXJhbXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoZXJyLCByZXN1bHQpID0+IGVyciA/IGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2soZXJyKSA6IGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2socmVzdWx0KVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hlblByb21pc2VTZXR0bGVzKFxuICAgICAgICAgICAgdGhpcy5jbGllbnQuaHR0cC5kb1VyaShIdHRwTWV0aG9kc19kZWZhdWx0LkdldCwgcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoVXJsLCBhdXRoSGVhZGVycyB8fCB7fSwgbnVsbCwgYXV0aFBhcmFtcyksXG4gICAgICAgICAgICAoZXJyLCByZXN1bHQpID0+IGVyciA/IGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2soZXJyKSA6IGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2socmVzdWx0KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChyZXNvbHZlZEF1dGhPcHRpb25zLmtleSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkF1dGgucmVxdWVzdFRva2VuKClcIixcbiAgICAgICAgXCJ1c2luZyB0b2tlbiBhdXRoIHdpdGggY2xpZW50LXNpZGUgc2lnbmluZ1wiXG4gICAgICApO1xuICAgICAgdG9rZW5SZXF1ZXN0Q2FsbGJhY2sgPSAocGFyYW1zLCBjYikgPT4ge1xuICAgICAgICB3aGVuUHJvbWlzZVNldHRsZXMoXG4gICAgICAgICAgdGhpcy5jcmVhdGVUb2tlblJlcXVlc3QocGFyYW1zLCByZXNvbHZlZEF1dGhPcHRpb25zKSxcbiAgICAgICAgICAoZXJyLCByZXN1bHQpID0+IGNiKGVyciwgcmVzdWx0ICE9IG51bGwgPyByZXN1bHQgOiBudWxsKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbXNnID0gXCJOZWVkIGEgbmV3IHRva2VuLCBidXQgYXV0aE9wdGlvbnMgZG9lcyBub3QgaW5jbHVkZSBhbnkgd2F5IHRvIHJlcXVlc3Qgb25lIChubyBhdXRoVXJsLCBhdXRoQ2FsbGJhY2ssIG9yIGtleSlcIjtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJBdXRoKClcIixcbiAgICAgICAgXCJsaWJyYXJ5IGluaXRpYWxpemVkIHdpdGggYSB0b2tlbiBsaXRlcmFsIHdpdGhvdXQgYW55IHdheSB0byByZW5ldyB0aGUgdG9rZW4gd2hlbiBpdCBleHBpcmVzIChubyBhdXRoVXJsLCBhdXRoQ2FsbGJhY2ssIG9yIGtleSkuIFNlZSBodHRwczovL2hlbHAuYWJseS5pby9lcnJvci80MDE3MSBmb3IgaGVscFwiXG4gICAgICApO1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhtc2csIDQwMTcxLCA0MDMpO1xuICAgIH1cbiAgICBpZiAoXCJjYXBhYmlsaXR5XCIgaW4gcmVzb2x2ZWRUb2tlblBhcmFtcylcbiAgICAgIHJlc29sdmVkVG9rZW5QYXJhbXMuY2FwYWJpbGl0eSA9IGMxNG4oXG4gICAgICAgIHJlc29sdmVkVG9rZW5QYXJhbXMuY2FwYWJpbGl0eVxuICAgICAgKTtcbiAgICBjb25zdCB0b2tlblJlcXVlc3QgPSAoc2lnbmVkVG9rZW5QYXJhbXMsIHRva2VuQ2IpID0+IHtcbiAgICAgIGNvbnN0IGtleU5hbWUgPSBzaWduZWRUb2tlblBhcmFtcy5rZXlOYW1lLCBwYXRoID0gXCIva2V5cy9cIiArIGtleU5hbWUgKyBcIi9yZXF1ZXN0VG9rZW5cIiwgdG9rZW5VcmkgPSBmdW5jdGlvbihob3N0KSB7XG4gICAgICAgIHJldHVybiBjbGllbnQuYmFzZVVyaShob3N0KSArIHBhdGg7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVxdWVzdEhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zKTtcbiAgICAgIGlmIChyZXNvbHZlZEF1dGhPcHRpb25zLnJlcXVlc3RIZWFkZXJzKVxuICAgICAgICBtaXhpbihyZXF1ZXN0SGVhZGVycywgcmVzb2x2ZWRBdXRoT3B0aW9ucy5yZXF1ZXN0SGVhZGVycyk7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKS5yZXF1ZXN0VG9rZW5cIixcbiAgICAgICAgXCJTZW5kaW5nIFBPU1QgdG8gXCIgKyBwYXRoICsgXCI7IFRva2VuIHBhcmFtczogXCIgKyBKU09OLnN0cmluZ2lmeShzaWduZWRUb2tlblBhcmFtcylcbiAgICAgICk7XG4gICAgICB3aGVuUHJvbWlzZVNldHRsZXMoXG4gICAgICAgIHRoaXMuY2xpZW50Lmh0dHAuZG8oSHR0cE1ldGhvZHNfZGVmYXVsdC5Qb3N0LCB0b2tlblVyaSwgcmVxdWVzdEhlYWRlcnMsIEpTT04uc3RyaW5naWZ5KHNpZ25lZFRva2VuUGFyYW1zKSwgbnVsbCksXG4gICAgICAgIChlcnIsIHJlc3VsdCkgPT4gZXJyID8gdG9rZW5DYihlcnIpIDogdG9rZW5DYihyZXN1bHQuZXJyb3IsIHJlc3VsdC5ib2R5LCByZXN1bHQudW5wYWNrZWQpXG4gICAgICApO1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCB0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXRFeHBpcmVkID0gZmFsc2UsIHRpbWVvdXRMZW5ndGggPSB0aGlzLmNsaWVudC5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQsIHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXRFeHBpcmVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgbXNnID0gXCJUb2tlbiByZXF1ZXN0IGNhbGxiYWNrIHRpbWVkIG91dCBhZnRlciBcIiArIHRpbWVvdXRMZW5ndGggLyAxZTMgKyBcIiBzZWNvbmRzXCI7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkF1dGgucmVxdWVzdFRva2VuKClcIiwgbXNnKTtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8obXNnLCA0MDE3MCwgNDAxKSk7XG4gICAgICB9LCB0aW1lb3V0TGVuZ3RoKTtcbiAgICAgIHRva2VuUmVxdWVzdENhbGxiYWNrKHJlc29sdmVkVG9rZW5QYXJhbXMsIChlcnIsIHRva2VuUmVxdWVzdE9yRGV0YWlscywgY29udGVudFR5cGUpID0+IHtcbiAgICAgICAgaWYgKHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dEV4cGlyZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjbGVhclRpbWVvdXQodG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0KTtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgICAgXCJBdXRoLnJlcXVlc3RUb2tlbigpXCIsXG4gICAgICAgICAgICBcInRva2VuIHJlcXVlc3Qgc2lnbmluZyBjYWxsIHJldHVybmVkIGVycm9yOyBlcnIgPSBcIiArIGluc3BlY3RFcnJvcihlcnIpXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZWplY3Qobm9ybWFsaXNlQXV0aGNhbGxiYWNrRXJyb3IoZXJyKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKHRva2VuUmVxdWVzdE9yRGV0YWlscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3JJbmZvKFwiVG9rZW4gc3RyaW5nIGlzIGVtcHR5XCIsIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuUmVxdWVzdE9yRGV0YWlscy5sZW5ndGggPiBNQVhfVE9LRU5fTEVOR1RIKSB7XG4gICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgICAgICAgXCJUb2tlbiBzdHJpbmcgZXhjZWVkZWQgbWF4IHBlcm1pdHRlZCBsZW5ndGggKHdhcyBcIiArIHRva2VuUmVxdWVzdE9yRGV0YWlscy5sZW5ndGggKyBcIiBieXRlcylcIixcbiAgICAgICAgICAgICAgICA0MDE3MCxcbiAgICAgICAgICAgICAgICA0MDFcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuUmVxdWVzdE9yRGV0YWlscyA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0b2tlblJlcXVlc3RPckRldGFpbHMgPT09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhcIlRva2VuIHN0cmluZyB3YXMgbGl0ZXJhbCBudWxsL3VuZGVmaW5lZFwiLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0b2tlblJlcXVlc3RPckRldGFpbHNbMF0gPT09IFwie1wiICYmICEoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5kZXhPZihcImFwcGxpY2F0aW9uL2p3dFwiKSA+IC0xKSkge1xuICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgICAgICAgIFwiVG9rZW4gd2FzIGRvdWJsZS1lbmNvZGVkOyBtYWtlIHN1cmUgeW91J3JlIG5vdCBKU09OLWVuY29kaW5nIGFuIGFscmVhZHkgZW5jb2RlZCB0b2tlbiByZXF1ZXN0IG9yIGRldGFpbHNcIixcbiAgICAgICAgICAgICAgICA0MDE3MCxcbiAgICAgICAgICAgICAgICA0MDFcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZSh7IHRva2VuOiB0b2tlblJlcXVlc3RPckRldGFpbHMgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRva2VuUmVxdWVzdE9yRGV0YWlscyAhPT0gXCJvYmplY3RcIiB8fCB0b2tlblJlcXVlc3RPckRldGFpbHMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSBcIkV4cGVjdGVkIHRva2VuIHJlcXVlc3QgY2FsbGJhY2sgdG8gY2FsbCBiYWNrIHdpdGggYSB0b2tlbiBzdHJpbmcgb3IgdG9rZW4gcmVxdWVzdC9kZXRhaWxzIG9iamVjdCwgYnV0IGdvdCBhIFwiICsgdHlwZW9mIHRva2VuUmVxdWVzdE9yRGV0YWlscztcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJBdXRoLnJlcXVlc3RUb2tlbigpXCIsIG1zZyk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8obXNnLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9iamVjdFNpemUgPSBKU09OLnN0cmluZ2lmeSh0b2tlblJlcXVlc3RPckRldGFpbHMpLmxlbmd0aDtcbiAgICAgICAgaWYgKG9iamVjdFNpemUgPiBNQVhfVE9LRU5fTEVOR1RIICYmICFyZXNvbHZlZEF1dGhPcHRpb25zLnN1cHByZXNzTWF4TGVuZ3RoQ2hlY2spIHtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgICAgICBcIlRva2VuIHJlcXVlc3QvZGV0YWlscyBvYmplY3QgZXhjZWVkZWQgbWF4IHBlcm1pdHRlZCBzdHJpbmdpZmllZCBzaXplICh3YXMgXCIgKyBvYmplY3RTaXplICsgXCIgYnl0ZXMpXCIsXG4gICAgICAgICAgICAgIDQwMTcwLFxuICAgICAgICAgICAgICA0MDFcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJpc3N1ZWRcIiBpbiB0b2tlblJlcXVlc3RPckRldGFpbHMpIHtcbiAgICAgICAgICByZXNvbHZlKHRva2VuUmVxdWVzdE9yRGV0YWlscyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKFwia2V5TmFtZVwiIGluIHRva2VuUmVxdWVzdE9yRGV0YWlscykpIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSBcIkV4cGVjdGVkIHRva2VuIHJlcXVlc3QgY2FsbGJhY2sgdG8gY2FsbCBiYWNrIHdpdGggYSB0b2tlbiBzdHJpbmcsIHRva2VuIHJlcXVlc3Qgb2JqZWN0LCBvciB0b2tlbiBkZXRhaWxzIG9iamVjdFwiO1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkF1dGgucmVxdWVzdFRva2VuKClcIiwgbXNnKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhtc2csIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5SZXF1ZXN0KHRva2VuUmVxdWVzdE9yRGV0YWlscywgKGVycjIsIHRva2VuUmVzcG9uc2UsIHVucGFja2VkKSA9PiB7XG4gICAgICAgICAgaWYgKGVycjIpIHtcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICAgICAgXCJBdXRoLnJlcXVlc3RUb2tlbigpXCIsXG4gICAgICAgICAgICAgIFwidG9rZW4gcmVxdWVzdCBBUEkgY2FsbCByZXR1cm5lZCBlcnJvcjsgZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyMilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZWplY3Qobm9ybWFsaXNlQXV0aGNhbGxiYWNrRXJyb3IoZXJyMikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXVucGFja2VkKVxuICAgICAgICAgICAgdG9rZW5SZXNwb25zZSA9IEpTT04ucGFyc2UodG9rZW5SZXNwb25zZSk7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQXV0aC5nZXRUb2tlbigpXCIsIFwidG9rZW4gcmVjZWl2ZWRcIik7XG4gICAgICAgICAgcmVzb2x2ZSh0b2tlblJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuZCBzaWduIGEgdG9rZW4gcmVxdWVzdCBiYXNlZCBvbiB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgICogTk9URSB0aGlzIGNhbiBvbmx5IGJlIHVzZWQgd2hlbiB0aGUga2V5IHZhbHVlIGlzIGF2YWlsYWJsZSBsb2NhbGx5LlxuICAgKiBPdGhlcndpc2UsIHNpZ25lZCB0b2tlbiByZXF1ZXN0cyBtdXN0IGJlIG9idGFpbmVkIGZyb20gdGhlIGtleVxuICAgKiBvd25lciAoZWl0aGVyIHVzaW5nIHRoZSB0b2tlbiByZXF1ZXN0IGNhbGxiYWNrIG9yIHVybCkuXG4gICAqXG4gICAqIEBwYXJhbSBhdXRoT3B0aW9uc1xuICAgKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVxdWVzdCBvcHRpb25zOlxuICAgKiAtIGtleTogICAgICAgICAgIHRoZSBrZXkgdG8gdXNlLiBJZiBub3Qgc3BlY2lmaWVkLCBhIGtleSBwYXNzZWQgaW4gY29uc3RydWN0aW5nXG4gICAqICAgICAgICAgICAgICAgICAgdGhlIFJlc3QgaW50ZXJmYWNlIHdpbGwgYmUgdXNlZFxuICAgKlxuICAgKiAtIHF1ZXJ5VGltZSAgICAgIChvcHRpb25hbCkgYm9vbGVhbiBpbmRpY2F0aW5nIHRoYXQgdGhlIGFibHkgc3lzdGVtIHNob3VsZCBiZVxuICAgKiAgICAgICAgICAgICAgICAgIHF1ZXJpZWQgZm9yIHRoZSBjdXJyZW50IHRpbWUgd2hlbiBub25lIGlzIHNwZWNpZmllZCBleHBsaWNpdGx5XG4gICAqXG4gICAqIC0gcmVxdWVzdEhlYWRlcnMgKG9wdGlvbmFsLCB1bnN1cHBvcnRlZCwgZm9yIHRlc3Rpbmcgb25seSkgZXh0cmEgaGVhZGVycyB0byBhZGQgdG8gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2VuIHJlcXVlc3RcbiAgICpcbiAgICogQHBhcmFtIHRva2VuUGFyYW1zXG4gICAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVxdWVzdGVkIHRva2VuOlxuICAgKiAtIHR0bDogICAgICAgKG9wdGlvbmFsKSB0aGUgcmVxdWVzdGVkIGxpZmUgb2YgdGhlIHRva2VuIGluIG1zLiBJZiBub25lIGlzIHNwZWNpZmllZFxuICAgKiAgICAgICAgICAgICAgICAgIGEgZGVmYXVsdCBvZiAxIGhvdXIgaXMgcHJvdmlkZWQuIFRoZSBtYXhpbXVtIGxpZmV0aW1lIGlzIDI0aG91cnM7IGFueSByZXF1ZXN0XG4gICAqICAgICAgICAgICAgICAgICAgZXhjZWVkaW5nIHRoYXQgbGlmZXRpbWUgd2lsbCBiZSByZWplY3RlZCB3aXRoIGFuIGVycm9yLlxuICAgKlxuICAgKiAtIGNhcGFiaWxpdHk6ICAgIChvcHRpb25hbCkgdGhlIGNhcGFiaWxpdHkgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGFjY2VzcyB0b2tlbi5cbiAgICogICAgICAgICAgICAgICAgICBJZiBub25lIGlzIHNwZWNpZmllZCwgYSB0b2tlbiB3aWxsIGJlIHJlcXVlc3RlZCB3aXRoIGFsbCBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICBjYXBhYmlsaXRpZXMgb2YgdGhlIHNwZWNpZmllZCBrZXkuXG4gICAqXG4gICAqIC0gY2xpZW50SWQ6ICAgICAgKG9wdGlvbmFsKSBhIGNsaWVudCBJRCB0byBhc3NvY2lhdGUgd2l0aCB0aGUgdG9rZW47IGlmIG5vdFxuICAgKiAgICAgICAgICAgICAgICAgIHNwZWNpZmllZCwgYSBjbGllbnRJZCBwYXNzZWQgaW4gY29uc3RydWN0aW5nIHRoZSBSZXN0IGludGVyZmFjZSB3aWxsIGJlIHVzZWRcbiAgICpcbiAgICogLSB0aW1lc3RhbXA6ICAgICAob3B0aW9uYWwpIHRoZSB0aW1lIGluIG1zIHNpbmNlIHRoZSBlcG9jaC4gSWYgbm9uZSBpcyBzcGVjaWZpZWQsXG4gICAqICAgICAgICAgICAgICAgICAgdGhlIHN5c3RlbSB3aWxsIGJlIHF1ZXJpZWQgZm9yIGEgdGltZSB2YWx1ZSB0byB1c2UuXG4gICAqL1xuICBhc3luYyBjcmVhdGVUb2tlblJlcXVlc3QodG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zKSB7XG4gICAgYXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucyB8fCB0aGlzLmF1dGhPcHRpb25zO1xuICAgIHRva2VuUGFyYW1zID0gdG9rZW5QYXJhbXMgfHwgY29weSh0aGlzLnRva2VuUGFyYW1zKTtcbiAgICBjb25zdCBrZXkgPSBhdXRoT3B0aW9ucy5rZXk7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJObyBrZXkgc3BlY2lmaWVkXCIsIDQwMTAxLCA0MDMpO1xuICAgIH1cbiAgICBjb25zdCBrZXlQYXJ0cyA9IGtleS5zcGxpdChcIjpcIiksIGtleU5hbWUgPSBrZXlQYXJ0c1swXSwga2V5U2VjcmV0ID0ga2V5UGFydHNbMV07XG4gICAgaWYgKCFrZXlTZWNyZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJJbnZhbGlkIGtleSBzcGVjaWZpZWRcIiwgNDAxMDEsIDQwMyk7XG4gICAgfVxuICAgIGlmICh0b2tlblBhcmFtcy5jbGllbnRJZCA9PT0gXCJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcImNsaWVudElkIGNhblxcdTIwMTl0IGJlIGFuIGVtcHR5IHN0cmluZ1wiLCA0MDAxMiwgNDAwKTtcbiAgICB9XG4gICAgaWYgKFwiY2FwYWJpbGl0eVwiIGluIHRva2VuUGFyYW1zKSB7XG4gICAgICB0b2tlblBhcmFtcy5jYXBhYmlsaXR5ID0gYzE0bih0b2tlblBhcmFtcy5jYXBhYmlsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdCA9IG1peGluKHsga2V5TmFtZSB9LCB0b2tlblBhcmFtcyksIGNsaWVudElkID0gdG9rZW5QYXJhbXMuY2xpZW50SWQgfHwgXCJcIiwgdHRsID0gdG9rZW5QYXJhbXMudHRsIHx8IFwiXCIsIGNhcGFiaWxpdHkgPSB0b2tlblBhcmFtcy5jYXBhYmlsaXR5IHx8IFwiXCI7XG4gICAgaWYgKCFyZXF1ZXN0LnRpbWVzdGFtcCkge1xuICAgICAgcmVxdWVzdC50aW1lc3RhbXAgPSBhd2FpdCB0aGlzLl9nZXRUaW1lc3RhbXAoYXV0aE9wdGlvbnMgJiYgYXV0aE9wdGlvbnMucXVlcnlUaW1lKTtcbiAgICB9XG4gICAgY29uc3Qgbm9uY2UgPSByZXF1ZXN0Lm5vbmNlIHx8IChyZXF1ZXN0Lm5vbmNlID0gcmFuZG9tKCkpLCB0aW1lc3RhbXAgPSByZXF1ZXN0LnRpbWVzdGFtcDtcbiAgICBjb25zdCBzaWduVGV4dCA9IHJlcXVlc3Qua2V5TmFtZSArIFwiXFxuXCIgKyB0dGwgKyBcIlxcblwiICsgY2FwYWJpbGl0eSArIFwiXFxuXCIgKyBjbGllbnRJZCArIFwiXFxuXCIgKyB0aW1lc3RhbXAgKyBcIlxcblwiICsgbm9uY2UgKyBcIlxcblwiO1xuICAgIHJlcXVlc3QubWFjID0gcmVxdWVzdC5tYWMgfHwgaG1hYyhzaWduVGV4dCwga2V5U2VjcmV0KTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoLmdldFRva2VuUmVxdWVzdCgpXCIsIFwiZ2VuZXJhdGVkIHNpZ25lZCByZXF1ZXN0XCIpO1xuICAgIHJldHVybiByZXF1ZXN0O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGF1dGggcXVlcnkgcGFyYW1zIHRvIHVzZSBmb3IgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbixcbiAgICogYmFzZWQgb24gdGhlIGN1cnJlbnQgYXV0aCBwYXJhbWV0ZXJzXG4gICAqL1xuICBhc3luYyBnZXRBdXRoUGFyYW1zKCkge1xuICAgIGlmICh0aGlzLm1ldGhvZCA9PSBcImJhc2ljXCIpXG4gICAgICByZXR1cm4geyBrZXk6IHRoaXMua2V5IH07XG4gICAgZWxzZSB7XG4gICAgICBsZXQgdG9rZW5EZXRhaWxzID0gYXdhaXQgdGhpcy5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoZmFsc2UpO1xuICAgICAgaWYgKCF0b2tlbkRldGFpbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXV0aC5nZXRBdXRoUGFyYW1zKCk6IF9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyByZXR1cm5lZCBubyBlcnJvciBvciB0b2tlbkRldGFpbHNcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBhY2Nlc3NfdG9rZW46IHRva2VuRGV0YWlscy50b2tlbiB9O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBhdXRob3JpemF0aW9uIGhlYWRlciB0byB1c2UgZm9yIGEgUkVTVCBvciBjb21ldCByZXF1ZXN0LFxuICAgKiBiYXNlZCBvbiB0aGUgY3VycmVudCBhdXRoIHBhcmFtZXRlcnNcbiAgICovXG4gIGFzeW5jIGdldEF1dGhIZWFkZXJzKCkge1xuICAgIGlmICh0aGlzLm1ldGhvZCA9PSBcImJhc2ljXCIpIHtcbiAgICAgIHJldHVybiB7IGF1dGhvcml6YXRpb246IFwiQmFzaWMgXCIgKyB0aGlzLmJhc2ljS2V5IH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRva2VuRGV0YWlscyA9IGF3YWl0IHRoaXMuX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKGZhbHNlKTtcbiAgICAgIGlmICghdG9rZW5EZXRhaWxzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF1dGguZ2V0QXV0aFBhcmFtcygpOiBfZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMgcmV0dXJuZWQgbm8gZXJyb3Igb3IgdG9rZW5EZXRhaWxzXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgYXV0aG9yaXphdGlvbjogXCJCZWFyZXIgXCIgKyB0b0Jhc2U2NCh0b2tlbkRldGFpbHMudG9rZW4pIH07XG4gICAgfVxuICB9XG4gIF9zYXZlQmFzaWNPcHRpb25zKGF1dGhPcHRpb25zKSB7XG4gICAgdGhpcy5tZXRob2QgPSBcImJhc2ljXCI7XG4gICAgdGhpcy5rZXkgPSBhdXRoT3B0aW9ucy5rZXk7XG4gICAgdGhpcy5iYXNpY0tleSA9IHRvQmFzZTY0KGF1dGhPcHRpb25zLmtleSk7XG4gICAgdGhpcy5hdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zIHx8IHt9O1xuICAgIGlmIChcImNsaWVudElkXCIgaW4gYXV0aE9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX3VzZXJTZXRDbGllbnRJZChhdXRoT3B0aW9ucy5jbGllbnRJZCk7XG4gICAgfVxuICB9XG4gIF9zYXZlVG9rZW5PcHRpb25zKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucykge1xuICAgIHRoaXMubWV0aG9kID0gXCJ0b2tlblwiO1xuICAgIGlmICh0b2tlblBhcmFtcykge1xuICAgICAgdGhpcy50b2tlblBhcmFtcyA9IHRva2VuUGFyYW1zO1xuICAgIH1cbiAgICBpZiAoYXV0aE9wdGlvbnMpIHtcbiAgICAgIGlmIChhdXRoT3B0aW9ucy50b2tlbikge1xuICAgICAgICBhdXRoT3B0aW9ucy50b2tlbkRldGFpbHMgPSB0eXBlb2YgYXV0aE9wdGlvbnMudG9rZW4gPT09IFwic3RyaW5nXCIgPyB7IHRva2VuOiBhdXRoT3B0aW9ucy50b2tlbiB9IDogYXV0aE9wdGlvbnMudG9rZW47XG4gICAgICB9XG4gICAgICBpZiAoYXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzKSB7XG4gICAgICAgIHRoaXMudG9rZW5EZXRhaWxzID0gYXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzO1xuICAgICAgfVxuICAgICAgaWYgKFwiY2xpZW50SWRcIiBpbiBhdXRoT3B0aW9ucykge1xuICAgICAgICB0aGlzLl91c2VyU2V0Q2xpZW50SWQoYXV0aE9wdGlvbnMuY2xpZW50SWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5hdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zO1xuICAgIH1cbiAgfVxuICAvKiBAcGFyYW0gZm9yY2VTdXBlcnNlZGU6IGZvcmNlIGEgbmV3IHRva2VuIHJlcXVlc3QgZXZlbiBpZiB0aGVyZSdzIG9uZSBpblxuICAgKiBwcm9ncmVzcywgbWFraW5nIGFsbCBwZW5kaW5nIGNhbGxiYWNrcyB3YWl0IGZvciB0aGUgbmV3IG9uZSAqL1xuICBhc3luYyBfZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoZm9yY2VTdXBlcnNlZGUpIHtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXMudG9rZW5EZXRhaWxzO1xuICAgIGlmICh0b2tlbikge1xuICAgICAgaWYgKHRoaXMuX3Rva2VuQ2xpZW50SWRNaXNtYXRjaCh0b2tlbi5jbGllbnRJZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICBcIk1pc21hdGNoIGJldHdlZW4gY2xpZW50SWQgaW4gdG9rZW4gKFwiICsgdG9rZW4uY2xpZW50SWQgKyBcIikgYW5kIGN1cnJlbnQgY2xpZW50SWQgKFwiICsgdGhpcy5jbGllbnRJZCArIFwiKVwiLFxuICAgICAgICAgIDQwMTAyLFxuICAgICAgICAgIDQwM1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNsaWVudC5pc1RpbWVPZmZzZXRTZXQoKSB8fCAhdG9rZW4uZXhwaXJlcyB8fCB0b2tlbi5leHBpcmVzID49IHRoaXMuY2xpZW50LmdldFRpbWVzdGFtcFVzaW5nT2Zmc2V0KCkpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkF1dGguZ2V0VG9rZW4oKVwiLFxuICAgICAgICAgIFwidXNpbmcgY2FjaGVkIHRva2VuOyBleHBpcmVzID0gXCIgKyB0b2tlbi5leHBpcmVzXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH1cbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGguZ2V0VG9rZW4oKVwiLCBcImRlbGV0aW5nIGV4cGlyZWQgdG9rZW5cIik7XG4gICAgICB0aGlzLnRva2VuRGV0YWlscyA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSAodGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0IHx8ICh0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgPSBtdWx0aWNhc3Rlcl9kZWZhdWx0LmNyZWF0ZSh0aGlzLmxvZ2dlcikpKS5jcmVhdGVQcm9taXNlKCk7XG4gICAgaWYgKHRoaXMuY3VycmVudFRva2VuUmVxdWVzdElkICE9PSBudWxsICYmICFmb3JjZVN1cGVyc2VkZSkge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHRva2VuUmVxdWVzdElkID0gdGhpcy5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgPSBnZXRUb2tlblJlcXVlc3RJZCgpO1xuICAgIGxldCB0b2tlblJlc3BvbnNlLCBjYXVnaHRFcnJvciA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHRva2VuUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3RUb2tlbih0aGlzLnRva2VuUGFyYW1zLCB0aGlzLmF1dGhPcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhdWdodEVycm9yID0gZXJyO1xuICAgIH1cbiAgICBpZiAodGhpcy5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgPiB0b2tlblJlcXVlc3RJZCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkF1dGguX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKClcIixcbiAgICAgICAgXCJEaXNjYXJkaW5nIHRva2VuIHJlcXVlc3QgcmVzcG9uc2U7IG92ZXJ0YWtlbiBieSBuZXdlciBvbmVcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA9IG51bGw7XG4gICAgY29uc3QgbXVsdGljYXN0ZXIgPSB0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3Q7XG4gICAgdGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoY2F1Z2h0RXJyb3IpIHtcbiAgICAgIG11bHRpY2FzdGVyID09IG51bGwgPyB2b2lkIDAgOiBtdWx0aWNhc3Rlci5yZWplY3RBbGwoY2F1Z2h0RXJyb3IpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIG11bHRpY2FzdGVyID09IG51bGwgPyB2b2lkIDAgOiBtdWx0aWNhc3Rlci5yZXNvbHZlQWxsKHRoaXMudG9rZW5EZXRhaWxzID0gdG9rZW5SZXNwb25zZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgLyogVXNlci1zZXQ6IGNoZWNrIHR5cGVzLCAnKicgaXMgZGlzYWxsb3dlZCwgdGhyb3cgYW55IGVycm9ycyAqL1xuICBfdXNlclNldENsaWVudElkKGNsaWVudElkKSB7XG4gICAgaWYgKCEodHlwZW9mIGNsaWVudElkID09PSBcInN0cmluZ1wiIHx8IGNsaWVudElkID09PSBudWxsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcImNsaWVudElkIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bGxcIiwgNDAwMTIsIDQwMCk7XG4gICAgfSBlbHNlIGlmIChjbGllbnRJZCA9PT0gXCIqXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgICdDYW5cXHUyMDE5dCB1c2UgXCIqXCIgYXMgYSBjbGllbnRJZCBhcyB0aGF0IHN0cmluZyBpcyByZXNlcnZlZC4gKFRvIGNoYW5nZSB0aGUgZGVmYXVsdCB0b2tlbiByZXF1ZXN0IGJlaGF2aW91ciB0byB1c2UgYSB3aWxkY2FyZCBjbGllbnRJZCwgaW5zdGFudGlhdGUgdGhlIGxpYnJhcnkgd2l0aCB7ZGVmYXVsdFRva2VuUGFyYW1zOiB7Y2xpZW50SWQ6IFwiKlwifX0pLCBvciBpZiBjYWxsaW5nIGF1dGhvcml6ZSgpLCBwYXNzIGl0IGluIGFzIGEgdG9rZW5QYXJhbTogYXV0aG9yaXplKHtjbGllbnRJZDogXCIqXCJ9LCBhdXRoT3B0aW9ucyknLFxuICAgICAgICA0MDAxMixcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlcnIgPSB0aGlzLl91bmNoZWNrZWRTZXRDbGllbnRJZChjbGllbnRJZCk7XG4gICAgICBpZiAoZXJyKVxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIC8qIEFibHktc2V0OiBubyB0eXBlY2hlY2tpbmcsICcqJyBpcyBhbGxvd2VkIGJ1dCBub3Qgc2V0IG9uIHRoaXMuY2xpZW50SWQpLCByZXR1cm4gZXJyb3JzIHRvIHRoZSBjYWxsZXIgKi9cbiAgX3VuY2hlY2tlZFNldENsaWVudElkKGNsaWVudElkKSB7XG4gICAgaWYgKHRoaXMuX3Rva2VuQ2xpZW50SWRNaXNtYXRjaChjbGllbnRJZCkpIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwiVW5leHBlY3RlZCBjbGllbnRJZCBtaXNtYXRjaDogY2xpZW50IGhhcyBcIiArIHRoaXMuY2xpZW50SWQgKyBcIiwgcmVxdWVzdGVkIFwiICsgY2xpZW50SWQ7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3JJbmZvKG1zZywgNDAxMDIsIDQwMSk7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJBdXRoLl91bmNoZWNrZWRTZXRDbGllbnRJZCgpXCIsIG1zZyk7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsaWVudElkID0gdGhpcy50b2tlblBhcmFtcy5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIF90b2tlbkNsaWVudElkTWlzbWF0Y2godG9rZW5DbGllbnRJZCkge1xuICAgIHJldHVybiAhISh0aGlzLmNsaWVudElkICYmIHRoaXMuY2xpZW50SWQgIT09IFwiKlwiICYmIHRva2VuQ2xpZW50SWQgJiYgdG9rZW5DbGllbnRJZCAhPT0gXCIqXCIgJiYgdGhpcy5jbGllbnRJZCAhPT0gdG9rZW5DbGllbnRJZCk7XG4gIH1cbiAgc3RhdGljIGlzVG9rZW5FcnIoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IuY29kZSAmJiBlcnJvci5jb2RlID49IDQwMTQwICYmIGVycm9yLmNvZGUgPCA0MDE1MDtcbiAgfVxuICByZXZva2VUb2tlbnMoc3BlY2lmaWVycywgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXN0LnJldm9rZVRva2VucyhzcGVjaWZpZXJzLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogU2FtZSBhcyB7QGxpbmsgQmFzZUNsaWVudC5nZXRUaW1lc3RhbXB9IGJ1dCBhbHNvIHRha2VzIGludG8gYWNjb3VudCB7QGxpbmsgQXV0aC5hdXRoT3B0aW9uc31cbiAgICovXG4gIGFzeW5jIF9nZXRUaW1lc3RhbXAocXVlcnlUaW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmdldFRpbWVzdGFtcChxdWVyeVRpbWUgfHwgISF0aGlzLmF1dGhPcHRpb25zLnF1ZXJ5VGltZSk7XG4gIH1cbn07XG52YXIgYXV0aF9kZWZhdWx0ID0gQXV0aDtcblxuLy8gc3JjL2NvbW1vbi90eXBlcy9odHRwLnRzXG5mdW5jdGlvbiBwYXJhbVN0cmluZyhwYXJhbXMpIHtcbiAgY29uc3QgcGFyYW1QYWlycyA9IFtdO1xuICBpZiAocGFyYW1zKSB7XG4gICAgZm9yIChjb25zdCBuZWVkbGUgaW4gcGFyYW1zKSB7XG4gICAgICBwYXJhbVBhaXJzLnB1c2gobmVlZGxlICsgXCI9XCIgKyBwYXJhbXNbbmVlZGxlXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJhbVBhaXJzLmpvaW4oXCImXCIpO1xufVxuZnVuY3Rpb24gYXBwZW5kaW5nUGFyYW1zKHVyaSwgcGFyYW1zKSB7XG4gIHJldHVybiB1cmkgKyAocGFyYW1zID8gXCI/XCIgOiBcIlwiKSArIHBhcmFtU3RyaW5nKHBhcmFtcyk7XG59XG5mdW5jdGlvbiBsb2dSZXN1bHQocmVzdWx0LCBtZXRob2QsIHVyaSwgcGFyYW1zLCBsb2dnZXIpIHtcbiAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbk5vU3RyaXAoXG4gICAgICBsb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIkh0dHAuXCIgKyBtZXRob2QgKyBcIigpXCIsXG4gICAgICBcIlJlY2VpdmVkIEVycm9yOyBcIiArIGFwcGVuZGluZ1BhcmFtcyh1cmksIHBhcmFtcykgKyBcIjsgRXJyb3I6IFwiICsgaW5zcGVjdEVycm9yKHJlc3VsdC5lcnJvcilcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbk5vU3RyaXAoXG4gICAgICBsb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIkh0dHAuXCIgKyBtZXRob2QgKyBcIigpXCIsXG4gICAgICBcIlJlY2VpdmVkOyBcIiArIGFwcGVuZGluZ1BhcmFtcyh1cmksIHBhcmFtcykgKyBcIjsgSGVhZGVyczogXCIgKyBwYXJhbVN0cmluZyhyZXN1bHQuaGVhZGVycykgKyBcIjsgU3RhdHVzQ29kZTogXCIgKyByZXN1bHQuc3RhdHVzQ29kZSArIFwiOyBCb2R5XCIgKyAoUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIocmVzdWx0LmJvZHkpID8gXCIgKEJhc2U2NCk6IFwiICsgUGxhdGZvcm0uQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKHJlc3VsdC5ib2R5KSA6IFwiOiBcIiArIHJlc3VsdC5ib2R5KVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGxvZ1JlcXVlc3QobWV0aG9kLCB1cmksIGJvZHksIHBhcmFtcywgbG9nZ2VyKSB7XG4gIGlmIChsb2dnZXIuc2hvdWxkTG9nKGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb25Ob1N0cmlwKFxuICAgICAgbG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJIdHRwLlwiICsgbWV0aG9kICsgXCIoKVwiLFxuICAgICAgXCJTZW5kaW5nOyBcIiArIGFwcGVuZGluZ1BhcmFtcyh1cmksIHBhcmFtcykgKyBcIjsgQm9keVwiICsgKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGJvZHkpID8gXCIgKEJhc2U2NCk6IFwiICsgUGxhdGZvcm0uQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKGJvZHkpIDogXCI6IFwiICsgYm9keSlcbiAgICApO1xuICB9XG59XG52YXIgSHR0cCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5wbGF0Zm9ybUh0dHAgPSBuZXcgUGxhdGZvcm0uSHR0cChjbGllbnQpO1xuICAgIHRoaXMuY2hlY2tDb25uZWN0aXZpdHkgPSB0aGlzLnBsYXRmb3JtSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSA/ICgpID0+IHRoaXMucGxhdGZvcm1IdHRwLmNoZWNrQ29ubmVjdGl2aXR5KCkgOiB2b2lkIDA7XG4gIH1cbiAgZ2V0IGxvZ2dlcigpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hMiA9IHRoaXMuY2xpZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmxvZ2dlcikgIT0gbnVsbCA/IF9iIDogbG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlcjtcbiAgfVxuICBnZXQgc3VwcG9ydHNBdXRoSGVhZGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF0Zm9ybUh0dHAuc3VwcG9ydHNBdXRoSGVhZGVycztcbiAgfVxuICBnZXQgc3VwcG9ydHNMaW5rSGVhZGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF0Zm9ybUh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycztcbiAgfVxuICBfZ2V0SG9zdHMoY2xpZW50KSB7XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IGNsaWVudC5jb25uZWN0aW9uLCBjb25uZWN0aW9uSG9zdCA9IGNvbm5lY3Rpb24gJiYgY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5ob3N0O1xuICAgIGlmIChjb25uZWN0aW9uSG9zdCkge1xuICAgICAgcmV0dXJuIFtjb25uZWN0aW9uSG9zdF0uY29uY2F0KGRlZmF1bHRzX2RlZmF1bHQuZ2V0RmFsbGJhY2tIb3N0cyhjbGllbnQub3B0aW9ucykpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdHNfZGVmYXVsdC5nZXRIb3N0cyhjbGllbnQub3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgbm90IHRocm93IGFueSBlcnJvcnM7IHJhdGhlciwgaXQgd2lsbCBjb21tdW5pY2F0ZSBhbnkgZXJyb3IgYnkgcG9wdWxhdGluZyB0aGUge0BsaW5rIFJlcXVlc3RSZXN1bHQuZXJyb3J9IHByb3BlcnR5IG9mIHRoZSByZXR1cm5lZCB7QGxpbmsgUmVxdWVzdFJlc3VsdH0uXG4gICAqL1xuICBhc3luYyBkbyhtZXRob2QsIHBhdGgsIGhlYWRlcnMsIGJvZHksIHBhcmFtcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudDtcbiAgICAgIGlmICghY2xpZW50KSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yOiBuZXcgRXJyb3JJbmZvKFwiaHR0cC5kbyBjYWxsZWQgd2l0aG91dCBjbGllbnRcIiwgNWU0LCA1MDApIH07XG4gICAgICB9XG4gICAgICBjb25zdCB1cmlGcm9tSG9zdCA9IHR5cGVvZiBwYXRoID09PSBcImZ1bmN0aW9uXCIgPyBwYXRoIDogZnVuY3Rpb24oaG9zdCkge1xuICAgICAgICByZXR1cm4gY2xpZW50LmJhc2VVcmkoaG9zdCkgKyBwYXRoO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGN1cnJlbnRGYWxsYmFjayA9IGNsaWVudC5fY3VycmVudEZhbGxiYWNrO1xuICAgICAgaWYgKGN1cnJlbnRGYWxsYmFjaykge1xuICAgICAgICBpZiAoY3VycmVudEZhbGxiYWNrLnZhbGlkVW50aWwgPiBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5kb1VyaShtZXRob2QsIHVyaUZyb21Ib3N0KGN1cnJlbnRGYWxsYmFjay5ob3N0KSwgaGVhZGVycywgYm9keSwgcGFyYW1zKTtcbiAgICAgICAgICBpZiAocmVzdWx0LmVycm9yICYmIHRoaXMucGxhdGZvcm1IdHRwLnNob3VsZEZhbGxiYWNrKHJlc3VsdC5lcnJvcikpIHtcbiAgICAgICAgICAgIGNsaWVudC5fY3VycmVudEZhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvKG1ldGhvZCwgcGF0aCwgaGVhZGVycywgYm9keSwgcGFyYW1zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGllbnQuX2N1cnJlbnRGYWxsYmFjayA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGhvc3RzID0gdGhpcy5fZ2V0SG9zdHMoY2xpZW50KTtcbiAgICAgIGlmIChob3N0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9VcmkobWV0aG9kLCB1cmlGcm9tSG9zdChob3N0c1swXSksIGhlYWRlcnMsIGJvZHksIHBhcmFtcyk7XG4gICAgICB9XG4gICAgICBsZXQgdHJ5QUhvc3RTdGFydGVkQXQgPSBudWxsO1xuICAgICAgY29uc3QgdHJ5QUhvc3QgPSBhc3luYyAoY2FuZGlkYXRlSG9zdHMsIHBlcnNpc3RPblN1Y2Nlc3MpID0+IHtcbiAgICAgICAgY29uc3QgaG9zdCA9IGNhbmRpZGF0ZUhvc3RzLnNoaWZ0KCk7XG4gICAgICAgIHRyeUFIb3N0U3RhcnRlZEF0ID0gdHJ5QUhvc3RTdGFydGVkQXQgIT0gbnVsbCA/IHRyeUFIb3N0U3RhcnRlZEF0IDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZG9VcmkobWV0aG9kLCB1cmlGcm9tSG9zdChob3N0KSwgaGVhZGVycywgYm9keSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvciAmJiB0aGlzLnBsYXRmb3JtSHR0cC5zaG91bGRGYWxsYmFjayhyZXN1bHQuZXJyb3IpICYmIGNhbmRpZGF0ZUhvc3RzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gRGF0ZS5ub3coKSAtIHRyeUFIb3N0U3RhcnRlZEF0LmdldFRpbWUoKTtcbiAgICAgICAgICBpZiAoZWxhcHNlZFRpbWUgPiBjbGllbnQub3B0aW9ucy50aW1lb3V0cy5odHRwTWF4UmV0cnlEdXJhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgICAgICAgYFRpbWVvdXQgZm9yIHRyeWluZyBmYWxsYmFjayBob3N0cyByZXRyaWVzLiBUb3RhbCBlbGFwc2VkIHRpbWUgZXhjZWVkZWQgdGhlICR7Y2xpZW50Lm9wdGlvbnMudGltZW91dHMuaHR0cE1heFJldHJ5RHVyYXRpb259bXMgbGltaXRgLFxuICAgICAgICAgICAgICAgIDUwMDAzLFxuICAgICAgICAgICAgICAgIDUwMFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ5QUhvc3QoY2FuZGlkYXRlSG9zdHMsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZXJzaXN0T25TdWNjZXNzKSB7XG4gICAgICAgICAgY2xpZW50Ll9jdXJyZW50RmFsbGJhY2sgPSB7XG4gICAgICAgICAgICBob3N0LFxuICAgICAgICAgICAgdmFsaWRVbnRpbDogRGF0ZS5ub3coKSArIGNsaWVudC5vcHRpb25zLnRpbWVvdXRzLmZhbGxiYWNrUmV0cnlUaW1lb3V0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIHJldHVybiB0cnlBSG9zdChob3N0cyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyBlcnJvcjogbmV3IEVycm9ySW5mbyhgVW5leHBlY3RlZCBlcnJvciBpbiBIdHRwLmRvOiAke2luc3BlY3RFcnJvcihlcnIpfWAsIDUwMCwgNWU0KSB9O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBub3QgdGhyb3cgYW55IGVycm9yczsgcmF0aGVyLCBpdCB3aWxsIGNvbW11bmljYXRlIGFueSBlcnJvciBieSBwb3B1bGF0aW5nIHRoZSB7QGxpbmsgUmVxdWVzdFJlc3VsdC5lcnJvcn0gcHJvcGVydHkgb2YgdGhlIHJldHVybmVkIHtAbGluayBSZXF1ZXN0UmVzdWx0fS5cbiAgICovXG4gIGFzeW5jIGRvVXJpKG1ldGhvZCwgdXJpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMpIHtcbiAgICB0cnkge1xuICAgICAgbG9nUmVxdWVzdChtZXRob2QsIHVyaSwgYm9keSwgcGFyYW1zLCB0aGlzLmxvZ2dlcik7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnBsYXRmb3JtSHR0cC5kb1VyaShtZXRob2QsIHVyaSwgaGVhZGVycywgYm9keSwgcGFyYW1zKTtcbiAgICAgIGlmICh0aGlzLmxvZ2dlci5zaG91bGRMb2cobG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgICAgICBsb2dSZXN1bHQocmVzdWx0LCBtZXRob2QsIHVyaSwgcGFyYW1zLCB0aGlzLmxvZ2dlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgZXJyb3I6IG5ldyBFcnJvckluZm8oYFVuZXhwZWN0ZWQgZXJyb3IgaW4gSHR0cC5kb1VyaTogJHtpbnNwZWN0RXJyb3IoZXJyKX1gLCA1MDAsIDVlNCkgfTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tb24vbGliL3V0aWwvZXZlbnRlbWl0dGVyLnRzXG5mdW5jdGlvbiBjYWxsTGlzdGVuZXIobG9nZ2VyLCBldmVudFRoaXMsIGxpc3RlbmVyLCBhcmdzKSB7XG4gIHRyeSB7XG4gICAgbGlzdGVuZXIuYXBwbHkoZXZlbnRUaGlzLCBhcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIGxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgIFwiRXZlbnRFbWl0dGVyLmVtaXQoKVwiLFxuICAgICAgXCJVbmV4cGVjdGVkIGxpc3RlbmVyIGV4Y2VwdGlvbjogXCIgKyBlICsgXCI7IHN0YWNrID0gXCIgKyAoZSAmJiBlLnN0YWNrKVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHRhcmdldExpc3RlbmVycywgbGlzdGVuZXIsIGV2ZW50RmlsdGVyKSB7XG4gIGxldCBsaXN0ZW5lcnM7XG4gIGxldCBpbmRleDtcbiAgbGV0IGV2ZW50TmFtZTtcbiAgZm9yIChsZXQgdGFyZ2V0TGlzdGVuZXJzSW5kZXggPSAwOyB0YXJnZXRMaXN0ZW5lcnNJbmRleCA8IHRhcmdldExpc3RlbmVycy5sZW5ndGg7IHRhcmdldExpc3RlbmVyc0luZGV4KyspIHtcbiAgICBsaXN0ZW5lcnMgPSB0YXJnZXRMaXN0ZW5lcnNbdGFyZ2V0TGlzdGVuZXJzSW5kZXhdO1xuICAgIGlmIChldmVudEZpbHRlcikge1xuICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzW2V2ZW50RmlsdGVyXTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGlzdGVuZXJzKSkge1xuICAgICAgd2hpbGUgKChpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKSkgIT09IC0xKSB7XG4gICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50RmlsdGVyICYmIGxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHRhcmdldExpc3RlbmVyc1t0YXJnZXRMaXN0ZW5lcnNJbmRleF1bZXZlbnRGaWx0ZXJdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdGVuZXJzKSkge1xuICAgICAgZm9yIChldmVudE5hbWUgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGlzdGVuZXJzLCBldmVudE5hbWUpICYmIEFycmF5LmlzQXJyYXkobGlzdGVuZXJzW2V2ZW50TmFtZV0pKSB7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoW2xpc3RlbmVyc10sIGxpc3RlbmVyLCBldmVudE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG52YXIgRXZlbnRFbWl0dGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihsb2dnZXIpIHtcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLmFueSA9IFtdO1xuICAgIHRoaXMuZXZlbnRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hbnlPbmNlID0gW107XG4gICAgdGhpcy5ldmVudHNPbmNlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgb24oLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSBhcmdzWzBdO1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMuYW55LnB1c2gobGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRMaXN0ZW5lci5vbigpOiBJbnZhbGlkIGFyZ3VtZW50czogXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgW2V2ZW50LCBsaXN0ZW5lcl0gPSBhcmdzO1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50TGlzdGVuZXIub24oKTogSW52YWxpZCBhcmd1bWVudHM6IFwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgfVxuICAgICAgaWYgKGlzTmlsKGV2ZW50KSkge1xuICAgICAgICB0aGlzLmFueS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgICAgZXZlbnQuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgICAgdGhpcy5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIGV2ZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRMaXN0ZW5lci5vbigpOiBJbnZhbGlkIGFyZ3VtZW50czogXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8ICh0aGlzLmV2ZW50c1tldmVudF0gPSBbXSk7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb2ZmKC4uLmFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT0gMCB8fCBpc05pbChhcmdzWzBdKSAmJiBpc05pbChhcmdzWzFdKSkge1xuICAgICAgdGhpcy5hbnkgPSBbXTtcbiAgICAgIHRoaXMuZXZlbnRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLmFueU9uY2UgPSBbXTtcbiAgICAgIHRoaXMuZXZlbnRzT25jZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbZmlyc3RBcmcsIHNlY29uZEFyZ10gPSBhcmdzO1xuICAgIGxldCBsaXN0ZW5lciA9IG51bGw7XG4gICAgbGV0IGV2ZW50ID0gbnVsbDtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgfHwgIXNlY29uZEFyZykge1xuICAgICAgaWYgKHR5cGVvZiBmaXJzdEFyZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGxpc3RlbmVyID0gZmlyc3RBcmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldmVudCA9IGZpcnN0QXJnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHNlY29uZEFyZyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlci5vZmYoKTogaW52YWxpZCBhcmd1bWVudHM6XCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICB9XG4gICAgICBbZXZlbnQsIGxpc3RlbmVyXSA9IFtmaXJzdEFyZywgc2Vjb25kQXJnXTtcbiAgICB9XG4gICAgaWYgKGxpc3RlbmVyICYmIGlzTmlsKGV2ZW50KSkge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoW3RoaXMuYW55LCB0aGlzLmV2ZW50cywgdGhpcy5hbnlPbmNlLCB0aGlzLmV2ZW50c09uY2VdLCBsaXN0ZW5lcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZXZlbnQuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgIHRoaXMub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZXZlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlci5vZmYoKTogaW52YWxpZCBhcmd1bWVudHM6XCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgfVxuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoW3RoaXMuZXZlbnRzLCB0aGlzLmV2ZW50c09uY2VdLCBsaXN0ZW5lciwgZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5ldmVudHNbZXZlbnRdO1xuICAgICAgZGVsZXRlIHRoaXMuZXZlbnRzT25jZVtldmVudF07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGFycmF5IG9mIGxpc3RlbmVycyBmb3IgYSBnaXZlbiBldmVudDsgZXhjbHVkZXMgb25jZSBldmVudHNcbiAgICogQHBhcmFtIGV2ZW50IChvcHRpb25hbCkgdGhlIG5hbWUgb2YgdGhlIGV2ZW50LCBvciBub25lIGZvciAnYW55J1xuICAgKiBAcmV0dXJuIGFycmF5IG9mIGV2ZW50cywgb3IgbnVsbCBpZiBub25lXG4gICAqL1xuICBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuZXZlbnRzW2V2ZW50XSB8fCBbXTtcbiAgICAgIGlmICh0aGlzLmV2ZW50c09uY2VbZXZlbnRdKVxuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIHRoaXMuZXZlbnRzT25jZVtldmVudF0pO1xuICAgICAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGggPyBsaXN0ZW5lcnMgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hbnkubGVuZ3RoID8gdGhpcy5hbnkgOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBFbWl0IGFuIGV2ZW50XG4gICAqIEBwYXJhbSBldmVudCB0aGUgZXZlbnQgbmFtZVxuICAgKiBAcGFyYW0gYXJncyB0aGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGxpc3RlbmVyXG4gICAqL1xuICBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgY29uc3QgZXZlbnRUaGlzID0geyBldmVudCB9O1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IFtdO1xuICAgIGlmICh0aGlzLmFueU9uY2UubGVuZ3RoKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIHRoaXMuYW55T25jZSk7XG4gICAgICB0aGlzLmFueU9uY2UgPSBbXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW55Lmxlbmd0aCkge1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCB0aGlzLmFueSk7XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50c09uY2VMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c09uY2VbZXZlbnRdO1xuICAgIGlmIChldmVudHNPbmNlTGlzdGVuZXJzKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIGV2ZW50c09uY2VMaXN0ZW5lcnMpO1xuICAgICAgZGVsZXRlIHRoaXMuZXZlbnRzT25jZVtldmVudF07XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50c0xpc3RlbmVycyA9IHRoaXMuZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoZXZlbnRzTGlzdGVuZXJzKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIGV2ZW50c0xpc3RlbmVycyk7XG4gICAgfVxuICAgIGxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgY2FsbExpc3RlbmVyKHRoaXMubG9nZ2VyLCBldmVudFRoaXMsIGxpc3RlbmVyLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxuICBvbmNlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBhcmdDb3VudCA9IGFyZ3MubGVuZ3RoO1xuICAgIGlmIChhcmdDb3VudCA9PT0gMCB8fCBhcmdDb3VudCA9PT0gMSAmJiB0eXBlb2YgYXJnc1swXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zdCBldmVudCA9IGFyZ3NbMF07XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgdGhpcy5vbmNlKGV2ZW50LCByZXNvbHZlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBbZmlyc3RBcmcsIHNlY29uZEFyZ10gPSBhcmdzO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZmlyc3RBcmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhpcy5hbnlPbmNlLnB1c2goZmlyc3RBcmcpO1xuICAgIH0gZWxzZSBpZiAoaXNOaWwoZmlyc3RBcmcpKSB7XG4gICAgICBpZiAodHlwZW9mIHNlY29uZEFyZyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlci5vbmNlKCk6IEludmFsaWQgYXJndW1lbnRzOlwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgfVxuICAgICAgdGhpcy5hbnlPbmNlLnB1c2goc2Vjb25kQXJnKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZmlyc3RBcmcpKSB7XG4gICAgICBjb25zdCBzZWxmMiA9IHRoaXM7XG4gICAgICBjb25zdCBsaXN0ZW5lcldyYXBwZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgaW5uZXJBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgZmlyc3RBcmcuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgICBzZWxmMi5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcldyYXBwZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmRBcmcgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlci5vbmNlKCk6IEludmFsaWQgYXJndW1lbnRzOlwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIHNlY29uZEFyZy5hcHBseSh0aGlzLCBpbm5lckFyZ3MpO1xuICAgICAgfTtcbiAgICAgIGZpcnN0QXJnLmZvckVhY2goZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICAgIHNlbGYyLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXJXcmFwcGVyKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIGZpcnN0QXJnICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlci5vbmNlKCk6IEludmFsaWQgYXJndW1lbnRzOlwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgfVxuICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5ldmVudHNPbmNlW2ZpcnN0QXJnXSB8fCAodGhpcy5ldmVudHNPbmNlW2ZpcnN0QXJnXSA9IFtdKTtcbiAgICAgIGlmIChzZWNvbmRBcmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmRBcmcgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlci5vbmNlKCk6IEludmFsaWQgYXJndW1lbnRzOlwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKHNlY29uZEFyZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBMaXN0ZW4gZm9yIGEgc2luZ2xlIG9jY3VycmVuY2Ugb2YgYSBzdGF0ZSBldmVudCBhbmQgZmlyZSBpbW1lZGlhdGVseSBpZiBjdXJyZW50U3RhdGUgbWF0Y2hlcyB0YXJnZXRTdGF0ZVxuICAgKiBAcGFyYW0gdGFyZ2V0U3RhdGUgdGhlIG5hbWUgb2YgdGhlIHN0YXRlIGV2ZW50IHRvIGxpc3RlbiB0b1xuICAgKiBAcGFyYW0gY3VycmVudFN0YXRlIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgb2JqZWN0XG4gICAqL1xuICBhc3luYyB3aGVuU3RhdGUodGFyZ2V0U3RhdGUsIGN1cnJlbnRTdGF0ZSkge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0U3RhdGUgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGN1cnJlbnRTdGF0ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2hlblN0YXRlIHJlcXVpcmVzIGEgdmFsaWQgc3RhdGUgU3RyaW5nIGFyZ3VtZW50XCIpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0U3RhdGUgPT09IGN1cnJlbnRTdGF0ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLm9uY2UodGFyZ2V0U3RhdGUpO1xuICAgIH1cbiAgfVxufTtcbnZhciBldmVudGVtaXR0ZXJfZGVmYXVsdCA9IEV2ZW50RW1pdHRlcjtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvcHJvdG9jb2xtZXNzYWdlY29tbW9uLnRzXG52YXIgYWN0aW9ucyA9IHtcbiAgSEVBUlRCRUFUOiAwLFxuICBBQ0s6IDEsXG4gIE5BQ0s6IDIsXG4gIENPTk5FQ1Q6IDMsXG4gIENPTk5FQ1RFRDogNCxcbiAgRElTQ09OTkVDVDogNSxcbiAgRElTQ09OTkVDVEVEOiA2LFxuICBDTE9TRTogNyxcbiAgQ0xPU0VEOiA4LFxuICBFUlJPUjogOSxcbiAgQVRUQUNIOiAxMCxcbiAgQVRUQUNIRUQ6IDExLFxuICBERVRBQ0g6IDEyLFxuICBERVRBQ0hFRDogMTMsXG4gIFBSRVNFTkNFOiAxNCxcbiAgTUVTU0FHRTogMTUsXG4gIFNZTkM6IDE2LFxuICBBVVRIOiAxNyxcbiAgQUNUSVZBVEU6IDE4LFxuICBPQkpFQ1Q6IDE5LFxuICBPQkpFQ1RfU1lOQzogMjAsXG4gIEFOTk9UQVRJT046IDIxXG59O1xudmFyIEFjdGlvbk5hbWUgPSBbXTtcbk9iamVjdC5rZXlzKGFjdGlvbnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICBBY3Rpb25OYW1lW2FjdGlvbnNbbmFtZV1dID0gbmFtZTtcbn0pO1xudmFyIGZsYWdzID0ge1xuICAvKiBDaGFubmVsIGF0dGFjaCBzdGF0ZSBmbGFncyAqL1xuICBIQVNfUFJFU0VOQ0U6IDEgPDwgMCxcbiAgSEFTX0JBQ0tMT0c6IDEgPDwgMSxcbiAgUkVTVU1FRDogMSA8PCAyLFxuICBUUkFOU0lFTlQ6IDEgPDwgNCxcbiAgQVRUQUNIX1JFU1VNRTogMSA8PCA1LFxuICBIQVNfT0JKRUNUUzogMSA8PCA3LFxuICAvKiBDaGFubmVsIG1vZGUgZmxhZ3MgKi9cbiAgUFJFU0VOQ0U6IDEgPDwgMTYsXG4gIFBVQkxJU0g6IDEgPDwgMTcsXG4gIFNVQlNDUklCRTogMSA8PCAxOCxcbiAgUFJFU0VOQ0VfU1VCU0NSSUJFOiAxIDw8IDE5LFxuICBBTk5PVEFUSU9OX1BVQkxJU0g6IDEgPDwgMjEsXG4gIEFOTk9UQVRJT05fU1VCU0NSSUJFOiAxIDw8IDIyLFxuICBPQkpFQ1RfU1VCU0NSSUJFOiAxIDw8IDI0LFxuICBPQkpFQ1RfUFVCTElTSDogMSA8PCAyNVxufTtcbnZhciBmbGFnTmFtZXMgPSBPYmplY3Qua2V5cyhmbGFncyk7XG5mbGFncy5NT0RFX0FMTCA9IGZsYWdzLlBSRVNFTkNFIHwgZmxhZ3MuUFVCTElTSCB8IGZsYWdzLlNVQlNDUklCRSB8IGZsYWdzLlBSRVNFTkNFX1NVQlNDUklCRSB8IGZsYWdzLkFOTk9UQVRJT05fUFVCTElTSCB8IGZsYWdzLkFOTk9UQVRJT05fU1VCU0NSSUJFIHwgZmxhZ3MuT0JKRUNUX1NVQlNDUklCRSB8IGZsYWdzLk9CSkVDVF9QVUJMSVNIO1xudmFyIGNoYW5uZWxNb2RlcyA9IFtcbiAgXCJQUkVTRU5DRVwiLFxuICBcIlBVQkxJU0hcIixcbiAgXCJTVUJTQ1JJQkVcIixcbiAgXCJQUkVTRU5DRV9TVUJTQ1JJQkVcIixcbiAgXCJBTk5PVEFUSU9OX1BVQkxJU0hcIixcbiAgXCJBTk5PVEFUSU9OX1NVQlNDUklCRVwiLFxuICBcIk9CSkVDVF9TVUJTQ1JJQkVcIixcbiAgXCJPQkpFQ1RfUFVCTElTSFwiXG5dO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9iYXNlbWVzc2FnZS50c1xuZnVuY3Rpb24gbm9ybWFsaXNlQ29udGV4dChjb250ZXh0KSB7XG4gIGlmICghY29udGV4dCB8fCAhY29udGV4dC5jaGFubmVsT3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICBjaGFubmVsT3B0aW9uczogY29udGV4dCxcbiAgICAgIHBsdWdpbnM6IHt9LFxuICAgICAgYmFzZUVuY29kZWRQcmV2aW91c1BheWxvYWQ6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDaXBoZXJPcHRpb25zKENyeXB0bzIsIGxvZ2dlciwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNpcGhlcikge1xuICAgIGlmICghQ3J5cHRvMilcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiQ3J5cHRvXCIpO1xuICAgIGNvbnN0IGNpcGhlciA9IENyeXB0bzIuZ2V0Q2lwaGVyKG9wdGlvbnMuY2lwaGVyLCBsb2dnZXIpO1xuICAgIHJldHVybiB7XG4gICAgICBjaXBoZXI6IGNpcGhlci5jaXBoZXJQYXJhbXMsXG4gICAgICBjaGFubmVsQ2lwaGVyOiBjaXBoZXIuY2lwaGVyXG4gICAgfTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHt9O1xufVxuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdChtc2csIGNpcGhlck9wdGlvbnMpIHtcbiAgY29uc3QgeyBkYXRhLCBlbmNvZGluZyB9ID0gYXdhaXQgZW5jcnlwdERhdGEobXNnLmRhdGEsIG1zZy5lbmNvZGluZywgY2lwaGVyT3B0aW9ucyk7XG4gIG1zZy5kYXRhID0gZGF0YTtcbiAgbXNnLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiBtc2c7XG59XG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0RGF0YShkYXRhLCBlbmNvZGluZywgY2lwaGVyT3B0aW9ucykge1xuICBsZXQgY2lwaGVyID0gY2lwaGVyT3B0aW9ucy5jaGFubmVsQ2lwaGVyO1xuICBsZXQgZGF0YVRvRW5jcnlwdCA9IGRhdGE7XG4gIGxldCBmaW5hbEVuY29kaW5nID0gZW5jb2RpbmcgPyBlbmNvZGluZyArIFwiL1wiIDogXCJcIjtcbiAgaWYgKCFQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihkYXRhVG9FbmNyeXB0KSkge1xuICAgIGRhdGFUb0VuY3J5cHQgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy51dGY4RW5jb2RlKFN0cmluZyhkYXRhVG9FbmNyeXB0KSk7XG4gICAgZmluYWxFbmNvZGluZyA9IGZpbmFsRW5jb2RpbmcgKyBcInV0Zi04L1wiO1xuICB9XG4gIGNvbnN0IGNpcGhlcnRleHQgPSBhd2FpdCBjaXBoZXIuZW5jcnlwdChkYXRhVG9FbmNyeXB0KTtcbiAgZmluYWxFbmNvZGluZyA9IGZpbmFsRW5jb2RpbmcgKyBcImNpcGhlcitcIiArIGNpcGhlci5hbGdvcml0aG07XG4gIHJldHVybiB7XG4gICAgZGF0YTogY2lwaGVydGV4dCxcbiAgICBlbmNvZGluZzogZmluYWxFbmNvZGluZ1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gZW5jb2RlKG1zZywgb3B0aW9ucykge1xuICBjb25zdCB7IGRhdGEsIGVuY29kaW5nIH0gPSBlbmNvZGVEYXRhKG1zZy5kYXRhLCBtc2cuZW5jb2RpbmcpO1xuICBtc2cuZGF0YSA9IGRhdGE7XG4gIG1zZy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuY2lwaGVyKSB7XG4gICAgcmV0dXJuIGVuY3J5cHQobXNnLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbXNnO1xuICB9XG59XG5mdW5jdGlvbiBlbmNvZGVEYXRhKGRhdGEsIGVuY29kaW5nKSB7XG4gIGNvbnN0IG5hdGl2ZURhdGFUeXBlID0gdHlwZW9mIGRhdGEgPT0gXCJzdHJpbmdcIiB8fCBQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihkYXRhKSB8fCBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMDtcbiAgaWYgKG5hdGl2ZURhdGFUeXBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGEsXG4gICAgICBlbmNvZGluZ1xuICAgIH07XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGRhdGEpIHx8IEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcgPyBlbmNvZGluZyArIFwiL2pzb25cIiA6IFwianNvblwiXG4gICAgfTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiRGF0YSB0eXBlIGlzIHVuc3VwcG9ydGVkXCIsIDQwMDEzLCA0MDApO1xufVxuYXN5bmMgZnVuY3Rpb24gZGVjb2RlKG1lc3NhZ2UsIGlucHV0Q29udGV4dCkge1xuICBjb25zdCB7IGRhdGEsIGVuY29kaW5nLCBlcnJvciB9ID0gYXdhaXQgZGVjb2RlRGF0YShtZXNzYWdlLmRhdGEsIG1lc3NhZ2UuZW5jb2RpbmcsIGlucHV0Q29udGV4dCk7XG4gIG1lc3NhZ2UuZGF0YSA9IGRhdGE7XG4gIG1lc3NhZ2UuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKGVycm9yKSB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGRlY29kZURhdGEoZGF0YSwgZW5jb2RpbmcsIGlucHV0Q29udGV4dCkge1xuICBjb25zdCBjb250ZXh0ID0gbm9ybWFsaXNlQ29udGV4dChpbnB1dENvbnRleHQpO1xuICBsZXQgbGFzdFBheWxvYWQgPSBkYXRhO1xuICBsZXQgZGVjb2RlZERhdGEgPSBkYXRhO1xuICBsZXQgZmluYWxFbmNvZGluZyA9IGVuY29kaW5nO1xuICBsZXQgZGVjb2RpbmdFcnJvcjtcbiAgaWYgKGVuY29kaW5nKSB7XG4gICAgY29uc3QgeGZvcm1zID0gZW5jb2Rpbmcuc3BsaXQoXCIvXCIpO1xuICAgIGxldCBsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleDtcbiAgICBsZXQgZW5jb2RpbmdzVG9Qcm9jZXNzID0geGZvcm1zLmxlbmd0aDtcbiAgICBsZXQgeGZvcm0gPSBcIlwiO1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAoKGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4ID0gZW5jb2RpbmdzVG9Qcm9jZXNzKSA+IDApIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB4Zm9ybXNbLS1lbmNvZGluZ3NUb1Byb2Nlc3NdLm1hdGNoKC8oWy1cXHddKykoXFwrKFtcXHctXSspKT8vKTtcbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgeGZvcm0gPSBtYXRjaFsxXTtcbiAgICAgICAgc3dpdGNoICh4Zm9ybSkge1xuICAgICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgICAgIGRlY29kZWREYXRhID0gUGxhdGZvcm0uQnVmZmVyVXRpbHMuYmFzZTY0RGVjb2RlKFN0cmluZyhkZWNvZGVkRGF0YSkpO1xuICAgICAgICAgICAgaWYgKGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4ID09IHhmb3Jtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbGFzdFBheWxvYWQgPSBkZWNvZGVkRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgXCJ1dGYtOFwiOlxuICAgICAgICAgICAgZGVjb2RlZERhdGEgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy51dGY4RGVjb2RlKGRlY29kZWREYXRhKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgXCJqc29uXCI6XG4gICAgICAgICAgICBkZWNvZGVkRGF0YSA9IEpTT04ucGFyc2UoZGVjb2RlZERhdGEpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBcImNpcGhlclwiOlxuICAgICAgICAgICAgaWYgKGNvbnRleHQuY2hhbm5lbE9wdGlvbnMgIT0gbnVsbCAmJiBjb250ZXh0LmNoYW5uZWxPcHRpb25zLmNpcGhlciAmJiBjb250ZXh0LmNoYW5uZWxPcHRpb25zLmNoYW5uZWxDaXBoZXIpIHtcbiAgICAgICAgICAgICAgY29uc3QgeGZvcm1BbGdvcml0aG0gPSBtYXRjaFszXSwgY2lwaGVyID0gY29udGV4dC5jaGFubmVsT3B0aW9ucy5jaGFubmVsQ2lwaGVyO1xuICAgICAgICAgICAgICBpZiAoeGZvcm1BbGdvcml0aG0gIT0gY2lwaGVyLmFsZ29yaXRobSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBkZWNyeXB0IG1lc3NhZ2Ugd2l0aCBnaXZlbiBjaXBoZXI7IGluY29tcGF0aWJsZSBjaXBoZXIgcGFyYW1zXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlY29kZWREYXRhID0gYXdhaXQgY2lwaGVyLmRlY3J5cHQoZGVjb2RlZERhdGEpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBkZWNyeXB0IG1lc3NhZ2U7IG5vdCBhbiBlbmNyeXB0ZWQgY2hhbm5lbFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidmNkaWZmXCI6XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQucGx1Z2lucyB8fCAhY29udGV4dC5wbHVnaW5zLnZjZGlmZikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiTWlzc2luZyBWY2RpZmYgZGVjb2RlciAoaHR0cHM6Ly9naXRodWIuY29tL2FibHktZm9ya3MvdmNkaWZmLWRlY29kZXIpXCIsIDQwMDE5LCA0MDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBVaW50OEFycmF5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgICAgICAgXCJEZWx0YSBkZWNvZGluZyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3NlciAobmVlZCBBcnJheUJ1ZmZlciAmIFVpbnQ4QXJyYXkpXCIsXG4gICAgICAgICAgICAgICAgNDAwMjAsXG4gICAgICAgICAgICAgICAgNDAwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsZXQgZGVsdGFCYXNlID0gY29udGV4dC5iYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZDtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWx0YUJhc2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBkZWx0YUJhc2UgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy51dGY4RW5jb2RlKGRlbHRhQmFzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgZGVsdGFCYXNlQnVmZmVyID0gUGxhdGZvcm0uQnVmZmVyVXRpbHMudG9CdWZmZXIoZGVsdGFCYXNlKTtcbiAgICAgICAgICAgICAgZGVjb2RlZERhdGEgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy50b0J1ZmZlcihkZWNvZGVkRGF0YSk7XG4gICAgICAgICAgICAgIGRlY29kZWREYXRhID0gUGxhdGZvcm0uQnVmZmVyVXRpbHMuYXJyYXlCdWZmZXJWaWV3VG9CdWZmZXIoXG4gICAgICAgICAgICAgICAgY29udGV4dC5wbHVnaW5zLnZjZGlmZi5kZWNvZGUoZGVjb2RlZERhdGEsIGRlbHRhQmFzZUJ1ZmZlcilcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgbGFzdFBheWxvYWQgPSBkZWNvZGVkRGF0YTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIlZjZGlmZiBkZWx0YSBkZWNvZGUgZmFpbGVkIHdpdGggXCIgKyBlLCA0MDAxOCwgNDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGVuY29kaW5nXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3QgZXJyID0gZTtcbiAgICAgIGRlY29kaW5nRXJyb3IgPSBuZXcgRXJyb3JJbmZvKFxuICAgICAgICBgRXJyb3IgcHJvY2Vzc2luZyB0aGUgJHt4Zm9ybX0gZW5jb2RpbmcsIGRlY29kZXIgcmV0dXJuZWQgXFx1MjAxOCR7ZXJyLm1lc3NhZ2V9XFx1MjAxOWAsXG4gICAgICAgIGVyci5jb2RlIHx8IDQwMDEzLFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGZpbmFsRW5jb2RpbmcgPSBsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCA8PSAwID8gbnVsbCA6IHhmb3Jtcy5zbGljZSgwLCBsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCkuam9pbihcIi9cIik7XG4gICAgfVxuICB9XG4gIGlmIChkZWNvZGluZ0Vycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBkZWNvZGluZ0Vycm9yLFxuICAgICAgZGF0YTogZGVjb2RlZERhdGEsXG4gICAgICBlbmNvZGluZzogZmluYWxFbmNvZGluZ1xuICAgIH07XG4gIH1cbiAgY29udGV4dC5iYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZCA9IGxhc3RQYXlsb2FkO1xuICByZXR1cm4ge1xuICAgIGRhdGE6IGRlY29kZWREYXRhLFxuICAgIGVuY29kaW5nOiBmaW5hbEVuY29kaW5nXG4gIH07XG59XG5mdW5jdGlvbiB3aXJlVG9KU09OKC4uLmFyZ3MpIHtcbiAgY29uc3QgZm9ybWF0ID0gYXJncy5sZW5ndGggPiAwID8gXCJqc29uXCIgLyoganNvbiAqLyA6IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi87XG4gIGNvbnN0IHsgZGF0YSwgZW5jb2RpbmcgfSA9IGVuY29kZURhdGFGb3JXaXJlKHRoaXMuZGF0YSwgdGhpcy5lbmNvZGluZywgZm9ybWF0KTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMsIHsgZW5jb2RpbmcsIGRhdGEgfSk7XG59XG5mdW5jdGlvbiBlbmNvZGVEYXRhRm9yV2lyZShkYXRhLCBlbmNvZGluZywgZm9ybWF0KSB7XG4gIGlmICghZGF0YSB8fCAhUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YSxcbiAgICAgIGVuY29kaW5nXG4gICAgfTtcbiAgfVxuICBpZiAoZm9ybWF0ID09PSBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLnRvQnVmZmVyKGRhdGEpLFxuICAgICAgZW5jb2RpbmdcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0YTogUGxhdGZvcm0uQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKGRhdGEpLFxuICAgIGVuY29kaW5nOiBlbmNvZGluZyA/IGVuY29kaW5nICsgXCIvYmFzZTY0XCIgOiBcImJhc2U2NFwiXG4gIH07XG59XG52YXIgTWVzc2FnZUVuY29kaW5nID0ge1xuICBlbmNyeXB0RGF0YSxcbiAgZW5jb2RlRGF0YSxcbiAgZW5jb2RlRGF0YUZvcldpcmUsXG4gIGRlY29kZURhdGFcbn07XG5mdW5jdGlvbiBwb3B1bGF0ZUZpZWxkc0Zyb21QYXJlbnQocGFyZW50KSB7XG4gIGNvbnN0IHsgaWQsIGNvbm5lY3Rpb25JZCwgdGltZXN0YW1wIH0gPSBwYXJlbnQ7XG4gIGxldCBtc2dzO1xuICBzd2l0Y2ggKHBhcmVudC5hY3Rpb24pIHtcbiAgICBjYXNlIGFjdGlvbnMuTUVTU0FHRToge1xuICAgICAgbXNncyA9IHBhcmVudC5tZXNzYWdlcztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIGFjdGlvbnMuUFJFU0VOQ0U6XG4gICAgY2FzZSBhY3Rpb25zLlNZTkM6XG4gICAgICBtc2dzID0gcGFyZW50LnByZXNlbmNlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhY3Rpb25zLkFOTk9UQVRJT046XG4gICAgICBtc2dzID0gcGFyZW50LmFubm90YXRpb25zO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhY3Rpb25zLk9CSkVDVDpcbiAgICBjYXNlIGFjdGlvbnMuT0JKRUNUX1NZTkM6XG4gICAgICBtc2dzID0gcGFyZW50LnN0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJVbmV4cGVjdGVkIGFjdGlvbiBcIiArIHBhcmVudC5hY3Rpb24sIDRlNCwgNDAwKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1zZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtc2cgPSBtc2dzW2ldO1xuICAgIGlmICghbXNnLmNvbm5lY3Rpb25JZCkge1xuICAgICAgbXNnLmNvbm5lY3Rpb25JZCA9IGNvbm5lY3Rpb25JZDtcbiAgICB9XG4gICAgaWYgKCFtc2cudGltZXN0YW1wKSB7XG4gICAgICBtc2cudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgIH1cbiAgICBpZiAoaWQgJiYgIW1zZy5pZCkge1xuICAgICAgbXNnLmlkID0gaWQgKyBcIjpcIiArIGk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzdHJNc2cobSwgY2xzKSB7XG4gIGxldCByZXN1bHQgPSBcIltcIiArIGNscztcbiAgZm9yIChjb25zdCBhdHRyIGluIG0pIHtcbiAgICBpZiAoYXR0ciA9PT0gXCJkYXRhXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgbS5kYXRhID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiOyBkYXRhPVwiICsgbS5kYXRhO1xuICAgICAgfSBlbHNlIGlmIChQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihtLmRhdGEpKSB7XG4gICAgICAgIHJlc3VsdCArPSBcIjsgZGF0YSAoYnVmZmVyKT1cIiArIFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShtLmRhdGEpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbS5kYXRhICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJlc3VsdCArPSBcIjsgZGF0YSAoanNvbik9XCIgKyBKU09OLnN0cmluZ2lmeShtLmRhdGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXR0ciAmJiAoYXR0ciA9PT0gXCJleHRyYXNcIiB8fCBhdHRyID09PSBcIm9wZXJhdGlvblwiKSkge1xuICAgICAgcmVzdWx0ICs9IFwiOyBcIiArIGF0dHIgKyBcIj1cIiArIEpTT04uc3RyaW5naWZ5KG1bYXR0cl0pO1xuICAgIH0gZWxzZSBpZiAoYXR0ciA9PT0gXCJ2ZXJzaW9uXCIpIHtcbiAgICAgIHJlc3VsdCArPSBcIjsgdmVyc2lvbj1cIiArIEpTT04uc3RyaW5naWZ5KG1bYXR0cl0pO1xuICAgIH0gZWxzZSBpZiAoYXR0ciA9PT0gXCJhbm5vdGF0aW9uc1wiKSB7XG4gICAgICByZXN1bHQgKz0gXCI7IGFubm90YXRpb25zPVwiICsgSlNPTi5zdHJpbmdpZnkobVthdHRyXSk7XG4gICAgfSBlbHNlIGlmIChtW2F0dHJdICE9PSB2b2lkIDApIHtcbiAgICAgIHJlc3VsdCArPSBcIjsgXCIgKyBhdHRyICsgXCI9XCIgKyBtW2F0dHJdO1xuICAgIH1cbiAgfVxuICByZXN1bHQgKz0gXCJdXCI7XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgQmFzZU1lc3NhZ2UgPSBjbGFzcyB7XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvYmFzZWNsaWVudC50c1xudmFyIEJhc2VDbGllbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBUaGVzZSBleHBvcnRzIGFyZSBmb3IgdXNlIGJ5IFVNRCBwbHVnaW5zOyByZWFzb24gYmVpbmcgc28gdGhhdCBjb25zdHJ1Y3RvcnMgYW5kIHN0YXRpYyBtZXRob2RzIGNhbiBiZSBhY2Nlc3NlZCBieSB0aGVzZSBwbHVnaW5zIHdpdGhvdXQgbmVlZGluZyB0byBpbXBvcnQgdGhlIGNsYXNzZXMgZGlyZWN0bHkgYW5kIHJlc3VsdCBpbiB0aGUgY2xhc3MgZXhpc3RpbmcgaW4gYm90aCB0aGUgcGx1Z2luIGFuZCB0aGUgY29yZSBsaWJyYXJ5LlxuICAgICAqL1xuICAgIHRoaXMuUGxhdGZvcm0gPSBQbGF0Zm9ybTtcbiAgICB0aGlzLkVycm9ySW5mbyA9IEVycm9ySW5mbztcbiAgICB0aGlzLkxvZ2dlciA9IGxvZ2dlcl9kZWZhdWx0O1xuICAgIHRoaXMuRGVmYXVsdHMgPSBkZWZhdWx0c19kZWZhdWx0O1xuICAgIHRoaXMuVXRpbHMgPSB1dGlsc19leHBvcnRzO1xuICAgIHRoaXMuRXZlbnRFbWl0dGVyID0gZXZlbnRlbWl0dGVyX2RlZmF1bHQ7XG4gICAgdGhpcy5NZXNzYWdlRW5jb2RpbmcgPSBNZXNzYWdlRW5jb2Rpbmc7XG4gICAgdmFyIF9hMiwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9pLCBfajtcbiAgICB0aGlzLl9hZGRpdGlvbmFsSFRUUFJlcXVlc3RJbXBsZW1lbnRhdGlvbnMgPSAoX2EyID0gb3B0aW9ucy5wbHVnaW5zKSAhPSBudWxsID8gX2EyIDogbnVsbDtcbiAgICB0aGlzLmxvZ2dlciA9IG5ldyBsb2dnZXJfZGVmYXVsdCgpO1xuICAgIHRoaXMubG9nZ2VyLnNldExvZyhvcHRpb25zLmxvZ0xldmVsLCBvcHRpb25zLmxvZ0hhbmRsZXIpO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJCYXNlQ2xpZW50KClcIixcbiAgICAgIFwiaW5pdGlhbGl6ZWQgd2l0aCBjbGllbnRPcHRpb25zIFwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3Qob3B0aW9ucylcbiAgICApO1xuICAgIHRoaXMuX01zZ1BhY2sgPSAoX2MgPSAoX2IgPSBvcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5Nc2dQYWNrKSAhPSBudWxsID8gX2MgOiBudWxsO1xuICAgIGNvbnN0IG5vcm1hbE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgPSBkZWZhdWx0c19kZWZhdWx0Lm5vcm1hbGlzZU9wdGlvbnMob3B0aW9ucywgdGhpcy5fTXNnUGFjaywgdGhpcy5sb2dnZXIpO1xuICAgIGlmIChub3JtYWxPcHRpb25zLmtleSkge1xuICAgICAgY29uc3Qga2V5TWF0Y2ggPSBub3JtYWxPcHRpb25zLmtleS5tYXRjaCgvXihbXjpcXHNdKyk6KFteOi5cXHNdKykkLyk7XG4gICAgICBpZiAoIWtleU1hdGNoKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IFwiaW52YWxpZCBrZXkgcGFyYW1ldGVyXCI7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkJhc2VDbGllbnQoKVwiLCBtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKG1zZywgNDA0MDAsIDQwNCk7XG4gICAgICB9XG4gICAgICBub3JtYWxPcHRpb25zLmtleU5hbWUgPSBrZXlNYXRjaFsxXTtcbiAgICAgIG5vcm1hbE9wdGlvbnMua2V5U2VjcmV0ID0ga2V5TWF0Y2hbMl07XG4gICAgfVxuICAgIGlmIChcImNsaWVudElkXCIgaW4gbm9ybWFsT3B0aW9ucykge1xuICAgICAgaWYgKCEodHlwZW9mIG5vcm1hbE9wdGlvbnMuY2xpZW50SWQgPT09IFwic3RyaW5nXCIgfHwgbm9ybWFsT3B0aW9ucy5jbGllbnRJZCA9PT0gbnVsbCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJjbGllbnRJZCBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBudWxsXCIsIDQwMDEyLCA0MDApO1xuICAgICAgZWxzZSBpZiAobm9ybWFsT3B0aW9ucy5jbGllbnRJZCA9PT0gXCIqXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgJ0NhblxcdTIwMTl0IHVzZSBcIipcIiBhcyBhIGNsaWVudElkIGFzIHRoYXQgc3RyaW5nIGlzIHJlc2VydmVkLiAoVG8gY2hhbmdlIHRoZSBkZWZhdWx0IHRva2VuIHJlcXVlc3QgYmVoYXZpb3VyIHRvIHVzZSBhIHdpbGRjYXJkIGNsaWVudElkLCB1c2Uge2RlZmF1bHRUb2tlblBhcmFtczoge2NsaWVudElkOiBcIipcIn19KScsXG4gICAgICAgICAgNDAwMTIsXG4gICAgICAgICAgNDAwXG4gICAgICAgICk7XG4gICAgfVxuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkJhc2VDbGllbnQoKVwiLCBcInN0YXJ0ZWQ7IHZlcnNpb24gPSBcIiArIGRlZmF1bHRzX2RlZmF1bHQudmVyc2lvbik7XG4gICAgdGhpcy5fY3VycmVudEZhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLnNlcnZlclRpbWVPZmZzZXQgPSBudWxsO1xuICAgIHRoaXMuaHR0cCA9IG5ldyBIdHRwKHRoaXMpO1xuICAgIHRoaXMuYXV0aCA9IG5ldyBhdXRoX2RlZmF1bHQodGhpcywgbm9ybWFsT3B0aW9ucyk7XG4gICAgdGhpcy5fcmVzdCA9ICgoX2QgPSBvcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfZC5SZXN0KSA/IG5ldyBvcHRpb25zLnBsdWdpbnMuUmVzdCh0aGlzKSA6IG51bGw7XG4gICAgdGhpcy5fQ3J5cHRvID0gKF9mID0gKF9lID0gb3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2UuQ3J5cHRvKSAhPSBudWxsID8gX2YgOiBudWxsO1xuICAgIHRoaXMuX19GaWx0ZXJlZFN1YnNjcmlwdGlvbnMgPSAoX2ggPSAoX2cgPSBvcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfZy5NZXNzYWdlSW50ZXJhY3Rpb25zKSAhPSBudWxsID8gX2ggOiBudWxsO1xuICAgIHRoaXMuX0Fubm90YXRpb25zID0gKF9qID0gKF9pID0gb3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2kuQW5ub3RhdGlvbnMpICE9IG51bGwgPyBfaiA6IG51bGw7XG4gIH1cbiAgZ2V0IHJlc3QoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXN0KSB7XG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIlJlc3RcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZXN0O1xuICB9XG4gIGdldCBfRmlsdGVyZWRTdWJzY3JpcHRpb25zKCkge1xuICAgIGlmICghdGhpcy5fX0ZpbHRlcmVkU3Vic2NyaXB0aW9ucykge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJNZXNzYWdlSW50ZXJhY3Rpb25zXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fX0ZpbHRlcmVkU3Vic2NyaXB0aW9ucztcbiAgfVxuICBnZXQgY2hhbm5lbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5jaGFubmVscztcbiAgfVxuICBnZXQgcHVzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN0LnB1c2g7XG4gIH1cbiAgLyoqIFJTSDggKi9cbiAgZGV2aWNlKCkge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKCEoKF9hMiA9IHRoaXMub3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLlB1c2gpIHx8ICF0aGlzLnB1c2guTG9jYWxEZXZpY2UpIHtcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiUHVzaFwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kZXZpY2UpIHtcbiAgICAgIHRoaXMuX2RldmljZSA9IHRoaXMucHVzaC5Mb2NhbERldmljZS5sb2FkKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGV2aWNlO1xuICB9XG4gIGJhc2VVcmkoaG9zdCkge1xuICAgIHJldHVybiBkZWZhdWx0c19kZWZhdWx0LmdldEh0dHBTY2hlbWUodGhpcy5vcHRpb25zKSArIGhvc3QgKyBcIjpcIiArIGRlZmF1bHRzX2RlZmF1bHQuZ2V0UG9ydCh0aGlzLm9wdGlvbnMsIGZhbHNlKTtcbiAgfVxuICBhc3luYyBzdGF0cyhwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN0LnN0YXRzKHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgdGltZShwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN0LnRpbWUocGFyYW1zKTtcbiAgfVxuICBhc3luYyByZXF1ZXN0KG1ldGhvZCwgcGF0aCwgdmVyc2lvbjIsIHBhcmFtcywgYm9keSwgY3VzdG9tSGVhZGVycykge1xuICAgIHJldHVybiB0aGlzLnJlc3QucmVxdWVzdChtZXRob2QsIHBhdGgsIHZlcnNpb24yLCBwYXJhbXMsIGJvZHksIGN1c3RvbUhlYWRlcnMpO1xuICB9XG4gIGJhdGNoUHVibGlzaChzcGVjT3JTcGVjcykge1xuICAgIHJldHVybiB0aGlzLnJlc3QuYmF0Y2hQdWJsaXNoKHNwZWNPclNwZWNzKTtcbiAgfVxuICBiYXRjaFByZXNlbmNlKGNoYW5uZWxzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5iYXRjaFByZXNlbmNlKGNoYW5uZWxzKTtcbiAgfVxuICBzZXRMb2cobG9nT3B0aW9ucykge1xuICAgIHRoaXMubG9nZ2VyLnNldExvZyhsb2dPcHRpb25zLmxldmVsLCBsb2dPcHRpb25zLmhhbmRsZXIpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgdGltZSBiYXNlZCBvbiB0aGUgbG9jYWwgY2xvY2ssXG4gICAqIG9yIGlmIHRoZSBvcHRpb24gcXVlcnlUaW1lIGlzIHRydWUsIHJldHVybiB0aGUgc2VydmVyIHRpbWUuXG4gICAqIFRoZSBzZXJ2ZXIgdGltZSBvZmZzZXQgZnJvbSB0aGUgbG9jYWwgdGltZSBpcyBzdG9yZWQgc28gdGhhdFxuICAgKiBvbmx5IG9uZSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdG8gZ2V0IHRoZSB0aW1lIGlzIGV2ZXIgbmVlZGVkXG4gICAqL1xuICBhc3luYyBnZXRUaW1lc3RhbXAocXVlcnlUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVGltZU9mZnNldFNldCgpICYmIHF1ZXJ5VGltZSkge1xuICAgICAgcmV0dXJuIHRoaXMudGltZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRUaW1lc3RhbXBVc2luZ09mZnNldCgpO1xuICB9XG4gIGdldFRpbWVzdGFtcFVzaW5nT2Zmc2V0KCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpICsgKHRoaXMuc2VydmVyVGltZU9mZnNldCB8fCAwKTtcbiAgfVxuICBpc1RpbWVPZmZzZXRTZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VydmVyVGltZU9mZnNldCAhPT0gbnVsbDtcbiAgfVxufTtcbkJhc2VDbGllbnQuUGxhdGZvcm0gPSBQbGF0Zm9ybTtcbnZhciBiYXNlY2xpZW50X2RlZmF1bHQgPSBCYXNlQ2xpZW50O1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9kZXZpY2VkZXRhaWxzLnRzXG52YXIgRGV2aWNlRGV0YWlscyA9IGNsYXNzIF9EZXZpY2VEZXRhaWxzIHtcbiAgdG9KU09OKCkge1xuICAgIHZhciBfYTIsIF9iLCBfYztcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBkZXZpY2VTZWNyZXQ6IHRoaXMuZGV2aWNlU2VjcmV0LFxuICAgICAgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0sXG4gICAgICBmb3JtRmFjdG9yOiB0aGlzLmZvcm1GYWN0b3IsXG4gICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcbiAgICAgIG1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhLFxuICAgICAgZGV2aWNlSWRlbnRpdHlUb2tlbjogdGhpcy5kZXZpY2VJZGVudGl0eVRva2VuLFxuICAgICAgcHVzaDoge1xuICAgICAgICByZWNpcGllbnQ6IChfYTIgPSB0aGlzLnB1c2gpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucmVjaXBpZW50LFxuICAgICAgICBzdGF0ZTogKF9iID0gdGhpcy5wdXNoKSA9PSBudWxsID8gdm9pZCAwIDogX2Iuc3RhdGUsXG4gICAgICAgIGVycm9yOiAoX2MgPSB0aGlzLnB1c2gpID09IG51bGwgPyB2b2lkIDAgOiBfYy5lcnJvclxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgdmFyIF9hMiwgX2IsIF9jLCBfZDtcbiAgICBsZXQgcmVzdWx0ID0gXCJbRGV2aWNlRGV0YWlsc1wiO1xuICAgIGlmICh0aGlzLmlkKVxuICAgICAgcmVzdWx0ICs9IFwiOyBpZD1cIiArIHRoaXMuaWQ7XG4gICAgaWYgKHRoaXMucGxhdGZvcm0pXG4gICAgICByZXN1bHQgKz0gXCI7IHBsYXRmb3JtPVwiICsgdGhpcy5wbGF0Zm9ybTtcbiAgICBpZiAodGhpcy5mb3JtRmFjdG9yKVxuICAgICAgcmVzdWx0ICs9IFwiOyBmb3JtRmFjdG9yPVwiICsgdGhpcy5mb3JtRmFjdG9yO1xuICAgIGlmICh0aGlzLmNsaWVudElkKVxuICAgICAgcmVzdWx0ICs9IFwiOyBjbGllbnRJZD1cIiArIHRoaXMuY2xpZW50SWQ7XG4gICAgaWYgKHRoaXMubWV0YWRhdGEpXG4gICAgICByZXN1bHQgKz0gXCI7IG1ldGFkYXRhPVwiICsgdGhpcy5tZXRhZGF0YTtcbiAgICBpZiAodGhpcy5kZXZpY2VJZGVudGl0eVRva2VuKVxuICAgICAgcmVzdWx0ICs9IFwiOyBkZXZpY2VJZGVudGl0eVRva2VuPVwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5kZXZpY2VJZGVudGl0eVRva2VuKTtcbiAgICBpZiAoKF9hMiA9IHRoaXMucHVzaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5yZWNpcGllbnQpXG4gICAgICByZXN1bHQgKz0gXCI7IHB1c2gucmVjaXBpZW50PVwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5wdXNoLnJlY2lwaWVudCk7XG4gICAgaWYgKChfYiA9IHRoaXMucHVzaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnN0YXRlKVxuICAgICAgcmVzdWx0ICs9IFwiOyBwdXNoLnN0YXRlPVwiICsgdGhpcy5wdXNoLnN0YXRlO1xuICAgIGlmICgoX2MgPSB0aGlzLnB1c2gpID09IG51bGwgPyB2b2lkIDAgOiBfYy5lcnJvcilcbiAgICAgIHJlc3VsdCArPSBcIjsgcHVzaC5lcnJvcj1cIiArIEpTT04uc3RyaW5naWZ5KHRoaXMucHVzaC5lcnJvcik7XG4gICAgaWYgKChfZCA9IHRoaXMucHVzaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLm1ldGFkYXRhKVxuICAgICAgcmVzdWx0ICs9IFwiOyBwdXNoLm1ldGFkYXRhPVwiICsgdGhpcy5wdXNoLm1ldGFkYXRhO1xuICAgIHJlc3VsdCArPSBcIl1cIjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyB0b1JlcXVlc3RCb2R5KGJvZHksIE1zZ1BhY2ssIGZvcm1hdCkge1xuICAgIHJldHVybiBlbmNvZGVCb2R5KGJvZHksIE1zZ1BhY2ssIGZvcm1hdCk7XG4gIH1cbiAgc3RhdGljIGZyb21SZXNwb25zZUJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgYm9keSA9IGRlY29kZUJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYm9keSkpIHtcbiAgICAgIHJldHVybiBfRGV2aWNlRGV0YWlscy5mcm9tVmFsdWVzQXJyYXkoYm9keSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBfRGV2aWNlRGV0YWlscy5mcm9tVmFsdWVzKGJvZHkpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICB2YWx1ZXMuZXJyb3IgPSB2YWx1ZXMuZXJyb3IgJiYgRXJyb3JJbmZvLmZyb21WYWx1ZXModmFsdWVzLmVycm9yKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgX0RldmljZURldGFpbHMoKSwgdmFsdWVzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUxvY2FsRGV2aWNlKGRldmljZSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBfRGV2aWNlRGV0YWlscygpLCBkZXZpY2UpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzQXJyYXkodmFsdWVzKSB7XG4gICAgY29uc3QgY291bnQgPSB2YWx1ZXMubGVuZ3RoLCByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKylcbiAgICAgIHJlc3VsdFtpXSA9IF9EZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXModmFsdWVzW2ldKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xudmFyIGRldmljZWRldGFpbHNfZGVmYXVsdCA9IERldmljZURldGFpbHM7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9yZXNvdXJjZS50c1xuYXN5bmMgZnVuY3Rpb24gd2l0aEF1dGhEZXRhaWxzKGNsaWVudCwgaGVhZGVycywgcGFyYW1zLCBvcENhbGxiYWNrKSB7XG4gIGlmIChjbGllbnQuaHR0cC5zdXBwb3J0c0F1dGhIZWFkZXJzKSB7XG4gICAgY29uc3QgYXV0aEhlYWRlcnMgPSBhd2FpdCBjbGllbnQuYXV0aC5nZXRBdXRoSGVhZGVycygpO1xuICAgIHJldHVybiBvcENhbGxiYWNrKG1peGluKGF1dGhIZWFkZXJzLCBoZWFkZXJzKSwgcGFyYW1zKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBhdXRoUGFyYW1zID0gYXdhaXQgY2xpZW50LmF1dGguZ2V0QXV0aFBhcmFtcygpO1xuICAgIHJldHVybiBvcENhbGxiYWNrKGhlYWRlcnMsIG1peGluKGF1dGhQYXJhbXMsIHBhcmFtcykpO1xuICB9XG59XG5mdW5jdGlvbiB1bmVudmVsb3BlKHJlc3VsdCwgTXNnUGFjaywgZm9ybWF0KSB7XG4gIGlmIChyZXN1bHQuZXJyICYmICFyZXN1bHQuYm9keSkge1xuICAgIHJldHVybiB7IGVycjogcmVzdWx0LmVyciB9O1xuICB9XG4gIGlmIChyZXN1bHQuc3RhdHVzQ29kZSA9PT0gSHR0cFN0YXR1c0NvZGVzX2RlZmF1bHQuTm9Db250ZW50KSB7XG4gICAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHJlc3VsdCksIHsgYm9keTogW10sIHVucGFja2VkOiB0cnVlIH0pO1xuICB9XG4gIGxldCBib2R5ID0gcmVzdWx0LmJvZHk7XG4gIGlmICghcmVzdWx0LnVucGFja2VkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGJvZHkgPSBkZWNvZGVCb2R5KGJvZHksIE1zZ1BhY2ssIGZvcm1hdCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGlzRXJyb3JJbmZvT3JQYXJ0aWFsRXJyb3JJbmZvKGUpKSB7XG4gICAgICAgIHJldHVybiB7IGVycjogZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyOiBuZXcgUGFydGlhbEVycm9ySW5mbyhpbnNwZWN0RXJyb3IoZSksIG51bGwpIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghYm9keSkge1xuICAgIHJldHVybiB7IGVycjogbmV3IFBhcnRpYWxFcnJvckluZm8oXCJ1bmVudmVsb3BlKCk6IFJlc3BvbnNlIGJvZHkgaXMgbWlzc2luZ1wiLCBudWxsKSB9O1xuICB9XG4gIGNvbnN0IHsgc3RhdHVzQ29kZTogd3JhcHBlZFN0YXR1c0NvZGUsIHJlc3BvbnNlLCBoZWFkZXJzOiB3cmFwcGVkSGVhZGVycyB9ID0gYm9keTtcbiAgaWYgKHdyYXBwZWRTdGF0dXNDb2RlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcmVzdWx0KSwgeyBib2R5LCB1bnBhY2tlZDogdHJ1ZSB9KTtcbiAgfVxuICBpZiAod3JhcHBlZFN0YXR1c0NvZGUgPCAyMDAgfHwgd3JhcHBlZFN0YXR1c0NvZGUgPj0gMzAwKSB7XG4gICAgbGV0IHdyYXBwZWRFcnIgPSByZXNwb25zZSAmJiByZXNwb25zZS5lcnJvciB8fCByZXN1bHQuZXJyO1xuICAgIGlmICghd3JhcHBlZEVycikge1xuICAgICAgd3JhcHBlZEVyciA9IG5ldyBFcnJvcihcIkVycm9yIGluIHVuZW52ZWxvcGluZyBcIiArIGJvZHkpO1xuICAgICAgd3JhcHBlZEVyci5zdGF0dXNDb2RlID0gd3JhcHBlZFN0YXR1c0NvZGU7XG4gICAgfVxuICAgIHJldHVybiB7IGVycjogd3JhcHBlZEVyciwgYm9keTogcmVzcG9uc2UsIGhlYWRlcnM6IHdyYXBwZWRIZWFkZXJzLCB1bnBhY2tlZDogdHJ1ZSwgc3RhdHVzQ29kZTogd3JhcHBlZFN0YXR1c0NvZGUgfTtcbiAgfVxuICByZXR1cm4geyBlcnI6IHJlc3VsdC5lcnIsIGJvZHk6IHJlc3BvbnNlLCBoZWFkZXJzOiB3cmFwcGVkSGVhZGVycywgdW5wYWNrZWQ6IHRydWUsIHN0YXR1c0NvZGU6IHdyYXBwZWRTdGF0dXNDb2RlIH07XG59XG5mdW5jdGlvbiBsb2dSZXN1bHQyKHJlc3VsdCwgbWV0aG9kLCBwYXRoLCBwYXJhbXMsIGxvZ2dlcikge1xuICBpZiAocmVzdWx0LmVycikge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIGxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiUmVzb3VyY2UuXCIgKyBtZXRob2QgKyBcIigpXCIsXG4gICAgICBcIlJlY2VpdmVkIEVycm9yOyBcIiArIGFwcGVuZGluZ1BhcmFtcyhwYXRoLCBwYXJhbXMpICsgXCI7IEVycm9yOiBcIiArIGluc3BlY3RFcnJvcihyZXN1bHQuZXJyKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgbG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZXNvdXJjZS5cIiArIG1ldGhvZCArIFwiKClcIixcbiAgICAgIFwiUmVjZWl2ZWQ7IFwiICsgYXBwZW5kaW5nUGFyYW1zKHBhdGgsIHBhcmFtcykgKyBcIjsgSGVhZGVyczogXCIgKyBwYXJhbVN0cmluZyhyZXN1bHQuaGVhZGVycykgKyBcIjsgU3RhdHVzQ29kZTogXCIgKyByZXN1bHQuc3RhdHVzQ29kZSArIFwiOyBCb2R5OiBcIiArIChQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihyZXN1bHQuYm9keSkgPyBcIiAoQmFzZTY0KTogXCIgKyBQbGF0Zm9ybS5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUocmVzdWx0LmJvZHkpIDogXCI6IFwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QocmVzdWx0LmJvZHkpKVxuICAgICk7XG4gIH1cbn1cbnZhciBSZXNvdXJjZSA9IGNsYXNzIF9SZXNvdXJjZSB7XG4gIHN0YXRpYyBhc3luYyBnZXQoY2xpZW50LCBwYXRoLCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCB0aHJvd0Vycm9yKSB7XG4gICAgcmV0dXJuIF9SZXNvdXJjZS5kbyhIdHRwTWV0aG9kc19kZWZhdWx0LkdldCwgY2xpZW50LCBwYXRoLCBudWxsLCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCB0aHJvd0Vycm9yICE9IG51bGwgPyB0aHJvd0Vycm9yIDogZmFsc2UpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZWxldGUoY2xpZW50LCBwYXRoLCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCB0aHJvd0Vycm9yKSB7XG4gICAgcmV0dXJuIF9SZXNvdXJjZS5kbyhIdHRwTWV0aG9kc19kZWZhdWx0LkRlbGV0ZSwgY2xpZW50LCBwYXRoLCBudWxsLCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCB0aHJvd0Vycm9yKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgcG9zdChjbGllbnQsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpIHtcbiAgICByZXR1cm4gX1Jlc291cmNlLmRvKEh0dHBNZXRob2RzX2RlZmF1bHQuUG9zdCwgY2xpZW50LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCB0aHJvd0Vycm9yKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgcGF0Y2goY2xpZW50LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCB0aHJvd0Vycm9yKSB7XG4gICAgcmV0dXJuIF9SZXNvdXJjZS5kbyhIdHRwTWV0aG9kc19kZWZhdWx0LlBhdGNoLCBjbGllbnQsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBwdXQoY2xpZW50LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCB0aHJvd0Vycm9yKSB7XG4gICAgcmV0dXJuIF9SZXNvdXJjZS5kbyhIdHRwTWV0aG9kc19kZWZhdWx0LlB1dCwgY2xpZW50LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCB0aHJvd0Vycm9yKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZG8obWV0aG9kLCBjbGllbnQsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpIHtcbiAgICBpZiAoZW52ZWxvcGUpIHtcbiAgICAgIChwYXJhbXMgPSBwYXJhbXMgfHwge30pW1wiZW52ZWxvcGVcIl0gPSBlbnZlbG9wZTtcbiAgICB9XG4gICAgY29uc3QgbG9nZ2VyID0gY2xpZW50LmxvZ2dlcjtcbiAgICBhc3luYyBmdW5jdGlvbiBkb1JlcXVlc3QoaGVhZGVyczIsIHBhcmFtczIpIHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBpZiAobG9nZ2VyLnNob3VsZExvZyhsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICAgIGxldCBkZWNvZGVkQm9keSA9IGJvZHk7XG4gICAgICAgIGlmICgoKF9hMiA9IGhlYWRlcnMyW1wiY29udGVudC10eXBlXCJdKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmluZGV4T2YoXCJtc2dwYWNrXCIpKSA+IDApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFjbGllbnQuX01zZ1BhY2spIHtcbiAgICAgICAgICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJNc2dQYWNrXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZEJvZHkgPSBjbGllbnQuX01zZ1BhY2suZGVjb2RlKGJvZHkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGRlY29kZUVycikge1xuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgICBsb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICAgICAgXCJSZXNvdXJjZS5cIiArIG1ldGhvZCArIFwiKClcIixcbiAgICAgICAgICAgICAgXCJTZW5kaW5nIE1zZ1BhY2sgRGVjb2RpbmcgRXJyb3I6IFwiICsgaW5zcGVjdEVycm9yKGRlY29kZUVycilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICBsb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICAgIFwiUmVzb3VyY2UuXCIgKyBtZXRob2QgKyBcIigpXCIsXG4gICAgICAgICAgXCJTZW5kaW5nOyBcIiArIGFwcGVuZGluZ1BhcmFtcyhwYXRoLCBwYXJhbXMyKSArIFwiOyBCb2R5OiBcIiArIGRlY29kZWRCb2R5XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBodHRwUmVzdWx0ID0gYXdhaXQgY2xpZW50Lmh0dHAuZG8obWV0aG9kLCBwYXRoLCBoZWFkZXJzMiwgYm9keSwgcGFyYW1zMik7XG4gICAgICBpZiAoaHR0cFJlc3VsdC5lcnJvciAmJiBhdXRoX2RlZmF1bHQuaXNUb2tlbkVycihodHRwUmVzdWx0LmVycm9yKSkge1xuICAgICAgICBhd2FpdCBjbGllbnQuYXV0aC5hdXRob3JpemUobnVsbCwgbnVsbCk7XG4gICAgICAgIHJldHVybiB3aXRoQXV0aERldGFpbHMoY2xpZW50LCBoZWFkZXJzMiwgcGFyYW1zMiwgZG9SZXF1ZXN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycjogaHR0cFJlc3VsdC5lcnJvcixcbiAgICAgICAgYm9keTogaHR0cFJlc3VsdC5ib2R5LFxuICAgICAgICBoZWFkZXJzOiBodHRwUmVzdWx0LmhlYWRlcnMsXG4gICAgICAgIHVucGFja2VkOiBodHRwUmVzdWx0LnVucGFja2VkLFxuICAgICAgICBzdGF0dXNDb2RlOiBodHRwUmVzdWx0LnN0YXR1c0NvZGVcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBhd2FpdCB3aXRoQXV0aERldGFpbHMoY2xpZW50LCBoZWFkZXJzLCBwYXJhbXMsIGRvUmVxdWVzdCk7XG4gICAgaWYgKGVudmVsb3BlKSB7XG4gICAgICByZXN1bHQgPSB1bmVudmVsb3BlKHJlc3VsdCwgY2xpZW50Ll9Nc2dQYWNrLCBlbnZlbG9wZSk7XG4gICAgfVxuICAgIGlmIChsb2dnZXIuc2hvdWxkTG9nKGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgIGxvZ1Jlc3VsdDIocmVzdWx0LCBtZXRob2QsIHBhdGgsIHBhcmFtcywgbG9nZ2VyKTtcbiAgICB9XG4gICAgaWYgKHRocm93RXJyb3IpIHtcbiAgICAgIGlmIChyZXN1bHQuZXJyKSB7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IF9fc3ByZWFkVmFsdWVzKHt9LCByZXN1bHQpO1xuICAgICAgICBkZWxldGUgcmVzcG9uc2UuZXJyO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG52YXIgcmVzb3VyY2VfZGVmYXVsdCA9IFJlc291cmNlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcGFnaW5hdGVkcmVzb3VyY2UudHNcbmZ1bmN0aW9uIGdldFJlbFBhcmFtcyhsaW5rVXJsKSB7XG4gIGNvbnN0IHVybE1hdGNoID0gbGlua1VybC5tYXRjaCgvXlxcLlxcLyhcXHcrKVxcPyguKikkLyk7XG4gIHJldHVybiB1cmxNYXRjaCAmJiB1cmxNYXRjaFsyXSAmJiBwYXJzZVF1ZXJ5U3RyaW5nKHVybE1hdGNoWzJdKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmVsTGlua3MobGlua0hlYWRlcikge1xuICBpZiAodHlwZW9mIGxpbmtIZWFkZXIgPT0gXCJzdHJpbmdcIilcbiAgICBsaW5rSGVhZGVyID0gbGlua0hlYWRlci5zcGxpdChcIixcIik7XG4gIGNvbnN0IHJlbFBhcmFtcyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmtIZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaW5rTWF0Y2ggPSBsaW5rSGVhZGVyW2ldLm1hdGNoKC9eXFxzKjwoLispPjtcXHMqcmVsPVwiKFxcdyspXCIkLyk7XG4gICAgaWYgKGxpbmtNYXRjaCkge1xuICAgICAgY29uc3QgcGFyYW1zID0gZ2V0UmVsUGFyYW1zKGxpbmtNYXRjaFsxXSk7XG4gICAgICBpZiAocGFyYW1zKVxuICAgICAgICByZWxQYXJhbXNbbGlua01hdGNoWzJdXSA9IHBhcmFtcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbFBhcmFtcztcbn1cbmZ1bmN0aW9uIHJldHVybkVyck9ubHkoZXJyLCBib2R5LCB1c2VIUFIpIHtcbiAgcmV0dXJuICEodXNlSFBSICYmIChib2R5IHx8IHR5cGVvZiBlcnIuY29kZSA9PT0gXCJudW1iZXJcIikpO1xufVxudmFyIFBhZ2luYXRlZFJlc291cmNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIHBhdGgsIGhlYWRlcnMsIGVudmVsb3BlLCBib2R5SGFuZGxlciwgdXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlKSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHRoaXMuZW52ZWxvcGUgPSBlbnZlbG9wZSAhPSBudWxsID8gZW52ZWxvcGUgOiBudWxsO1xuICAgIHRoaXMuYm9keUhhbmRsZXIgPSBib2R5SGFuZGxlcjtcbiAgICB0aGlzLnVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSA9IHVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSB8fCBmYWxzZTtcbiAgfVxuICBnZXQgbG9nZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5sb2dnZXI7XG4gIH1cbiAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQuZ2V0KHRoaXMuY2xpZW50LCB0aGlzLnBhdGgsIHRoaXMuaGVhZGVycywgcGFyYW1zLCB0aGlzLmVudmVsb3BlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUGFnZShyZXN1bHQpO1xuICB9XG4gIGFzeW5jIGRlbGV0ZShwYXJhbXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LmRlbGV0ZSh0aGlzLmNsaWVudCwgdGhpcy5wYXRoLCB0aGlzLmhlYWRlcnMsIHBhcmFtcywgdGhpcy5lbnZlbG9wZSwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVBhZ2UocmVzdWx0KTtcbiAgfVxuICBhc3luYyBwb3N0KHBhcmFtcywgYm9keSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQucG9zdCh0aGlzLmNsaWVudCwgdGhpcy5wYXRoLCBib2R5LCB0aGlzLmhlYWRlcnMsIHBhcmFtcywgdGhpcy5lbnZlbG9wZSwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVBhZ2UocmVzdWx0KTtcbiAgfVxuICBhc3luYyBwdXQocGFyYW1zLCBib2R5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5wdXQodGhpcy5jbGllbnQsIHRoaXMucGF0aCwgYm9keSwgdGhpcy5oZWFkZXJzLCBwYXJhbXMsIHRoaXMuZW52ZWxvcGUsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVQYWdlKHJlc3VsdCk7XG4gIH1cbiAgYXN5bmMgcGF0Y2gocGFyYW1zLCBib2R5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5wYXRjaCh0aGlzLmNsaWVudCwgdGhpcy5wYXRoLCBib2R5LCB0aGlzLmhlYWRlcnMsIHBhcmFtcywgdGhpcy5lbnZlbG9wZSwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVBhZ2UocmVzdWx0KTtcbiAgfVxuICBhc3luYyBoYW5kbGVQYWdlKHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQuZXJyICYmIHJldHVybkVyck9ubHkocmVzdWx0LmVyciwgcmVzdWx0LmJvZHksIHRoaXMudXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlKSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICBcIlBhZ2luYXRlZFJlc291cmNlLmhhbmRsZVBhZ2UoKVwiLFxuICAgICAgICBcIlVuZXhwZWN0ZWQgZXJyb3IgZ2V0dGluZyByZXNvdXJjZTogZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IocmVzdWx0LmVycilcbiAgICAgICk7XG4gICAgICB0aHJvdyByZXN1bHQuZXJyO1xuICAgIH1cbiAgICBsZXQgaXRlbXMsIGxpbmtIZWFkZXIsIHJlbFBhcmFtcztcbiAgICB0cnkge1xuICAgICAgaXRlbXMgPSByZXN1bHQuc3RhdHVzQ29kZSA9PSBIdHRwU3RhdHVzQ29kZXNfZGVmYXVsdC5Ob0NvbnRlbnQgPyBbXSA6IGF3YWl0IHRoaXMuYm9keUhhbmRsZXIocmVzdWx0LmJvZHksIHJlc3VsdC5oZWFkZXJzIHx8IHt9LCByZXN1bHQudW5wYWNrZWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IHJlc3VsdC5lcnIgfHwgZTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5oZWFkZXJzICYmIChsaW5rSGVhZGVyID0gcmVzdWx0LmhlYWRlcnNbXCJMaW5rXCJdIHx8IHJlc3VsdC5oZWFkZXJzW1wibGlua1wiXSkpIHtcbiAgICAgIHJlbFBhcmFtcyA9IHBhcnNlUmVsTGlua3MobGlua0hlYWRlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLnVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSkge1xuICAgICAgcmV0dXJuIG5ldyBIdHRwUGFnaW5hdGVkUmVzcG9uc2UoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIGl0ZW1zLFxuICAgICAgICByZXN1bHQuaGVhZGVycyB8fCB7fSxcbiAgICAgICAgcmVzdWx0LnN0YXR1c0NvZGUsXG4gICAgICAgIHJlbFBhcmFtcyxcbiAgICAgICAgcmVzdWx0LmVyclxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBQYWdpbmF0ZWRSZXN1bHQodGhpcywgaXRlbXMsIHJlbFBhcmFtcyk7XG4gICAgfVxuICB9XG59O1xudmFyIFBhZ2luYXRlZFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocmVzb3VyY2UsIGl0ZW1zLCByZWxQYXJhbXMpIHtcbiAgICB0aGlzLnJlc291cmNlID0gcmVzb3VyY2U7XG4gICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICAgIHRoaXMuX3JlbFBhcmFtcyA9IHJlbFBhcmFtcztcbiAgfVxuICBhc3luYyBmaXJzdCgpIHtcbiAgICBpZiAodGhpcy5oYXNGaXJzdCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy5fcmVsUGFyYW1zLmZpcnN0KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIk5vIGxpbmsgdG8gdGhlIGZpcnN0IHBhZ2Ugb2YgcmVzdWx0c1wiLCA0MDQwMCwgNDA0KTtcbiAgfVxuICBhc3luYyBjdXJyZW50KCkge1xuICAgIGlmICh0aGlzLmhhc0N1cnJlbnQoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMuX3JlbFBhcmFtcy5jdXJyZW50KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIk5vIGxpbmsgdG8gdGhlIGN1cnJlbnQgcGFnZSBvZiByZXN1bHRzXCIsIDQwNDAwLCA0MDQpO1xuICB9XG4gIGFzeW5jIG5leHQoKSB7XG4gICAgaWYgKHRoaXMuaGFzTmV4dCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy5fcmVsUGFyYW1zLm5leHQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBoYXNGaXJzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVsUGFyYW1zICE9IG51bGwgJiYgXCJmaXJzdFwiIGluIHRoaXMuX3JlbFBhcmFtcztcbiAgfVxuICBoYXNDdXJyZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWxQYXJhbXMgIT0gbnVsbCAmJiBcImN1cnJlbnRcIiBpbiB0aGlzLl9yZWxQYXJhbXM7XG4gIH1cbiAgaGFzTmV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVsUGFyYW1zICE9IG51bGwgJiYgXCJuZXh0XCIgaW4gdGhpcy5fcmVsUGFyYW1zO1xuICB9XG4gIGlzTGFzdCgpIHtcbiAgICByZXR1cm4gIXRoaXMuaGFzTmV4dCgpO1xuICB9XG4gIC8qIFdlIGFzc3VtZSB0aGF0IG9ubHkgdGhlIGluaXRpYWwgcmVxdWVzdCBjYW4gYmUgYSBQT1NULCBhbmQgdGhhdCBhY2Nlc3NpbmdcbiAgICogdGhlIHJlc3Qgb2YgYSBtdWx0aXBhZ2Ugc2V0IG9mIHJlc3VsdHMgY2FuIGFsd2F5cyBiZSBkb25lIHdpdGggR0VUICovXG4gIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICBjb25zdCByZXMgPSB0aGlzLnJlc291cmNlO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQuZ2V0KHJlcy5jbGllbnQsIHJlcy5wYXRoLCByZXMuaGVhZGVycywgcGFyYW1zLCByZXMuZW52ZWxvcGUsIGZhbHNlKTtcbiAgICByZXR1cm4gcmVzLmhhbmRsZVBhZ2UocmVzdWx0KTtcbiAgfVxufTtcbnZhciBIdHRwUGFnaW5hdGVkUmVzcG9uc2UgPSBjbGFzcyBleHRlbmRzIFBhZ2luYXRlZFJlc3VsdCB7XG4gIGNvbnN0cnVjdG9yKHJlc291cmNlLCBpdGVtcywgaGVhZGVycywgc3RhdHVzQ29kZSwgcmVsUGFyYW1zLCBlcnIpIHtcbiAgICBzdXBlcihyZXNvdXJjZSwgaXRlbXMsIHJlbFBhcmFtcyk7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLnN1Y2Nlc3MgPSBzdGF0dXNDb2RlIDwgMzAwICYmIHN0YXR1c0NvZGUgPj0gMjAwO1xuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgdGhpcy5lcnJvckNvZGUgPSBlcnIgJiYgZXJyLmNvZGU7XG4gICAgdGhpcy5lcnJvck1lc3NhZ2UgPSBlcnIgJiYgZXJyLm1lc3NhZ2U7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtczogdGhpcy5pdGVtcyxcbiAgICAgIHN0YXR1c0NvZGU6IHRoaXMuc3RhdHVzQ29kZSxcbiAgICAgIHN1Y2Nlc3M6IHRoaXMuc3VjY2VzcyxcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIGVycm9yQ29kZTogdGhpcy5lcnJvckNvZGUsXG4gICAgICBlcnJvck1lc3NhZ2U6IHRoaXMuZXJyb3JNZXNzYWdlXG4gICAgfTtcbiAgfVxufTtcbnZhciBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0ID0gUGFnaW5hdGVkUmVzb3VyY2U7XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL3B1c2hjaGFubmVsc3Vic2NyaXB0aW9uLnRzXG52YXIgX1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uID0gY2xhc3MgX1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uIHtcbiAgLyoqXG4gICAqIE92ZXJsb2FkIHRvSlNPTigpIHRvIGludGVyY2VwdCBKU09OLnN0cmluZ2lmeSgpXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYW5uZWw6IHRoaXMuY2hhbm5lbCxcbiAgICAgIGRldmljZUlkOiB0aGlzLmRldmljZUlkLFxuICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWRcbiAgICB9O1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGxldCByZXN1bHQgPSBcIltQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvblwiO1xuICAgIGlmICh0aGlzLmNoYW5uZWwpXG4gICAgICByZXN1bHQgKz0gXCI7IGNoYW5uZWw9XCIgKyB0aGlzLmNoYW5uZWw7XG4gICAgaWYgKHRoaXMuZGV2aWNlSWQpXG4gICAgICByZXN1bHQgKz0gXCI7IGRldmljZUlkPVwiICsgdGhpcy5kZXZpY2VJZDtcbiAgICBpZiAodGhpcy5jbGllbnRJZClcbiAgICAgIHJlc3VsdCArPSBcIjsgY2xpZW50SWQ9XCIgKyB0aGlzLmNsaWVudElkO1xuICAgIHJlc3VsdCArPSBcIl1cIjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyBmcm9tUmVzcG9uc2VCb2R5KGJvZHksIE1zZ1BhY2ssIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgIGJvZHkgPSBkZWNvZGVCb2R5KGJvZHksIE1zZ1BhY2ssIGZvcm1hdCk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGJvZHkpKSB7XG4gICAgICByZXR1cm4gX1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXNBcnJheShib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9QdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5mcm9tVmFsdWVzKGJvZHkpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgX1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uKCksIHZhbHVlcyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXNBcnJheSh2YWx1ZXMpIHtcbiAgICBjb25zdCBjb3VudCA9IHZhbHVlcy5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKVxuICAgICAgcmVzdWx0W2ldID0gX1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXModmFsdWVzW2ldKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuX1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uLnRvUmVxdWVzdEJvZHkgPSBlbmNvZGVCb2R5O1xudmFyIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uID0gX1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uO1xudmFyIHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uX2RlZmF1bHQgPSBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbjtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3B1c2gudHNcbnZhciBQdXNoID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB2YXIgX2EyO1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuYWRtaW4gPSBuZXcgQWRtaW4oY2xpZW50KTtcbiAgICBpZiAoUGxhdGZvcm0uQ29uZmlnLnB1c2ggJiYgKChfYTIgPSBjbGllbnQub3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLlB1c2gpKSB7XG4gICAgICB0aGlzLnN0YXRlTWFjaGluZSA9IG5ldyBjbGllbnQub3B0aW9ucy5wbHVnaW5zLlB1c2guQWN0aXZhdGlvblN0YXRlTWFjaGluZShjbGllbnQpO1xuICAgICAgdGhpcy5Mb2NhbERldmljZSA9IGNsaWVudC5vcHRpb25zLnBsdWdpbnMuUHVzaC5sb2NhbERldmljZUZhY3RvcnkoZGV2aWNlZGV0YWlsc19kZWZhdWx0KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYWN0aXZhdGUocmVnaXN0ZXJDYWxsYmFjaywgdXBkYXRlRmFpbGVkQ2FsbGJhY2spIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgaWYgKCEoKF9hMiA9IHRoaXMuY2xpZW50Lm9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5QdXNoKSkge1xuICAgICAgICByZWplY3QoY3JlYXRlTWlzc2luZ1BsdWdpbkVycm9yKFwiUHVzaFwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5zdGF0ZU1hY2hpbmUpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8oXCJUaGlzIHBsYXRmb3JtIGlzIG5vdCBzdXBwb3J0ZWQgYXMgYSB0YXJnZXQgb2YgcHVzaCBub3RpZmljYXRpb25zXCIsIDRlNCwgNDAwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXRlTWFjaGluZS5hY3RpdmF0ZWRDYWxsYmFjaykge1xuICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhcIkFjdGl2YXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzc1wiLCA0ZTQsIDQwMCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlTWFjaGluZS5hY3RpdmF0ZWRDYWxsYmFjayA9IChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5zdGF0ZU1hY2hpbmUudXBkYXRlRmFpbGVkQ2FsbGJhY2sgPSB1cGRhdGVGYWlsZWRDYWxsYmFjaztcbiAgICAgIHRoaXMuc3RhdGVNYWNoaW5lLmhhbmRsZUV2ZW50KFxuICAgICAgICBuZXcgdGhpcy5jbGllbnQub3B0aW9ucy5wbHVnaW5zLlB1c2guQ2FsbGVkQWN0aXZhdGUodGhpcy5zdGF0ZU1hY2hpbmUsIHJlZ2lzdGVyQ2FsbGJhY2spXG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGRlYWN0aXZhdGUoZGVyZWdpc3RlckNhbGxiYWNrKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGlmICghKChfYTIgPSB0aGlzLmNsaWVudC5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuUHVzaCkpIHtcbiAgICAgICAgcmVqZWN0KGNyZWF0ZU1pc3NpbmdQbHVnaW5FcnJvcihcIlB1c2hcIikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3RhdGVNYWNoaW5lKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3JJbmZvKFwiVGhpcyBwbGF0Zm9ybSBpcyBub3Qgc3VwcG9ydGVkIGFzIGEgdGFyZ2V0IG9mIHB1c2ggbm90aWZpY2F0aW9uc1wiLCA0ZTQsIDQwMCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGF0ZU1hY2hpbmUuZGVhY3RpdmF0ZWRDYWxsYmFjaykge1xuICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhcIkRlYWN0aXZhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzXCIsIDRlNCwgNDAwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGVNYWNoaW5lLmRlYWN0aXZhdGVkQ2FsbGJhY2sgPSAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuc3RhdGVNYWNoaW5lLmhhbmRsZUV2ZW50KFxuICAgICAgICBuZXcgdGhpcy5jbGllbnQub3B0aW9ucy5wbHVnaW5zLlB1c2guQ2FsbGVkRGVhY3RpdmF0ZSh0aGlzLnN0YXRlTWFjaGluZSwgZGVyZWdpc3RlckNhbGxiYWNrKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciBBZG1pbiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5kZXZpY2VSZWdpc3RyYXRpb25zID0gbmV3IERldmljZVJlZ2lzdHJhdGlvbnMoY2xpZW50KTtcbiAgICB0aGlzLmNoYW5uZWxTdWJzY3JpcHRpb25zID0gbmV3IENoYW5uZWxTdWJzY3JpcHRpb25zKGNsaWVudCk7XG4gIH1cbiAgYXN5bmMgcHVibGlzaChyZWNpcGllbnQsIHBheWxvYWQpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudDtcbiAgICBjb25zdCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pLCBwYXJhbXMgPSB7fTtcbiAgICBjb25zdCBib2R5ID0gbWl4aW4oeyByZWNpcGllbnQgfSwgcGF5bG9hZCk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGNsaWVudC5vcHRpb25zLnB1c2hGdWxsV2FpdClcbiAgICAgIG1peGluKHBhcmFtcywgeyBmdWxsV2FpdDogXCJ0cnVlXCIgfSk7XG4gICAgY29uc3QgcmVxdWVzdEJvZHkgPSBlbmNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnBvc3QoY2xpZW50LCBcIi9wdXNoL3B1Ymxpc2hcIiwgcmVxdWVzdEJvZHksIGhlYWRlcnMsIHBhcmFtcywgbnVsbCwgdHJ1ZSk7XG4gIH1cbn07XG52YXIgRGV2aWNlUmVnaXN0cmF0aW9ucyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gIH1cbiAgYXN5bmMgc2F2ZShkZXZpY2UpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudDtcbiAgICBjb25zdCBib2R5ID0gZGV2aWNlZGV0YWlsc19kZWZhdWx0LmZyb21WYWx1ZXMoZGV2aWNlKTtcbiAgICBjb25zdCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pLCBwYXJhbXMgPSB7fTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBpZiAoY2xpZW50Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgbWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiBcInRydWVcIiB9KTtcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IGVuY29kZUJvZHkoYm9keSwgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5wdXQoXG4gICAgICBjbGllbnQsXG4gICAgICBcIi9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMvXCIgKyBlbmNvZGVVUklDb21wb25lbnQoZGV2aWNlLmlkKSxcbiAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcyxcbiAgICAgIG51bGwsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICByZXR1cm4gZGV2aWNlZGV0YWlsc19kZWZhdWx0LmZyb21SZXNwb25zZUJvZHkoXG4gICAgICByZXNwb25zZS5ib2R5LFxuICAgICAgY2xpZW50Ll9Nc2dQYWNrLFxuICAgICAgcmVzcG9uc2UudW5wYWNrZWQgPyB2b2lkIDAgOiBmb3JtYXRcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldChkZXZpY2VJZE9yRGV0YWlscykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSksIGRldmljZUlkID0gZGV2aWNlSWRPckRldGFpbHMuaWQgfHwgZGV2aWNlSWRPckRldGFpbHM7XG4gICAgaWYgKHR5cGVvZiBkZXZpY2VJZCAhPT0gXCJzdHJpbmdcIiB8fCAhZGV2aWNlSWQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICBcIkZpcnN0IGFyZ3VtZW50IHRvIERldmljZVJlZ2lzdHJhdGlvbnMjZ2V0IG11c3QgYmUgYSBkZXZpY2VJZCBzdHJpbmcgb3IgRGV2aWNlRGV0YWlsc1wiLFxuICAgICAgICA0ZTQsXG4gICAgICAgIDQwMFxuICAgICAgKTtcbiAgICB9XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LmdldChcbiAgICAgIGNsaWVudCxcbiAgICAgIFwiL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9ucy9cIiArIGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2VJZCksXG4gICAgICBoZWFkZXJzLFxuICAgICAge30sXG4gICAgICBudWxsLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgcmV0dXJuIGRldmljZWRldGFpbHNfZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KFxuICAgICAgcmVzcG9uc2UuYm9keSxcbiAgICAgIGNsaWVudC5fTXNnUGFjayxcbiAgICAgIHJlc3BvbnNlLnVucGFja2VkID8gdm9pZCAwIDogZm9ybWF0XG4gICAgKTtcbiAgfVxuICBhc3luYyBsaXN0KHBhcmFtcykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBlbnZlbG9wZSA9IHRoaXMuY2xpZW50Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHZvaWQgMCA6IGZvcm1hdCwgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIHJldHVybiBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfZGVmYXVsdChjbGllbnQsIFwiL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9uc1wiLCBoZWFkZXJzLCBlbnZlbG9wZSwgYXN5bmMgZnVuY3Rpb24oYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSB7XG4gICAgICByZXR1cm4gZGV2aWNlZGV0YWlsc19kZWZhdWx0LmZyb21SZXNwb25zZUJvZHkoXG4gICAgICAgIGJvZHksXG4gICAgICAgIGNsaWVudC5fTXNnUGFjayxcbiAgICAgICAgdW5wYWNrZWQgPyB2b2lkIDAgOiBmb3JtYXRcbiAgICAgICk7XG4gICAgfSkuZ2V0KHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgcmVtb3ZlKGRldmljZUlkT3JEZXRhaWxzKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQsIGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KSwgcGFyYW1zID0ge30sIGRldmljZUlkID0gZGV2aWNlSWRPckRldGFpbHMuaWQgfHwgZGV2aWNlSWRPckRldGFpbHM7XG4gICAgaWYgKHR5cGVvZiBkZXZpY2VJZCAhPT0gXCJzdHJpbmdcIiB8fCAhZGV2aWNlSWQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICBcIkZpcnN0IGFyZ3VtZW50IHRvIERldmljZVJlZ2lzdHJhdGlvbnMjcmVtb3ZlIG11c3QgYmUgYSBkZXZpY2VJZCBzdHJpbmcgb3IgRGV2aWNlRGV0YWlsc1wiLFxuICAgICAgICA0ZTQsXG4gICAgICAgIDQwMFxuICAgICAgKTtcbiAgICB9XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGNsaWVudC5vcHRpb25zLnB1c2hGdWxsV2FpdClcbiAgICAgIG1peGluKHBhcmFtcywgeyBmdWxsV2FpdDogXCJ0cnVlXCIgfSk7XG4gICAgYXdhaXQgcmVzb3VyY2VfZGVmYXVsdFtcImRlbGV0ZVwiXShcbiAgICAgIGNsaWVudCxcbiAgICAgIFwiL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9ucy9cIiArIGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2VJZCksXG4gICAgICBoZWFkZXJzLFxuICAgICAgcGFyYW1zLFxuICAgICAgbnVsbCxcbiAgICAgIHRydWVcbiAgICApO1xuICB9XG4gIGFzeW5jIHJlbW92ZVdoZXJlKHBhcmFtcykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGNsaWVudC5vcHRpb25zLnB1c2hGdWxsV2FpdClcbiAgICAgIG1peGluKHBhcmFtcywgeyBmdWxsV2FpdDogXCJ0cnVlXCIgfSk7XG4gICAgYXdhaXQgcmVzb3VyY2VfZGVmYXVsdFtcImRlbGV0ZVwiXShjbGllbnQsIFwiL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9uc1wiLCBoZWFkZXJzLCBwYXJhbXMsIG51bGwsIHRydWUpO1xuICB9XG59O1xudmFyIENoYW5uZWxTdWJzY3JpcHRpb25zID0gY2xhc3MgX0NoYW5uZWxTdWJzY3JpcHRpb25zIHtcbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgLyogQ2hhbm5lbFN1YnNjcmlwdGlvbnMgaGF2ZSBubyB1bmlxdWUgaWQ7IHJlbW92aW5nIG9uZSBpcyBlcXVpdmFsZW50IHRvIHJlbW92ZVdoZXJlIGJ5IGl0cyBwcm9wZXJ0aWVzICovXG4gICAgdGhpcy5yZW1vdmUgPSBfQ2hhbm5lbFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnJlbW92ZVdoZXJlO1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICB9XG4gIGFzeW5jIHNhdmUoc3Vic2NyaXB0aW9uKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQ7XG4gICAgY29uc3QgYm9keSA9IHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uX2RlZmF1bHQuZnJvbVZhbHVlcyhzdWJzY3JpcHRpb24pO1xuICAgIGNvbnN0IGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyhjbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSksIHBhcmFtcyA9IHt9O1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmIChjbGllbnQub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICBtaXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6IFwidHJ1ZVwiIH0pO1xuICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gZW5jb2RlQm9keShib2R5LCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnBvc3QoXG4gICAgICBjbGllbnQsXG4gICAgICBcIi9wdXNoL2NoYW5uZWxTdWJzY3JpcHRpb25zXCIsXG4gICAgICByZXF1ZXN0Qm9keSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBwYXJhbXMsXG4gICAgICBudWxsLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgcmV0dXJuIHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uX2RlZmF1bHQuZnJvbVJlc3BvbnNlQm9keShcbiAgICAgIHJlc3BvbnNlLmJvZHksXG4gICAgICBjbGllbnQuX01zZ1BhY2ssXG4gICAgICByZXNwb25zZS51bnBhY2tlZCA/IHZvaWQgMCA6IGZvcm1hdFxuICAgICk7XG4gIH1cbiAgYXN5bmMgbGlzdChwYXJhbXMpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudCwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgZW52ZWxvcGUgPSB0aGlzLmNsaWVudC5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB2b2lkIDAgOiBmb3JtYXQsIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICByZXR1cm4gbmV3IHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQoY2xpZW50LCBcIi9wdXNoL2NoYW5uZWxTdWJzY3JpcHRpb25zXCIsIGhlYWRlcnMsIGVudmVsb3BlLCBhc3luYyBmdW5jdGlvbihib2R5LCBoZWFkZXJzMiwgdW5wYWNrZWQpIHtcbiAgICAgIHJldHVybiBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbl9kZWZhdWx0LmZyb21SZXNwb25zZUJvZHkoXG4gICAgICAgIGJvZHksXG4gICAgICAgIGNsaWVudC5fTXNnUGFjayxcbiAgICAgICAgdW5wYWNrZWQgPyB2b2lkIDAgOiBmb3JtYXRcbiAgICAgICk7XG4gICAgfSkuZ2V0KHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgcmVtb3ZlV2hlcmUocGFyYW1zKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQsIGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBpZiAoY2xpZW50Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgbWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiBcInRydWVcIiB9KTtcbiAgICBhd2FpdCByZXNvdXJjZV9kZWZhdWx0W1wiZGVsZXRlXCJdKGNsaWVudCwgXCIvcHVzaC9jaGFubmVsU3Vic2NyaXB0aW9uc1wiLCBoZWFkZXJzLCBwYXJhbXMsIG51bGwsIHRydWUpO1xuICB9XG4gIGFzeW5jIGxpc3RDaGFubmVscyhwYXJhbXMpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudCwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgZW52ZWxvcGUgPSB0aGlzLmNsaWVudC5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB2b2lkIDAgOiBmb3JtYXQsIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBpZiAoY2xpZW50Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgbWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiBcInRydWVcIiB9KTtcbiAgICByZXR1cm4gbmV3IHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQoY2xpZW50LCBcIi9wdXNoL2NoYW5uZWxzXCIsIGhlYWRlcnMsIGVudmVsb3BlLCBhc3luYyBmdW5jdGlvbihib2R5LCBoZWFkZXJzMiwgdW5wYWNrZWQpIHtcbiAgICAgIGNvbnN0IHBhcnNlZEJvZHkgPSAhdW5wYWNrZWQgJiYgZm9ybWF0ID8gZGVjb2RlQm9keShib2R5LCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCkgOiBib2R5O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWRCb2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhcnNlZEJvZHlbaV0gPSBTdHJpbmcocGFyc2VkQm9keVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VkQm9keTtcbiAgICB9KS5nZXQocGFyYW1zKTtcbiAgfVxufTtcbnZhciBwdXNoX2RlZmF1bHQgPSBQdXNoO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9wcmVzZW5jZW1lc3NhZ2UudHNcbnZhciBhY3Rpb25zMiA9IFtcImFic2VudFwiLCBcInByZXNlbnRcIiwgXCJlbnRlclwiLCBcImxlYXZlXCIsIFwidXBkYXRlXCJdO1xuYXN5bmMgZnVuY3Rpb24gZnJvbUVuY29kZWQobG9nZ2VyLCBDcnlwdG8yLCBlbmNvZGVkLCBpbnB1dE9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IG5vcm1hbGl6ZUNpcGhlck9wdGlvbnMoQ3J5cHRvMiwgbG9nZ2VyLCBpbnB1dE9wdGlvbnMgIT0gbnVsbCA/IGlucHV0T3B0aW9ucyA6IG51bGwpO1xuICBjb25zdCB3cG0gPSBXaXJlUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXMoZW5jb2RlZCk7XG4gIHJldHVybiB3cG0uZGVjb2RlKG9wdGlvbnMsIGxvZ2dlcik7XG59XG5hc3luYyBmdW5jdGlvbiBmcm9tRW5jb2RlZEFycmF5KGxvZ2dlciwgQ3J5cHRvMiwgZW5jb2RlZEFycmF5LCBvcHRpb25zKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChcbiAgICBlbmNvZGVkQXJyYXkubWFwKGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHJldHVybiBmcm9tRW5jb2RlZChsb2dnZXIsIENyeXB0bzIsIGVuY29kZWQsIG9wdGlvbnMpO1xuICAgIH0pXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBfZnJvbUVuY29kZWQoZW5jb2RlZCwgY2hhbm5lbCkge1xuICByZXR1cm4gV2lyZVByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzKGVuY29kZWQpLmRlY29kZShjaGFubmVsLmNoYW5uZWxPcHRpb25zLCBjaGFubmVsLmxvZ2dlcik7XG59XG5hc3luYyBmdW5jdGlvbiBfZnJvbUVuY29kZWRBcnJheShlbmNvZGVkQXJyYXksIGNoYW5uZWwpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgIGVuY29kZWRBcnJheS5tYXAoZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgcmV0dXJuIF9mcm9tRW5jb2RlZChlbmNvZGVkLCBjaGFubmVsKTtcbiAgICB9KVxuICApO1xufVxudmFyIFByZXNlbmNlTWVzc2FnZSA9IGNsYXNzIF9QcmVzZW5jZU1lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gIC8qIFJldHVybnMgd2hldGhlciB0aGlzIHByZXNlbmNlTWVzc2FnZSBpcyBzeW50aGVzaXplZCwgaS5lLiB3YXMgbm90IGFjdHVhbGx5XG4gICAqIHNlbnQgYnkgdGhlIGNvbm5lY3Rpb24gKHVzdWFsbHkgbWVhbnMgYSBsZWF2ZSBldmVudCBzZW50IDE1cyBhZnRlciBhXG4gICAqIGRpc2Nvbm5lY3Rpb24pLiBUaGlzIGlzIHVzZWZ1bCBiZWNhdXNlIHN5bnRoZXNpemVkIG1lc3NhZ2VzIGNhbm5vdCBiZVxuICAgKiBjb21wYXJlZCBmb3IgbmV3bmVzcyBieSBpZCBsZXhpY29ncmFwaGljYWxseSAtIFJUUDJiMVxuICAgKi9cbiAgaXNTeW50aGVzaXplZCgpIHtcbiAgICBpZiAoIXRoaXMuaWQgfHwgIXRoaXMuY29ubmVjdGlvbklkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaWQuc3Vic3RyaW5nKHRoaXMuY29ubmVjdGlvbklkLmxlbmd0aCwgMCkgIT09IHRoaXMuY29ubmVjdGlvbklkO1xuICB9XG4gIC8qIFJUUDJiMiAqL1xuICBwYXJzZUlkKCkge1xuICAgIGlmICghdGhpcy5pZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInBhcnNlSWQoKTogUHJlc2VuY2UgbWVzc2FnZSBkb2VzIG5vdCBjb250YWluIGFuIGlkXCIpO1xuICAgIGNvbnN0IHBhcnRzID0gdGhpcy5pZC5zcGxpdChcIjpcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbm5lY3Rpb25JZDogcGFydHNbMF0sXG4gICAgICBtc2dTZXJpYWw6IHBhcnNlSW50KHBhcnRzWzFdLCAxMCksXG4gICAgICBpbmRleDogcGFyc2VJbnQocGFydHNbMl0sIDEwKVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZW5jb2RlKG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXMgPSBPYmplY3QuYXNzaWduKG5ldyBXaXJlUHJlc2VuY2VNZXNzYWdlKCksIHRoaXMsIHtcbiAgICAgIGFjdGlvbjogYWN0aW9uczIuaW5kZXhPZih0aGlzLmFjdGlvbiB8fCBcInByZXNlbnRcIilcbiAgICB9KTtcbiAgICByZXR1cm4gZW5jb2RlKHJlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IF9QcmVzZW5jZU1lc3NhZ2UoKSwgdmFsdWVzKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlc0FycmF5KHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMubWFwKCh2KSA9PiBfUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXModikpO1xuICB9XG4gIHN0YXRpYyBmcm9tRGF0YShkYXRhKSB7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBfUHJlc2VuY2VNZXNzYWdlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIF9QcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyh7XG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHN0ck1zZyh0aGlzLCBcIlByZXNlbmNlTWVzc2FnZVwiKTtcbiAgfVxufTtcbnZhciBXaXJlUHJlc2VuY2VNZXNzYWdlID0gY2xhc3MgX1dpcmVQcmVzZW5jZU1lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gIHRvSlNPTiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHdpcmVUb0pTT04uY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgX1dpcmVQcmVzZW5jZU1lc3NhZ2UoKSwgdmFsdWVzKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlc0FycmF5KHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMubWFwKCh2KSA9PiBfV2lyZVByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzKHYpKTtcbiAgfVxuICBhc3luYyBkZWNvZGUoY2hhbm5lbE9wdGlvbnMsIGxvZ2dlcikge1xuICAgIGNvbnN0IHJlcyA9IE9iamVjdC5hc3NpZ24obmV3IFByZXNlbmNlTWVzc2FnZSgpLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzKSwge1xuICAgICAgYWN0aW9uOiBhY3Rpb25zMlt0aGlzLmFjdGlvbl1cbiAgICB9KSk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGRlY29kZShyZXMsIGNoYW5uZWxPcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiV2lyZVByZXNlbmNlTWVzc2FnZS5kZWNvZGUoKVwiLCBpbnNwZWN0RXJyb3IoZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBzdHJNc2codGhpcywgXCJXaXJlUHJlc2VuY2VNZXNzYWdlXCIpO1xuICB9XG59O1xudmFyIHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0ID0gUHJlc2VuY2VNZXNzYWdlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVzdHByZXNlbmNlLnRzXG52YXIgUmVzdFByZXNlbmNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjaGFubmVsKSB7XG4gICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgfVxuICBnZXQgbG9nZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwubG9nZ2VyO1xuICB9XG4gIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZXN0UHJlc2VuY2UuZ2V0KClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLmNoYW5uZWwubmFtZSk7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jaGFubmVsLmNsaWVudCwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgZW52ZWxvcGUgPSB0aGlzLmNoYW5uZWwuY2xpZW50Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHZvaWQgMCA6IGZvcm1hdCwgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIHJldHVybiBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfZGVmYXVsdChcbiAgICAgIGNsaWVudCxcbiAgICAgIHRoaXMuY2hhbm5lbC5jbGllbnQucmVzdC5wcmVzZW5jZU1peGluLmJhc2VQYXRoKHRoaXMpLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGVudmVsb3BlLFxuICAgICAgYXN5bmMgKGJvZHksIGhlYWRlcnMyLCB1bnBhY2tlZCkgPT4ge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gdW5wYWNrZWQgPyBib2R5IDogZGVjb2RlQm9keShib2R5LCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgICAgIHJldHVybiBfZnJvbUVuY29kZWRBcnJheShkZWNvZGVkLCB0aGlzLmNoYW5uZWwpO1xuICAgICAgfVxuICAgICkuZ2V0KHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgaGlzdG9yeShwYXJhbXMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZXN0UHJlc2VuY2UuaGlzdG9yeSgpXCIsIFwiY2hhbm5lbCA9IFwiICsgdGhpcy5jaGFubmVsLm5hbWUpO1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuY2xpZW50LnJlc3QucHJlc2VuY2VNaXhpbi5oaXN0b3J5KHRoaXMsIHBhcmFtcyk7XG4gIH1cbn07XG52YXIgcmVzdHByZXNlbmNlX2RlZmF1bHQgPSBSZXN0UHJlc2VuY2U7XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL21lc3NhZ2UudHNcbnZhciBhY3Rpb25zMyA9IFtcIm1lc3NhZ2UuY3JlYXRlXCIsIFwibWVzc2FnZS51cGRhdGVcIiwgXCJtZXNzYWdlLmRlbGV0ZVwiLCBcIm1ldGFcIiwgXCJtZXNzYWdlLnN1bW1hcnlcIl07XG5mdW5jdGlvbiBzdHJpbmdpZnlBY3Rpb24oYWN0aW9uKSB7XG4gIHJldHVybiBhY3Rpb25zM1thY3Rpb24gfHwgMF0gfHwgXCJ1bmtub3duXCI7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlU2l6ZShtc2cpIHtcbiAgbGV0IHNpemUgPSAwO1xuICBpZiAobXNnLm5hbWUpIHtcbiAgICBzaXplICs9IG1zZy5uYW1lLmxlbmd0aDtcbiAgfVxuICBpZiAobXNnLmNsaWVudElkKSB7XG4gICAgc2l6ZSArPSBtc2cuY2xpZW50SWQubGVuZ3RoO1xuICB9XG4gIGlmIChtc2cuZXh0cmFzKSB7XG4gICAgc2l6ZSArPSBKU09OLnN0cmluZ2lmeShtc2cuZXh0cmFzKS5sZW5ndGg7XG4gIH1cbiAgaWYgKG1zZy5kYXRhKSB7XG4gICAgc2l6ZSArPSBkYXRhU2l6ZUJ5dGVzKG1zZy5kYXRhKTtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZyb21FbmNvZGVkMihsb2dnZXIsIENyeXB0bzIsIGVuY29kZWQsIGlucHV0T3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zID0gbm9ybWFsaXplQ2lwaGVyT3B0aW9ucyhDcnlwdG8yLCBsb2dnZXIsIGlucHV0T3B0aW9ucyAhPSBudWxsID8gaW5wdXRPcHRpb25zIDogbnVsbCk7XG4gIGNvbnN0IHdtID0gV2lyZU1lc3NhZ2UuZnJvbVZhbHVlcyhlbmNvZGVkKTtcbiAgcmV0dXJuIHdtLmRlY29kZShvcHRpb25zLCBsb2dnZXIpO1xufVxuYXN5bmMgZnVuY3Rpb24gZnJvbUVuY29kZWRBcnJheTIobG9nZ2VyLCBDcnlwdG8yLCBlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgIGVuY29kZWRBcnJheS5tYXAoZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgcmV0dXJuIGZyb21FbmNvZGVkMihsb2dnZXIsIENyeXB0bzIsIGVuY29kZWQsIG9wdGlvbnMpO1xuICAgIH0pXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBfZnJvbUVuY29kZWQyKGVuY29kZWQsIGNoYW5uZWwpIHtcbiAgY29uc3Qgd20gPSBXaXJlTWVzc2FnZS5mcm9tVmFsdWVzKGVuY29kZWQpO1xuICByZXR1cm4gd20uZGVjb2RlKGNoYW5uZWwuY2hhbm5lbE9wdGlvbnMsIGNoYW5uZWwubG9nZ2VyKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9mcm9tRW5jb2RlZEFycmF5MihlbmNvZGVkQXJyYXksIGNoYW5uZWwpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgIGVuY29kZWRBcnJheS5tYXAoZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgcmV0dXJuIF9mcm9tRW5jb2RlZDIoZW5jb2RlZCwgY2hhbm5lbCk7XG4gICAgfSlcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVuY29kZUFycmF5KG1lc3NhZ2VzLCBvcHRpb25zKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChtZXNzYWdlcy5tYXAoKG1lc3NhZ2UpID0+IG1lc3NhZ2UuZW5jb2RlKG9wdGlvbnMpKSk7XG59XG52YXIgc2VyaWFsaXplID0gZW5jb2RlQm9keTtcbmZ1bmN0aW9uIGdldE1lc3NhZ2VzU2l6ZShtZXNzYWdlcykge1xuICBsZXQgbXNnLCB0b3RhbCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICBtc2cgPSBtZXNzYWdlc1tpXTtcbiAgICB0b3RhbCArPSBtc2cuc2l6ZSB8fCAobXNnLnNpemUgPSBnZXRNZXNzYWdlU2l6ZShtc2cpKTtcbiAgfVxuICByZXR1cm4gdG90YWw7XG59XG52YXIgTWVzc2FnZSA9IGNsYXNzIF9NZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICBleHBhbmRGaWVsZHMoKSB7XG4gICAgaWYgKCF0aGlzLnZlcnNpb24pIHtcbiAgICAgIHRoaXMudmVyc2lvbiA9IHt9O1xuICAgIH1cbiAgICBpZiAoIXRoaXMudmVyc2lvbi5zZXJpYWwgJiYgdGhpcy5zZXJpYWwpIHtcbiAgICAgIHRoaXMudmVyc2lvbi5zZXJpYWwgPSB0aGlzLnNlcmlhbDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnZlcnNpb24udGltZXN0YW1wICYmIHRoaXMudGltZXN0YW1wKSB7XG4gICAgICB0aGlzLnZlcnNpb24udGltZXN0YW1wID0gdGhpcy50aW1lc3RhbXA7XG4gICAgfVxuICAgIGlmICghdGhpcy5hbm5vdGF0aW9ucykge1xuICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IHtcbiAgICAgICAgc3VtbWFyeToge31cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICghdGhpcy5hbm5vdGF0aW9ucy5zdW1tYXJ5KSB7XG4gICAgICB0aGlzLmFubm90YXRpb25zLnN1bW1hcnkgPSB7fTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbnMgJiYgdGhpcy5hbm5vdGF0aW9ucy5zdW1tYXJ5KSB7XG4gICAgICBmb3IgKGNvbnN0IFt0eXBlLCBzdW1tYXJ5RW50cnldIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuYW5ub3RhdGlvbnMuc3VtbWFyeSkpIHtcbiAgICAgICAgaWYgKHR5cGUuZW5kc1dpdGgoXCI6ZGlzdGluY3QudjFcIikgfHwgdHlwZS5lbmRzV2l0aChcIjp1bmlxdWUudjFcIikgfHwgdHlwZS5lbmRzV2l0aChcIjptdWx0aXBsZS52MVwiKSkge1xuICAgICAgICAgIGZvciAoY29uc3QgWywgZW50cnldIG9mIE9iamVjdC5lbnRyaWVzKHN1bW1hcnlFbnRyeSkpIHtcbiAgICAgICAgICAgIGlmICghZW50cnkuY2xpcHBlZCkge1xuICAgICAgICAgICAgICBlbnRyeS5jbGlwcGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUuZW5kc1dpdGgoXCI6ZmxhZy52MVwiKSkge1xuICAgICAgICAgIGlmICghc3VtbWFyeUVudHJ5LmNsaXBwZWQpIHtcbiAgICAgICAgICAgIHN1bW1hcnlFbnRyeS5jbGlwcGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGVuY29kZShvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzID0gT2JqZWN0LmFzc2lnbihuZXcgV2lyZU1lc3NhZ2UoKSwgdGhpcywge1xuICAgICAgYWN0aW9uOiBhY3Rpb25zMy5pbmRleE9mKHRoaXMuYWN0aW9uIHx8IFwibWVzc2FnZS5jcmVhdGVcIilcbiAgICB9KTtcbiAgICByZXR1cm4gZW5jb2RlKHJlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IF9NZXNzYWdlKCksIHZhbHVlcyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXNBcnJheSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLm1hcCgodikgPT4gX01lc3NhZ2UuZnJvbVZhbHVlcyh2KSk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHN0ck1zZyh0aGlzLCBcIk1lc3NhZ2VcIik7XG4gIH1cbn07XG52YXIgV2lyZU1lc3NhZ2UgPSBjbGFzcyBfV2lyZU1lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gIC8vIE92ZXJsb2FkIHRvSlNPTigpIHRvIGludGVyY2VwdCBKU09OLnN0cmluZ2lmeSgpXG4gIHRvSlNPTiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHdpcmVUb0pTT04uY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgX1dpcmVNZXNzYWdlKCksIHZhbHVlcyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXNBcnJheSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLm1hcCgodikgPT4gX1dpcmVNZXNzYWdlLmZyb21WYWx1ZXModikpO1xuICB9XG4gIC8vIGZvciBjb250ZXh0cyB3aGVyZSBzb21lIGRlY29kaW5nIGVycm9ycyBuZWVkIHRvIGJlIGhhbmRsZWQgc3BlY2lhbGx5IGJ5IHRoZSBjYWxsZXJcbiAgYXN5bmMgZGVjb2RlV2l0aEVycihpbnB1dENvbnRleHQsIGxvZ2dlcikge1xuICAgIGNvbnN0IHJlcyA9IE9iamVjdC5hc3NpZ24obmV3IE1lc3NhZ2UoKSwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcyksIHtcbiAgICAgIGFjdGlvbjogc3RyaW5naWZ5QWN0aW9uKHRoaXMuYWN0aW9uKVxuICAgIH0pKTtcbiAgICBsZXQgZXJyO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBkZWNvZGUocmVzLCBpbnB1dENvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJXaXJlTWVzc2FnZS5kZWNvZGUoKVwiLCBpbnNwZWN0RXJyb3IoZSkpO1xuICAgICAgZXJyID0gZTtcbiAgICB9XG4gICAgcmVzLmV4cGFuZEZpZWxkcygpO1xuICAgIHJldHVybiB7IGRlY29kZWQ6IHJlcywgZXJyIH07XG4gIH1cbiAgYXN5bmMgZGVjb2RlKGlucHV0Q29udGV4dCwgbG9nZ2VyKSB7XG4gICAgY29uc3QgeyBkZWNvZGVkIH0gPSBhd2FpdCB0aGlzLmRlY29kZVdpdGhFcnIoaW5wdXRDb250ZXh0LCBsb2dnZXIpO1xuICAgIHJldHVybiBkZWNvZGVkO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBzdHJNc2codGhpcywgXCJXaXJlTWVzc2FnZVwiKTtcbiAgfVxufTtcbnZhciBtZXNzYWdlX2RlZmF1bHQgPSBNZXNzYWdlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVzdGNoYW5uZWwudHNcbnZhciBNU0dfSURfRU5UUk9QWV9CWVRFUyA9IDk7XG5mdW5jdGlvbiBhbGxFbXB0eUlkcyhtZXNzYWdlcykge1xuICByZXR1cm4gbWVzc2FnZXMuZXZlcnkoZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIHJldHVybiAhbWVzc2FnZS5pZDtcbiAgfSk7XG59XG52YXIgUmVzdENoYW5uZWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgbmFtZSwgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICB0aGlzLl9hbm5vdGF0aW9ucyA9IG51bGw7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGNsaWVudC5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJSZXN0Q2hhbm5lbCgpXCIsIFwic3RhcnRlZDsgbmFtZSA9IFwiICsgbmFtZSk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLnByZXNlbmNlID0gbmV3IHJlc3RwcmVzZW5jZV9kZWZhdWx0KHRoaXMpO1xuICAgIHRoaXMuY2hhbm5lbE9wdGlvbnMgPSBub3JtYWxpc2VDaGFubmVsT3B0aW9ucygoX2EyID0gY2xpZW50Ll9DcnlwdG8pICE9IG51bGwgPyBfYTIgOiBudWxsLCB0aGlzLmxvZ2dlciwgY2hhbm5lbE9wdGlvbnMpO1xuICAgIGlmICgoX2IgPSBjbGllbnQub3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2IuUHVzaCkge1xuICAgICAgdGhpcy5fcHVzaCA9IG5ldyBjbGllbnQub3B0aW9ucy5wbHVnaW5zLlB1c2guUHVzaENoYW5uZWwodGhpcyk7XG4gICAgfVxuICAgIGlmIChjbGllbnQuX0Fubm90YXRpb25zKSB7XG4gICAgICB0aGlzLl9hbm5vdGF0aW9ucyA9IG5ldyBjbGllbnQuX0Fubm90YXRpb25zLlJlc3RBbm5vdGF0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFubm90YXRpb25zKCkge1xuICAgIGlmICghdGhpcy5fYW5ub3RhdGlvbnMpIHtcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiQW5ub3RhdGlvbnNcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hbm5vdGF0aW9ucztcbiAgfVxuICBnZXQgcHVzaCgpIHtcbiAgICBpZiAoIXRoaXMuX3B1c2gpIHtcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiUHVzaFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3B1c2g7XG4gIH1cbiAgZ2V0IGxvZ2dlcigpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQubG9nZ2VyO1xuICB9XG4gIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciBfYTI7XG4gICAgdGhpcy5jaGFubmVsT3B0aW9ucyA9IG5vcm1hbGlzZUNoYW5uZWxPcHRpb25zKChfYTIgPSB0aGlzLmNsaWVudC5fQ3J5cHRvKSAhPSBudWxsID8gX2EyIDogbnVsbCwgdGhpcy5sb2dnZXIsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGhpc3RvcnkocGFyYW1zKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVzdENoYW5uZWwuaGlzdG9yeSgpXCIsIFwiY2hhbm5lbCA9IFwiICsgdGhpcy5uYW1lKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucmVzdC5jaGFubmVsTWl4aW4uaGlzdG9yeSh0aGlzLCBwYXJhbXMpO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2goLi4uYXJncykge1xuICAgIGNvbnN0IGZpcnN0ID0gYXJnc1swXSwgc2Vjb25kID0gYXJnc1sxXTtcbiAgICBsZXQgbWVzc2FnZXM7XG4gICAgbGV0IHBhcmFtcztcbiAgICBpZiAodHlwZW9mIGZpcnN0ID09PSBcInN0cmluZ1wiIHx8IGZpcnN0ID09PSBudWxsKSB7XG4gICAgICBtZXNzYWdlcyA9IFttZXNzYWdlX2RlZmF1bHQuZnJvbVZhbHVlcyh7IG5hbWU6IGZpcnN0LCBkYXRhOiBzZWNvbmQgfSldO1xuICAgICAgcGFyYW1zID0gYXJnc1syXTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpcnN0KSkge1xuICAgICAgbWVzc2FnZXMgPSBbbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXMoZmlyc3QpXTtcbiAgICAgIHBhcmFtcyA9IGFyZ3NbMV07XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGZpcnN0KSkge1xuICAgICAgbWVzc2FnZXMgPSBtZXNzYWdlX2RlZmF1bHQuZnJvbVZhbHVlc0FycmF5KGZpcnN0KTtcbiAgICAgIHBhcmFtcyA9IGFyZ3NbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgIFwiVGhlIHNpbmdsZS1hcmd1bWVudCBmb3JtIG9mIHB1Ymxpc2goKSBleHBlY3RzIGEgbWVzc2FnZSBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgbWVzc2FnZSBvYmplY3RzXCIsXG4gICAgICAgIDQwMDEzLFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghcGFyYW1zKSB7XG4gICAgICBwYXJhbXMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQsIG9wdGlvbnMgPSBjbGllbnQub3B0aW9ucywgZm9ybWF0ID0gb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBpZGVtcG90ZW50UmVzdFB1Ymxpc2hpbmcgPSBjbGllbnQub3B0aW9ucy5pZGVtcG90ZW50UmVzdFB1Ymxpc2hpbmcsIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyhjbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSk7XG4gICAgbWl4aW4oaGVhZGVycywgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICBpZiAoaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nICYmIGFsbEVtcHR5SWRzKG1lc3NhZ2VzKSkge1xuICAgICAgY29uc3QgbXNnSWRCYXNlID0gYXdhaXQgcmFuZG9tU3RyaW5nKE1TR19JRF9FTlRST1BZX0JZVEVTKTtcbiAgICAgIG1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24obWVzc2FnZSwgaW5kZXgpIHtcbiAgICAgICAgbWVzc2FnZS5pZCA9IG1zZ0lkQmFzZSArIFwiOlwiICsgaW5kZXgudG9TdHJpbmcoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB3aXJlTWVzc2FnZXMgPSBhd2FpdCBlbmNvZGVBcnJheShtZXNzYWdlcywgdGhpcy5jaGFubmVsT3B0aW9ucyk7XG4gICAgY29uc3Qgc2l6ZSA9IGdldE1lc3NhZ2VzU2l6ZSh3aXJlTWVzc2FnZXMpLCBtYXhNZXNzYWdlU2l6ZSA9IG9wdGlvbnMubWF4TWVzc2FnZVNpemU7XG4gICAgaWYgKHNpemUgPiBtYXhNZXNzYWdlU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgYE1heGltdW0gc2l6ZSBvZiBtZXNzYWdlcyB0aGF0IGNhbiBiZSBwdWJsaXNoZWQgYXQgb25jZSBleGNlZWRlZCAod2FzICR7c2l6ZX0gYnl0ZXM7IGxpbWl0IGlzICR7bWF4TWVzc2FnZVNpemV9IGJ5dGVzKWAsXG4gICAgICAgIDQwMDA5LFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuX3B1Ymxpc2goc2VyaWFsaXplKHdpcmVNZXNzYWdlcywgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpLCBoZWFkZXJzLCBwYXJhbXMpO1xuICB9XG4gIGFzeW5jIF9wdWJsaXNoKHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBwYXJhbXMpIHtcbiAgICBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnBvc3QoXG4gICAgICB0aGlzLmNsaWVudCxcbiAgICAgIHRoaXMuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLmJhc2VQYXRoKHRoaXMpICsgXCIvbWVzc2FnZXNcIixcbiAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcyxcbiAgICAgIG51bGwsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfVxuICBhc3luYyBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLnN0YXR1cyh0aGlzKTtcbiAgfVxufTtcbnZhciByZXN0Y2hhbm5lbF9kZWZhdWx0ID0gUmVzdENoYW5uZWw7XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL3N0YXRzLnRzXG52YXIgU3RhdHMgPSBjbGFzcyBfU3RhdHMge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZXMpIHtcbiAgICB0aGlzLmVudHJpZXMgPSB2YWx1ZXMgJiYgdmFsdWVzLmVudHJpZXMgfHwgdm9pZCAwO1xuICAgIHRoaXMuc2NoZW1hID0gdmFsdWVzICYmIHZhbHVlcy5zY2hlbWEgfHwgdm9pZCAwO1xuICAgIHRoaXMuYXBwSWQgPSB2YWx1ZXMgJiYgdmFsdWVzLmFwcElkIHx8IHZvaWQgMDtcbiAgICB0aGlzLmluUHJvZ3Jlc3MgPSB2YWx1ZXMgJiYgdmFsdWVzLmluUHJvZ3Jlc3MgfHwgdm9pZCAwO1xuICAgIHRoaXMudW5pdCA9IHZhbHVlcyAmJiB2YWx1ZXMudW5pdCB8fCB2b2lkIDA7XG4gICAgdGhpcy5pbnRlcnZhbElkID0gdmFsdWVzICYmIHZhbHVlcy5pbnRlcnZhbElkIHx8IHZvaWQgMDtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gbmV3IF9TdGF0cyh2YWx1ZXMpO1xuICB9XG59O1xudmFyIHN0YXRzX2RlZmF1bHQgPSBTdGF0cztcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3Jlc3RjaGFubmVsbWl4aW4udHNcbnZhciBSZXN0Q2hhbm5lbE1peGluID0gY2xhc3Mge1xuICBzdGF0aWMgYmFzZVBhdGgoY2hhbm5lbCkge1xuICAgIHJldHVybiBcIi9jaGFubmVscy9cIiArIGVuY29kZVVSSUNvbXBvbmVudChjaGFubmVsLm5hbWUpO1xuICB9XG4gIHN0YXRpYyBoaXN0b3J5KGNoYW5uZWwsIHBhcmFtcykge1xuICAgIGNvbnN0IGNsaWVudCA9IGNoYW5uZWwuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBlbnZlbG9wZSA9IGNoYW5uZWwuY2xpZW50Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHZvaWQgMCA6IGZvcm1hdCwgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIHJldHVybiBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfZGVmYXVsdChjbGllbnQsIHRoaXMuYmFzZVBhdGgoY2hhbm5lbCkgKyBcIi9tZXNzYWdlc1wiLCBoZWFkZXJzLCBlbnZlbG9wZSwgYXN5bmMgZnVuY3Rpb24oYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSB7XG4gICAgICBjb25zdCBkZWNvZGVkID0gdW5wYWNrZWQgPyBib2R5IDogZGVjb2RlQm9keShib2R5LCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgICByZXR1cm4gX2Zyb21FbmNvZGVkQXJyYXkyKGRlY29kZWQsIGNoYW5uZWwpO1xuICAgIH0pLmdldChwYXJhbXMpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBzdGF0dXMoY2hhbm5lbCkge1xuICAgIGNvbnN0IGZvcm1hdCA9IGNoYW5uZWwuY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLztcbiAgICBjb25zdCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnMoY2hhbm5lbC5jbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LmdldChcbiAgICAgIGNoYW5uZWwuY2xpZW50LFxuICAgICAgdGhpcy5iYXNlUGF0aChjaGFubmVsKSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICB7fSxcbiAgICAgIGZvcm1hdCxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIHJldHVybiByZXNwb25zZS5ib2R5O1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVzdHByZXNlbmNlbWl4aW4udHNcbnZhciBSZXN0UHJlc2VuY2VNaXhpbiA9IGNsYXNzIHtcbiAgc3RhdGljIGJhc2VQYXRoKHByZXNlbmNlKSB7XG4gICAgcmV0dXJuIFJlc3RDaGFubmVsTWl4aW4uYmFzZVBhdGgocHJlc2VuY2UuY2hhbm5lbCkgKyBcIi9wcmVzZW5jZVwiO1xuICB9XG4gIHN0YXRpYyBhc3luYyBoaXN0b3J5KHByZXNlbmNlLCBwYXJhbXMpIHtcbiAgICBjb25zdCBjbGllbnQgPSBwcmVzZW5jZS5jaGFubmVsLmNsaWVudCwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgZW52ZWxvcGUgPSBwcmVzZW5jZS5jaGFubmVsLmNsaWVudC5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB2b2lkIDAgOiBmb3JtYXQsIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICByZXR1cm4gbmV3IHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQoXG4gICAgICBjbGllbnQsXG4gICAgICB0aGlzLmJhc2VQYXRoKHByZXNlbmNlKSArIFwiL2hpc3RvcnlcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBlbnZlbG9wZSxcbiAgICAgIGFzeW5jIChib2R5LCBoZWFkZXJzMiwgdW5wYWNrZWQpID0+IHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IHVucGFja2VkID8gYm9keSA6IGRlY29kZUJvZHkoYm9keSwgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgICAgICByZXR1cm4gX2Zyb21FbmNvZGVkQXJyYXkoZGVjb2RlZCwgcHJlc2VuY2UuY2hhbm5lbCk7XG4gICAgICB9XG4gICAgKS5nZXQocGFyYW1zKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3Jlc3QudHNcbnZhciBSZXN0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNoYW5uZWxNaXhpbiA9IFJlc3RDaGFubmVsTWl4aW47XG4gICAgdGhpcy5wcmVzZW5jZU1peGluID0gUmVzdFByZXNlbmNlTWl4aW47XG4gICAgLy8gZXhwb3NlZCBmb3IgcGx1Z2lucyBidXQgc2hvdWxkbid0IGJlIGJ1bmRsZWQgd2l0aCBtaW5pbWFsIHJlYWx0aW1lXG4gICAgdGhpcy5SZXNvdXJjZSA9IHJlc291cmNlX2RlZmF1bHQ7XG4gICAgdGhpcy5QYWdpbmF0ZWRSZXNvdXJjZSA9IHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQ7XG4gICAgdGhpcy5EZXZpY2VEZXRhaWxzID0gZGV2aWNlZGV0YWlsc19kZWZhdWx0O1xuICAgIHRoaXMuUHVzaENoYW5uZWxTdWJzY3JpcHRpb24gPSBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbl9kZWZhdWx0O1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuY2hhbm5lbHMgPSBuZXcgQ2hhbm5lbHModGhpcy5jbGllbnQpO1xuICAgIHRoaXMucHVzaCA9IG5ldyBwdXNoX2RlZmF1bHQodGhpcy5jbGllbnQpO1xuICB9XG4gIGFzeW5jIHN0YXRzKHBhcmFtcykge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKHRoaXMuY2xpZW50Lm9wdGlvbnMpLCBmb3JtYXQgPSB0aGlzLmNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGVudmVsb3BlID0gdGhpcy5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0O1xuICAgIG1peGluKGhlYWRlcnMsIHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgcmV0dXJuIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KHRoaXMuY2xpZW50LCBcIi9zdGF0c1wiLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24oYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSB7XG4gICAgICBjb25zdCBzdGF0c1ZhbHVlcyA9IHVucGFja2VkID8gYm9keSA6IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRzVmFsdWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICBzdGF0c1ZhbHVlc1tpXSA9IHN0YXRzX2RlZmF1bHQuZnJvbVZhbHVlcyhzdGF0c1ZhbHVlc1tpXSk7XG4gICAgICByZXR1cm4gc3RhdHNWYWx1ZXM7XG4gICAgfSkuZ2V0KHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgdGltZShwYXJhbXMpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zKTtcbiAgICBpZiAodGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgbWl4aW4oaGVhZGVycywgdGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCB0aW1lVXJpID0gKGhvc3QpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNsaWVudC5iYXNlVXJpKGhvc3QpICsgXCIvdGltZVwiO1xuICAgIH07XG4gICAgbGV0IHsgZXJyb3IsIGJvZHksIHVucGFja2VkIH0gPSBhd2FpdCB0aGlzLmNsaWVudC5odHRwLmRvKFxuICAgICAgSHR0cE1ldGhvZHNfZGVmYXVsdC5HZXQsXG4gICAgICB0aW1lVXJpLFxuICAgICAgaGVhZGVycyxcbiAgICAgIG51bGwsXG4gICAgICBwYXJhbXNcbiAgICApO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmICghdW5wYWNrZWQpXG4gICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICBjb25zdCB0aW1lID0gYm9keVswXTtcbiAgICBpZiAoIXRpbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJJbnRlcm5hbCBlcnJvciAodW5leHBlY3RlZCByZXN1bHQgdHlwZSBmcm9tIEdFVCAvdGltZSlcIiwgNWU0LCA1MDApO1xuICAgIH1cbiAgICB0aGlzLmNsaWVudC5zZXJ2ZXJUaW1lT2Zmc2V0ID0gdGltZSAtIERhdGUubm93KCk7XG4gICAgcmV0dXJuIHRpbWU7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdChtZXRob2QsIHBhdGgsIHZlcnNpb24yLCBwYXJhbXMsIGJvZHksIGN1c3RvbUhlYWRlcnMpIHtcbiAgICB2YXIgX2EyO1xuICAgIGNvbnN0IFtlbmNvZGVyLCBkZWNvZGVyLCBmb3JtYXRdID0gKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sKSB7XG4gICAgICAgIGlmICghdGhpcy5jbGllbnQuX01zZ1BhY2spIHtcbiAgICAgICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIk1zZ1BhY2tcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0aGlzLmNsaWVudC5fTXNnUGFjay5lbmNvZGUsIHRoaXMuY2xpZW50Ll9Nc2dQYWNrLmRlY29kZSwgXCJtc2dwYWNrXCIgLyogbXNncGFjayAqL107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW0pTT04uc3RyaW5naWZ5LCBKU09OLnBhcnNlLCBcImpzb25cIiAvKiBqc29uICovXTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICAgIGNvbnN0IGVudmVsb3BlID0gdGhpcy5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0O1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBjb25zdCBfbWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgaGVhZGVycyA9IF9tZXRob2QgPT0gXCJnZXRcIiA/IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnModGhpcy5jbGllbnQub3B0aW9ucywgeyBmb3JtYXQsIHByb3RvY29sVmVyc2lvbjogdmVyc2lvbjIgfSkgOiBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCwgcHJvdG9jb2xWZXJzaW9uOiB2ZXJzaW9uMiB9KTtcbiAgICBpZiAodHlwZW9mIGJvZHkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGJvZHkgPSAoX2EyID0gZW5jb2Rlcihib2R5KSkgIT0gbnVsbCA/IF9hMiA6IG51bGw7XG4gICAgfVxuICAgIG1peGluKGhlYWRlcnMsIHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGN1c3RvbUhlYWRlcnMpIHtcbiAgICAgIG1peGluKGhlYWRlcnMsIGN1c3RvbUhlYWRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBwYWdpbmF0ZWRSZXNvdXJjZSA9IG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KFxuICAgICAgdGhpcy5jbGllbnQsXG4gICAgICBwYXRoLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGVudmVsb3BlLFxuICAgICAgYXN5bmMgZnVuY3Rpb24ocmVzYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSB7XG4gICAgICAgIHJldHVybiBlbnN1cmVBcnJheSh1bnBhY2tlZCA/IHJlc2JvZHkgOiBkZWNvZGVyKHJlc2JvZHkpKTtcbiAgICAgIH0sXG4gICAgICAvKiB1c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2U6ICovXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBpZiAoIVBsYXRmb3JtLkh0dHAubWV0aG9kcy5pbmNsdWRlcyhfbWV0aG9kKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIlVuc3VwcG9ydGVkIG1ldGhvZCBcIiArIF9tZXRob2QsIDQwNTAwLCA0MDUpO1xuICAgIH1cbiAgICBpZiAoUGxhdGZvcm0uSHR0cC5tZXRob2RzV2l0aEJvZHkuaW5jbHVkZXMoX21ldGhvZCkpIHtcbiAgICAgIHJldHVybiBwYWdpbmF0ZWRSZXNvdXJjZVtfbWV0aG9kXShwYXJhbXMsIGJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFnaW5hdGVkUmVzb3VyY2VbX21ldGhvZF0ocGFyYW1zKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYmF0Y2hQdWJsaXNoKHNwZWNPclNwZWNzKSB7XG4gICAgbGV0IHJlcXVlc3RCb2R5RFRPO1xuICAgIGxldCBzaW5nbGVTcGVjTW9kZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzcGVjT3JTcGVjcykpIHtcbiAgICAgIHJlcXVlc3RCb2R5RFRPID0gc3BlY09yU3BlY3M7XG4gICAgICBzaW5nbGVTcGVjTW9kZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXF1ZXN0Qm9keURUTyA9IFtzcGVjT3JTcGVjc107XG4gICAgICBzaW5nbGVTcGVjTW9kZSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFBvc3RIZWFkZXJzKHRoaXMuY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pO1xuICAgIGlmICh0aGlzLmNsaWVudC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICBtaXhpbihoZWFkZXJzLCB0aGlzLmNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gZW5jb2RlQm9keShyZXF1ZXN0Qm9keURUTywgdGhpcy5jbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnBvc3QodGhpcy5jbGllbnQsIFwiL21lc3NhZ2VzXCIsIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCB7fSwgbnVsbCwgdHJ1ZSk7XG4gICAgY29uc3QgYmF0Y2hSZXN1bHRzID0gcmVzcG9uc2UudW5wYWNrZWQgPyByZXNwb25zZS5ib2R5IDogZGVjb2RlQm9keShyZXNwb25zZS5ib2R5LCB0aGlzLmNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICBpZiAoc2luZ2xlU3BlY01vZGUpIHtcbiAgICAgIHJldHVybiBiYXRjaFJlc3VsdHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiYXRjaFJlc3VsdHM7XG4gICAgfVxuICB9XG4gIGFzeW5jIGJhdGNoUHJlc2VuY2UoY2hhbm5lbHMpIHtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KTtcbiAgICBpZiAodGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgbWl4aW4oaGVhZGVycywgdGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCBjaGFubmVsc1BhcmFtID0gY2hhbm5lbHMuam9pbihcIixcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LmdldCh0aGlzLmNsaWVudCwgXCIvcHJlc2VuY2VcIiwgaGVhZGVycywgeyBjaGFubmVsczogY2hhbm5lbHNQYXJhbSB9LCBudWxsLCB0cnVlKTtcbiAgICByZXR1cm4gcmVzcG9uc2UudW5wYWNrZWQgPyByZXNwb25zZS5ib2R5IDogZGVjb2RlQm9keShyZXNwb25zZS5ib2R5LCB0aGlzLmNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgfVxuICBhc3luYyByZXZva2VUb2tlbnMoc3BlY2lmaWVycywgb3B0aW9ucykge1xuICAgIGlmICh1c2VUb2tlbkF1dGgodGhpcy5jbGllbnQub3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJDYW5ub3QgcmV2b2tlIHRva2VucyB3aGVuIHVzaW5nIHRva2VuIGF1dGhcIiwgNDAxNjIsIDQwMSk7XG4gICAgfVxuICAgIGNvbnN0IGtleU5hbWUgPSB0aGlzLmNsaWVudC5vcHRpb25zLmtleU5hbWU7XG4gICAgbGV0IHJlc29sdmVkT3B0aW9ucyA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMgOiB7fTtcbiAgICBjb25zdCByZXF1ZXN0Qm9keURUTyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIHRhcmdldHM6IHNwZWNpZmllcnMubWFwKChzcGVjaWZpZXIpID0+IGAke3NwZWNpZmllci50eXBlfToke3NwZWNpZmllci52YWx1ZX1gKVxuICAgIH0sIHJlc29sdmVkT3B0aW9ucyk7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5jbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnModGhpcy5jbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSk7XG4gICAgaWYgKHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgIG1peGluKGhlYWRlcnMsIHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgY29uc3QgcmVxdWVzdEJvZHkgPSBlbmNvZGVCb2R5KHJlcXVlc3RCb2R5RFRPLCB0aGlzLmNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQucG9zdChcbiAgICAgIHRoaXMuY2xpZW50LFxuICAgICAgYC9rZXlzLyR7a2V5TmFtZX0vcmV2b2tlVG9rZW5zYCxcbiAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHt9LFxuICAgICAgbnVsbCxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIHJldHVybiByZXNwb25zZS51bnBhY2tlZCA/IHJlc3BvbnNlLmJvZHkgOiBkZWNvZGVCb2R5KHJlc3BvbnNlLmJvZHksIHRoaXMuY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICB9XG59O1xudmFyIENoYW5uZWxzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLmFsbCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGdldChuYW1lLCBjaGFubmVsT3B0aW9ucykge1xuICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgbGV0IGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXTtcbiAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgIHRoaXMuYWxsW25hbWVdID0gY2hhbm5lbCA9IG5ldyByZXN0Y2hhbm5lbF9kZWZhdWx0KHRoaXMuY2xpZW50LCBuYW1lLCBjaGFubmVsT3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChjaGFubmVsT3B0aW9ucykge1xuICAgICAgY2hhbm5lbC5zZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5uZWw7XG4gIH1cbiAgLyogSW5jbHVkZWQgdG8gc3VwcG9ydCBjZXJ0YWluIG5pY2hlIHVzZS1jYXNlczsgbW9zdCB1c2VycyBzaG91bGQgaWdub3JlIHRoaXMuXG4gICAqIFBsZWFzZSBkbyBub3QgdXNlIHRoaXMgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nICovXG4gIHJlbGVhc2UobmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLmFsbFtTdHJpbmcobmFtZSldO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvYmFzZXJlc3QudHNcbnZhciBCYXNlUmVzdCA9IGNsYXNzIGV4dGVuZHMgYmFzZWNsaWVudF9kZWZhdWx0IHtcbiAgLypcbiAgICogVGhlIHB1YmxpYyB0eXBpbmdzIGRlY2xhcmUgdGhhdCB0aGlzIG9ubHkgYWNjZXB0cyBhbiBvYmplY3QsIGJ1dCBzaW5jZSB3ZSB3YW50IHRvIGVtaXQgYSBnb29kIGVycm9yIG1lc3NhZ2UgaW4gdGhlIGNhc2Ugd2hlcmUgYSBub24tVHlwZVNjcmlwdCB1c2VyIGRvZXMgb25lIG9mIHRoZXNlIHRoaW5nczpcbiAgICpcbiAgICogMS4gcGFzc2VzIGEgc3RyaW5nICh3aGljaCBpcyBxdWl0ZSBsaWtlbHkgaWYgdGhleeKAmXJlIGUuZy4gbWlncmF0aW5nIGZyb20gdGhlIGRlZmF1bHQgdmFyaWFudCB0byB0aGUgbW9kdWxhciB2YXJpYW50KVxuICAgKiAyLiBwYXNzZXMgbm8gYXJndW1lbnQgYXQgYWxsXG4gICAqXG4gICAqIHRlbGwgdGhlIGNvbXBpbGVyIHRoYXQgdGhlc2UgY2FzZXMgYXJlIHBvc3NpYmxlIHNvIHRoYXQgaXQgZm9yY2VzIHVzIHRvIGhhbmRsZSB0aGVtLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKGRlZmF1bHRzX2RlZmF1bHQub2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zLCBmYWxzZSwgXCJCYXNlUmVzdFwiLCBsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCB7IFJlc3QgfSkpO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvbW9kdWxhcnBsdWdpbnMudHNcbnZhciBhbGxDb21tb25Nb2R1bGFyUGx1Z2lucyA9IHsgUmVzdCB9O1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9kZWZhdWx0bWVzc2FnZS50c1xudmFyIERlZmF1bHRNZXNzYWdlID0gY2xhc3MgZXh0ZW5kcyBtZXNzYWdlX2RlZmF1bHQge1xuICBzdGF0aWMgYXN5bmMgZnJvbUVuY29kZWQoZW5jb2RlZCwgaW5wdXRPcHRpb25zKSB7XG4gICAgcmV0dXJuIGZyb21FbmNvZGVkMihsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCBQbGF0Zm9ybS5DcnlwdG8sIGVuY29kZWQsIGlucHV0T3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21FbmNvZGVkQXJyYXkoZW5jb2RlZEFycmF5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZyb21FbmNvZGVkQXJyYXkyKGxvZ2dlcl9kZWZhdWx0LmRlZmF1bHRMb2dnZXIsIFBsYXRmb3JtLkNyeXB0bywgZW5jb2RlZEFycmF5LCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXModmFsdWVzKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvZGVmYXVsdHByZXNlbmNlbWVzc2FnZS50c1xudmFyIERlZmF1bHRQcmVzZW5jZU1lc3NhZ2UgPSBjbGFzcyBleHRlbmRzIHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0IHtcbiAgc3RhdGljIGFzeW5jIGZyb21FbmNvZGVkKGVuY29kZWQsIGlucHV0T3B0aW9ucykge1xuICAgIHJldHVybiBmcm9tRW5jb2RlZChsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCBQbGF0Zm9ybS5DcnlwdG8sIGVuY29kZWQsIGlucHV0T3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21FbmNvZGVkQXJyYXkoZW5jb2RlZEFycmF5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZyb21FbmNvZGVkQXJyYXkobG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlciwgUGxhdGZvcm0uQ3J5cHRvLCBlbmNvZGVkQXJyYXksIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiBwcmVzZW5jZW1lc3NhZ2VfZGVmYXVsdC5mcm9tVmFsdWVzKHZhbHVlcyk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL2Fubm90YXRpb24udHNcbnZhciBhY3Rpb25zNCA9IFtcImFubm90YXRpb24uY3JlYXRlXCIsIFwiYW5ub3RhdGlvbi5kZWxldGVcIl07XG5hc3luYyBmdW5jdGlvbiBmcm9tRW5jb2RlZDMobG9nZ2VyLCBlbmNvZGVkLCBvcHRpb25zKSB7XG4gIGNvbnN0IHdhID0gV2lyZUFubm90YXRpb24uZnJvbVZhbHVlcyhlbmNvZGVkKTtcbiAgcmV0dXJuIHdhLmRlY29kZShvcHRpb25zIHx8IHt9LCBsb2dnZXIpO1xufVxuYXN5bmMgZnVuY3Rpb24gZnJvbUVuY29kZWRBcnJheTMobG9nZ2VyLCBlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgIGVuY29kZWRBcnJheS5tYXAoZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgcmV0dXJuIGZyb21FbmNvZGVkMyhsb2dnZXIsIGVuY29kZWQsIG9wdGlvbnMpO1xuICAgIH0pXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBfZnJvbUVuY29kZWQzKGVuY29kZWQsIGNoYW5uZWwpIHtcbiAgcmV0dXJuIFdpcmVBbm5vdGF0aW9uLmZyb21WYWx1ZXMoZW5jb2RlZCkuZGVjb2RlKGNoYW5uZWwuY2hhbm5lbE9wdGlvbnMsIGNoYW5uZWwubG9nZ2VyKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9mcm9tRW5jb2RlZEFycmF5MyhlbmNvZGVkQXJyYXksIGNoYW5uZWwpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgIGVuY29kZWRBcnJheS5tYXAoZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgcmV0dXJuIF9mcm9tRW5jb2RlZDMoZW5jb2RlZCwgY2hhbm5lbCk7XG4gICAgfSlcbiAgKTtcbn1cbnZhciBBbm5vdGF0aW9uID0gY2xhc3MgX0Fubm90YXRpb24gZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gIGFzeW5jIGVuY29kZSgpIHtcbiAgICBjb25zdCByZXMgPSBPYmplY3QuYXNzaWduKG5ldyBXaXJlQW5ub3RhdGlvbigpLCB0aGlzLCB7XG4gICAgICBhY3Rpb246IGFjdGlvbnM0LmluZGV4T2YodGhpcy5hY3Rpb24gfHwgXCJhbm5vdGF0aW9uLmNyZWF0ZVwiKVxuICAgIH0pO1xuICAgIHJldHVybiBlbmNvZGUocmVzLCB7fSk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IF9Bbm5vdGF0aW9uKCksIHZhbHVlcyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXNBcnJheSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLm1hcCgodikgPT4gX0Fubm90YXRpb24uZnJvbVZhbHVlcyh2KSk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHN0ck1zZyh0aGlzLCBcIkFubm90YXRpb25cIik7XG4gIH1cbn07XG52YXIgV2lyZUFubm90YXRpb24gPSBjbGFzcyBfV2lyZUFubm90YXRpb24gZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gIHRvSlNPTiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHdpcmVUb0pTT04uY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgX1dpcmVBbm5vdGF0aW9uKCksIHZhbHVlcyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXNBcnJheSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLm1hcCgodikgPT4gX1dpcmVBbm5vdGF0aW9uLmZyb21WYWx1ZXModikpO1xuICB9XG4gIGFzeW5jIGRlY29kZShjaGFubmVsT3B0aW9ucywgbG9nZ2VyKSB7XG4gICAgY29uc3QgcmVzID0gT2JqZWN0LmFzc2lnbihuZXcgQW5ub3RhdGlvbigpLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzKSwge1xuICAgICAgYWN0aW9uOiBhY3Rpb25zNFt0aGlzLmFjdGlvbl1cbiAgICB9KSk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGRlY29kZShyZXMsIGNoYW5uZWxPcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiV2lyZUFubm90YXRpb24uZGVjb2RlKClcIiwgaW5zcGVjdEVycm9yKGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gc3RyTXNnKHRoaXMsIFwiV2lyZUFubm90YXRpb25cIik7XG4gIH1cbn07XG52YXIgYW5ub3RhdGlvbl9kZWZhdWx0ID0gQW5ub3RhdGlvbjtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvZGVmYXVsdGFubm90YXRpb24udHNcbnZhciBEZWZhdWx0QW5ub3RhdGlvbiA9IGNsYXNzIGV4dGVuZHMgYW5ub3RhdGlvbl9kZWZhdWx0IHtcbiAgc3RhdGljIGFzeW5jIGZyb21FbmNvZGVkKGVuY29kZWQsIGlucHV0T3B0aW9ucykge1xuICAgIHJldHVybiBmcm9tRW5jb2RlZDMobG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlciwgZW5jb2RlZCwgaW5wdXRPcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbUVuY29kZWRBcnJheShlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnJvbUVuY29kZWRBcnJheTMobG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlciwgZW5jb2RlZEFycmF5LCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gYW5ub3RhdGlvbl9kZWZhdWx0LmZyb21WYWx1ZXModmFsdWVzKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3Jlc3Rhbm5vdGF0aW9ucy50c1xuZnVuY3Rpb24gc2VyaWFsRnJvbU1zZ09yU2VyaWFsKG1zZ09yU2VyaWFsKSB7XG4gIGxldCBtZXNzYWdlU2VyaWFsO1xuICBzd2l0Y2ggKHR5cGVvZiBtc2dPclNlcmlhbCkge1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIG1lc3NhZ2VTZXJpYWwgPSBtc2dPclNlcmlhbDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIG1lc3NhZ2VTZXJpYWwgPSBtc2dPclNlcmlhbC5zZXJpYWw7XG4gICAgICBicmVhaztcbiAgfVxuICBpZiAoIW1lc3NhZ2VTZXJpYWwgfHwgdHlwZW9mIG1lc3NhZ2VTZXJpYWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgXCJGaXJzdCBhcmd1bWVudCBvZiBhbm5vdGF0aW9ucy5wdWJsaXNoKCkgbXVzdCBiZSBlaXRoZXIgYSBNZXNzYWdlIChvciBhdCBsZWFzdCBhbiBvYmplY3Qgd2l0aCBhIHN0cmluZyBgc2VyaWFsYCBwcm9wZXJ0eSkgb3IgYSBtZXNzYWdlIHNlcmlhbCAoc3RyaW5nKVwiLFxuICAgICAgNDAwMDMsXG4gICAgICA0MDBcbiAgICApO1xuICB9XG4gIHJldHVybiBtZXNzYWdlU2VyaWFsO1xufVxuZnVuY3Rpb24gY29uc3RydWN0VmFsaWRhdGVBbm5vdGF0aW9uKG1zZ09yU2VyaWFsLCBhbm5vdGF0aW9uVmFsdWVzKSB7XG4gIGNvbnN0IG1lc3NhZ2VTZXJpYWwgPSBzZXJpYWxGcm9tTXNnT3JTZXJpYWwobXNnT3JTZXJpYWwpO1xuICBpZiAoIWFubm90YXRpb25WYWx1ZXMgfHwgdHlwZW9mIGFubm90YXRpb25WYWx1ZXMgIT09IFwib2JqZWN0XCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgXCJTZWNvbmQgYXJndW1lbnQgb2YgYW5ub3RhdGlvbnMucHVibGlzaCgpIG11c3QgYmUgYW4gb2JqZWN0ICh0aGUgaW50ZW5kZWQgYW5ub3RhdGlvbiB0byBwdWJsaXNoKVwiLFxuICAgICAgNDAwMDMsXG4gICAgICA0MDBcbiAgICApO1xuICB9XG4gIGNvbnN0IGFubm90YXRpb24gPSBhbm5vdGF0aW9uX2RlZmF1bHQuZnJvbVZhbHVlcyhhbm5vdGF0aW9uVmFsdWVzKTtcbiAgYW5ub3RhdGlvbi5tZXNzYWdlU2VyaWFsID0gbWVzc2FnZVNlcmlhbDtcbiAgaWYgKCFhbm5vdGF0aW9uLmFjdGlvbikge1xuICAgIGFubm90YXRpb24uYWN0aW9uID0gXCJhbm5vdGF0aW9uLmNyZWF0ZVwiO1xuICB9XG4gIHJldHVybiBhbm5vdGF0aW9uO1xufVxuZnVuY3Rpb24gYmFzZVBhdGhGb3JTZXJpYWwoY2hhbm5lbCwgc2VyaWFsKSB7XG4gIHJldHVybiBjaGFubmVsLmNsaWVudC5yZXN0LmNoYW5uZWxNaXhpbi5iYXNlUGF0aChjaGFubmVsKSArIFwiL21lc3NhZ2VzL1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KHNlcmlhbCkgKyBcIi9hbm5vdGF0aW9uc1wiO1xufVxudmFyIFJlc3RBbm5vdGF0aW9ucyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2hhbm5lbCkge1xuICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gIH1cbiAgYXN5bmMgcHVibGlzaChtc2dPclNlcmlhbCwgYW5ub3RhdGlvblZhbHVlcykge1xuICAgIGNvbnN0IGFubm90YXRpb24gPSBjb25zdHJ1Y3RWYWxpZGF0ZUFubm90YXRpb24obXNnT3JTZXJpYWwsIGFubm90YXRpb25WYWx1ZXMpO1xuICAgIGNvbnN0IHdpcmVBbm5vdGF0aW9uID0gYXdhaXQgYW5ub3RhdGlvbi5lbmNvZGUoKTtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNoYW5uZWwuY2xpZW50LCBvcHRpb25zID0gY2xpZW50Lm9wdGlvbnMsIGZvcm1hdCA9IG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFBvc3RIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KSwgcGFyYW1zID0ge307XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgY29uc3QgcmVxdWVzdEJvZHkgPSBlbmNvZGVCb2R5KFt3aXJlQW5ub3RhdGlvbl0sIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnBvc3QoXG4gICAgICBjbGllbnQsXG4gICAgICBiYXNlUGF0aEZvclNlcmlhbCh0aGlzLmNoYW5uZWwsIGFubm90YXRpb24ubWVzc2FnZVNlcmlhbCksXG4gICAgICByZXF1ZXN0Qm9keSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBwYXJhbXMsXG4gICAgICBudWxsLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZGVsZXRlKG1zZ09yU2VyaWFsLCBhbm5vdGF0aW9uVmFsdWVzKSB7XG4gICAgYW5ub3RhdGlvblZhbHVlcy5hY3Rpb24gPSBcImFubm90YXRpb24uZGVsZXRlXCI7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaChtc2dPclNlcmlhbCwgYW5ub3RhdGlvblZhbHVlcyk7XG4gIH1cbiAgYXN5bmMgZ2V0KG1zZ09yU2VyaWFsLCBwYXJhbXMpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNoYW5uZWwuY2xpZW50LCBtZXNzYWdlU2VyaWFsID0gc2VyaWFsRnJvbU1zZ09yU2VyaWFsKG1zZ09yU2VyaWFsKSwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgZW52ZWxvcGUgPSBjbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0LCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgcmV0dXJuIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KFxuICAgICAgY2xpZW50LFxuICAgICAgYmFzZVBhdGhGb3JTZXJpYWwodGhpcy5jaGFubmVsLCBtZXNzYWdlU2VyaWFsKSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBlbnZlbG9wZSxcbiAgICAgIGFzeW5jIChib2R5LCBfLCB1bnBhY2tlZCkgPT4ge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gdW5wYWNrZWQgPyBib2R5IDogZGVjb2RlQm9keShib2R5LCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgICAgIHJldHVybiBfZnJvbUVuY29kZWRBcnJheTMoZGVjb2RlZCwgdGhpcy5jaGFubmVsKTtcbiAgICAgIH1cbiAgICApLmdldChwYXJhbXMpO1xuICB9XG59O1xudmFyIHJlc3Rhbm5vdGF0aW9uc19kZWZhdWx0ID0gUmVzdEFubm90YXRpb25zO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9wcm90b2NvbG1lc3NhZ2UudHNcbnZhciBzZXJpYWxpemUyID0gZW5jb2RlQm9keTtcbmZ1bmN0aW9uIHRvU3RyaW5nQXJyYXkoYXJyYXkpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGlmIChhcnJheSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gXCJbIFwiICsgcmVzdWx0LmpvaW4oXCIsIFwiKSArIFwiIF1cIjtcbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWQsIE1zZ1BhY2ssIHByZXNlbmNlTWVzc2FnZVBsdWdpbiwgYW5ub3RhdGlvbnNQbHVnaW4sIG9iamVjdHNQbHVnaW4sIGZvcm1hdCkge1xuICBjb25zdCBkZXNlcmlhbGl6ZWQgPSBkZWNvZGVCb2R5KHNlcmlhbGl6ZWQsIE1zZ1BhY2ssIGZvcm1hdCk7XG4gIHJldHVybiBmcm9tRGVzZXJpYWxpemVkKGRlc2VyaWFsaXplZCwgcHJlc2VuY2VNZXNzYWdlUGx1Z2luLCBhbm5vdGF0aW9uc1BsdWdpbiwgb2JqZWN0c1BsdWdpbik7XG59XG5mdW5jdGlvbiBmcm9tRGVzZXJpYWxpemVkKGRlc2VyaWFsaXplZCwgcHJlc2VuY2VNZXNzYWdlUGx1Z2luLCBhbm5vdGF0aW9uc1BsdWdpbiwgb2JqZWN0c1BsdWdpbikge1xuICBsZXQgZXJyb3I7XG4gIGlmIChkZXNlcmlhbGl6ZWQuZXJyb3IpIHtcbiAgICBlcnJvciA9IEVycm9ySW5mby5mcm9tVmFsdWVzKGRlc2VyaWFsaXplZC5lcnJvcik7XG4gIH1cbiAgbGV0IG1lc3NhZ2VzO1xuICBpZiAoZGVzZXJpYWxpemVkLm1lc3NhZ2VzKSB7XG4gICAgbWVzc2FnZXMgPSBXaXJlTWVzc2FnZS5mcm9tVmFsdWVzQXJyYXkoZGVzZXJpYWxpemVkLm1lc3NhZ2VzKTtcbiAgfVxuICBsZXQgcHJlc2VuY2U7XG4gIGlmIChwcmVzZW5jZU1lc3NhZ2VQbHVnaW4gJiYgZGVzZXJpYWxpemVkLnByZXNlbmNlKSB7XG4gICAgcHJlc2VuY2UgPSBwcmVzZW5jZU1lc3NhZ2VQbHVnaW4uV2lyZVByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzQXJyYXkoXG4gICAgICBkZXNlcmlhbGl6ZWQucHJlc2VuY2VcbiAgICApO1xuICB9XG4gIGxldCBhbm5vdGF0aW9ucztcbiAgaWYgKGFubm90YXRpb25zUGx1Z2luICYmIGRlc2VyaWFsaXplZC5hbm5vdGF0aW9ucykge1xuICAgIGFubm90YXRpb25zID0gYW5ub3RhdGlvbnNQbHVnaW4uV2lyZUFubm90YXRpb24uZnJvbVZhbHVlc0FycmF5KFxuICAgICAgZGVzZXJpYWxpemVkLmFubm90YXRpb25zXG4gICAgKTtcbiAgfVxuICBsZXQgc3RhdGU7XG4gIGlmIChvYmplY3RzUGx1Z2luICYmIGRlc2VyaWFsaXplZC5zdGF0ZSkge1xuICAgIHN0YXRlID0gb2JqZWN0c1BsdWdpbi5XaXJlT2JqZWN0TWVzc2FnZS5mcm9tVmFsdWVzQXJyYXkoXG4gICAgICBkZXNlcmlhbGl6ZWQuc3RhdGUsXG4gICAgICB1dGlsc19leHBvcnRzLFxuICAgICAgTWVzc2FnZUVuY29kaW5nXG4gICAgKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgUHJvdG9jb2xNZXNzYWdlKCksIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGRlc2VyaWFsaXplZCksIHsgcHJlc2VuY2UsIG1lc3NhZ2VzLCBhbm5vdGF0aW9ucywgc3RhdGUsIGVycm9yIH0pKTtcbn1cbmZ1bmN0aW9uIG1ha2VGcm9tRGVzZXJpYWxpemVkV2l0aERlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpIHtcbiAgcmV0dXJuIChkZXNlcmlhbGl6ZWQpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIHJldHVybiBmcm9tRGVzZXJpYWxpemVkKFxuICAgICAgZGVzZXJpYWxpemVkLFxuICAgICAge1xuICAgICAgICBQcmVzZW5jZU1lc3NhZ2U6IHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0LFxuICAgICAgICBXaXJlUHJlc2VuY2VNZXNzYWdlXG4gICAgICB9LFxuICAgICAgeyBBbm5vdGF0aW9uOiBhbm5vdGF0aW9uX2RlZmF1bHQsIFdpcmVBbm5vdGF0aW9uLCBSZWFsdGltZUFubm90YXRpb25zOiByZWFsdGltZWFubm90YXRpb25zX2RlZmF1bHQsIFJlc3RBbm5vdGF0aW9uczogcmVzdGFubm90YXRpb25zX2RlZmF1bHQgfSxcbiAgICAgIChfYTIgPSBkZXBlbmRlbmNpZXMgPT0gbnVsbCA/IHZvaWQgMCA6IGRlcGVuZGVuY2llcy5PYmplY3RzUGx1Z2luKSAhPSBudWxsID8gX2EyIDogbnVsbFxuICAgICk7XG4gIH07XG59XG5mdW5jdGlvbiBmcm9tVmFsdWVzKHZhbHVlcykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgUHJvdG9jb2xNZXNzYWdlKCksIHZhbHVlcyk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkobXNnLCBwcmVzZW5jZU1lc3NhZ2VQbHVnaW4sIGFubm90YXRpb25zUGx1Z2luLCBvYmplY3RzUGx1Z2luKSB7XG4gIGxldCByZXN1bHQgPSBcIltQcm90b2NvbE1lc3NhZ2VcIjtcbiAgaWYgKG1zZy5hY3Rpb24gIT09IHZvaWQgMClcbiAgICByZXN1bHQgKz0gXCI7IGFjdGlvbj1cIiArIEFjdGlvbk5hbWVbbXNnLmFjdGlvbl0gfHwgbXNnLmFjdGlvbjtcbiAgY29uc3Qgc2ltcGxlQXR0cmlidXRlcyA9IFtcImlkXCIsIFwiY2hhbm5lbFwiLCBcImNoYW5uZWxTZXJpYWxcIiwgXCJjb25uZWN0aW9uSWRcIiwgXCJjb3VudFwiLCBcIm1zZ1NlcmlhbFwiLCBcInRpbWVzdGFtcFwiXTtcbiAgbGV0IGF0dHJpYnV0ZTtcbiAgZm9yIChsZXQgYXR0cmliSW5kZXggPSAwOyBhdHRyaWJJbmRleCA8IHNpbXBsZUF0dHJpYnV0ZXMubGVuZ3RoOyBhdHRyaWJJbmRleCsrKSB7XG4gICAgYXR0cmlidXRlID0gc2ltcGxlQXR0cmlidXRlc1thdHRyaWJJbmRleF07XG4gICAgaWYgKG1zZ1thdHRyaWJ1dGVdICE9PSB2b2lkIDApXG4gICAgICByZXN1bHQgKz0gXCI7IFwiICsgYXR0cmlidXRlICsgXCI9XCIgKyBtc2dbYXR0cmlidXRlXTtcbiAgfVxuICBpZiAobXNnLm1lc3NhZ2VzKVxuICAgIHJlc3VsdCArPSBcIjsgbWVzc2FnZXM9XCIgKyB0b1N0cmluZ0FycmF5KFdpcmVNZXNzYWdlLmZyb21WYWx1ZXNBcnJheShtc2cubWVzc2FnZXMpKTtcbiAgaWYgKG1zZy5wcmVzZW5jZSAmJiBwcmVzZW5jZU1lc3NhZ2VQbHVnaW4pXG4gICAgcmVzdWx0ICs9IFwiOyBwcmVzZW5jZT1cIiArIHRvU3RyaW5nQXJyYXkocHJlc2VuY2VNZXNzYWdlUGx1Z2luLldpcmVQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlc0FycmF5KG1zZy5wcmVzZW5jZSkpO1xuICBpZiAobXNnLmFubm90YXRpb25zICYmIGFubm90YXRpb25zUGx1Z2luKSB7XG4gICAgcmVzdWx0ICs9IFwiOyBhbm5vdGF0aW9ucz1cIiArIHRvU3RyaW5nQXJyYXkoYW5ub3RhdGlvbnNQbHVnaW4uV2lyZUFubm90YXRpb24uZnJvbVZhbHVlc0FycmF5KG1zZy5hbm5vdGF0aW9ucykpO1xuICB9XG4gIGlmIChtc2cuc3RhdGUgJiYgb2JqZWN0c1BsdWdpbikge1xuICAgIHJlc3VsdCArPSBcIjsgc3RhdGU9XCIgKyB0b1N0cmluZ0FycmF5KG9iamVjdHNQbHVnaW4uV2lyZU9iamVjdE1lc3NhZ2UuZnJvbVZhbHVlc0FycmF5KG1zZy5zdGF0ZSwgdXRpbHNfZXhwb3J0cywgTWVzc2FnZUVuY29kaW5nKSk7XG4gIH1cbiAgaWYgKG1zZy5lcnJvcilcbiAgICByZXN1bHQgKz0gXCI7IGVycm9yPVwiICsgRXJyb3JJbmZvLmZyb21WYWx1ZXMobXNnLmVycm9yKS50b1N0cmluZygpO1xuICBpZiAobXNnLmF1dGggJiYgbXNnLmF1dGguYWNjZXNzVG9rZW4pXG4gICAgcmVzdWx0ICs9IFwiOyB0b2tlbj1cIiArIG1zZy5hdXRoLmFjY2Vzc1Rva2VuO1xuICBpZiAobXNnLmZsYWdzKVxuICAgIHJlc3VsdCArPSBcIjsgZmxhZ3M9XCIgKyBmbGFnTmFtZXMuZmlsdGVyKG1zZy5oYXNGbGFnKS5qb2luKFwiLFwiKTtcbiAgaWYgKG1zZy5wYXJhbXMpIHtcbiAgICBsZXQgc3RyaW5naWZpZWRQYXJhbXMgPSBcIlwiO1xuICAgIGZvckluT3duTm9uTnVsbFByb3BlcnRpZXMobXNnLnBhcmFtcywgZnVuY3Rpb24ocHJvcCkge1xuICAgICAgaWYgKHN0cmluZ2lmaWVkUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RyaW5naWZpZWRQYXJhbXMgKz0gXCI7IFwiO1xuICAgICAgfVxuICAgICAgc3RyaW5naWZpZWRQYXJhbXMgKz0gcHJvcCArIFwiPVwiICsgbXNnLnBhcmFtc1twcm9wXTtcbiAgICB9KTtcbiAgICBpZiAoc3RyaW5naWZpZWRQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0ICs9IFwiOyBwYXJhbXM9W1wiICsgc3RyaW5naWZpZWRQYXJhbXMgKyBcIl1cIjtcbiAgICB9XG4gIH1cbiAgcmVzdWx0ICs9IFwiXVwiO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIFByb3RvY29sTWVzc2FnZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5oYXNGbGFnID0gKGZsYWcpID0+IHtcbiAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIGZsYWdzW2ZsYWddKSA+IDA7XG4gICAgfTtcbiAgfVxuICBzZXRGbGFnKGZsYWcpIHtcbiAgICByZXR1cm4gdGhpcy5mbGFncyA9IHRoaXMuZmxhZ3MgfCBmbGFnc1tmbGFnXTtcbiAgfVxuICBnZXRNb2RlKCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyB8fCAwKSAmIGZsYWdzLk1PREVfQUxMO1xuICB9XG4gIGVuY29kZU1vZGVzVG9GbGFncyhtb2Rlcykge1xuICAgIG1vZGVzLmZvckVhY2goKG1vZGUpID0+IHRoaXMuc2V0RmxhZyhtb2RlKSk7XG4gIH1cbiAgZGVjb2RlTW9kZXNGcm9tRmxhZ3MoKSB7XG4gICAgY29uc3QgbW9kZXMgPSBbXTtcbiAgICBjaGFubmVsTW9kZXMuZm9yRWFjaCgobW9kZSkgPT4ge1xuICAgICAgaWYgKHRoaXMuaGFzRmxhZyhtb2RlKSkge1xuICAgICAgICBtb2Rlcy5wdXNoKG1vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtb2Rlcy5sZW5ndGggPiAwID8gbW9kZXMgOiB2b2lkIDA7XG4gIH1cbn07XG52YXIgcHJvdG9jb2xtZXNzYWdlX2RlZmF1bHQgPSBQcm90b2NvbE1lc3NhZ2U7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9jaGFubmVsc3RhdGVjaGFuZ2UudHNcbnZhciBDaGFubmVsU3RhdGVDaGFuZ2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHByZXZpb3VzLCBjdXJyZW50LCByZXN1bWVkLCBoYXNCYWNrbG9nLCByZWFzb24pIHtcbiAgICB0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbiAgICBpZiAoY3VycmVudCA9PT0gXCJhdHRhY2hlZFwiKSB7XG4gICAgICB0aGlzLnJlc3VtZWQgPSByZXN1bWVkO1xuICAgICAgdGhpcy5oYXNCYWNrbG9nID0gaGFzQmFja2xvZztcbiAgICB9XG4gICAgaWYgKHJlYXNvbilcbiAgICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICB9XG59O1xudmFyIGNoYW5uZWxzdGF0ZWNoYW5nZV9kZWZhdWx0ID0gQ2hhbm5lbFN0YXRlQ2hhbmdlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVhbHRpbWVjaGFubmVsLnRzXG52YXIgbm9vcCA9IGZ1bmN0aW9uKCkge1xufTtcbmZ1bmN0aW9uIHZhbGlkYXRlQ2hhbm5lbE9wdGlvbnMob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAmJiBcInBhcmFtc1wiIGluIG9wdGlvbnMgJiYgIWlzT2JqZWN0KG9wdGlvbnMucGFyYW1zKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3JJbmZvKFwib3B0aW9ucy5wYXJhbXMgbXVzdCBiZSBhbiBvYmplY3RcIiwgNGU0LCA0MDApO1xuICB9XG4gIGlmIChvcHRpb25zICYmIFwibW9kZXNcIiBpbiBvcHRpb25zKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMubW9kZXMpKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9ySW5mbyhcIm9wdGlvbnMubW9kZXMgbXVzdCBiZSBhbiBhcnJheVwiLCA0ZTQsIDQwMCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5tb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY3VycmVudE1vZGUgPSBvcHRpb25zLm1vZGVzW2ldO1xuICAgICAgaWYgKCFjdXJyZW50TW9kZSB8fCB0eXBlb2YgY3VycmVudE1vZGUgIT09IFwic3RyaW5nXCIgfHwgIWNoYW5uZWxNb2Rlcy5pbmNsdWRlcyhTdHJpbmcucHJvdG90eXBlLnRvVXBwZXJDYXNlLmNhbGwoY3VycmVudE1vZGUpKSkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9ySW5mbyhcIkludmFsaWQgY2hhbm5lbCBtb2RlOiBcIiArIGN1cnJlbnRNb2RlLCA0ZTQsIDQwMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG52YXIgUmVhbHRpbWVDaGFubmVsID0gY2xhc3MgX1JlYWx0aW1lQ2hhbm5lbCBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBuYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hMiwgX2IsIF9jO1xuICAgIHN1cGVyKGNsaWVudC5sb2dnZXIpO1xuICAgIHRoaXMuX2Fubm90YXRpb25zID0gbnVsbDtcbiAgICB0aGlzLl9tb2RlID0gMDtcbiAgICB0aGlzLnJldHJ5Q291bnQgPSAwO1xuICAgIHRoaXMuaGlzdG9yeSA9IGFzeW5jIGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVhbHRpbWVDaGFubmVsLmhpc3RvcnkoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMubmFtZSk7XG4gICAgICBjb25zdCByZXN0TWl4aW4gPSB0aGlzLmNsaWVudC5yZXN0LmNoYW5uZWxNaXhpbjtcbiAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLnVudGlsQXR0YWNoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwib3B0aW9uIHVudGlsQXR0YWNoIHJlcXVpcmVzIHRoZSBjaGFubmVsIHRvIGJlIGF0dGFjaGVkXCIsIDRlNCwgNDAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucHJvcGVydGllcy5hdHRhY2hTZXJpYWwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgICAgXCJ1bnRpbEF0dGFjaCB3YXMgc3BlY2lmaWVkIGFuZCBjaGFubmVsIGlzIGF0dGFjaGVkLCBidXQgYXR0YWNoU2VyaWFsIGlzIG5vdCBkZWZpbmVkXCIsXG4gICAgICAgICAgICA0ZTQsXG4gICAgICAgICAgICA0MDBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBwYXJhbXMudW50aWxBdHRhY2g7XG4gICAgICAgIHBhcmFtcy5mcm9tX3NlcmlhbCA9IHRoaXMucHJvcGVydGllcy5hdHRhY2hTZXJpYWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdE1peGluLmhpc3RvcnkodGhpcywgcGFyYW1zKTtcbiAgICB9O1xuICAgIHRoaXMud2hlblN0YXRlID0gKHN0YXRlKSA9PiB7XG4gICAgICByZXR1cm4gZXZlbnRlbWl0dGVyX2RlZmF1bHQucHJvdG90eXBlLndoZW5TdGF0ZS5jYWxsKHRoaXMsIHN0YXRlLCB0aGlzLnN0YXRlKTtcbiAgICB9O1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlJlYWx0aW1lQ2hhbm5lbCgpXCIsIFwic3RhcnRlZDsgbmFtZSA9IFwiICsgbmFtZSk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmNoYW5uZWxPcHRpb25zID0gbm9ybWFsaXNlQ2hhbm5lbE9wdGlvbnMoKF9hMiA9IGNsaWVudC5fQ3J5cHRvKSAhPSBudWxsID8gX2EyIDogbnVsbCwgdGhpcy5sb2dnZXIsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuX3ByZXNlbmNlID0gY2xpZW50Ll9SZWFsdGltZVByZXNlbmNlID8gbmV3IGNsaWVudC5fUmVhbHRpbWVQcmVzZW5jZS5SZWFsdGltZVByZXNlbmNlKHRoaXMpIDogbnVsbDtcbiAgICBpZiAoY2xpZW50Ll9Bbm5vdGF0aW9ucykge1xuICAgICAgdGhpcy5fYW5ub3RhdGlvbnMgPSBuZXcgY2xpZW50Ll9Bbm5vdGF0aW9ucy5SZWFsdGltZUFubm90YXRpb25zKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gY2xpZW50LmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgdGhpcy5zdGF0ZSA9IFwiaW5pdGlhbGl6ZWRcIjtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgZXZlbnRlbWl0dGVyX2RlZmF1bHQodGhpcy5sb2dnZXIpO1xuICAgIHRoaXMuc3luY0NoYW5uZWxTZXJpYWwgPSB2b2lkIDA7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xuICAgICAgYXR0YWNoU2VyaWFsOiB2b2lkIDAsXG4gICAgICBjaGFubmVsU2VyaWFsOiB2b2lkIDBcbiAgICB9O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLmVycm9yUmVhc29uID0gbnVsbDtcbiAgICB0aGlzLl9hdHRhY2hSZXN1bWUgPSBmYWxzZTtcbiAgICB0aGlzLl9kZWNvZGluZ0NvbnRleHQgPSB7XG4gICAgICBjaGFubmVsT3B0aW9uczogdGhpcy5jaGFubmVsT3B0aW9ucyxcbiAgICAgIHBsdWdpbnM6IGNsaWVudC5vcHRpb25zLnBsdWdpbnMgfHwge30sXG4gICAgICBiYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZDogdm9pZCAwXG4gICAgfTtcbiAgICB0aGlzLl9sYXN0UGF5bG9hZCA9IHtcbiAgICAgIG1lc3NhZ2VJZDogbnVsbCxcbiAgICAgIHByb3RvY29sTWVzc2FnZUNoYW5uZWxTZXJpYWw6IG51bGwsXG4gICAgICBkZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzOiBudWxsXG4gICAgfTtcbiAgICB0aGlzLl9hbGxDaGFubmVsQ2hhbmdlcyA9IG5ldyBldmVudGVtaXR0ZXJfZGVmYXVsdCh0aGlzLmxvZ2dlcik7XG4gICAgaWYgKChfYiA9IGNsaWVudC5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5QdXNoKSB7XG4gICAgICB0aGlzLl9wdXNoID0gbmV3IGNsaWVudC5vcHRpb25zLnBsdWdpbnMuUHVzaC5QdXNoQ2hhbm5lbCh0aGlzKTtcbiAgICB9XG4gICAgaWYgKChfYyA9IGNsaWVudC5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYy5PYmplY3RzKSB7XG4gICAgICB0aGlzLl9vYmplY3RzID0gbmV3IGNsaWVudC5vcHRpb25zLnBsdWdpbnMuT2JqZWN0cy5PYmplY3RzKHRoaXMpO1xuICAgIH1cbiAgfVxuICBnZXQgcHJlc2VuY2UoKSB7XG4gICAgaWYgKCF0aGlzLl9wcmVzZW5jZSkge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJSZWFsdGltZVByZXNlbmNlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHJlc2VuY2U7XG4gIH1cbiAgZ2V0IGFubm90YXRpb25zKCkge1xuICAgIGlmICghdGhpcy5fYW5ub3RhdGlvbnMpIHtcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiQW5ub3RhdGlvbnNcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hbm5vdGF0aW9ucztcbiAgfVxuICBnZXQgcHVzaCgpIHtcbiAgICBpZiAoIXRoaXMuX3B1c2gpIHtcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiUHVzaFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3B1c2g7XG4gIH1cbiAgLyoqIEBzcGVjIFJUTDI3ICovXG4gIGdldCBvYmplY3RzKCkge1xuICAgIGlmICghdGhpcy5fb2JqZWN0cykge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJPYmplY3RzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0cztcbiAgfVxuICBpbnZhbGlkU3RhdGVFcnJvcigpIHtcbiAgICByZXR1cm4gbmV3IEVycm9ySW5mbyhcbiAgICAgIFwiQ2hhbm5lbCBvcGVyYXRpb24gZmFpbGVkIGFzIGNoYW5uZWwgc3RhdGUgaXMgXCIgKyB0aGlzLnN0YXRlLFxuICAgICAgOTAwMDEsXG4gICAgICA0MDAsXG4gICAgICB0aGlzLmVycm9yUmVhc29uIHx8IHZvaWQgMFxuICAgICk7XG4gIH1cbiAgc3RhdGljIHByb2Nlc3NMaXN0ZW5lckFyZ3MoYXJncykge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgYXJncy51bnNoaWZ0KG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gYXJncztcbiAgfVxuICBhc3luYyBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyO1xuICAgIGNvbnN0IHByZXZpb3VzQ2hhbm5lbE9wdGlvbnMgPSB0aGlzLmNoYW5uZWxPcHRpb25zO1xuICAgIGNvbnN0IGVyciA9IHZhbGlkYXRlQ2hhbm5lbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgaWYgKGVycikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICB0aGlzLmNoYW5uZWxPcHRpb25zID0gbm9ybWFsaXNlQ2hhbm5lbE9wdGlvbnMoKF9hMiA9IHRoaXMuY2xpZW50Ll9DcnlwdG8pICE9IG51bGwgPyBfYTIgOiBudWxsLCB0aGlzLmxvZ2dlciwgb3B0aW9ucyk7XG4gICAgaWYgKHRoaXMuX2RlY29kaW5nQ29udGV4dClcbiAgICAgIHRoaXMuX2RlY29kaW5nQ29udGV4dC5jaGFubmVsT3B0aW9ucyA9IHRoaXMuY2hhbm5lbE9wdGlvbnM7XG4gICAgaWYgKHRoaXMuX3Nob3VsZFJlYXR0YWNoVG9TZXRPcHRpb25zKG9wdGlvbnMsIHByZXZpb3VzQ2hhbm5lbE9wdGlvbnMpKSB7XG4gICAgICB0aGlzLmF0dGFjaEltcGwoKTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLm9uY2UoXG4gICAgICAgICAgW1wiYXR0YWNoZWRcIiwgXCJ1cGRhdGVcIiwgXCJkZXRhY2hlZFwiLCBcImZhaWxlZFwiXSxcbiAgICAgICAgICBmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmV2ZW50KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ1cGRhdGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImF0dGFjaGVkXCI6XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlamVjdChzdGF0ZUNoYW5nZS5yZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfc2hvdWxkUmVhdHRhY2hUb1NldE9wdGlvbnMob3B0aW9ucywgcHJldk9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzLnN0YXRlID09PSBcImF0dGFjaGVkXCIgfHwgdGhpcy5zdGF0ZSA9PT0gXCJhdHRhY2hpbmdcIikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zKSB7XG4gICAgICBjb25zdCByZXF1ZXN0ZWRQYXJhbXMgPSBvbWl0QWdlbnQob3B0aW9ucy5wYXJhbXMpO1xuICAgICAgY29uc3QgZXhpc3RpbmdQYXJhbXMgPSBvbWl0QWdlbnQocHJldk9wdGlvbnMucGFyYW1zKTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhyZXF1ZXN0ZWRQYXJhbXMpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoZXhpc3RpbmdQYXJhbXMpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghc2hhbGxvd0VxdWFscyhleGlzdGluZ1BhcmFtcywgcmVxdWVzdGVkUGFyYW1zKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kZXMpIHtcbiAgICAgIGlmICghcHJldk9wdGlvbnMubW9kZXMgfHwgIWFyckVxdWFscyhvcHRpb25zLm1vZGVzLCBwcmV2T3B0aW9ucy5tb2RlcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKC4uLmFyZ3MpIHtcbiAgICBsZXQgbWVzc2FnZXM7XG4gICAgbGV0IGFyZ0NvdW50ID0gYXJncy5sZW5ndGg7XG4gICAgaWYgKGFyZ0NvdW50ID09IDEpIHtcbiAgICAgIGlmIChpc09iamVjdChhcmdzWzBdKSkge1xuICAgICAgICBtZXNzYWdlcyA9IFttZXNzYWdlX2RlZmF1bHQuZnJvbVZhbHVlcyhhcmdzWzBdKV07XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgbWVzc2FnZXMgPSBtZXNzYWdlX2RlZmF1bHQuZnJvbVZhbHVlc0FycmF5KGFyZ3NbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICBcIlRoZSBzaW5nbGUtYXJndW1lbnQgZm9ybSBvZiBwdWJsaXNoKCkgZXhwZWN0cyBhIG1lc3NhZ2Ugb2JqZWN0IG9yIGFuIGFycmF5IG9mIG1lc3NhZ2Ugb2JqZWN0c1wiLFxuICAgICAgICAgIDQwMDEzLFxuICAgICAgICAgIDQwMFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlcyA9IFttZXNzYWdlX2RlZmF1bHQuZnJvbVZhbHVlcyh7IG5hbWU6IGFyZ3NbMF0sIGRhdGE6IGFyZ3NbMV0gfSldO1xuICAgIH1cbiAgICBjb25zdCBtYXhNZXNzYWdlU2l6ZSA9IHRoaXMuY2xpZW50Lm9wdGlvbnMubWF4TWVzc2FnZVNpemU7XG4gICAgY29uc3Qgd2lyZU1lc3NhZ2VzID0gYXdhaXQgZW5jb2RlQXJyYXkobWVzc2FnZXMsIHRoaXMuY2hhbm5lbE9wdGlvbnMpO1xuICAgIGNvbnN0IHNpemUgPSBnZXRNZXNzYWdlc1NpemUod2lyZU1lc3NhZ2VzKTtcbiAgICBpZiAoc2l6ZSA+IG1heE1lc3NhZ2VTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICBgTWF4aW11bSBzaXplIG9mIG1lc3NhZ2VzIHRoYXQgY2FuIGJlIHB1Ymxpc2hlZCBhdCBvbmNlIGV4Y2VlZGVkICh3YXMgJHtzaXplfSBieXRlczsgbGltaXQgaXMgJHttYXhNZXNzYWdlU2l6ZX0gYnl0ZXMpYCxcbiAgICAgICAgNDAwMDksXG4gICAgICAgIDQwMFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy50aHJvd0lmVW5wdWJsaXNoYWJsZVN0YXRlKCk7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5wdWJsaXNoKClcIixcbiAgICAgIFwic2VuZGluZyBtZXNzYWdlOyBjaGFubmVsIHN0YXRlIGlzIFwiICsgdGhpcy5zdGF0ZSArIFwiLCBtZXNzYWdlIGNvdW50ID0gXCIgKyB3aXJlTWVzc2FnZXMubGVuZ3RoXG4gICAgKTtcbiAgICBjb25zdCBwbSA9IGZyb21WYWx1ZXMoeyBhY3Rpb246IGFjdGlvbnMuTUVTU0FHRSwgY2hhbm5lbDogdGhpcy5uYW1lLCBtZXNzYWdlczogd2lyZU1lc3NhZ2VzIH0pO1xuICAgIHJldHVybiB0aGlzLnNlbmRNZXNzYWdlKHBtKTtcbiAgfVxuICB0aHJvd0lmVW5wdWJsaXNoYWJsZVN0YXRlKCkge1xuICAgIGlmICghdGhpcy5jb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG4gICAgICB0aHJvdyB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlID09PSBcImZhaWxlZFwiIHx8IHRoaXMuc3RhdGUgPT09IFwic3VzcGVuZGVkXCIpIHtcbiAgICAgIHRocm93IHRoaXMuaW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICB9XG4gIH1cbiAgb25FdmVudChtZXNzYWdlcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlYWx0aW1lQ2hhbm5lbC5vbkV2ZW50KClcIiwgXCJyZWNlaXZlZCBtZXNzYWdlXCIpO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VzW2ldO1xuICAgICAgc3Vic2NyaXB0aW9ucy5lbWl0KG1lc3NhZ2UubmFtZSwgbWVzc2FnZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGF0dGFjaCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJhdHRhY2hlZFwiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX2F0dGFjaChmYWxzZSwgbnVsbCwgKGVyciwgcmVzdWx0KSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVzdWx0KSk7XG4gICAgfSk7XG4gIH1cbiAgX2F0dGFjaChmb3JjZVJlYXR0YWNoLCBhdHRhY2hSZWFzb24sIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sgPSAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICAgIFwiUmVhbHRpbWVDaGFubmVsLl9hdHRhY2goKVwiLFxuICAgICAgICAgICAgXCJDaGFubmVsIGF0dGFjaCBmYWlsZWQ6IFwiICsgZXJyLnRvU3RyaW5nKClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBjb25uZWN0aW9uTWFuYWdlciA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgaWYgKCFjb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG4gICAgICBjYWxsYmFjayhjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFwiYXR0YWNoaW5nXCIgfHwgZm9yY2VSZWF0dGFjaCkge1xuICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoXCJhdHRhY2hpbmdcIiwgYXR0YWNoUmVhc29uKTtcbiAgICB9XG4gICAgdGhpcy5vbmNlKGZ1bmN0aW9uKHN0YXRlQ2hhbmdlKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuZXZlbnQpIHtcbiAgICAgICAgY2FzZSBcImF0dGFjaGVkXCI6XG4gICAgICAgICAgY2FsbGJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrKG51bGwsIHN0YXRlQ2hhbmdlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRldGFjaGVkXCI6XG4gICAgICAgIGNhc2UgXCJzdXNwZW5kZWRcIjpcbiAgICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgICAgIGNhbGxiYWNrID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFjayhcbiAgICAgICAgICAgIHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCBjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpIHx8IG5ldyBFcnJvckluZm8oXCJVbmFibGUgdG8gYXR0YWNoOyByZWFzb24gdW5rbm93bjsgc3RhdGUgPSBcIiArIHRoaXMuZXZlbnQsIDllNCwgNTAwKVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZXRhY2hpbmdcIjpcbiAgICAgICAgICBjYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2sobmV3IEVycm9ySW5mbyhcIkF0dGFjaCByZXF1ZXN0IHN1cGVyc2VkZWQgYnkgYSBzdWJzZXF1ZW50IGRldGFjaCByZXF1ZXN0XCIsIDllNCwgNDA5KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXR0YWNoSW1wbCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZWFsdGltZUNoYW5uZWwuYXR0YWNoSW1wbCgpXCIsIFwic2VuZGluZyBBVFRBQ0ggbWVzc2FnZVwiKTtcbiAgICBjb25zdCBhdHRhY2hNc2cgPSBmcm9tVmFsdWVzKHtcbiAgICAgIGFjdGlvbjogYWN0aW9ucy5BVFRBQ0gsXG4gICAgICBjaGFubmVsOiB0aGlzLm5hbWUsXG4gICAgICBwYXJhbXM6IHRoaXMuY2hhbm5lbE9wdGlvbnMucGFyYW1zLFxuICAgICAgLy8gUlRMNGMxOiBJbmNsdWRlcyB0aGUgY2hhbm5lbCBzZXJpYWwgdG8gcmVzdW1lIGZyb20gYSBwcmV2aW91cyBtZXNzYWdlXG4gICAgICAvLyBvciBhdHRhY2htZW50LlxuICAgICAgY2hhbm5lbFNlcmlhbDogdGhpcy5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWxcbiAgICB9KTtcbiAgICBpZiAodGhpcy5jaGFubmVsT3B0aW9ucy5tb2Rlcykge1xuICAgICAgYXR0YWNoTXNnLmVuY29kZU1vZGVzVG9GbGFncyhhbGxUb1VwcGVyQ2FzZSh0aGlzLmNoYW5uZWxPcHRpb25zLm1vZGVzKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9hdHRhY2hSZXN1bWUpIHtcbiAgICAgIGF0dGFjaE1zZy5zZXRGbGFnKFwiQVRUQUNIX1JFU1VNRVwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MpIHtcbiAgICAgIGF0dGFjaE1zZy5jaGFubmVsU2VyaWFsID0gdGhpcy5fbGFzdFBheWxvYWQucHJvdG9jb2xNZXNzYWdlQ2hhbm5lbFNlcmlhbDtcbiAgICB9XG4gICAgdGhpcy5zZW5kTWVzc2FnZShhdHRhY2hNc2cpLmNhdGNoKG5vb3ApO1xuICB9XG4gIGFzeW5jIGRldGFjaCgpIHtcbiAgICBjb25zdCBjb25uZWN0aW9uTWFuYWdlciA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgaWYgKCFjb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG4gICAgICB0aHJvdyBjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJzdXNwZW5kZWRcIjpcbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShcImRldGFjaGVkXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiZGV0YWNoZWRcIjpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGRldGFjaDsgY2hhbm5lbCBzdGF0ZSA9IGZhaWxlZFwiLCA5MDAwMSwgNDAwKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKFwiZGV0YWNoaW5nXCIpO1xuICAgICAgY2FzZSBcImRldGFjaGluZ1wiOlxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHRoaXMub25jZShmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmV2ZW50KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJkZXRhY2hlZFwiOlxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImF0dGFjaGVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzdXNwZW5kZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICAgIHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCBjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpIHx8IG5ldyBFcnJvckluZm8oXCJVbmFibGUgdG8gZGV0YWNoOyByZWFzb24gdW5rbm93bjsgc3RhdGUgPSBcIiArIHRoaXMuZXZlbnQsIDllNCwgNTAwKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJhdHRhY2hpbmdcIjpcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhcIkRldGFjaCByZXF1ZXN0IHN1cGVyc2VkZWQgYnkgYSBzdWJzZXF1ZW50IGF0dGFjaCByZXF1ZXN0XCIsIDllNCwgNDA5KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBkZXRhY2hJbXBsKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlYWx0aW1lQ2hhbm5lbC5kZXRhY2goKVwiLCBcInNlbmRpbmcgREVUQUNIIG1lc3NhZ2VcIik7XG4gICAgY29uc3QgbXNnID0gZnJvbVZhbHVlcyh7IGFjdGlvbjogYWN0aW9ucy5ERVRBQ0gsIGNoYW5uZWw6IHRoaXMubmFtZSB9KTtcbiAgICB0aGlzLnNlbmRNZXNzYWdlKG1zZykuY2F0Y2gobm9vcCk7XG4gIH1cbiAgYXN5bmMgc3Vic2NyaWJlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBbZXZlbnQsIGxpc3RlbmVyXSA9IF9SZWFsdGltZUNoYW5uZWwucHJvY2Vzc0xpc3RlbmVyQXJncyhhcmdzKTtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJmYWlsZWRcIikge1xuICAgICAgdGhyb3cgRXJyb3JJbmZvLmZyb21WYWx1ZXModGhpcy5pbnZhbGlkU3RhdGVFcnJvcigpKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50ICYmIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIHRoaXMuY2xpZW50Ll9GaWx0ZXJlZFN1YnNjcmlwdGlvbnMuc3Vic2NyaWJlRmlsdGVyKHRoaXMsIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jaGFubmVsT3B0aW9ucy5hdHRhY2hPblN1YnNjcmliZSAhPT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dGFjaCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgdW5zdWJzY3JpYmUoLi4uYXJncykge1xuICAgIHZhciBfYTI7XG4gICAgY29uc3QgW2V2ZW50LCBsaXN0ZW5lcl0gPSBfUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NMaXN0ZW5lckFyZ3MoYXJncyk7XG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiAhbGlzdGVuZXIgfHwgKChfYTIgPSB0aGlzLmZpbHRlcmVkU3Vic2NyaXB0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5oYXMobGlzdGVuZXIpKSkge1xuICAgICAgdGhpcy5jbGllbnQuX0ZpbHRlcmVkU3Vic2NyaXB0aW9ucy5nZXRBbmREZWxldGVGaWx0ZXJlZFN1YnNjcmlwdGlvbnModGhpcywgZXZlbnQsIGxpc3RlbmVyKS5mb3JFYWNoKChsKSA9PiB0aGlzLnN1YnNjcmlwdGlvbnMub2ZmKGwpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICB9XG4gIHN5bmMoKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFwiaW5pdGlhbGl6ZWRcIjpcbiAgICAgIGNhc2UgXCJkZXRhY2hpbmdcIjpcbiAgICAgIGNhc2UgXCJkZXRhY2hlZFwiOlxuICAgICAgICB0aHJvdyBuZXcgUGFydGlhbEVycm9ySW5mbyhcIlVuYWJsZSB0byBzeW5jIHRvIGNoYW5uZWw7IG5vdCBhdHRhY2hlZFwiLCA0ZTQpO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gICAgY29uc3QgY29ubmVjdGlvbk1hbmFnZXIgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyO1xuICAgIGlmICghY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuICAgICAgdGhyb3cgY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKTtcbiAgICB9XG4gICAgY29uc3Qgc3luY01lc3NhZ2UgPSBmcm9tVmFsdWVzKHsgYWN0aW9uOiBhY3Rpb25zLlNZTkMsIGNoYW5uZWw6IHRoaXMubmFtZSB9KTtcbiAgICBpZiAodGhpcy5zeW5jQ2hhbm5lbFNlcmlhbCkge1xuICAgICAgc3luY01lc3NhZ2UuY2hhbm5lbFNlcmlhbCA9IHRoaXMuc3luY0NoYW5uZWxTZXJpYWw7XG4gICAgfVxuICAgIGNvbm5lY3Rpb25NYW5hZ2VyLnNlbmQoc3luY01lc3NhZ2UpO1xuICB9XG4gIGFzeW5jIHNlbmRNZXNzYWdlKG1zZykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnNlbmQobXNnLCB0aGlzLmNsaWVudC5vcHRpb25zLnF1ZXVlTWVzc2FnZXMsIChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgc2VuZFByZXNlbmNlKHByZXNlbmNlKSB7XG4gICAgY29uc3QgbXNnID0gZnJvbVZhbHVlcyh7XG4gICAgICBhY3Rpb246IGFjdGlvbnMuUFJFU0VOQ0UsXG4gICAgICBjaGFubmVsOiB0aGlzLm5hbWUsXG4gICAgICBwcmVzZW5jZVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnNlbmRNZXNzYWdlKG1zZyk7XG4gIH1cbiAgc2VuZFN0YXRlKG9iamVjdE1lc3NhZ2VzKSB7XG4gICAgY29uc3QgbXNnID0gZnJvbVZhbHVlcyh7XG4gICAgICBhY3Rpb246IGFjdGlvbnMuT0JKRUNULFxuICAgICAgY2hhbm5lbDogdGhpcy5uYW1lLFxuICAgICAgc3RhdGU6IG9iamVjdE1lc3NhZ2VzXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuc2VuZE1lc3NhZ2UobXNnKTtcbiAgfVxuICAvLyBBY2Nlc3MgdG8gdGhpcyBtZXRob2QgaXMgc3luY2hyb25pc2VkIGJ5IENvbm5lY3Rpb25NYW5hZ2VyI3Byb2Nlc3NDaGFubmVsTWVzc2FnZSwgaW4gb3JkZXIgdG8gc3luY2hyb25pc2UgYWNjZXNzIHRvIHRoZSBzdGF0ZSBzdG9yZWQgaW4gX2RlY29kaW5nQ29udGV4dC5cbiAgYXN5bmMgcHJvY2Vzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlLmFjdGlvbiA9PT0gYWN0aW9ucy5BVFRBQ0hFRCB8fCBtZXNzYWdlLmFjdGlvbiA9PT0gYWN0aW9ucy5NRVNTQUdFIHx8IG1lc3NhZ2UuYWN0aW9uID09PSBhY3Rpb25zLlBSRVNFTkNFIHx8IG1lc3NhZ2UuYWN0aW9uID09PSBhY3Rpb25zLk9CSkVDVCB8fCBtZXNzYWdlLmFjdGlvbiA9PT0gYWN0aW9ucy5BTk5PVEFUSU9OKSB7XG4gICAgICB0aGlzLnNldENoYW5uZWxTZXJpYWwobWVzc2FnZS5jaGFubmVsU2VyaWFsKTtcbiAgICB9XG4gICAgbGV0IHN5bmNDaGFubmVsU2VyaWFsLCBpc1N5bmMgPSBmYWxzZTtcbiAgICBzd2l0Y2ggKG1lc3NhZ2UuYWN0aW9uKSB7XG4gICAgICBjYXNlIGFjdGlvbnMuQVRUQUNIRUQ6IHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmF0dGFjaFNlcmlhbCA9IG1lc3NhZ2UuY2hhbm5lbFNlcmlhbDtcbiAgICAgICAgdGhpcy5fbW9kZSA9IG1lc3NhZ2UuZ2V0TW9kZSgpO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IG1lc3NhZ2UucGFyYW1zIHx8IHt9O1xuICAgICAgICBjb25zdCBtb2Rlc0Zyb21GbGFncyA9IG1lc3NhZ2UuZGVjb2RlTW9kZXNGcm9tRmxhZ3MoKTtcbiAgICAgICAgdGhpcy5tb2RlcyA9IG1vZGVzRnJvbUZsYWdzICYmIGFsbFRvTG93ZXJDYXNlKG1vZGVzRnJvbUZsYWdzKSB8fCB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHJlc3VtZWQgPSBtZXNzYWdlLmhhc0ZsYWcoXCJSRVNVTUVEXCIpO1xuICAgICAgICBjb25zdCBoYXNQcmVzZW5jZSA9IG1lc3NhZ2UuaGFzRmxhZyhcIkhBU19QUkVTRU5DRVwiKTtcbiAgICAgICAgY29uc3QgaGFzQmFja2xvZyA9IG1lc3NhZ2UuaGFzRmxhZyhcIkhBU19CQUNLTE9HXCIpO1xuICAgICAgICBjb25zdCBoYXNPYmplY3RzID0gbWVzc2FnZS5oYXNGbGFnKFwiSEFTX09CSkVDVFNcIik7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgICAgICBpZiAoIXJlc3VtZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcmVzZW5jZSkge1xuICAgICAgICAgICAgICB0aGlzLl9wcmVzZW5jZS5vbkF0dGFjaGVkKGhhc1ByZXNlbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vYmplY3RzKSB7XG4gICAgICAgICAgICAgIHRoaXMuX29iamVjdHMub25BdHRhY2hlZChoYXNPYmplY3RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY2hhbmdlID0gbmV3IGNoYW5uZWxzdGF0ZWNoYW5nZV9kZWZhdWx0KHRoaXMuc3RhdGUsIHRoaXMuc3RhdGUsIHJlc3VtZWQsIGhhc0JhY2tsb2csIG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgIHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLmVtaXQoXCJ1cGRhdGVcIiwgY2hhbmdlKTtcbiAgICAgICAgICBpZiAoIXJlc3VtZWQgfHwgdGhpcy5jaGFubmVsT3B0aW9ucy51cGRhdGVPbkF0dGFjaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgY2hhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gXCJkZXRhY2hpbmdcIikge1xuICAgICAgICAgIHRoaXMuY2hlY2tQZW5kaW5nU3RhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKFwiYXR0YWNoZWRcIiwgbWVzc2FnZS5lcnJvciwgcmVzdW1lZCwgaGFzUHJlc2VuY2UsIGhhc0JhY2tsb2csIGhhc09iamVjdHMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBhY3Rpb25zLkRFVEFDSEVEOiB7XG4gICAgICAgIGNvbnN0IGRldGFjaEVyciA9IG1lc3NhZ2UuZXJyb3IgPyBFcnJvckluZm8uZnJvbVZhbHVlcyhtZXNzYWdlLmVycm9yKSA6IG5ldyBFcnJvckluZm8oXCJDaGFubmVsIGRldGFjaGVkXCIsIDkwMDAxLCA0MDQpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJkZXRhY2hpbmdcIikge1xuICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoXCJkZXRhY2hlZFwiLCBkZXRhY2hFcnIpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFwiYXR0YWNoaW5nXCIpIHtcbiAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKFwic3VzcGVuZGVkXCIsIGRldGFjaEVycik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gXCJhdHRhY2hlZFwiIHx8IHRoaXMuc3RhdGUgPT09IFwic3VzcGVuZGVkXCIpIHtcbiAgICAgICAgICB0aGlzLnJlcXVlc3RTdGF0ZShcImF0dGFjaGluZ1wiLCBkZXRhY2hFcnIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBhY3Rpb25zLlNZTkM6XG4gICAgICAgIGlzU3luYyA9IHRydWU7XG4gICAgICAgIHN5bmNDaGFubmVsU2VyaWFsID0gdGhpcy5zeW5jQ2hhbm5lbFNlcmlhbCA9IG1lc3NhZ2UuY2hhbm5lbFNlcmlhbDtcbiAgICAgICAgaWYgKCFtZXNzYWdlLnByZXNlbmNlKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhY3Rpb25zLlBSRVNFTkNFOiB7XG4gICAgICAgIGlmICghbWVzc2FnZS5wcmVzZW5jZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBvcHVsYXRlRmllbGRzRnJvbVBhcmVudChtZXNzYWdlKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuY2hhbm5lbE9wdGlvbnM7XG4gICAgICAgIGlmICh0aGlzLl9wcmVzZW5jZSkge1xuICAgICAgICAgIGNvbnN0IHByZXNlbmNlTWVzc2FnZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIG1lc3NhZ2UucHJlc2VuY2UubWFwKCh3cG0pID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdwbS5kZWNvZGUob3B0aW9ucywgdGhpcy5sb2dnZXIpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuX3ByZXNlbmNlLnNldFByZXNlbmNlKHByZXNlbmNlTWVzc2FnZXMsIGlzU3luYywgc3luY0NoYW5uZWxTZXJpYWwpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBhY3Rpb25zLk9CSkVDVDpcbiAgICAgIGNhc2UgYWN0aW9ucy5PQkpFQ1RfU1lOQzoge1xuICAgICAgICBpZiAoIXRoaXMuX29iamVjdHMgfHwgIW1lc3NhZ2Uuc3RhdGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcG9wdWxhdGVGaWVsZHNGcm9tUGFyZW50KG1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmNsaWVudC5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLmdldEFjdGl2ZVRyYW5zcG9ydEZvcm1hdCgpO1xuICAgICAgICBjb25zdCBvYmplY3RNZXNzYWdlcyA9IG1lc3NhZ2Uuc3RhdGUubWFwKChvbSkgPT4gb20uZGVjb2RlKHRoaXMuY2xpZW50LCBmb3JtYXQpKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYWN0aW9uID09PSBhY3Rpb25zLk9CSkVDVCkge1xuICAgICAgICAgIHRoaXMuX29iamVjdHMuaGFuZGxlT2JqZWN0TWVzc2FnZXMob2JqZWN0TWVzc2FnZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX29iamVjdHMuaGFuZGxlT2JqZWN0U3luY01lc3NhZ2VzKG9iamVjdE1lc3NhZ2VzLCBtZXNzYWdlLmNoYW5uZWxTZXJpYWwpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBhY3Rpb25zLk1FU1NBR0U6IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01BSk9SLFxuICAgICAgICAgICAgXCJSZWFsdGltZUNoYW5uZWwucHJvY2Vzc01lc3NhZ2UoKVwiLFxuICAgICAgICAgICAgJ01lc3NhZ2UgXCInICsgbWVzc2FnZS5pZCArICdcIiBza2lwcGVkIGFzIHRoaXMgY2hhbm5lbCBcIicgKyB0aGlzLm5hbWUgKyAnXCIgc3RhdGUgaXMgbm90IFwiYXR0YWNoZWRcIiAoc3RhdGUgaXMgXCInICsgdGhpcy5zdGF0ZSArICdcIikuJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBvcHVsYXRlRmllbGRzRnJvbVBhcmVudChtZXNzYWdlKTtcbiAgICAgICAgY29uc3QgZW5jb2RlZCA9IG1lc3NhZ2UubWVzc2FnZXMsIGZpcnN0TWVzc2FnZSA9IGVuY29kZWRbMF0sIGxhc3RNZXNzYWdlID0gZW5jb2RlZFtlbmNvZGVkLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoZmlyc3RNZXNzYWdlLmV4dHJhcyAmJiBmaXJzdE1lc3NhZ2UuZXh0cmFzLmRlbHRhICYmIGZpcnN0TWVzc2FnZS5leHRyYXMuZGVsdGEuZnJvbSAhPT0gdGhpcy5fbGFzdFBheWxvYWQubWVzc2FnZUlkKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gJ0RlbHRhIG1lc3NhZ2UgZGVjb2RlIGZhaWx1cmUgLSBwcmV2aW91cyBtZXNzYWdlIG5vdCBhdmFpbGFibGUgZm9yIG1lc3NhZ2UgXCInICsgbWVzc2FnZS5pZCArICdcIiBvbiB0aGlzIGNoYW5uZWwgXCInICsgdGhpcy5uYW1lICsgJ1wiLic7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NNZXNzYWdlKClcIiwgbXNnKTtcbiAgICAgICAgICB0aGlzLl9zdGFydERlY29kZUZhaWx1cmVSZWNvdmVyeShuZXcgRXJyb3JJbmZvKG1zZywgNDAwMTgsIDQwMCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZXNzYWdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCB7IGRlY29kZWQsIGVyciB9ID0gYXdhaXQgZW5jb2RlZFtpXS5kZWNvZGVXaXRoRXJyKHRoaXMuX2RlY29kaW5nQ29udGV4dCwgdGhpcy5sb2dnZXIpO1xuICAgICAgICAgIG1lc3NhZ2VzW2ldID0gZGVjb2RlZDtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGVyci5jb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgNDAwMTg6XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnREZWNvZGVGYWlsdXJlUmVjb3ZlcnkoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIGNhc2UgNDAwMTk6XG4gICAgICAgICAgICAgIGNhc2UgNDAwMjE6XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShcImZhaWxlZFwiLCBlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGFzdFBheWxvYWQubWVzc2FnZUlkID0gbGFzdE1lc3NhZ2UuaWQ7XG4gICAgICAgIHRoaXMuX2xhc3RQYXlsb2FkLnByb3RvY29sTWVzc2FnZUNoYW5uZWxTZXJpYWwgPSBtZXNzYWdlLmNoYW5uZWxTZXJpYWw7XG4gICAgICAgIHRoaXMub25FdmVudChtZXNzYWdlcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBhY3Rpb25zLkFOTk9UQVRJT046IHtcbiAgICAgICAgcG9wdWxhdGVGaWVsZHNGcm9tUGFyZW50KG1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5jaGFubmVsT3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuX2Fubm90YXRpb25zKSB7XG4gICAgICAgICAgY29uc3QgYW5ub3RhdGlvbnMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIChtZXNzYWdlLmFubm90YXRpb25zIHx8IFtdKS5tYXAoKHdwbSkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gd3BtLmRlY29kZShvcHRpb25zLCB0aGlzLmxvZ2dlcik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5fYW5ub3RhdGlvbnMuX3Byb2Nlc3NJbmNvbWluZyhhbm5vdGF0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGFjdGlvbnMuRVJST1I6IHtcbiAgICAgICAgY29uc3QgZXJyID0gbWVzc2FnZS5lcnJvcjtcbiAgICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSA9PSA4MDAxNikge1xuICAgICAgICAgIHRoaXMuY2hlY2tQZW5kaW5nU3RhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKFwiZmFpbGVkXCIsIEVycm9ySW5mby5mcm9tVmFsdWVzKGVycikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NQUpPUixcbiAgICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTWVzc2FnZSgpXCIsXG4gICAgICAgICAgXCJQcm90b2NvbCBlcnJvcjogdW5yZWNvZ25pc2VkIG1lc3NhZ2UgYWN0aW9uIChcIiArIG1lc3NhZ2UuYWN0aW9uICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cbiAgX3N0YXJ0RGVjb2RlRmFpbHVyZVJlY292ZXJ5KHJlYXNvbikge1xuICAgIGlmICghdGhpcy5fbGFzdFBheWxvYWQuZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzcykge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01BSk9SLFxuICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTWVzc2FnZSgpXCIsXG4gICAgICAgIFwiU3RhcnRpbmcgZGVjb2RlIGZhaWx1cmUgcmVjb3ZlcnkgcHJvY2Vzcy5cIlxuICAgICAgKTtcbiAgICAgIHRoaXMuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgdGhpcy5fYXR0YWNoKHRydWUsIHJlYXNvbiwgKCkgPT4ge1xuICAgICAgICB0aGlzLl9sYXN0UGF5bG9hZC5kZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgb25BdHRhY2hlZCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiUmVhbHRpbWVDaGFubmVsLm9uQXR0YWNoZWRcIixcbiAgICAgIFwiYWN0aXZhdGluZyBjaGFubmVsOyBuYW1lID0gXCIgKyB0aGlzLm5hbWVcbiAgICApO1xuICB9XG4gIG5vdGlmeVN0YXRlKHN0YXRlLCByZWFzb24sIHJlc3VtZWQsIGhhc1ByZXNlbmNlLCBoYXNCYWNrbG9nLCBoYXNPYmplY3RzKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5ub3RpZnlTdGF0ZVwiLFxuICAgICAgXCJuYW1lID0gXCIgKyB0aGlzLm5hbWUgKyBcIiwgY3VycmVudCBzdGF0ZSA9IFwiICsgdGhpcy5zdGF0ZSArIFwiLCBub3RpZnlpbmcgc3RhdGUgXCIgKyBzdGF0ZVxuICAgICk7XG4gICAgdGhpcy5jbGVhclN0YXRlVGltZXIoKTtcbiAgICBpZiAoW1wiZGV0YWNoZWRcIiwgXCJzdXNwZW5kZWRcIiwgXCJmYWlsZWRcIl0uaW5jbHVkZXMoc3RhdGUpKSB7XG4gICAgICB0aGlzLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PT0gdGhpcy5zdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcHJlc2VuY2UpIHtcbiAgICAgIHRoaXMuX3ByZXNlbmNlLmFjdE9uQ2hhbm5lbFN0YXRlKHN0YXRlLCBoYXNQcmVzZW5jZSwgcmVhc29uKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29iamVjdHMpIHtcbiAgICAgIHRoaXMuX29iamVjdHMuYWN0T25DaGFubmVsU3RhdGUoc3RhdGUsIGhhc09iamVjdHMpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUgPT09IFwic3VzcGVuZGVkXCIgJiYgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICB0aGlzLnN0YXJ0UmV0cnlUaW1lcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNhbmNlbFJldHJ5VGltZXIoKTtcbiAgICB9XG4gICAgaWYgKHJlYXNvbikge1xuICAgICAgdGhpcy5lcnJvclJlYXNvbiA9IHJlYXNvbjtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlID0gbmV3IGNoYW5uZWxzdGF0ZWNoYW5nZV9kZWZhdWx0KHRoaXMuc3RhdGUsIHN0YXRlLCByZXN1bWVkLCBoYXNCYWNrbG9nLCByZWFzb24pO1xuICAgIGNvbnN0IGFjdGlvbiA9ICdDaGFubmVsIHN0YXRlIGZvciBjaGFubmVsIFwiJyArIHRoaXMubmFtZSArICdcIic7XG4gICAgY29uc3QgbWVzc2FnZSA9IHN0YXRlICsgKHJlYXNvbiA/IFwiOyByZWFzb246IFwiICsgcmVhc29uIDogXCJcIik7XG4gICAgaWYgKHN0YXRlID09PSBcImZhaWxlZFwiKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgYWN0aW9uLCBtZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsIGFjdGlvbiwgbWVzc2FnZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZSAhPT0gXCJhdHRhY2hpbmdcIiAmJiBzdGF0ZSAhPT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgdGhpcy5yZXRyeUNvdW50ID0gMDtcbiAgICB9XG4gICAgaWYgKHN0YXRlID09PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgIHRoaXMub25BdHRhY2hlZCgpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUgPT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgdGhpcy5fYXR0YWNoUmVzdW1lID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBcImRldGFjaGluZ1wiIHx8IHN0YXRlID09PSBcImZhaWxlZFwiKSB7XG4gICAgICB0aGlzLl9hdHRhY2hSZXN1bWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLmVtaXQoc3RhdGUsIGNoYW5nZSk7XG4gICAgdGhpcy5lbWl0KHN0YXRlLCBjaGFuZ2UpO1xuICB9XG4gIHJlcXVlc3RTdGF0ZShzdGF0ZSwgcmVhc29uKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5yZXF1ZXN0U3RhdGVcIixcbiAgICAgIFwibmFtZSA9IFwiICsgdGhpcy5uYW1lICsgXCIsIHN0YXRlID0gXCIgKyBzdGF0ZVxuICAgICk7XG4gICAgdGhpcy5ub3RpZnlTdGF0ZShzdGF0ZSwgcmVhc29uKTtcbiAgICB0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG4gIH1cbiAgY2hlY2tQZW5kaW5nU3RhdGUoKSB7XG4gICAgY29uc3QgY21TdGF0ZSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGU7XG4gICAgaWYgKCFjbVN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJSZWFsdGltZUNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGVcIixcbiAgICAgICAgXCJzZW5kRXZlbnRzIGlzIGZhbHNlOyBzdGF0ZSBpcyBcIiArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGUuc3RhdGVcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJSZWFsdGltZUNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGVcIixcbiAgICAgIFwibmFtZSA9IFwiICsgdGhpcy5uYW1lICsgXCIsIHN0YXRlID0gXCIgKyB0aGlzLnN0YXRlXG4gICAgKTtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJhdHRhY2hpbmdcIjpcbiAgICAgICAgdGhpcy5zdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcoKTtcbiAgICAgICAgdGhpcy5hdHRhY2hJbXBsKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRldGFjaGluZ1wiOlxuICAgICAgICB0aGlzLnN0YXJ0U3RhdGVUaW1lcklmTm90UnVubmluZygpO1xuICAgICAgICB0aGlzLmRldGFjaEltcGwoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYXR0YWNoZWRcIjpcbiAgICAgICAgdGhpcy5zeW5jKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRpbWVvdXRQZW5kaW5nU3RhdGUoKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFwiYXR0YWNoaW5nXCI6IHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9ySW5mbyhcIkNoYW5uZWwgYXR0YWNoIHRpbWVkIG91dFwiLCA5MDAwNywgNDA4KTtcbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShcInN1c3BlbmRlZFwiLCBlcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkZXRhY2hpbmdcIjoge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3JJbmZvKFwiQ2hhbm5lbCBkZXRhY2ggdGltZWQgb3V0XCIsIDkwMDA3LCA0MDgpO1xuICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKFwiYXR0YWNoZWRcIiwgZXJyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlVGltZXIpIHtcbiAgICAgIHRoaXMuc3RhdGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJSZWFsdGltZUNoYW5uZWwuc3RhcnRTdGF0ZVRpbWVySWZOb3RSdW5uaW5nXCIsIFwidGltZXIgZXhwaXJlZFwiKTtcbiAgICAgICAgdGhpcy5zdGF0ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy50aW1lb3V0UGVuZGluZ1N0YXRlKCk7XG4gICAgICB9LCB0aGlzLmNsaWVudC5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQpO1xuICAgIH1cbiAgfVxuICBjbGVhclN0YXRlVGltZXIoKSB7XG4gICAgY29uc3Qgc3RhdGVUaW1lciA9IHRoaXMuc3RhdGVUaW1lcjtcbiAgICBpZiAoc3RhdGVUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlVGltZXIpO1xuICAgICAgdGhpcy5zdGF0ZVRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhcnRSZXRyeVRpbWVyKCkge1xuICAgIGlmICh0aGlzLnJldHJ5VGltZXIpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yZXRyeUNvdW50Kys7XG4gICAgY29uc3QgcmV0cnlEZWxheSA9IGdldFJldHJ5VGltZSh0aGlzLmNsaWVudC5vcHRpb25zLnRpbWVvdXRzLmNoYW5uZWxSZXRyeVRpbWVvdXQsIHRoaXMucmV0cnlDb3VudCk7XG4gICAgdGhpcy5yZXRyeVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIiAmJiB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgICAgdGhpcy5yZXRyeVRpbWVyID0gbnVsbDtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbCByZXRyeSB0aW1lciBleHBpcmVkXCIsXG4gICAgICAgICAgXCJhdHRlbXB0aW5nIGEgbmV3IGF0dGFjaFwiXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKFwiYXR0YWNoaW5nXCIpO1xuICAgICAgfVxuICAgIH0sIHJldHJ5RGVsYXkpO1xuICB9XG4gIGNhbmNlbFJldHJ5VGltZXIoKSB7XG4gICAgaWYgKHRoaXMucmV0cnlUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lcik7XG4gICAgICB0aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKiBAcmV0dXJucyBudWxsIChpZiBjYW4gc2FmZWx5IGJlIHJlbGVhc2VkKSB8IEVycm9ySW5mbyAoaWYgY2Fubm90KSAqL1xuICBnZXRSZWxlYXNlRXJyKCkge1xuICAgIGNvbnN0IHMgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChzID09PSBcImluaXRpYWxpemVkXCIgfHwgcyA9PT0gXCJkZXRhY2hlZFwiIHx8IHMgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9ySW5mbyhcbiAgICAgIFwiQ2FuIG9ubHkgcmVsZWFzZSBhIGNoYW5uZWwgaW4gYSBzdGF0ZSB3aGVyZSB0aGVyZSBpcyBubyBwb3NzaWJpbGl0eSBvZiBmdXJ0aGVyIHVwZGF0ZXMgZnJvbSB0aGUgc2VydmVyIGJlaW5nIHJlY2VpdmVkIChpbml0aWFsaXplZCwgZGV0YWNoZWQsIG9yIGZhaWxlZCk7IHdhcyBcIiArIHMsXG4gICAgICA5MDAwMSxcbiAgICAgIDQwMFxuICAgICk7XG4gIH1cbiAgc2V0Q2hhbm5lbFNlcmlhbChjaGFubmVsU2VyaWFsKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5zZXRDaGFubmVsU2VyaWFsKClcIixcbiAgICAgIFwiVXBkYXRpbmcgY2hhbm5lbCBzZXJpYWw7IHNlcmlhbCA9IFwiICsgY2hhbm5lbFNlcmlhbCArIFwiOyBwcmV2aW91cyA9IFwiICsgdGhpcy5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWxcbiAgICApO1xuICAgIGlmIChjaGFubmVsU2VyaWFsKSB7XG4gICAgICB0aGlzLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCA9IGNoYW5uZWxTZXJpYWw7XG4gICAgfVxuICB9XG4gIGFzeW5jIHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucmVzdC5jaGFubmVsTWl4aW4uc3RhdHVzKHRoaXMpO1xuICB9XG59O1xuZnVuY3Rpb24gb21pdEFnZW50KGNoYW5uZWxQYXJhbXMpIHtcbiAgY29uc3QgX2EyID0gY2hhbm5lbFBhcmFtcyB8fCB7fSwgeyBhZ2VudDogXyB9ID0gX2EyLCBwYXJhbXNXaXRob3V0QWdlbnQgPSBfX29ialJlc3QoX2EyLCBbXCJhZ2VudFwiXSk7XG4gIHJldHVybiBwYXJhbXNXaXRob3V0QWdlbnQ7XG59XG52YXIgcmVhbHRpbWVjaGFubmVsX2RlZmF1bHQgPSBSZWFsdGltZUNoYW5uZWw7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9yZWFsdGltZWFubm90YXRpb25zLnRzXG52YXIgUmVhbHRpbWVBbm5vdGF0aW9ucyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2hhbm5lbCkge1xuICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgdGhpcy5sb2dnZXIgPSBjaGFubmVsLmxvZ2dlcjtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgZXZlbnRlbWl0dGVyX2RlZmF1bHQodGhpcy5sb2dnZXIpO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2gobXNnT3JTZXJpYWwsIGFubm90YXRpb25WYWx1ZXMpIHtcbiAgICBjb25zdCBjaGFubmVsTmFtZSA9IHRoaXMuY2hhbm5lbC5uYW1lO1xuICAgIGNvbnN0IGFubm90YXRpb24gPSBjb25zdHJ1Y3RWYWxpZGF0ZUFubm90YXRpb24obXNnT3JTZXJpYWwsIGFubm90YXRpb25WYWx1ZXMpO1xuICAgIGNvbnN0IHdpcmVBbm5vdGF0aW9uID0gYXdhaXQgYW5ub3RhdGlvbi5lbmNvZGUoKTtcbiAgICB0aGlzLmNoYW5uZWwudGhyb3dJZlVucHVibGlzaGFibGVTdGF0ZSgpO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZWFsdGltZUFubm90YXRpb25zLnB1Ymxpc2goKVwiLFxuICAgICAgXCJjaGFubmVsTmFtZSA9IFwiICsgY2hhbm5lbE5hbWUgKyBcIiwgc2VuZGluZyBhbm5vdGF0aW9uIHdpdGggbWVzc2FnZVNlcmlhbCA9IFwiICsgYW5ub3RhdGlvbi5tZXNzYWdlU2VyaWFsICsgXCIsIHR5cGUgPSBcIiArIGFubm90YXRpb24udHlwZVxuICAgICk7XG4gICAgY29uc3QgcG0gPSBmcm9tVmFsdWVzKHtcbiAgICAgIGFjdGlvbjogYWN0aW9ucy5BTk5PVEFUSU9OLFxuICAgICAgY2hhbm5lbDogY2hhbm5lbE5hbWUsXG4gICAgICBhbm5vdGF0aW9uczogW3dpcmVBbm5vdGF0aW9uXVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuc2VuZE1lc3NhZ2UocG0pO1xuICB9XG4gIGFzeW5jIGRlbGV0ZShtc2dPclNlcmlhbCwgYW5ub3RhdGlvblZhbHVlcykge1xuICAgIGFubm90YXRpb25WYWx1ZXMuYWN0aW9uID0gXCJhbm5vdGF0aW9uLmRlbGV0ZVwiO1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2gobXNnT3JTZXJpYWwsIGFubm90YXRpb25WYWx1ZXMpO1xuICB9XG4gIGFzeW5jIHN1YnNjcmliZSguLi5fYXJncykge1xuICAgIGNvbnN0IGFyZ3MgPSByZWFsdGltZWNoYW5uZWxfZGVmYXVsdC5wcm9jZXNzTGlzdGVuZXJBcmdzKF9hcmdzKTtcbiAgICBjb25zdCBldmVudCA9IGFyZ3NbMF07XG4gICAgY29uc3QgbGlzdGVuZXIgPSBhcmdzWzFdO1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG4gICAgaWYgKGNoYW5uZWwuc3RhdGUgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgIHRocm93IEVycm9ySW5mby5mcm9tVmFsdWVzKGNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3IoKSk7XG4gICAgfVxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIGlmICh0aGlzLmNoYW5uZWwuY2hhbm5lbE9wdGlvbnMuYXR0YWNoT25TdWJzY3JpYmUgIT09IGZhbHNlKSB7XG4gICAgICBhd2FpdCBjaGFubmVsLmF0dGFjaCgpO1xuICAgIH1cbiAgICBpZiAoKHRoaXMuY2hhbm5lbC5zdGF0ZSA9PT0gXCJhdHRhY2hlZFwiICYmIHRoaXMuY2hhbm5lbC5fbW9kZSAmIGZsYWdzLkFOTk9UQVRJT05fU1VCU0NSSUJFKSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgXCJZb3UgYXJlIHRyeWluZyB0byBhZGQgYW4gYW5ub3RhdGlvbiBsaXN0ZW5lciwgYnV0IHlvdSBoYXZlbid0IHJlcXVlc3RlZCB0aGUgYW5ub3RhdGlvbl9zdWJzY3JpYmUgY2hhbm5lbCBtb2RlIGluIENoYW5uZWxPcHRpb25zLCBzbyB0aGlzIHdvbid0IGRvIGFueXRoaW5nICh3ZSBvbmx5IGRlbGl2ZXIgYW5ub3RhdGlvbnMgdG8gY2xpZW50cyB3aG8gaGF2ZSBleHBsaWNpdGx5IHJlcXVlc3RlZCB0aGVtKVwiLFxuICAgICAgICA5MzAwMSxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB1bnN1YnNjcmliZSguLi5fYXJncykge1xuICAgIGNvbnN0IGFyZ3MgPSByZWFsdGltZWNoYW5uZWxfZGVmYXVsdC5wcm9jZXNzTGlzdGVuZXJBcmdzKF9hcmdzKTtcbiAgICBjb25zdCBldmVudCA9IGFyZ3NbMF07XG4gICAgY29uc3QgbGlzdGVuZXIgPSBhcmdzWzFdO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxuICBfcHJvY2Vzc0luY29taW5nKGFubm90YXRpb25zKSB7XG4gICAgZm9yIChjb25zdCBhbm5vdGF0aW9uIG9mIGFubm90YXRpb25zKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZW1pdChhbm5vdGF0aW9uLnR5cGUgfHwgXCJcIiwgYW5ub3RhdGlvbik7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldChtc2dPclNlcmlhbCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHJlc3Rhbm5vdGF0aW9uc19kZWZhdWx0LnByb3RvdHlwZS5nZXQuY2FsbCh0aGlzLCBtc2dPclNlcmlhbCwgcGFyYW1zKTtcbiAgfVxufTtcbnZhciByZWFsdGltZWFubm90YXRpb25zX2RlZmF1bHQgPSBSZWFsdGltZUFubm90YXRpb25zO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvZGVmYXVsdHJlc3QudHNcbnZhciBfRGVmYXVsdFJlc3QgPSBjbGFzcyBfRGVmYXVsdFJlc3QgZXh0ZW5kcyBCYXNlUmVzdCB7XG4gIC8vIFRoZSBwdWJsaWMgdHlwaW5ncyBkZWNsYXJlIHRoYXQgdGhpcyByZXF1aXJlcyBhbiBhcmd1bWVudCB0byBiZSBwYXNzZWQsIGJ1dCBzaW5jZSB3ZSB3YW50IHRvIGVtaXQgYSBnb29kIGVycm9yIG1lc3NhZ2UgaW4gdGhlIGNhc2Ugd2hlcmUgYSBub24tVHlwZVNjcmlwdCB1c2VyIGRvZXMgbm90IHBhc3MgYW4gYXJndW1lbnQsIHRlbGwgdGhlIGNvbXBpbGVyIHRoYXQgdGhpcyBpcyBwb3NzaWJsZSBzbyB0aGF0IGl0IGZvcmNlcyB1cyB0byBoYW5kbGUgaXQuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICBjb25zdCBNc2dQYWNrID0gX0RlZmF1bHRSZXN0Ll9Nc2dQYWNrO1xuICAgIGlmICghTXNnUGFjaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgRGVmYXVsdFJlc3QuX01zZ1BhY2sgdG8gaGF2ZSBiZWVuIHNldFwiKTtcbiAgICB9XG4gICAgc3VwZXIoXG4gICAgICBkZWZhdWx0c19kZWZhdWx0Lm9iamVjdGlmeU9wdGlvbnMob3B0aW9ucywgdHJ1ZSwgXCJSZXN0XCIsIGxvZ2dlcl9kZWZhdWx0LmRlZmF1bHRMb2dnZXIsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGFsbENvbW1vbk1vZHVsYXJQbHVnaW5zKSwge1xuICAgICAgICBDcnlwdG86IChfYTIgPSBfRGVmYXVsdFJlc3QuQ3J5cHRvKSAhPSBudWxsID8gX2EyIDogdm9pZCAwLFxuICAgICAgICBNc2dQYWNrOiAoX2IgPSBfRGVmYXVsdFJlc3QuX01zZ1BhY2spICE9IG51bGwgPyBfYiA6IHZvaWQgMCxcbiAgICAgICAgQW5ub3RhdGlvbnM6IHtcbiAgICAgICAgICBBbm5vdGF0aW9uOiBhbm5vdGF0aW9uX2RlZmF1bHQsXG4gICAgICAgICAgV2lyZUFubm90YXRpb24sXG4gICAgICAgICAgUmVhbHRpbWVBbm5vdGF0aW9uczogcmVhbHRpbWVhbm5vdGF0aW9uc19kZWZhdWx0LFxuICAgICAgICAgIFJlc3RBbm5vdGF0aW9uczogcmVzdGFubm90YXRpb25zX2RlZmF1bHRcbiAgICAgICAgfVxuICAgICAgfSkpXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgZ2V0IENyeXB0bygpIHtcbiAgICBpZiAodGhpcy5fQ3J5cHRvID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmNyeXB0aW9uIG5vdCBlbmFibGVkOyB1c2UgYWJseS5lbmNyeXB0aW9uLmpzIGluc3RlYWRcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9DcnlwdG87XG4gIH1cbiAgc3RhdGljIHNldCBDcnlwdG8obmV3VmFsdWUpIHtcbiAgICB0aGlzLl9DcnlwdG8gPSBuZXdWYWx1ZTtcbiAgfVxufTtcbl9EZWZhdWx0UmVzdC5fQ3J5cHRvID0gbnVsbDtcbl9EZWZhdWx0UmVzdC5NZXNzYWdlID0gRGVmYXVsdE1lc3NhZ2U7XG5fRGVmYXVsdFJlc3QuUHJlc2VuY2VNZXNzYWdlID0gRGVmYXVsdFByZXNlbmNlTWVzc2FnZTtcbl9EZWZhdWx0UmVzdC5Bbm5vdGF0aW9uID0gRGVmYXVsdEFubm90YXRpb247XG5fRGVmYXVsdFJlc3QuX01zZ1BhY2sgPSBudWxsO1xuLy8gVXNlZCBieSB0ZXN0c1xuX0RlZmF1bHRSZXN0Ll9IdHRwID0gSHR0cDtcbnZhciBEZWZhdWx0UmVzdCA9IF9EZWZhdWx0UmVzdDtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHJhbnNwb3J0L21lc3NhZ2VxdWV1ZS50c1xudmFyIE1lc3NhZ2VRdWV1ZSA9IGNsYXNzIGV4dGVuZHMgZXZlbnRlbWl0dGVyX2RlZmF1bHQge1xuICBjb25zdHJ1Y3Rvcihsb2dnZXIpIHtcbiAgICBzdXBlcihsb2dnZXIpO1xuICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgfVxuICBjb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5sZW5ndGg7XG4gIH1cbiAgcHVzaChtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICB9XG4gIHNoaWZ0KCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzLnNoaWZ0KCk7XG4gIH1cbiAgbGFzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlc1t0aGlzLm1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGNvcHlBbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuc2xpY2UoKTtcbiAgfVxuICBhcHBlbmQobWVzc2FnZXMpIHtcbiAgICB0aGlzLm1lc3NhZ2VzLnB1c2guYXBwbHkodGhpcy5tZXNzYWdlcywgbWVzc2FnZXMpO1xuICB9XG4gIHByZXBlbmQobWVzc2FnZXMpIHtcbiAgICB0aGlzLm1lc3NhZ2VzLnVuc2hpZnQuYXBwbHkodGhpcy5tZXNzYWdlcywgbWVzc2FnZXMpO1xuICB9XG4gIGNvbXBsZXRlTWVzc2FnZXMoc2VyaWFsLCBjb3VudCwgZXJyKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIk1lc3NhZ2VRdWV1ZS5jb21wbGV0ZU1lc3NhZ2VzKClcIixcbiAgICAgIFwic2VyaWFsID0gXCIgKyBzZXJpYWwgKyBcIjsgY291bnQgPSBcIiArIGNvdW50XG4gICAgKTtcbiAgICBlcnIgPSBlcnIgfHwgbnVsbDtcbiAgICBjb25zdCBtZXNzYWdlcyA9IHRoaXMubWVzc2FnZXM7XG4gICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWVzc2FnZVF1ZXVlLmNvbXBsZXRlTWVzc2FnZXMoKTogY29tcGxldGVNZXNzYWdlcyBjYWxsZWQgb24gYW55IGVtcHR5IE1lc3NhZ2VRdWV1ZVwiKTtcbiAgICB9XG4gICAgY29uc3QgZmlyc3QgPSBtZXNzYWdlc1swXTtcbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIGNvbnN0IHN0YXJ0U2VyaWFsID0gZmlyc3QubWVzc2FnZS5tc2dTZXJpYWw7XG4gICAgICBjb25zdCBlbmRTZXJpYWwgPSBzZXJpYWwgKyBjb3VudDtcbiAgICAgIGlmIChlbmRTZXJpYWwgPiBzdGFydFNlcmlhbCkge1xuICAgICAgICBjb25zdCBjb21wbGV0ZU1lc3NhZ2VzID0gbWVzc2FnZXMuc3BsaWNlKDAsIGVuZFNlcmlhbCAtIHN0YXJ0U2VyaWFsKTtcbiAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIGNvbXBsZXRlTWVzc2FnZXMpIHtcbiAgICAgICAgICBtZXNzYWdlLmNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPT0gMClcbiAgICAgICAgdGhpcy5lbWl0KFwiaWRsZVwiKTtcbiAgICB9XG4gIH1cbiAgY29tcGxldGVBbGxNZXNzYWdlcyhlcnIpIHtcbiAgICB0aGlzLmNvbXBsZXRlTWVzc2FnZXMoMCwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgTnVtYmVyLk1BWF9WQUxVRSwgZXJyKTtcbiAgfVxuICByZXNldFNlbmRBdHRlbXB0ZWQoKSB7XG4gICAgZm9yIChsZXQgbXNnIG9mIHRoaXMubWVzc2FnZXMpIHtcbiAgICAgIG1zZy5zZW5kQXR0ZW1wdGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGNsZWFyKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJNZXNzYWdlUXVldWUuY2xlYXIoKVwiLFxuICAgICAgXCJjbGVhcmluZyBcIiArIHRoaXMubWVzc2FnZXMubGVuZ3RoICsgXCIgbWVzc2FnZXNcIlxuICAgICk7XG4gICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgIHRoaXMuZW1pdChcImlkbGVcIik7XG4gIH1cbn07XG52YXIgbWVzc2FnZXF1ZXVlX2RlZmF1bHQgPSBNZXNzYWdlUXVldWU7XG5cbi8vIHNyYy9jb21tb24vbGliL3RyYW5zcG9ydC9wcm90b2NvbC50c1xudmFyIFBlbmRpbmdNZXNzYWdlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMubWVyZ2VkID0gZmFsc2U7XG4gICAgY29uc3QgYWN0aW9uID0gbWVzc2FnZS5hY3Rpb247XG4gICAgdGhpcy5zZW5kQXR0ZW1wdGVkID0gZmFsc2U7XG4gICAgdGhpcy5hY2tSZXF1aXJlZCA9IHR5cGVvZiBhY3Rpb24gPT09IFwibnVtYmVyXCIgJiYgW2FjdGlvbnMuTUVTU0FHRSwgYWN0aW9ucy5QUkVTRU5DRSwgYWN0aW9ucy5BTk5PVEFUSU9OLCBhY3Rpb25zLk9CSkVDVF0uaW5jbHVkZXMoYWN0aW9uKTtcbiAgfVxufTtcbnZhciBQcm90b2NvbCA9IGNsYXNzIGV4dGVuZHMgZXZlbnRlbWl0dGVyX2RlZmF1bHQge1xuICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcbiAgICBzdXBlcih0cmFuc3BvcnQubG9nZ2VyKTtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB0aGlzLm1lc3NhZ2VRdWV1ZSA9IG5ldyBtZXNzYWdlcXVldWVfZGVmYXVsdCh0aGlzLmxvZ2dlcik7XG4gICAgdHJhbnNwb3J0Lm9uKFwiYWNrXCIsIChzZXJpYWwsIGNvdW50KSA9PiB7XG4gICAgICB0aGlzLm9uQWNrKHNlcmlhbCwgY291bnQpO1xuICAgIH0pO1xuICAgIHRyYW5zcG9ydC5vbihcIm5hY2tcIiwgKHNlcmlhbCwgY291bnQsIGVycikgPT4ge1xuICAgICAgdGhpcy5vbk5hY2soc2VyaWFsLCBjb3VudCwgZXJyKTtcbiAgICB9KTtcbiAgfVxuICBvbkFjayhzZXJpYWwsIGNvdW50KSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUHJvdG9jb2wub25BY2soKVwiLCBcInNlcmlhbCA9IFwiICsgc2VyaWFsICsgXCI7IGNvdW50ID0gXCIgKyBjb3VudCk7XG4gICAgdGhpcy5tZXNzYWdlUXVldWUuY29tcGxldGVNZXNzYWdlcyhzZXJpYWwsIGNvdW50KTtcbiAgfVxuICBvbk5hY2soc2VyaWFsLCBjb3VudCwgZXJyKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICBcIlByb3RvY29sLm9uTmFjaygpXCIsXG4gICAgICBcInNlcmlhbCA9IFwiICsgc2VyaWFsICsgXCI7IGNvdW50ID0gXCIgKyBjb3VudCArIFwiOyBlcnIgPSBcIiArIGluc3BlY3RFcnJvcihlcnIpXG4gICAgKTtcbiAgICBpZiAoIWVycikge1xuICAgICAgZXJyID0gbmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byBzZW5kIG1lc3NhZ2U7IGNoYW5uZWwgbm90IHJlc3BvbmRpbmdcIiwgNTAwMDEsIDUwMCk7XG4gICAgfVxuICAgIHRoaXMubWVzc2FnZVF1ZXVlLmNvbXBsZXRlTWVzc2FnZXMoc2VyaWFsLCBjb3VudCwgZXJyKTtcbiAgfVxuICBvbmNlSWRsZShsaXN0ZW5lcikge1xuICAgIGNvbnN0IG1lc3NhZ2VRdWV1ZSA9IHRoaXMubWVzc2FnZVF1ZXVlO1xuICAgIGlmIChtZXNzYWdlUXVldWUuY291bnQoKSA9PT0gMCkge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWVzc2FnZVF1ZXVlLm9uY2UoXCJpZGxlXCIsIGxpc3RlbmVyKTtcbiAgfVxuICBzZW5kKHBlbmRpbmdNZXNzYWdlKSB7XG4gICAgaWYgKHBlbmRpbmdNZXNzYWdlLmFja1JlcXVpcmVkKSB7XG4gICAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5wdXNoKHBlbmRpbmdNZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubG9nZ2VyLnNob3VsZExvZyhsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb25Ob1N0cmlwKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIlByb3RvY29sLnNlbmQoKVwiLFxuICAgICAgICBcInNlbmRpbmcgbXNnOyBcIiArIHN0cmluZ2lmeShcbiAgICAgICAgICBwZW5kaW5nTWVzc2FnZS5tZXNzYWdlLFxuICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9SZWFsdGltZVByZXNlbmNlLFxuICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9Bbm5vdGF0aW9ucyxcbiAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fb2JqZWN0c1BsdWdpblxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICBwZW5kaW5nTWVzc2FnZS5zZW5kQXR0ZW1wdGVkID0gdHJ1ZTtcbiAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHBlbmRpbmdNZXNzYWdlLm1lc3NhZ2UpO1xuICB9XG4gIGdldFRyYW5zcG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQ7XG4gIH1cbiAgZ2V0UGVuZGluZ01lc3NhZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VRdWV1ZS5jb3B5QWxsKCk7XG4gIH1cbiAgY2xlYXJQZW5kaW5nTWVzc2FnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZVF1ZXVlLmNsZWFyKCk7XG4gIH1cbiAgZmluaXNoKCkge1xuICAgIGNvbnN0IHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0O1xuICAgIHRoaXMub25jZUlkbGUoZnVuY3Rpb24oKSB7XG4gICAgICB0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgIH0pO1xuICB9XG59O1xudmFyIHByb3RvY29sX2RlZmF1bHQgPSBQcm90b2NvbDtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZS50c1xudmFyIENvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocHJldmlvdXMsIGN1cnJlbnQsIHJldHJ5SW4sIHJlYXNvbikge1xuICAgIHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICB0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xuICAgIGlmIChyZXRyeUluKVxuICAgICAgdGhpcy5yZXRyeUluID0gcmV0cnlJbjtcbiAgICBpZiAocmVhc29uKVxuICAgICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gIH1cbn07XG52YXIgY29ubmVjdGlvbnN0YXRlY2hhbmdlX2RlZmF1bHQgPSBDb25uZWN0aW9uU3RhdGVDaGFuZ2U7XG5cbi8vIHNyYy9jb21tb24vbGliL3RyYW5zcG9ydC9jb25uZWN0aW9uZXJyb3JzLnRzXG52YXIgQ29ubmVjdGlvbkVycm9yQ29kZXMgPSB7XG4gIERJU0NPTk5FQ1RFRDogODAwMDMsXG4gIFNVU1BFTkRFRDogODAwMDIsXG4gIEZBSUxFRDogOGU0LFxuICBDTE9TSU5HOiA4MDAxNyxcbiAgQ0xPU0VEOiA4MDAxNyxcbiAgVU5LTk9XTl9DT05ORUNUSU9OX0VSUjogNTAwMDIsXG4gIFVOS05PV05fQ0hBTk5FTF9FUlI6IDUwMDAxXG59O1xudmFyIENvbm5lY3Rpb25FcnJvcnMgPSB7XG4gIGRpc2Nvbm5lY3RlZDogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5ESVNDT05ORUNURUQsXG4gICAgbWVzc2FnZTogXCJDb25uZWN0aW9uIHRvIHNlcnZlciB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZVwiXG4gIH0pLFxuICBzdXNwZW5kZWQ6ICgpID0+IEVycm9ySW5mby5mcm9tVmFsdWVzKHtcbiAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuU1VTUEVOREVELFxuICAgIG1lc3NhZ2U6IFwiQ29ubmVjdGlvbiB0byBzZXJ2ZXIgdW5hdmFpbGFibGVcIlxuICB9KSxcbiAgZmFpbGVkOiAoKSA9PiBFcnJvckluZm8uZnJvbVZhbHVlcyh7XG4gICAgc3RhdHVzQ29kZTogNDAwLFxuICAgIGNvZGU6IENvbm5lY3Rpb25FcnJvckNvZGVzLkZBSUxFRCxcbiAgICBtZXNzYWdlOiBcIkNvbm5lY3Rpb24gZmFpbGVkIG9yIGRpc2Nvbm5lY3RlZCBieSBzZXJ2ZXJcIlxuICB9KSxcbiAgY2xvc2luZzogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5DTE9TSU5HLFxuICAgIG1lc3NhZ2U6IFwiQ29ubmVjdGlvbiBjbG9zaW5nXCJcbiAgfSksXG4gIGNsb3NlZDogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5DTE9TRUQsXG4gICAgbWVzc2FnZTogXCJDb25uZWN0aW9uIGNsb3NlZFwiXG4gIH0pLFxuICB1bmtub3duQ29ubmVjdGlvbkVycjogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDUwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5VTktOT1dOX0NPTk5FQ1RJT05fRVJSLFxuICAgIG1lc3NhZ2U6IFwiSW50ZXJuYWwgY29ubmVjdGlvbiBlcnJvclwiXG4gIH0pLFxuICB1bmtub3duQ2hhbm5lbEVycjogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDUwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5VTktOT1dOX0NPTk5FQ1RJT05fRVJSLFxuICAgIG1lc3NhZ2U6IFwiSW50ZXJuYWwgY2hhbm5lbCBlcnJvclwiXG4gIH0pXG59O1xuZnVuY3Rpb24gaXNSZXRyaWFibGUoZXJyKSB7XG4gIGlmICghZXJyLnN0YXR1c0NvZGUgfHwgIWVyci5jb2RlIHx8IGVyci5zdGF0dXNDb2RlID49IDUwMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBPYmplY3QudmFsdWVzKENvbm5lY3Rpb25FcnJvckNvZGVzKS5pbmNsdWRlcyhlcnIuY29kZSk7XG59XG52YXIgY29ubmVjdGlvbmVycm9yc19kZWZhdWx0ID0gQ29ubmVjdGlvbkVycm9ycztcblxuLy8gc3JjL2NvbW1vbi9saWIvdHJhbnNwb3J0L3RyYW5zcG9ydC50c1xudmFyIGNsb3NlTWVzc2FnZSA9IGZyb21WYWx1ZXMoeyBhY3Rpb246IGFjdGlvbnMuQ0xPU0UgfSk7XG52YXIgZGlzY29ubmVjdE1lc3NhZ2UgPSBmcm9tVmFsdWVzKHsgYWN0aW9uOiBhY3Rpb25zLkRJU0NPTk5FQ1QgfSk7XG52YXIgVHJhbnNwb3J0ID0gY2xhc3MgZXh0ZW5kcyBldmVudGVtaXR0ZXJfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMsIGZvcmNlSnNvblByb3RvY29sKSB7XG4gICAgc3VwZXIoY29ubmVjdGlvbk1hbmFnZXIubG9nZ2VyKTtcbiAgICBpZiAoZm9yY2VKc29uUHJvdG9jb2wpIHtcbiAgICAgIHBhcmFtcy5mb3JtYXQgPSB2b2lkIDA7XG4gICAgICBwYXJhbXMuaGVhcnRiZWF0cyA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBjb25uZWN0aW9uTWFuYWdlcjtcbiAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMudGltZW91dHMgPSBwYXJhbXMub3B0aW9ucy50aW1lb3V0cztcbiAgICB0aGlzLmZvcm1hdCA9IHBhcmFtcy5mb3JtYXQ7XG4gICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMubWF4SWRsZUludGVydmFsID0gbnVsbDtcbiAgICB0aGlzLmlkbGVUaW1lciA9IG51bGw7XG4gICAgdGhpcy5sYXN0QWN0aXZpdHkgPSBudWxsO1xuICB9XG4gIGNvbm5lY3QoKSB7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMucmVxdWVzdENsb3NlKCk7XG4gICAgfVxuICAgIHRoaXMuZmluaXNoKFwiY2xvc2VkXCIsIGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdC5jbG9zZWQoKSk7XG4gIH1cbiAgZGlzY29ubmVjdChlcnIpIHtcbiAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy5yZXF1ZXN0RGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICB0aGlzLmZpbmlzaChcImRpc2Nvbm5lY3RlZFwiLCBlcnIgfHwgY29ubmVjdGlvbmVycm9yc19kZWZhdWx0LmRpc2Nvbm5lY3RlZCgpKTtcbiAgfVxuICBmYWlsKGVycikge1xuICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICB0aGlzLnJlcXVlc3REaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIHRoaXMuZmluaXNoKFwiZmFpbGVkXCIsIGVyciB8fCBjb25uZWN0aW9uZXJyb3JzX2RlZmF1bHQuZmFpbGVkKCkpO1xuICB9XG4gIGZpbmlzaChldmVudCwgZXJyKSB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAodGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNGaW5pc2hlZCA9IHRydWU7XG4gICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMubWF4SWRsZUludGVydmFsID0gbnVsbDtcbiAgICBjbGVhclRpbWVvdXQoKF9hMiA9IHRoaXMuaWRsZVRpbWVyKSAhPSBudWxsID8gX2EyIDogdm9pZCAwKTtcbiAgICB0aGlzLmlkbGVUaW1lciA9IG51bGw7XG4gICAgdGhpcy5lbWl0KGV2ZW50LCBlcnIpO1xuICAgIHRoaXMuZGlzcG9zZSgpO1xuICB9XG4gIG9uUHJvdG9jb2xNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5sb2dnZXIuc2hvdWxkTG9nKGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbk5vU3RyaXAoXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiVHJhbnNwb3J0Lm9uUHJvdG9jb2xNZXNzYWdlKClcIixcbiAgICAgICAgXCJyZWNlaXZlZCBvbiBcIiArIHRoaXMuc2hvcnROYW1lICsgXCI6IFwiICsgc3RyaW5naWZ5KFxuICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fUmVhbHRpbWVQcmVzZW5jZSxcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9Bbm5vdGF0aW9ucyxcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9vYmplY3RzUGx1Z2luXG4gICAgICAgICkgKyBcIjsgY29ubmVjdGlvbklkID0gXCIgKyB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rpb25JZFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5vbkFjdGl2aXR5KCk7XG4gICAgc3dpdGNoIChtZXNzYWdlLmFjdGlvbikge1xuICAgICAgY2FzZSBhY3Rpb25zLkhFQVJUQkVBVDpcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uTm9TdHJpcChcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgXCJUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKVwiLFxuICAgICAgICAgIHRoaXMuc2hvcnROYW1lICsgXCIgaGVhcnRiZWF0OyBjb25uZWN0aW9uSWQgPSBcIiArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZW1pdChcImhlYXJ0YmVhdFwiLCBtZXNzYWdlLmlkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMuQ09OTkVDVEVEOlxuICAgICAgICB0aGlzLm9uQ29ubmVjdChtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGVkXCIsIG1lc3NhZ2UuZXJyb3IsIG1lc3NhZ2UuY29ubmVjdGlvbklkLCBtZXNzYWdlLmNvbm5lY3Rpb25EZXRhaWxzLCBtZXNzYWdlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMuQ0xPU0VEOlxuICAgICAgICB0aGlzLm9uQ2xvc2UobWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhY3Rpb25zLkRJU0NPTk5FQ1RFRDpcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3QobWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhY3Rpb25zLkFDSzpcbiAgICAgICAgdGhpcy5lbWl0KFwiYWNrXCIsIG1lc3NhZ2UubXNnU2VyaWFsLCBtZXNzYWdlLmNvdW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMuTkFDSzpcbiAgICAgICAgdGhpcy5lbWl0KFwibmFja1wiLCBtZXNzYWdlLm1zZ1NlcmlhbCwgbWVzc2FnZS5jb3VudCwgbWVzc2FnZS5lcnJvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhY3Rpb25zLlNZTkM6XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub25DaGFubmVsTWVzc2FnZShtZXNzYWdlLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMuQUNUSVZBVEU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhY3Rpb25zLkFVVEg6XG4gICAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyh0aGlzLmF1dGguYXV0aG9yaXplKCksIChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgICAgIFwiVHJhbnNwb3J0Lm9uUHJvdG9jb2xNZXNzYWdlKClcIixcbiAgICAgICAgICAgICAgXCJBYmx5IHJlcXVlc3RlZCByZS1hdXRoZW50aWNhdGlvbiwgYnV0IHVuYWJsZSB0byBvYnRhaW4gYSBuZXcgdG9rZW46IFwiICsgaW5zcGVjdEVycm9yKGVycilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMuRVJST1I6XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKVwiLFxuICAgICAgICAgIFwicmVjZWl2ZWQgZXJyb3IgYWN0aW9uOyBjb25uZWN0aW9uSWQgPSBcIiArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkICsgXCI7IGVyciA9IFwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QobWVzc2FnZS5lcnJvcikgKyAobWVzc2FnZS5jaGFubmVsID8gXCIsIGNoYW5uZWw6IFwiICsgbWVzc2FnZS5jaGFubmVsIDogXCJcIilcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuY2hhbm5lbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhpcy5vbkZhdGFsRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub25DaGFubmVsTWVzc2FnZShtZXNzYWdlLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgb25Db25uZWN0KG1lc3NhZ2UpIHtcbiAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICBpZiAoIW1lc3NhZ2UuY29ubmVjdGlvbkRldGFpbHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9ydC5vbkNvbm5lY3QoKTogQ29ubmVjdCBtZXNzYWdlIHJlY2lldmVkIHdpdGhvdXQgY29ubmVjdGlvbkRldGFpbHNcIik7XG4gICAgfVxuICAgIGNvbnN0IG1heFByb21pc2VkSWRsZSA9IG1lc3NhZ2UuY29ubmVjdGlvbkRldGFpbHMubWF4SWRsZUludGVydmFsO1xuICAgIGlmIChtYXhQcm9taXNlZElkbGUpIHtcbiAgICAgIHRoaXMubWF4SWRsZUludGVydmFsID0gbWF4UHJvbWlzZWRJZGxlICsgdGhpcy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0O1xuICAgICAgdGhpcy5vbkFjdGl2aXR5KCk7XG4gICAgfVxuICB9XG4gIG9uRGlzY29ubmVjdChtZXNzYWdlKSB7XG4gICAgY29uc3QgZXJyID0gbWVzc2FnZSAmJiBtZXNzYWdlLmVycm9yO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlRyYW5zcG9ydC5vbkRpc2Nvbm5lY3QoKVwiLCBcImVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycikpO1xuICAgIHRoaXMuZmluaXNoKFwiZGlzY29ubmVjdGVkXCIsIGVycik7XG4gIH1cbiAgb25GYXRhbEVycm9yKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBlcnIgPSBtZXNzYWdlICYmIG1lc3NhZ2UuZXJyb3I7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiVHJhbnNwb3J0Lm9uRmF0YWxFcnJvcigpXCIsIFwiZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgdGhpcy5maW5pc2goXCJmYWlsZWRcIiwgZXJyKTtcbiAgfVxuICBvbkNsb3NlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBlcnIgPSBtZXNzYWdlICYmIG1lc3NhZ2UuZXJyb3I7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiVHJhbnNwb3J0Lm9uQ2xvc2UoKVwiLCBcImVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycikpO1xuICAgIHRoaXMuZmluaXNoKFwiY2xvc2VkXCIsIGVycik7XG4gIH1cbiAgcmVxdWVzdENsb3NlKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlRyYW5zcG9ydC5yZXF1ZXN0Q2xvc2UoKVwiLCBcIlwiKTtcbiAgICB0aGlzLnNlbmQoY2xvc2VNZXNzYWdlKTtcbiAgfVxuICByZXF1ZXN0RGlzY29ubmVjdCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJUcmFuc3BvcnQucmVxdWVzdERpc2Nvbm5lY3QoKVwiLCBcIlwiKTtcbiAgICB0aGlzLnNlbmQoZGlzY29ubmVjdE1lc3NhZ2UpO1xuICB9XG4gIHBpbmcoaWQpIHtcbiAgICBjb25zdCBtc2cgPSB7IGFjdGlvbjogYWN0aW9ucy5IRUFSVEJFQVQgfTtcbiAgICBpZiAoaWQpXG4gICAgICBtc2cuaWQgPSBpZDtcbiAgICB0aGlzLnNlbmQoZnJvbVZhbHVlcyhtc2cpKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlRyYW5zcG9ydC5kaXNwb3NlKClcIiwgXCJcIik7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLm9mZigpO1xuICB9XG4gIG9uQWN0aXZpdHkoKSB7XG4gICAgaWYgKCF0aGlzLm1heElkbGVJbnRlcnZhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3RBY3Rpdml0eSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIubGFzdEFjdGl2aXR5ID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLnNldElkbGVUaW1lcih0aGlzLm1heElkbGVJbnRlcnZhbCArIDEwMCk7XG4gIH1cbiAgc2V0SWRsZVRpbWVyKHRpbWVvdXQpIHtcbiAgICBpZiAoIXRoaXMuaWRsZVRpbWVyKSB7XG4gICAgICB0aGlzLmlkbGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLm9uSWRsZVRpbWVyRXhwaXJlKCk7XG4gICAgICB9LCB0aW1lb3V0KTtcbiAgICB9XG4gIH1cbiAgb25JZGxlVGltZXJFeHBpcmUoKSB7XG4gICAgaWYgKCF0aGlzLmxhc3RBY3Rpdml0eSB8fCAhdGhpcy5tYXhJZGxlSW50ZXJ2YWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9ydC5vbklkbGVUaW1lckV4cGlyZSgpOiBsYXN0QWN0aXZpdHkvbWF4SWRsZUludGVydmFsIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcbiAgICBjb25zdCBzaW5jZUxhc3QgPSBEYXRlLm5vdygpIC0gdGhpcy5sYXN0QWN0aXZpdHk7XG4gICAgY29uc3QgdGltZVJlbWFpbmluZyA9IHRoaXMubWF4SWRsZUludGVydmFsIC0gc2luY2VMYXN0O1xuICAgIGlmICh0aW1lUmVtYWluaW5nIDw9IDApIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwiTm8gYWN0aXZpdHkgc2VlbiBmcm9tIHJlYWx0aW1lIGluIFwiICsgc2luY2VMYXN0ICsgXCJtczsgYXNzdW1pbmcgY29ubmVjdGlvbiBoYXMgZHJvcHBlZFwiO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiVHJhbnNwb3J0Lm9uSWRsZVRpbWVyRXhwaXJlKClcIiwgbXNnKTtcbiAgICAgIHRoaXMuZGlzY29ubmVjdChuZXcgRXJyb3JJbmZvKG1zZywgODAwMDMsIDQwOCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldElkbGVUaW1lcih0aW1lUmVtYWluaW5nICsgMTAwKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHRyeUNvbm5lY3QodHJhbnNwb3J0Q3RvciwgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHRyYW5zcG9ydFBhcmFtcywgY2FsbGJhY2spIHtcbiAgICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0Q3Rvcihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgdHJhbnNwb3J0UGFyYW1zKTtcbiAgICBsZXQgdHJhbnNwb3J0QXR0ZW1wdFRpbWVyO1xuICAgIGNvbnN0IGVycm9yQ2IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0cmFuc3BvcnRBdHRlbXB0VGltZXIpO1xuICAgICAgY2FsbGJhY2soeyBldmVudDogdGhpcy5ldmVudCwgZXJyb3I6IGVyciB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlYWx0aW1lUmVxdWVzdFRpbWVvdXQgPSBjb25uZWN0aW9uTWFuYWdlci5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQ7XG4gICAgdHJhbnNwb3J0QXR0ZW1wdFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0cmFuc3BvcnQub2ZmKFtcInByZWNvbm5lY3RcIiwgXCJkaXNjb25uZWN0ZWRcIiwgXCJmYWlsZWRcIl0pO1xuICAgICAgdHJhbnNwb3J0LmRpc3Bvc2UoKTtcbiAgICAgIGVycm9yQ2IuY2FsbChcbiAgICAgICAgeyBldmVudDogXCJkaXNjb25uZWN0ZWRcIiB9LFxuICAgICAgICBuZXcgRXJyb3JJbmZvKFwiVGltZW91dCB3YWl0aW5nIGZvciB0cmFuc3BvcnQgdG8gaW5kaWNhdGUgaXRzZWxmIHZpYWJsZVwiLCA1ZTQsIDUwMClcbiAgICAgICk7XG4gICAgfSwgcmVhbHRpbWVSZXF1ZXN0VGltZW91dCk7XG4gICAgdHJhbnNwb3J0Lm9uKFtcImZhaWxlZFwiLCBcImRpc2Nvbm5lY3RlZFwiXSwgZXJyb3JDYik7XG4gICAgdHJhbnNwb3J0Lm9uKFwicHJlY29ubmVjdFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgY29ubmVjdGlvbk1hbmFnZXIubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiVHJhbnNwb3J0LnRyeUNvbm5lY3QoKVwiLFxuICAgICAgICBcInZpYWJsZSB0cmFuc3BvcnQgXCIgKyB0cmFuc3BvcnRcbiAgICAgICk7XG4gICAgICBjbGVhclRpbWVvdXQodHJhbnNwb3J0QXR0ZW1wdFRpbWVyKTtcbiAgICAgIHRyYW5zcG9ydC5vZmYoW1wiZmFpbGVkXCIsIFwiZGlzY29ubmVjdGVkXCJdLCBlcnJvckNiKTtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHRyYW5zcG9ydCk7XG4gICAgfSk7XG4gICAgdHJhbnNwb3J0LmNvbm5lY3QoKTtcbiAgICByZXR1cm4gdHJhbnNwb3J0O1xuICB9XG4gIHN0YXRpYyBpc0F2YWlsYWJsZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiaXNBdmFpbGFibGUgbm90IGltcGxlbWVudGVkIGZvciB0cmFuc3BvcnRcIiwgNWU0LCA1MDApO1xuICB9XG59O1xudmFyIHRyYW5zcG9ydF9kZWZhdWx0ID0gVHJhbnNwb3J0O1xuXG4vLyBzcmMvY29tbW9uL2NvbnN0YW50cy9UcmFuc3BvcnROYW1lLnRzXG52YXIgVHJhbnNwb3J0TmFtZXM7XG4oKFRyYW5zcG9ydE5hbWVzMikgPT4ge1xuICBUcmFuc3BvcnROYW1lczIuV2ViU29ja2V0ID0gXCJ3ZWJfc29ja2V0XCI7XG4gIFRyYW5zcG9ydE5hbWVzMi5Db21ldCA9IFwiY29tZXRcIjtcbiAgVHJhbnNwb3J0TmFtZXMyLlhoclBvbGxpbmcgPSBcInhocl9wb2xsaW5nXCI7XG59KShUcmFuc3BvcnROYW1lcyB8fCAoVHJhbnNwb3J0TmFtZXMgPSB7fSkpO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90cmFuc3BvcnQvY29ubmVjdGlvbm1hbmFnZXIudHNcbnZhciBnbG9iYWxPYmplY3QyID0gdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiBzZWxmO1xudmFyIGhhdmVXZWJTdG9yYWdlID0gKCkgPT4ge1xuICB2YXIgX2EyO1xuICByZXR1cm4gdHlwZW9mIFBsYXRmb3JtLldlYlN0b3JhZ2UgIT09IFwidW5kZWZpbmVkXCIgJiYgKChfYTIgPSBQbGF0Zm9ybS5XZWJTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmxvY2FsU3VwcG9ydGVkKTtcbn07XG52YXIgaGF2ZVNlc3Npb25TdG9yYWdlID0gKCkgPT4ge1xuICB2YXIgX2EyO1xuICByZXR1cm4gdHlwZW9mIFBsYXRmb3JtLldlYlN0b3JhZ2UgIT09IFwidW5kZWZpbmVkXCIgJiYgKChfYTIgPSBQbGF0Zm9ybS5XZWJTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnNlc3Npb25TdXBwb3J0ZWQpO1xufTtcbnZhciBub29wMiA9IGZ1bmN0aW9uKCkge1xufTtcbnZhciB0cmFuc3BvcnRQcmVmZXJlbmNlTmFtZSA9IFwiYWJseS10cmFuc3BvcnQtcHJlZmVyZW5jZVwiO1xuZnVuY3Rpb24gYnVuZGxlV2l0aChkZXN0LCBzcmMsIG1heFNpemUpIHtcbiAgbGV0IGFjdGlvbjtcbiAgaWYgKGRlc3QuY2hhbm5lbCAhPT0gc3JjLmNoYW5uZWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKChhY3Rpb24gPSBkZXN0LmFjdGlvbikgIT09IGFjdGlvbnMuUFJFU0VOQ0UgJiYgYWN0aW9uICE9PSBhY3Rpb25zLk1FU1NBR0UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFjdGlvbiAhPT0gc3JjLmFjdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBraW5kID0gYWN0aW9uID09PSBhY3Rpb25zLlBSRVNFTkNFID8gXCJwcmVzZW5jZVwiIDogXCJtZXNzYWdlc1wiLCBwcm9wb3NlZCA9IGRlc3Rba2luZF0uY29uY2F0KHNyY1traW5kXSksIHNpemUgPSBnZXRNZXNzYWdlc1NpemUocHJvcG9zZWQpO1xuICBpZiAoc2l6ZSA+IG1heFNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFhbGxTYW1lKHByb3Bvc2VkLCBcImNsaWVudElkXCIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghcHJvcG9zZWQuZXZlcnkoZnVuY3Rpb24obXNnKSB7XG4gICAgcmV0dXJuICFtc2cuaWQ7XG4gIH0pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRlc3Rba2luZF0gPSBwcm9wb3NlZDtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBkZWNvZGVSZWNvdmVyeUtleShyZWNvdmVyeUtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHJlY292ZXJ5S2V5KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG52YXIgVHJhbnNwb3J0UGFyYW1zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBob3N0LCBtb2RlLCBjb25uZWN0aW9uS2V5KSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgdGhpcy5jb25uZWN0aW9uS2V5ID0gY29ubmVjdGlvbktleTtcbiAgICB0aGlzLmZvcm1hdCA9IG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLztcbiAgfVxuICBnZXRDb25uZWN0UGFyYW1zKGF1dGhQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBhdXRoUGFyYW1zID8gY29weShhdXRoUGFyYW1zKSA6IHt9O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICAgIGNhc2UgXCJyZXN1bWVcIjpcbiAgICAgICAgcGFyYW1zLnJlc3VtZSA9IHRoaXMuY29ubmVjdGlvbktleTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmVjb3ZlclwiOiB7XG4gICAgICAgIGNvbnN0IHJlY292ZXJ5Q29udGV4dCA9IGRlY29kZVJlY292ZXJ5S2V5KG9wdGlvbnMucmVjb3Zlcik7XG4gICAgICAgIGlmIChyZWNvdmVyeUNvbnRleHQpIHtcbiAgICAgICAgICBwYXJhbXMucmVjb3ZlciA9IHJlY292ZXJ5Q29udGV4dC5jb25uZWN0aW9uS2V5O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2xpZW50SWQgIT09IHZvaWQgMCkge1xuICAgICAgcGFyYW1zLmNsaWVudElkID0gb3B0aW9ucy5jbGllbnRJZDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZWNob01lc3NhZ2VzID09PSBmYWxzZSkge1xuICAgICAgcGFyYW1zLmVjaG8gPSBcImZhbHNlXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmZvcm1hdCAhPT0gdm9pZCAwKSB7XG4gICAgICBwYXJhbXMuZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0cmVhbSAhPT0gdm9pZCAwKSB7XG4gICAgICBwYXJhbXMuc3RyZWFtID0gdGhpcy5zdHJlYW07XG4gICAgfVxuICAgIGlmICh0aGlzLmhlYXJ0YmVhdHMgIT09IHZvaWQgMCkge1xuICAgICAgcGFyYW1zLmhlYXJ0YmVhdHMgPSB0aGlzLmhlYXJ0YmVhdHM7XG4gICAgfVxuICAgIHBhcmFtcy52ID0gZGVmYXVsdHNfZGVmYXVsdC5wcm90b2NvbFZlcnNpb247XG4gICAgcGFyYW1zLmFnZW50ID0gZ2V0QWdlbnRTdHJpbmcodGhpcy5vcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy50cmFuc3BvcnRQYXJhbXMgIT09IHZvaWQgMCkge1xuICAgICAgbWl4aW4ocGFyYW1zLCBvcHRpb25zLnRyYW5zcG9ydFBhcmFtcyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiW21vZGU9XCIgKyB0aGlzLm1vZGU7XG4gICAgaWYgKHRoaXMuaG9zdCkge1xuICAgICAgcmVzdWx0ICs9IFwiLGhvc3Q9XCIgKyB0aGlzLmhvc3Q7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbm5lY3Rpb25LZXkpIHtcbiAgICAgIHJlc3VsdCArPSBcIixjb25uZWN0aW9uS2V5PVwiICsgdGhpcy5jb25uZWN0aW9uS2V5O1xuICAgIH1cbiAgICBpZiAodGhpcy5mb3JtYXQpIHtcbiAgICAgIHJlc3VsdCArPSBcIixmb3JtYXQ9XCIgKyB0aGlzLmZvcm1hdDtcbiAgICB9XG4gICAgcmVzdWx0ICs9IFwiXVwiO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG52YXIgQ29ubmVjdGlvbk1hbmFnZXIgPSBjbGFzcyBfQ29ubmVjdGlvbk1hbmFnZXIgZXh0ZW5kcyBldmVudGVtaXR0ZXJfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKHJlYWx0aW1lLCBvcHRpb25zKSB7XG4gICAgc3VwZXIocmVhbHRpbWUubG9nZ2VyKTtcbiAgICB0aGlzLnN1cHBvcnRlZFRyYW5zcG9ydHMgPSB7fTtcbiAgICB0aGlzLmRpc2Nvbm5lY3RlZFJldHJ5Q291bnQgPSAwO1xuICAgIHRoaXMucGVuZGluZ0NoYW5uZWxNZXNzYWdlc1N0YXRlID0geyBpc1Byb2Nlc3Npbmc6IGZhbHNlLCBxdWV1ZTogW10gfTtcbiAgICB0aGlzLnJlYWx0aW1lID0gcmVhbHRpbWU7XG4gICAgdGhpcy5pbml0VHJhbnNwb3J0cygpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgY29uc3QgdGltZW91dHMgPSBvcHRpb25zLnRpbWVvdXRzO1xuICAgIGNvbnN0IGNvbm5lY3RpbmdUaW1lb3V0ID0gdGltZW91dHMud2ViU29ja2V0Q29ubmVjdFRpbWVvdXQgKyB0aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0O1xuICAgIHRoaXMuc3RhdGVzID0ge1xuICAgICAgaW5pdGlhbGl6ZWQ6IHtcbiAgICAgICAgc3RhdGU6IFwiaW5pdGlhbGl6ZWRcIixcbiAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICBxdWV1ZUV2ZW50czogdHJ1ZSxcbiAgICAgICAgc2VuZEV2ZW50czogZmFsc2UsXG4gICAgICAgIGZhaWxTdGF0ZTogXCJkaXNjb25uZWN0ZWRcIlxuICAgICAgfSxcbiAgICAgIGNvbm5lY3Rpbmc6IHtcbiAgICAgICAgc3RhdGU6IFwiY29ubmVjdGluZ1wiLFxuICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgIHF1ZXVlRXZlbnRzOiB0cnVlLFxuICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgcmV0cnlEZWxheTogY29ubmVjdGluZ1RpbWVvdXQsXG4gICAgICAgIGZhaWxTdGF0ZTogXCJkaXNjb25uZWN0ZWRcIlxuICAgICAgfSxcbiAgICAgIGNvbm5lY3RlZDoge1xuICAgICAgICBzdGF0ZTogXCJjb25uZWN0ZWRcIixcbiAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICBxdWV1ZUV2ZW50czogZmFsc2UsXG4gICAgICAgIHNlbmRFdmVudHM6IHRydWUsXG4gICAgICAgIGZhaWxTdGF0ZTogXCJkaXNjb25uZWN0ZWRcIlxuICAgICAgfSxcbiAgICAgIGRpc2Nvbm5lY3RlZDoge1xuICAgICAgICBzdGF0ZTogXCJkaXNjb25uZWN0ZWRcIixcbiAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICBxdWV1ZUV2ZW50czogdHJ1ZSxcbiAgICAgICAgc2VuZEV2ZW50czogZmFsc2UsXG4gICAgICAgIHJldHJ5RGVsYXk6IHRpbWVvdXRzLmRpc2Nvbm5lY3RlZFJldHJ5VGltZW91dCxcbiAgICAgICAgZmFpbFN0YXRlOiBcImRpc2Nvbm5lY3RlZFwiXG4gICAgICB9LFxuICAgICAgc3VzcGVuZGVkOiB7XG4gICAgICAgIHN0YXRlOiBcInN1c3BlbmRlZFwiLFxuICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgIHF1ZXVlRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgc2VuZEV2ZW50czogZmFsc2UsXG4gICAgICAgIHJldHJ5RGVsYXk6IHRpbWVvdXRzLnN1c3BlbmRlZFJldHJ5VGltZW91dCxcbiAgICAgICAgZmFpbFN0YXRlOiBcInN1c3BlbmRlZFwiXG4gICAgICB9LFxuICAgICAgY2xvc2luZzoge1xuICAgICAgICBzdGF0ZTogXCJjbG9zaW5nXCIsXG4gICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgcXVldWVFdmVudHM6IGZhbHNlLFxuICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgcmV0cnlEZWxheTogdGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dCxcbiAgICAgICAgZmFpbFN0YXRlOiBcImNsb3NlZFwiXG4gICAgICB9LFxuICAgICAgY2xvc2VkOiB7IHN0YXRlOiBcImNsb3NlZFwiLCB0ZXJtaW5hbDogdHJ1ZSwgcXVldWVFdmVudHM6IGZhbHNlLCBzZW5kRXZlbnRzOiBmYWxzZSwgZmFpbFN0YXRlOiBcImNsb3NlZFwiIH0sXG4gICAgICBmYWlsZWQ6IHsgc3RhdGU6IFwiZmFpbGVkXCIsIHRlcm1pbmFsOiB0cnVlLCBxdWV1ZUV2ZW50czogZmFsc2UsIHNlbmRFdmVudHM6IGZhbHNlLCBmYWlsU3RhdGU6IFwiZmFpbGVkXCIgfVxuICAgIH07XG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzLmluaXRpYWxpemVkO1xuICAgIHRoaXMuZXJyb3JSZWFzb24gPSBudWxsO1xuICAgIHRoaXMucXVldWVkTWVzc2FnZXMgPSBuZXcgbWVzc2FnZXF1ZXVlX2RlZmF1bHQodGhpcy5sb2dnZXIpO1xuICAgIHRoaXMubXNnU2VyaWFsID0gMDtcbiAgICB0aGlzLmNvbm5lY3Rpb25EZXRhaWxzID0gdm9pZCAwO1xuICAgIHRoaXMuY29ubmVjdGlvbklkID0gdm9pZCAwO1xuICAgIHRoaXMuY29ubmVjdGlvbktleSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCA9IHRpbWVvdXRzLmNvbm5lY3Rpb25TdGF0ZVR0bDtcbiAgICB0aGlzLm1heElkbGVJbnRlcnZhbCA9IG51bGw7XG4gICAgdGhpcy50cmFuc3BvcnRzID0gaW50ZXJzZWN0KG9wdGlvbnMudHJhbnNwb3J0cyB8fCBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRUcmFuc3BvcnRzLCB0aGlzLnN1cHBvcnRlZFRyYW5zcG9ydHMpO1xuICAgIHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSA9IG51bGw7XG4gICAgaWYgKHRoaXMudHJhbnNwb3J0cy5pbmNsdWRlcyhUcmFuc3BvcnROYW1lcy5XZWJTb2NrZXQpKSB7XG4gICAgICB0aGlzLndlYlNvY2tldFRyYW5zcG9ydEF2YWlsYWJsZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLnRyYW5zcG9ydHMuaW5jbHVkZXMoVHJhbnNwb3J0TmFtZXMuWGhyUG9sbGluZykpIHtcbiAgICAgIHRoaXMuYmFzZVRyYW5zcG9ydCA9IFRyYW5zcG9ydE5hbWVzLlhoclBvbGxpbmc7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRyYW5zcG9ydHMuaW5jbHVkZXMoVHJhbnNwb3J0TmFtZXMuQ29tZXQpKSB7XG4gICAgICB0aGlzLmJhc2VUcmFuc3BvcnQgPSBUcmFuc3BvcnROYW1lcy5Db21ldDtcbiAgICB9XG4gICAgdGhpcy5kb21haW5zID0gZGVmYXVsdHNfZGVmYXVsdC5nZXRIb3N0cyhvcHRpb25zKTtcbiAgICB0aGlzLmFjdGl2ZVByb3RvY29sID0gbnVsbDtcbiAgICB0aGlzLmhvc3QgPSBudWxsO1xuICAgIHRoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ID0gbnVsbDtcbiAgICB0aGlzLmxhc3RBY3Rpdml0eSA9IG51bGw7XG4gICAgdGhpcy5mb3JjZUZhbGxiYWNrSG9zdCA9IGZhbHNlO1xuICAgIHRoaXMuY29ubmVjdENvdW50ZXIgPSAwO1xuICAgIHRoaXMud3NDaGVja1Jlc3VsdCA9IG51bGw7XG4gICAgdGhpcy53ZWJTb2NrZXRTbG93VGltZXIgPSBudWxsO1xuICAgIHRoaXMud2ViU29ja2V0R2l2ZVVwVGltZXIgPSBudWxsO1xuICAgIHRoaXMuYWJhbmRvbmVkV2ViU29ja2V0ID0gZmFsc2U7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKVwiLCBcInN0YXJ0ZWRcIik7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKClcIixcbiAgICAgIFwicmVxdWVzdGVkIHRyYW5zcG9ydHMgPSBbXCIgKyAob3B0aW9ucy50cmFuc3BvcnRzIHx8IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFRyYW5zcG9ydHMpICsgXCJdXCJcbiAgICApO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpXCIsXG4gICAgICBcImF2YWlsYWJsZSB0cmFuc3BvcnRzID0gW1wiICsgdGhpcy50cmFuc3BvcnRzICsgXCJdXCJcbiAgICApO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpXCIsXG4gICAgICBcImh0dHAgZG9tYWlucyA9IFtcIiArIHRoaXMuZG9tYWlucyArIFwiXVwiXG4gICAgKTtcbiAgICBpZiAoIXRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwibm8gcmVxdWVzdGVkIHRyYW5zcG9ydHMgYXZhaWxhYmxlXCI7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJyZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpXCIsIG1zZyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG4gICAgY29uc3QgYWRkRXZlbnRMaXN0ZW5lciA9IFBsYXRmb3JtLkNvbmZpZy5hZGRFdmVudExpc3RlbmVyO1xuICAgIGlmIChhZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBpZiAoaGF2ZVNlc3Npb25TdG9yYWdlKCkgJiYgdHlwZW9mIG9wdGlvbnMucmVjb3ZlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgdGhpcy5wZXJzaXN0Q29ubmVjdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmNsb3NlT25VbmxvYWQgPT09IHRydWUpIHtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsXG4gICAgICAgICAgICBcIlJlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKClcIixcbiAgICAgICAgICAgIFwiYmVmb3JldW5sb2FkIGV2ZW50IGhhcyB0cmlnZ2VyZWQgdGhlIGNvbm5lY3Rpb24gdG8gY2xvc2UgYXMgY2xvc2VPblVubG9hZCBpcyB0cnVlXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKHsgc3RhdGU6IFwiY2xvc2luZ1wiIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgKCkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5kaXNjb25uZWN0ZWQgfHwgdGhpcy5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5zdXNwZW5kZWQpIHtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIgY2F1Z2h0IGJyb3dzZXIgXFx1MjAxOG9ubGluZVxcdTIwMTkgZXZlbnRcIixcbiAgICAgICAgICAgIFwicmVhdHRlbXB0aW5nIGNvbm5lY3Rpb25cIlxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogXCJjb25uZWN0aW5nXCIgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nKSB7XG4gICAgICAgICAgKF9hMiA9IHRoaXMucGVuZGluZ1RyYW5zcG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5vZmYoKTtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG4gICAgICAgICAgdGhpcy5zdGFydENvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZCkge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBjYXVnaHQgYnJvd3NlciBcXHUyMDE4b2ZmbGluZVxcdTIwMTkgZXZlbnRcIixcbiAgICAgICAgICAgIFwiZGlzY29ubmVjdGluZyBhY3RpdmUgdHJhbnNwb3J0XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKioqKioqKioqKioqKioqKioqKipcbiAgICogdHJhbnNwb3J0IG1hbmFnZW1lbnRcbiAgICoqKioqKioqKioqKioqKioqKioqKi9cbiAgLy8gVXNlZCBieSB0ZXN0c1xuICBzdGF0aWMgc3VwcG9ydGVkVHJhbnNwb3J0cyhhZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHsgc3VwcG9ydGVkVHJhbnNwb3J0czoge30gfTtcbiAgICB0aGlzLmluaXRUcmFuc3BvcnRzKGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMsIHN0b3JhZ2UpO1xuICAgIHJldHVybiBzdG9yYWdlLnN1cHBvcnRlZFRyYW5zcG9ydHM7XG4gIH1cbiAgc3RhdGljIGluaXRUcmFuc3BvcnRzKGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMsIHN0b3JhZ2UpIHtcbiAgICBjb25zdCBpbXBsZW1lbnRhdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgUGxhdGZvcm0uVHJhbnNwb3J0cy5idW5kbGVkSW1wbGVtZW50YXRpb25zKSwgYWRkaXRpb25hbEltcGxlbWVudGF0aW9ucyk7XG4gICAgW1RyYW5zcG9ydE5hbWVzLldlYlNvY2tldCwgLi4uUGxhdGZvcm0uVHJhbnNwb3J0cy5vcmRlcl0uZm9yRWFjaCgodHJhbnNwb3J0TmFtZSkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNwb3J0ID0gaW1wbGVtZW50YXRpb25zW3RyYW5zcG9ydE5hbWVdO1xuICAgICAgaWYgKHRyYW5zcG9ydCAmJiB0cmFuc3BvcnQuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICBzdG9yYWdlLnN1cHBvcnRlZFRyYW5zcG9ydHNbdHJhbnNwb3J0TmFtZV0gPSB0cmFuc3BvcnQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaW5pdFRyYW5zcG9ydHMoKSB7XG4gICAgX0Nvbm5lY3Rpb25NYW5hZ2VyLmluaXRUcmFuc3BvcnRzKHRoaXMucmVhbHRpbWUuX2FkZGl0aW9uYWxUcmFuc3BvcnRJbXBsZW1lbnRhdGlvbnMsIHRoaXMpO1xuICB9XG4gIGNyZWF0ZVRyYW5zcG9ydFBhcmFtcyhob3N0LCBtb2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc3BvcnRQYXJhbXModGhpcy5vcHRpb25zLCBob3N0LCBtb2RlLCB0aGlzLmNvbm5lY3Rpb25LZXkpO1xuICB9XG4gIGdldFRyYW5zcG9ydFBhcmFtcyhjYWxsYmFjaykge1xuICAgIGNvbnN0IGRlY2lkZU1vZGUgPSAobW9kZUNiKSA9PiB7XG4gICAgICBpZiAodGhpcy5jb25uZWN0aW9uS2V5KSB7XG4gICAgICAgIG1vZGVDYihcInJlc3VtZVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucmVjb3ZlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtb2RlQ2IoXCJyZWNvdmVyXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZWNvdmVyRm4gPSB0aGlzLm9wdGlvbnMucmVjb3ZlciwgbGFzdFNlc3Npb25EYXRhID0gdGhpcy5nZXRTZXNzaW9uUmVjb3ZlckRhdGEoKSwgc2Vzc2lvblJlY292ZXJ5TmFtZSA9IHRoaXMuc2Vzc2lvblJlY292ZXJ5TmFtZSgpO1xuICAgICAgaWYgKGxhc3RTZXNzaW9uRGF0YSAmJiB0eXBlb2YgcmVjb3ZlckZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmdldFRyYW5zcG9ydFBhcmFtcygpXCIsXG4gICAgICAgICAgXCJDYWxsaW5nIGNsaWVudE9wdGlvbnMtcHJvdmlkZWQgcmVjb3ZlciBmdW5jdGlvbiB3aXRoIGxhc3Qgc2Vzc2lvbiBkYXRhIChyZWNvdmVyeSBzY29wZTogXCIgKyBzZXNzaW9uUmVjb3ZlcnlOYW1lICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmVjb3ZlckZuKGxhc3RTZXNzaW9uRGF0YSwgKHNob3VsZFJlY292ZXIpID0+IHtcbiAgICAgICAgICBpZiAoc2hvdWxkUmVjb3Zlcikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJlY292ZXIgPSBsYXN0U2Vzc2lvbkRhdGEucmVjb3ZlcnlLZXk7XG4gICAgICAgICAgICBtb2RlQ2IoXCJyZWNvdmVyXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2RlQ2IoXCJjbGVhblwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtb2RlQ2IoXCJjbGVhblwiKTtcbiAgICB9O1xuICAgIGRlY2lkZU1vZGUoKG1vZGUpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zcG9ydFBhcmFtcyA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0UGFyYW1zKG51bGwsIG1vZGUpO1xuICAgICAgaWYgKG1vZGUgPT09IFwicmVjb3ZlclwiKSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5nZXRUcmFuc3BvcnRQYXJhbXMoKVwiLFxuICAgICAgICAgIFwiVHJhbnNwb3J0IHJlY292ZXJ5IG1vZGUgPSByZWNvdmVyOyByZWNvdmVyeUtleSA9IFwiICsgdGhpcy5vcHRpb25zLnJlY292ZXJcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcmVjb3ZlcnlDb250ZXh0ID0gZGVjb2RlUmVjb3ZlcnlLZXkodGhpcy5vcHRpb25zLnJlY292ZXIpO1xuICAgICAgICBpZiAocmVjb3ZlcnlDb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy5tc2dTZXJpYWwgPSByZWNvdmVyeUNvbnRleHQubXNnU2VyaWFsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZ2V0VHJhbnNwb3J0UGFyYW1zKClcIixcbiAgICAgICAgICBcIlRyYW5zcG9ydCBwYXJhbXMgPSBcIiArIHRyYW5zcG9ydFBhcmFtcy50b1N0cmluZygpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayh0cmFuc3BvcnRQYXJhbXMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIGNvbm5lY3QgdXNpbmcgYSBnaXZlbiB0cmFuc3BvcnRcbiAgICogQHBhcmFtIHRyYW5zcG9ydFBhcmFtc1xuICAgKiBAcGFyYW0gY2FuZGlkYXRlLCB0aGUgdHJhbnNwb3J0IHRvIHRyeVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCBjYW5kaWRhdGUsIGNhbGxiYWNrKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ29ubmVjdGlvbk1hbmFnZXIudHJ5QVRyYW5zcG9ydCgpXCIsIFwidHJ5aW5nIFwiICsgY2FuZGlkYXRlKTtcbiAgICB0aGlzLnByb3Bvc2VkVHJhbnNwb3J0ID0gdHJhbnNwb3J0X2RlZmF1bHQudHJ5Q29ubmVjdChcbiAgICAgIHRoaXMuc3VwcG9ydGVkVHJhbnNwb3J0c1tjYW5kaWRhdGVdLFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMucmVhbHRpbWUuYXV0aCxcbiAgICAgIHRyYW5zcG9ydFBhcmFtcyxcbiAgICAgICh3cmFwcGVkRXJyLCB0cmFuc3BvcnQpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgPT0gdGhpcy5zdGF0ZXMuY2xvc2luZyB8fCBzdGF0ZSA9PSB0aGlzLnN0YXRlcy5jbG9zZWQgfHwgc3RhdGUgPT0gdGhpcy5zdGF0ZXMuZmFpbGVkKSB7XG4gICAgICAgICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKVwiLFxuICAgICAgICAgICAgICBcImNvbm5lY3Rpb24gXCIgKyBzdGF0ZS5zdGF0ZSArIFwiIHdoaWxlIHdlIHdlcmUgYXR0ZW1wdGluZyB0aGUgdHJhbnNwb3J0OyBjbG9zaW5nIFwiICsgdHJhbnNwb3J0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3JhcHBlZEVycikge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci50cnlBVHJhbnNwb3J0KClcIixcbiAgICAgICAgICAgIFwidHJhbnNwb3J0IFwiICsgY2FuZGlkYXRlICsgXCIgXCIgKyB3cmFwcGVkRXJyLmV2ZW50ICsgXCIsIGVycjogXCIgKyB3cmFwcGVkRXJyLmVycm9yLnRvU3RyaW5nKClcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChhdXRoX2RlZmF1bHQuaXNUb2tlbkVycih3cmFwcGVkRXJyLmVycm9yKSAmJiAhKHRoaXMuZXJyb3JSZWFzb24gJiYgYXV0aF9kZWZhdWx0LmlzVG9rZW5FcnIodGhpcy5lcnJvclJlYXNvbikpKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yUmVhc29uID0gd3JhcHBlZEVyci5lcnJvcjtcbiAgICAgICAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyh0aGlzLnJlYWx0aW1lLmF1dGguX2ZvcmNlTmV3VG9rZW4obnVsbCwgbnVsbCksIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgY2FuZGlkYXRlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdyYXBwZWRFcnIuZXZlbnQgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogXCJmYWlsZWRcIiwgZXJyb3I6IHdyYXBwZWRFcnIuZXJyb3IgfSk7XG4gICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdyYXBwZWRFcnIuZXZlbnQgPT09IFwiZGlzY29ubmVjdGVkXCIpIHtcbiAgICAgICAgICAgIGlmICghaXNSZXRyaWFibGUod3JhcHBlZEVyci5lcnJvcikpIHtcbiAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSwgZXJyb3I6IHdyYXBwZWRFcnIuZXJyb3IgfSk7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKVwiLFxuICAgICAgICAgIFwidmlhYmxlIHRyYW5zcG9ydCBcIiArIGNhbmRpZGF0ZSArIFwiOyBzZXR0aW5nIHBlbmRpbmdcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLnNldFRyYW5zcG9ydFBlbmRpbmcodHJhbnNwb3J0LCB0cmFuc3BvcnRQYXJhbXMpO1xuICAgICAgICBjYWxsYmFjayhudWxsLCB0cmFuc3BvcnQpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGlzIGluZGljYXRlZCB0byBiZSB2aWFibGUsIGFuZCB0aGUgQ29ubmVjdGlvbk1hbmFnZXJcbiAgICogZXhwZWN0cyB0byBhY3RpdmF0ZSB0aGlzIHRyYW5zcG9ydCBhcyBzb29uIGFzIGl0IGlzIGNvbm5lY3RlZC5cbiAgICogQHBhcmFtIHRyYW5zcG9ydFxuICAgKiBAcGFyYW0gdHJhbnNwb3J0UGFyYW1zXG4gICAqL1xuICBzZXRUcmFuc3BvcnRQZW5kaW5nKHRyYW5zcG9ydCwgdHJhbnNwb3J0UGFyYW1zKSB7XG4gICAgY29uc3QgbW9kZSA9IHRyYW5zcG9ydFBhcmFtcy5tb2RlO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5zZXRUcmFuc3BvcnRQZW5kaW5nKClcIixcbiAgICAgIFwidHJhbnNwb3J0ID0gXCIgKyB0cmFuc3BvcnQgKyBcIjsgbW9kZSA9IFwiICsgbW9kZVxuICAgICk7XG4gICAgdGhpcy5wZW5kaW5nVHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIHRoaXMuY2FuY2VsV2ViU29ja2V0U2xvd1RpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxXZWJTb2NrZXRHaXZlVXBUaW1lcigpO1xuICAgIHRyYW5zcG9ydC5vbmNlKFwiY29ubmVjdGVkXCIsIChlcnJvciwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscykgPT4ge1xuICAgICAgdGhpcy5hY3RpdmF0ZVRyYW5zcG9ydChlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKTtcbiAgICAgIGlmIChtb2RlID09PSBcInJlY292ZXJcIiAmJiB0aGlzLm9wdGlvbnMucmVjb3Zlcikge1xuICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zLnJlY292ZXI7XG4gICAgICAgIHRoaXMudW5wZXJzaXN0Q29ubmVjdGlvbigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHNlbGYyID0gdGhpcztcbiAgICB0cmFuc3BvcnQub24oW1wiZGlzY29ubmVjdGVkXCIsIFwiY2xvc2VkXCIsIFwiZmFpbGVkXCJdLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgc2VsZjIuZGVhY3RpdmF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQsIHRoaXMuZXZlbnQsIGVycm9yKTtcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoXCJ0cmFuc3BvcnQucGVuZGluZ1wiLCB0cmFuc3BvcnQpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBpcyBjb25uZWN0ZWQsIGFuZCB0aGUgY29ubmVjdGlvbm1hbmFnZXIgZGVjaWRlcyB0aGF0XG4gICAqIGl0IHdpbGwgbm93IGJlIHRoZSBhY3RpdmUgdHJhbnNwb3J0LiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGl0IGFjdGl2YXRlZFxuICAgKiB0aGUgdHJhbnNwb3J0IChpZiB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nL2Nsb3NlZCBpdCB3aWxsIGNob29zZSBub3QgdG8pLlxuICAgKiBAcGFyYW0gdHJhbnNwb3J0IHRoZSB0cmFuc3BvcnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIGNvbm5lY3Rpb25JZCB0aGUgaWQgb2YgdGhlIG5ldyBhY3RpdmUgY29ubmVjdGlvblxuICAgKiBAcGFyYW0gY29ubmVjdGlvbkRldGFpbHMgdGhlIGRldGFpbHMgb2YgdGhlIG5ldyBhY3RpdmUgY29ubmVjdGlvblxuICAgKi9cbiAgYWN0aXZhdGVUcmFuc3BvcnQoZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICBcInRyYW5zcG9ydCA9IFwiICsgdHJhbnNwb3J0XG4gICAgKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KClcIiwgXCJlcnJvciA9IFwiICsgZXJyb3IpO1xuICAgIH1cbiAgICBpZiAoY29ubmVjdGlvbklkKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICBcImNvbm5lY3Rpb25JZCA9ICBcIiArIGNvbm5lY3Rpb25JZFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNvbm5lY3Rpb25EZXRhaWxzKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICBcImNvbm5lY3Rpb25EZXRhaWxzID0gIFwiICsgSlNPTi5zdHJpbmdpZnkoY29ubmVjdGlvbkRldGFpbHMpXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKHRyYW5zcG9ydCk7XG4gICAgY29uc3QgZXhpc3RpbmdTdGF0ZSA9IHRoaXMuc3RhdGUsIGNvbm5lY3RlZFN0YXRlID0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkLnN0YXRlO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICBcImN1cnJlbnQgc3RhdGUgPSBcIiArIGV4aXN0aW5nU3RhdGUuc3RhdGVcbiAgICApO1xuICAgIGlmIChleGlzdGluZ1N0YXRlLnN0YXRlID09IHRoaXMuc3RhdGVzLmNsb3Npbmcuc3RhdGUgfHwgZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5jbG9zZWQuc3RhdGUgfHwgZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5mYWlsZWQuc3RhdGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICAgIFwiRGlzY29ubmVjdGluZyB0cmFuc3BvcnQgYW5kIGFiYW5kb25pbmdcIlxuICAgICAgKTtcbiAgICAgIHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUcmFuc3BvcnQ7XG4gICAgaWYgKCF0cmFuc3BvcnQuaXNDb25uZWN0ZWQpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICAgIFwiRGVjbGluaW5nIHRvIGFjdGl2YXRlIHRyYW5zcG9ydCBcIiArIHRyYW5zcG9ydCArIFwiIHNpbmNlIGl0IGFwcGVhcnMgdG8gbm8gbG9uZ2VyIGJlIGNvbm5lY3RlZFwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0FjdGl2ZVByb3RvY29sID0gdGhpcy5hY3RpdmVQcm90b2NvbDtcbiAgICB0aGlzLmFjdGl2ZVByb3RvY29sID0gbmV3IHByb3RvY29sX2RlZmF1bHQodHJhbnNwb3J0KTtcbiAgICB0aGlzLmhvc3QgPSB0cmFuc3BvcnQucGFyYW1zLmhvc3Q7XG4gICAgY29uc3QgY29ubmVjdGlvbktleSA9IGNvbm5lY3Rpb25EZXRhaWxzLmNvbm5lY3Rpb25LZXk7XG4gICAgaWYgKGNvbm5lY3Rpb25LZXkgJiYgdGhpcy5jb25uZWN0aW9uS2V5ICE9IGNvbm5lY3Rpb25LZXkpIHtcbiAgICAgIHRoaXMuc2V0Q29ubmVjdGlvbihjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCAhIWVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKGNvbm5lY3Rpb25EZXRhaWxzLCB0cmFuc3BvcnQpO1xuICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICB0cmFuc3BvcnQub24oXG4gICAgICAgIFwiY29ubmVjdGVkXCIsXG4gICAgICAgIChjb25uZWN0ZWRFcnIsIF9jb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzMikgPT4ge1xuICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZShjb25uZWN0aW9uRGV0YWlsczIsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIG5ldyBjb25uZWN0aW9uc3RhdGVjaGFuZ2VfZGVmYXVsdChjb25uZWN0ZWRTdGF0ZSwgY29ubmVjdGVkU3RhdGUsIG51bGwsIGNvbm5lY3RlZEVycikpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICAgIGlmIChleGlzdGluZ1N0YXRlLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGUpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aGlzLmVycm9yUmVhc29uID0gdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmVycm9yUmVhc29uID0gZXJyb3I7XG4gICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCBuZXcgY29ubmVjdGlvbnN0YXRlY2hhbmdlX2RlZmF1bHQoY29ubmVjdGVkU3RhdGUsIGNvbm5lY3RlZFN0YXRlLCBudWxsLCBlcnJvcikpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IFwiY29ubmVjdGVkXCIsIGVycm9yIH0pO1xuICAgICAgdGhpcy5lcnJvclJlYXNvbiA9IHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5lcnJvclJlYXNvbiA9IGVycm9yIHx8IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcInRyYW5zcG9ydC5hY3RpdmVcIiwgdHJhbnNwb3J0KTtcbiAgICBpZiAoZXhpc3RpbmdBY3RpdmVQcm90b2NvbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wubWVzc2FnZVF1ZXVlLmNvdW50KCkgPiAwKSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICAgICAgXCJQcmV2aW91cyBhY3RpdmUgcHJvdG9jb2wgKGZvciB0cmFuc3BvcnQgXCIgKyBleGlzdGluZ0FjdGl2ZVByb3RvY29sLnRyYW5zcG9ydC5zaG9ydE5hbWUgKyBcIiwgbmV3IG9uZSBpcyBcIiArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyBcIikgZmluaXNoaW5nIHdpdGggXCIgKyBleGlzdGluZ0FjdGl2ZVByb3RvY29sLm1lc3NhZ2VRdWV1ZS5jb3VudCgpICsgXCIgbWVzc2FnZXMgc3RpbGwgcGVuZGluZ1wiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZXhpc3RpbmdBY3RpdmVQcm90b2NvbC50cmFuc3BvcnQgPT09IHRyYW5zcG9ydCkge1xuICAgICAgICBjb25zdCBtc2cgPSBcIkFzc3VtcHRpb24gdmlvbGF0ZWQ6IGFjdGl2YXRpbmcgYSB0cmFuc3BvcnQgdGhhdCB3YXMgYWxzbyB0aGUgdHJhbnNwb3J0IGZvciB0aGUgcHJldmlvdXMgYWN0aXZlIHByb3RvY29sOyB0cmFuc3BvcnQgPSBcIiArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyBcIjsgc3RhY2sgPSBcIiArIG5ldyBFcnJvcigpLnN0YWNrO1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsIG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZ0FjdGl2ZVByb3RvY29sLmZpbmlzaCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSB0cmFuc3BvcnQgaXMgbm8gbG9uZ2VyIHRoZSBhY3RpdmUgdHJhbnNwb3J0LiBUaGlzIGNhbiBvY2N1clxuICAgKiBpbiBhbnkgdHJhbnNwb3J0IGNvbm5lY3Rpb24gc3RhdGUuXG4gICAqIEBwYXJhbSB0cmFuc3BvcnRcbiAgICovXG4gIGRlYWN0aXZhdGVUcmFuc3BvcnQodHJhbnNwb3J0LCBzdGF0ZSwgZXJyb3IpIHtcbiAgICBjb25zdCBjdXJyZW50UHJvdG9jb2wgPSB0aGlzLmFjdGl2ZVByb3RvY29sLCB3YXNBY3RpdmUgPSBjdXJyZW50UHJvdG9jb2wgJiYgY3VycmVudFByb3RvY29sLmdldFRyYW5zcG9ydCgpID09PSB0cmFuc3BvcnQsIHdhc1BlbmRpbmcgPSB0cmFuc3BvcnQgPT09IHRoaXMucGVuZGluZ1RyYW5zcG9ydCwgbm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbiA9IHRoaXMubm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbigpO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KClcIixcbiAgICAgIFwidHJhbnNwb3J0ID0gXCIgKyB0cmFuc3BvcnRcbiAgICApO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KClcIixcbiAgICAgIFwic3RhdGUgPSBcIiArIHN0YXRlICsgKHdhc0FjdGl2ZSA/IFwiOyB3YXMgYWN0aXZlXCIgOiB3YXNQZW5kaW5nID8gXCI7IHdhcyBwZW5kaW5nXCIgOiBcIlwiKSArIChub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uID8gXCJcIiA6IFwiOyBhbm90aGVyIHRyYW5zcG9ydCBpcyBzY2hlZHVsZWQgZm9yIGFjdGl2YXRpb25cIilcbiAgICApO1xuICAgIGlmIChlcnJvciAmJiBlcnJvci5tZXNzYWdlKVxuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICBcInJlYXNvbiA9ICBcIiArIGVycm9yLm1lc3NhZ2VcbiAgICAgICk7XG4gICAgaWYgKHdhc0FjdGl2ZSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICBcIkdldHRpbmcsIGNsZWFyaW5nLCBhbmQgcmVxdWV1aW5nIFwiICsgdGhpcy5hY3RpdmVQcm90b2NvbC5tZXNzYWdlUXVldWUuY291bnQoKSArIFwiIHBlbmRpbmcgbWVzc2FnZXNcIlxuICAgICAgKTtcbiAgICAgIHRoaXMucXVldWVQZW5kaW5nTWVzc2FnZXMoY3VycmVudFByb3RvY29sLmdldFBlbmRpbmdNZXNzYWdlcygpKTtcbiAgICAgIGN1cnJlbnRQcm90b2NvbC5jbGVhclBlbmRpbmdNZXNzYWdlcygpO1xuICAgICAgdGhpcy5hY3RpdmVQcm90b2NvbCA9IHRoaXMuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcInRyYW5zcG9ydC5pbmFjdGl2ZVwiLCB0cmFuc3BvcnQpO1xuICAgIGlmICh3YXNBY3RpdmUgJiYgbm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbiB8fCB3YXNBY3RpdmUgJiYgc3RhdGUgPT09IFwiZmFpbGVkXCIgfHwgc3RhdGUgPT09IFwiY2xvc2VkXCIgfHwgY3VycmVudFByb3RvY29sID09PSBudWxsICYmIHdhc1BlbmRpbmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gXCJkaXNjb25uZWN0ZWRcIiAmJiBlcnJvciAmJiBlcnJvci5zdGF0dXNDb2RlID4gNTAwICYmIHRoaXMuZG9tYWlucy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuICAgICAgICB0aGlzLmZvcmNlRmFsbGJhY2tIb3N0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlLCBlcnJvciwgcmV0cnlJbW1lZGlhdGVseTogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3Q29ubmVjdGlvblN0YXRlID0gc3RhdGUgPT09IFwiZmFpbGVkXCIgJiYgYXV0aF9kZWZhdWx0LmlzVG9rZW5FcnIoZXJyb3IpID8gXCJkaXNjb25uZWN0ZWRcIiA6IHN0YXRlO1xuICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiBuZXdDb25uZWN0aW9uU3RhdGUsIGVycm9yIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICAvKiBIZWxwZXIgdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlcmUgYXJlIG5vIHRyYW5zcG9ydHMgd2hpY2ggYXJlIHBlbmRpbmcsXG4gICAqIGhhdmUgYmVlbiBjb25uZWN0ZWQsIGFuZCBhcmUganVzdCB3YWl0aW5nIGZvciBvbmNlTm9QZW5kaW5nIHRvIGZpcmUgYmVmb3JlXG4gICAqIGJlaW5nIGFjdGl2YXRlZCAqL1xuICBub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy5wZW5kaW5nVHJhbnNwb3J0IHx8ICF0aGlzLnBlbmRpbmdUcmFuc3BvcnQuaXNDb25uZWN0ZWQ7XG4gIH1cbiAgc2V0Q29ubmVjdGlvbihjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCBoYXNDb25uZWN0aW9uRXJyb3IpIHtcbiAgICBjb25zdCBwcmV2Q29ubklkID0gdGhpcy5jb25uZWN0aW9uSWQsIGNvbm5JZENoYW5nZWQgPSBwcmV2Q29ubklkICYmIHByZXZDb25uSWQgIT09IGNvbm5lY3Rpb25JZCwgcmVjb3ZlckZhaWx1cmUgPSAhcHJldkNvbm5JZCAmJiBoYXNDb25uZWN0aW9uRXJyb3I7XG4gICAgaWYgKGNvbm5JZENoYW5nZWQgfHwgcmVjb3ZlckZhaWx1cmUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLnNldENvbm5lY3Rpb24oKVwiLCBcIlJlc2V0dGluZyBtc2dTZXJpYWxcIik7XG4gICAgICB0aGlzLm1zZ1NlcmlhbCA9IDA7XG4gICAgICB0aGlzLnF1ZXVlZE1lc3NhZ2VzLnJlc2V0U2VuZEF0dGVtcHRlZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25uZWN0aW9uSWQgIT09IGNvbm5lY3Rpb25JZCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnNldENvbm5lY3Rpb24oKVwiLFxuICAgICAgICBcIk5ldyBjb25uZWN0aW9uSWQ7IHJlYXR0YWNoaW5nIGFueSBhdHRhY2hlZCBjaGFubmVsc1wiXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uaWQgPSB0aGlzLmNvbm5lY3Rpb25JZCA9IGNvbm5lY3Rpb25JZDtcbiAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24ua2V5ID0gdGhpcy5jb25uZWN0aW9uS2V5ID0gY29ubmVjdGlvbkRldGFpbHMuY29ubmVjdGlvbktleTtcbiAgfVxuICBjbGVhckNvbm5lY3Rpb24oKSB7XG4gICAgdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmlkID0gdGhpcy5jb25uZWN0aW9uSWQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmtleSA9IHRoaXMuY29ubmVjdGlvbktleSA9IHZvaWQgMDtcbiAgICB0aGlzLm1zZ1NlcmlhbCA9IDA7XG4gICAgdGhpcy51bnBlcnNpc3RDb25uZWN0aW9uKCk7XG4gIH1cbiAgY3JlYXRlUmVjb3ZlcnlLZXkoKSB7XG4gICAgaWYgKCF0aGlzLmNvbm5lY3Rpb25LZXkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgY29ubmVjdGlvbktleTogdGhpcy5jb25uZWN0aW9uS2V5LFxuICAgICAgbXNnU2VyaWFsOiB0aGlzLm1zZ1NlcmlhbCxcbiAgICAgIGNoYW5uZWxTZXJpYWxzOiB0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLmNoYW5uZWxTZXJpYWxzKClcbiAgICB9KTtcbiAgfVxuICBjaGVja0Nvbm5lY3Rpb25TdGF0ZUZyZXNobmVzcygpIHtcbiAgICBpZiAoIXRoaXMubGFzdEFjdGl2aXR5IHx8ICF0aGlzLmNvbm5lY3Rpb25JZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaW5jZUxhc3QgPSBEYXRlLm5vdygpIC0gdGhpcy5sYXN0QWN0aXZpdHk7XG4gICAgaWYgKHNpbmNlTGFzdCA+IHRoaXMuY29ubmVjdGlvblN0YXRlVHRsICsgdGhpcy5tYXhJZGxlSW50ZXJ2YWwpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5jaGVja0Nvbm5lY3Rpb25TdGF0ZUZyZXNobmVzcygpXCIsXG4gICAgICAgIFwiTGFzdCBrbm93biBhY3Rpdml0eSBmcm9tIHJlYWx0aW1lIHdhcyBcIiArIHNpbmNlTGFzdCArIFwibXMgYWdvOyBkaXNjYXJkaW5nIGNvbm5lY3Rpb24gc3RhdGVcIlxuICAgICAgKTtcbiAgICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uKCk7XG4gICAgICB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSA9IFwic3VzcGVuZGVkXCI7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbm1hbmFnZXIgd2FudHMgdG8gcGVyc2lzdCB0cmFuc3BvcnRcbiAgICogc3RhdGUgZm9yIGxhdGVyIHJlY292ZXJ5LiBPbmx5IGFwcGxpY2FibGUgaW4gdGhlIGJyb3dzZXIgY29udGV4dC5cbiAgICovXG4gIHBlcnNpc3RDb25uZWN0aW9uKCkge1xuICAgIGlmIChoYXZlU2Vzc2lvblN0b3JhZ2UoKSkge1xuICAgICAgY29uc3QgcmVjb3ZlcnlLZXkgPSB0aGlzLmNyZWF0ZVJlY292ZXJ5S2V5KCk7XG4gICAgICBpZiAocmVjb3ZlcnlLZXkpIHtcbiAgICAgICAgdGhpcy5zZXRTZXNzaW9uUmVjb3ZlckRhdGEoe1xuICAgICAgICAgIHJlY292ZXJ5S2V5LFxuICAgICAgICAgIGRpc2Nvbm5lY3RlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICAgIGxvY2F0aW9uOiBnbG9iYWxPYmplY3QyLmxvY2F0aW9uLFxuICAgICAgICAgIGNsaWVudElkOiB0aGlzLnJlYWx0aW1lLmF1dGguY2xpZW50SWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbm1hbmFnZXIgd2FudHMgdG8gcGVyc2lzdCB0cmFuc3BvcnRcbiAgICogc3RhdGUgZm9yIGxhdGVyIHJlY292ZXJ5LiBPbmx5IGFwcGxpY2FibGUgaW4gdGhlIGJyb3dzZXIgY29udGV4dC5cbiAgICovXG4gIHVucGVyc2lzdENvbm5lY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclNlc3Npb25SZWNvdmVyRGF0YSgpO1xuICB9XG4gIGdldEFjdGl2ZVRyYW5zcG9ydEZvcm1hdCgpIHtcbiAgICB2YXIgX2EyO1xuICAgIHJldHVybiAoX2EyID0gdGhpcy5hY3RpdmVQcm90b2NvbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXRUcmFuc3BvcnQoKS5mb3JtYXQ7XG4gIH1cbiAgLyoqKioqKioqKioqKioqKioqKioqKlxuICAgKiBzdGF0ZSBtYW5hZ2VtZW50XG4gICAqKioqKioqKioqKioqKioqKioqKiovXG4gIGdldEVycm9yKCkge1xuICAgIGlmICh0aGlzLmVycm9yUmVhc29uKSB7XG4gICAgICBjb25zdCBuZXdFcnJvciA9IFBhcnRpYWxFcnJvckluZm8uZnJvbVZhbHVlcyh0aGlzLmVycm9yUmVhc29uKTtcbiAgICAgIG5ld0Vycm9yLmNhdXNlID0gdGhpcy5lcnJvclJlYXNvbjtcbiAgICAgIHJldHVybiBuZXdFcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGVFcnJvcigpO1xuICB9XG4gIGdldFN0YXRlRXJyb3IoKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYTIgPSBjb25uZWN0aW9uZXJyb3JzX2RlZmF1bHQpW3RoaXMuc3RhdGUuc3RhdGVdKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIpO1xuICB9XG4gIGFjdGl2ZVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnF1ZXVlRXZlbnRzIHx8IHRoaXMuc3RhdGUuc2VuZEV2ZW50cztcbiAgfVxuICBlbmFjdFN0YXRlQ2hhbmdlKHN0YXRlQ2hhbmdlKSB7XG4gICAgY29uc3QgYWN0aW9uID0gXCJDb25uZWN0aW9uIHN0YXRlXCI7XG4gICAgY29uc3QgbWVzc2FnZSA9IHN0YXRlQ2hhbmdlLmN1cnJlbnQgKyAoc3RhdGVDaGFuZ2UucmVhc29uID8gXCI7IHJlYXNvbjogXCIgKyBzdGF0ZUNoYW5nZS5yZWFzb24gOiBcIlwiKTtcbiAgICBpZiAoc3RhdGVDaGFuZ2UuY3VycmVudCA9PT0gXCJmYWlsZWRcIikge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIGFjdGlvbiwgbWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01BSk9SLCBhY3Rpb24sIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZW5hY3RTdGF0ZUNoYW5nZVwiLFxuICAgICAgXCJzZXR0aW5nIG5ldyBzdGF0ZTogXCIgKyBzdGF0ZUNoYW5nZS5jdXJyZW50ICsgXCI7IHJlYXNvbiA9IFwiICsgKHN0YXRlQ2hhbmdlLnJlYXNvbiAmJiBzdGF0ZUNoYW5nZS5yZWFzb24ubWVzc2FnZSlcbiAgICApO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzW3N0YXRlQ2hhbmdlLmN1cnJlbnRdO1xuICAgIGlmIChzdGF0ZUNoYW5nZS5yZWFzb24pIHtcbiAgICAgIHRoaXMuZXJyb3JSZWFzb24gPSBzdGF0ZUNoYW5nZS5yZWFzb247XG4gICAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uZXJyb3JSZWFzb24gPSBzdGF0ZUNoYW5nZS5yZWFzb247XG4gICAgfVxuICAgIGlmIChuZXdTdGF0ZS50ZXJtaW5hbCB8fCBuZXdTdGF0ZS5zdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb24oKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvbnN0YXRlXCIsIHN0YXRlQ2hhbmdlKTtcbiAgfVxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBDb25uZWN0aW9uTWFuYWdlciBjb25uZWN0aW9uIGxpZmVjeWNsZVxuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgc3RhcnRUcmFuc2l0aW9uVGltZXIodHJhbnNpdGlvblN0YXRlKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0VHJhbnNpdGlvblRpbWVyKClcIixcbiAgICAgIFwidHJhbnNpdGlvblN0YXRlOiBcIiArIHRyYW5zaXRpb25TdGF0ZS5zdGF0ZVxuICAgICk7XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvblRpbWVyKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRUcmFuc2l0aW9uVGltZXIoKVwiLFxuICAgICAgICBcImNsZWFyaW5nIGFscmVhZHktcnVubmluZyB0aW1lclwiXG4gICAgICApO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudHJhbnNpdGlvblRpbWVyKTtcbiAgICB9XG4gICAgdGhpcy50cmFuc2l0aW9uVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnRyYW5zaXRpb25UaW1lcikge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25UaW1lciA9IG51bGw7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBcIiArIHRyYW5zaXRpb25TdGF0ZS5zdGF0ZSArIFwiIHRpbWVyIGV4cGlyZWRcIixcbiAgICAgICAgICBcInJlcXVlc3RpbmcgbmV3IHN0YXRlOiBcIiArIHRyYW5zaXRpb25TdGF0ZS5mYWlsU3RhdGVcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiB0cmFuc2l0aW9uU3RhdGUuZmFpbFN0YXRlIH0pO1xuICAgICAgfVxuICAgIH0sIHRyYW5zaXRpb25TdGF0ZS5yZXRyeURlbGF5KTtcbiAgfVxuICBjYW5jZWxUcmFuc2l0aW9uVGltZXIoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIuY2FuY2VsVHJhbnNpdGlvblRpbWVyKClcIiwgXCJcIik7XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvblRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50cmFuc2l0aW9uVGltZXIpO1xuICAgICAgdGhpcy50cmFuc2l0aW9uVGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBzdGFydFN1c3BlbmRUaW1lcigpIHtcbiAgICBpZiAodGhpcy5zdXNwZW5kVGltZXIpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5zdXNwZW5kVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN1c3BlbmRUaW1lcikge1xuICAgICAgICB0aGlzLnN1c3BlbmRUaW1lciA9IG51bGw7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBzdXNwZW5kIHRpbWVyIGV4cGlyZWRcIixcbiAgICAgICAgICBcInJlcXVlc3RpbmcgbmV3IHN0YXRlOiBzdXNwZW5kZWRcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSA9IFwic3VzcGVuZGVkXCI7XG4gICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogXCJzdXNwZW5kZWRcIiB9KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCk7XG4gIH1cbiAgY2hlY2tTdXNwZW5kVGltZXIoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgIT09IFwiZGlzY29ubmVjdGVkXCIgJiYgc3RhdGUgIT09IFwic3VzcGVuZGVkXCIgJiYgc3RhdGUgIT09IFwiY29ubmVjdGluZ1wiKVxuICAgICAgdGhpcy5jYW5jZWxTdXNwZW5kVGltZXIoKTtcbiAgfVxuICBjYW5jZWxTdXNwZW5kVGltZXIoKSB7XG4gICAgdGhpcy5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUgPSBcImRpc2Nvbm5lY3RlZFwiO1xuICAgIGlmICh0aGlzLnN1c3BlbmRUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc3VzcGVuZFRpbWVyKTtcbiAgICAgIHRoaXMuc3VzcGVuZFRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhcnRSZXRyeVRpbWVyKGludGVydmFsKSB7XG4gICAgdGhpcy5yZXRyeVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uTWFuYWdlciByZXRyeSB0aW1lciBleHBpcmVkXCIsIFwicmV0cnlpbmdcIik7XG4gICAgICB0aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogXCJjb25uZWN0aW5nXCIgfSk7XG4gICAgfSwgaW50ZXJ2YWwpO1xuICB9XG4gIGNhbmNlbFJldHJ5VGltZXIoKSB7XG4gICAgaWYgKHRoaXMucmV0cnlUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lcik7XG4gICAgICB0aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBzdGFydFdlYlNvY2tldFNsb3dUaW1lcigpIHtcbiAgICB0aGlzLndlYlNvY2tldFNsb3dUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBzbG93IHRpbWVyXCIsXG4gICAgICAgIFwiY2hlY2tpbmcgY29ubmVjdGl2aXR5XCJcbiAgICAgICk7XG4gICAgICB0aGlzLmNoZWNrV3NDb25uZWN0aXZpdHkoKS50aGVuKCgpID0+IHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBzbG93IHRpbWVyXCIsXG4gICAgICAgICAgXCJ3cyBjb25uZWN0aXZpdHkgY2hlY2sgc3VjY2VlZGVkXCJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy53c0NoZWNrUmVzdWx0ID0gdHJ1ZTtcbiAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NQUpPUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBzbG93IHRpbWVyXCIsXG4gICAgICAgICAgXCJ3cyBjb25uZWN0aXZpdHkgY2hlY2sgZmFpbGVkXCJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy53c0NoZWNrUmVzdWx0ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnJlYWx0aW1lLmh0dHAuY2hlY2tDb25uZWN0aXZpdHkpIHtcbiAgICAgICAgd2hlblByb21pc2VTZXR0bGVzKHRoaXMucmVhbHRpbWUuaHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpLCAoZXJyLCBjb25uZWN0aXZpdHkpID0+IHtcbiAgICAgICAgICBpZiAoZXJyIHx8ICFjb25uZWN0aXZpdHkpIHtcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NQUpPUixcbiAgICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBXZWJTb2NrZXQgc2xvdyB0aW1lclwiLFxuICAgICAgICAgICAgICBcImh0dHAgY29ubmVjdGl2aXR5IGNoZWNrIGZhaWxlZFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxXZWJTb2NrZXRHaXZlVXBUaW1lcigpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7XG4gICAgICAgICAgICAgIHN0YXRlOiBcImRpc2Nvbm5lY3RlZFwiLFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byBjb25uZWN0IChuZXR3b3JrIHVucmVhY2hhYmxlKVwiLCA4MDAwMywgNDA0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBXZWJTb2NrZXQgc2xvdyB0aW1lclwiLFxuICAgICAgICAgICAgICBcImh0dHAgY29ubmVjdGl2aXR5IGNoZWNrIHN1Y2NlZWRlZFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vcHRpb25zLnRpbWVvdXRzLndlYlNvY2tldFNsb3dUaW1lb3V0KTtcbiAgfVxuICBjYW5jZWxXZWJTb2NrZXRTbG93VGltZXIoKSB7XG4gICAgaWYgKHRoaXMud2ViU29ja2V0U2xvd1RpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy53ZWJTb2NrZXRTbG93VGltZXIpO1xuICAgICAgdGhpcy53ZWJTb2NrZXRTbG93VGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBzdGFydFdlYlNvY2tldEdpdmVVcFRpbWVyKHRyYW5zcG9ydFBhcmFtcykge1xuICAgIHRoaXMud2ViU29ja2V0R2l2ZVVwVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgaWYgKCF0aGlzLndzQ2hlY2tSZXN1bHQpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBnaXZlIHVwIHRpbWVyXCIsXG4gICAgICAgICAgXCJ3ZWJzb2NrZXQgY29ubmVjdGlvbiB0b29rIG1vcmUgdGhhbiAxMHM7IFwiICsgKHRoaXMuYmFzZVRyYW5zcG9ydCA/IFwidHJ5aW5nIGJhc2UgdHJhbnNwb3J0XCIgOiBcIlwiKVxuICAgICAgICApO1xuICAgICAgICBpZiAodGhpcy5iYXNlVHJhbnNwb3J0KSB7XG4gICAgICAgICAgdGhpcy5hYmFuZG9uZWRXZWJTb2NrZXQgPSB0cnVlO1xuICAgICAgICAgIChfYTIgPSB0aGlzLnByb3Bvc2VkVHJhbnNwb3J0KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAoX2IgPSB0aGlzLnBlbmRpbmdUcmFuc3BvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5kaXNwb3NlKCk7XG4gICAgICAgICAgdGhpcy5jb25uZWN0QmFzZSh0cmFuc3BvcnRQYXJhbXMsICsrdGhpcy5jb25uZWN0Q291bnRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsXG4gICAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBnaXZlIHVwIHRpbWVyXCIsXG4gICAgICAgICAgICBcIndlYnNvY2tldCBjb25uZWN0aXZpdHkgYXBwZWFycyB0byBiZSB1bmF2YWlsYWJsZSBidXQgbm8gb3RoZXIgdHJhbnNwb3J0cyB0byB0cnlcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB0aGlzLm9wdGlvbnMudGltZW91dHMud2ViU29ja2V0Q29ubmVjdFRpbWVvdXQpO1xuICB9XG4gIGNhbmNlbFdlYlNvY2tldEdpdmVVcFRpbWVyKCkge1xuICAgIGlmICh0aGlzLndlYlNvY2tldEdpdmVVcFRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy53ZWJTb2NrZXRHaXZlVXBUaW1lcik7XG4gICAgICB0aGlzLndlYlNvY2tldEdpdmVVcFRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgbm90aWZ5U3RhdGUoaW5kaWNhdGVkKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgY29uc3Qgc3RhdGUgPSBpbmRpY2F0ZWQuc3RhdGU7XG4gICAgY29uc3QgcmV0cnlJbW1lZGlhdGVseSA9IHN0YXRlID09PSBcImRpc2Nvbm5lY3RlZFwiICYmICh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQgfHwgaW5kaWNhdGVkLnJldHJ5SW1tZWRpYXRlbHkgfHwgdGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZyAmJiBpbmRpY2F0ZWQuZXJyb3IgJiYgYXV0aF9kZWZhdWx0LmlzVG9rZW5FcnIoaW5kaWNhdGVkLmVycm9yKSAmJiAhKHRoaXMuZXJyb3JSZWFzb24gJiYgYXV0aF9kZWZhdWx0LmlzVG9rZW5FcnIodGhpcy5lcnJvclJlYXNvbikpKTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIubm90aWZ5U3RhdGUoKVwiLFxuICAgICAgXCJuZXcgc3RhdGU6IFwiICsgc3RhdGUgKyAocmV0cnlJbW1lZGlhdGVseSA/IFwiOyB3aWxsIHJldHJ5IGNvbm5lY3Rpb24gaW1tZWRpYXRlbHlcIiA6IFwiXCIpXG4gICAgKTtcbiAgICBpZiAoc3RhdGUgPT0gdGhpcy5zdGF0ZS5zdGF0ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmNhbmNlbFRyYW5zaXRpb25UaW1lcigpO1xuICAgIHRoaXMuY2FuY2VsUmV0cnlUaW1lcigpO1xuICAgIHRoaXMuY2FuY2VsV2ViU29ja2V0U2xvd1RpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxXZWJTb2NrZXRHaXZlVXBUaW1lcigpO1xuICAgIHRoaXMuY2hlY2tTdXNwZW5kVGltZXIoaW5kaWNhdGVkLnN0YXRlKTtcbiAgICBpZiAoc3RhdGUgPT09IFwic3VzcGVuZGVkXCIgfHwgc3RhdGUgPT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdGVkUmV0cnlDb3VudCA9IDA7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlLnRlcm1pbmFsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5zdGF0ZXNbaW5kaWNhdGVkLnN0YXRlXTtcbiAgICBsZXQgcmV0cnlEZWxheSA9IG5ld1N0YXRlLnJldHJ5RGVsYXk7XG4gICAgaWYgKG5ld1N0YXRlLnN0YXRlID09PSBcImRpc2Nvbm5lY3RlZFwiKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RlZFJldHJ5Q291bnQrKztcbiAgICAgIHJldHJ5RGVsYXkgPSBnZXRSZXRyeVRpbWUobmV3U3RhdGUucmV0cnlEZWxheSwgdGhpcy5kaXNjb25uZWN0ZWRSZXRyeUNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlID0gbmV3IGNvbm5lY3Rpb25zdGF0ZWNoYW5nZV9kZWZhdWx0KFxuICAgICAgdGhpcy5zdGF0ZS5zdGF0ZSxcbiAgICAgIG5ld1N0YXRlLnN0YXRlLFxuICAgICAgcmV0cnlEZWxheSxcbiAgICAgIGluZGljYXRlZC5lcnJvciB8fCAoKF9iID0gKF9hMiA9IGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdClbbmV3U3RhdGUuc3RhdGVdKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIpKVxuICAgICk7XG4gICAgaWYgKHJldHJ5SW1tZWRpYXRlbHkpIHtcbiAgICAgIGNvbnN0IGF1dG9SZWNvbm5lY3QgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5kaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLmxhc3RBdXRvUmVjb25uZWN0QXR0ZW1wdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogXCJjb25uZWN0aW5nXCIgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBzaW5jZUxhc3QgPSB0aGlzLmxhc3RBdXRvUmVjb25uZWN0QXR0ZW1wdCAmJiBEYXRlLm5vdygpIC0gdGhpcy5sYXN0QXV0b1JlY29ubmVjdEF0dGVtcHQgKyAxO1xuICAgICAgaWYgKHNpbmNlTGFzdCAmJiBzaW5jZUxhc3QgPCAxZTMpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLm5vdGlmeVN0YXRlKClcIixcbiAgICAgICAgICBcIkxhc3QgcmVjb25uZWN0IGF0dGVtcHQgd2FzIG9ubHkgXCIgKyBzaW5jZUxhc3QgKyBcIm1zIGFnbywgd2FpdGluZyBhbm90aGVyIFwiICsgKDFlMyAtIHNpbmNlTGFzdCkgKyBcIm1zIGJlZm9yZSB0cnlpbmcgYWdhaW5cIlxuICAgICAgICApO1xuICAgICAgICBzZXRUaW1lb3V0KGF1dG9SZWNvbm5lY3QsIDFlMyAtIHNpbmNlTGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soYXV0b1JlY29ubmVjdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gXCJkaXNjb25uZWN0ZWRcIiB8fCBzdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgdGhpcy5zdGFydFJldHJ5VGltZXIocmV0cnlEZWxheSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PT0gXCJkaXNjb25uZWN0ZWRcIiAmJiAhcmV0cnlJbW1lZGlhdGVseSB8fCBzdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIiB8fCBuZXdTdGF0ZS50ZXJtaW5hbCkge1xuICAgICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PSBcImNvbm5lY3RlZFwiICYmICF0aGlzLmFjdGl2ZVByb3RvY29sKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIubm90aWZ5U3RhdGUoKVwiLFxuICAgICAgICBcIkJyb2tlbiBpbnZhcmlhbnQ6IGF0dGVtcHRlZCB0byBnbyBpbnRvIGNvbm5lY3RlZCBzdGF0ZSwgYnV0IHRoZXJlIGlzIG5vIGFjdGl2ZSBwcm90b2NvbFwiXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmVuYWN0U3RhdGVDaGFuZ2UoY2hhbmdlKTtcbiAgICBpZiAodGhpcy5zdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICB0aGlzLnNlbmRRdWV1ZWRNZXNzYWdlcygpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuc3RhdGUucXVldWVFdmVudHMpIHtcbiAgICAgIHRoaXMucmVhbHRpbWUuY2hhbm5lbHMucHJvcG9nYXRlQ29ubmVjdGlvbkludGVycnVwdGlvbihzdGF0ZSwgY2hhbmdlLnJlYXNvbik7XG4gICAgICB0aGlzLmZhaWxRdWV1ZWRNZXNzYWdlcyhjaGFuZ2UucmVhc29uKTtcbiAgICB9XG4gIH1cbiAgcmVxdWVzdFN0YXRlKHJlcXVlc3QpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICBjb25zdCBzdGF0ZSA9IHJlcXVlc3Quc3RhdGU7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnJlcXVlc3RTdGF0ZSgpXCIsXG4gICAgICBcInJlcXVlc3RlZCBzdGF0ZTogXCIgKyBzdGF0ZSArIFwiOyBjdXJyZW50IHN0YXRlOiBcIiArIHRoaXMuc3RhdGUuc3RhdGVcbiAgICApO1xuICAgIGlmIChzdGF0ZSA9PSB0aGlzLnN0YXRlLnN0YXRlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuY2FuY2VsV2ViU29ja2V0U2xvd1RpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxXZWJTb2NrZXRHaXZlVXBUaW1lcigpO1xuICAgIHRoaXMuY2FuY2VsVHJhbnNpdGlvblRpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxSZXRyeVRpbWVyKCk7XG4gICAgdGhpcy5jaGVja1N1c3BlbmRUaW1lcihzdGF0ZSk7XG4gICAgaWYgKHN0YXRlID09IFwiY29ubmVjdGluZ1wiICYmIHRoaXMuc3RhdGUuc3RhdGUgPT0gXCJjb25uZWN0ZWRcIilcbiAgICAgIHJldHVybjtcbiAgICBpZiAoc3RhdGUgPT0gXCJjbG9zaW5nXCIgJiYgdGhpcy5zdGF0ZS5zdGF0ZSA9PSBcImNsb3NlZFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5zdGF0ZXNbc3RhdGVdLCBjaGFuZ2UgPSBuZXcgY29ubmVjdGlvbnN0YXRlY2hhbmdlX2RlZmF1bHQoXG4gICAgICB0aGlzLnN0YXRlLnN0YXRlLFxuICAgICAgbmV3U3RhdGUuc3RhdGUsXG4gICAgICBudWxsLFxuICAgICAgcmVxdWVzdC5lcnJvciB8fCAoKF9iID0gKF9hMiA9IGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdClbbmV3U3RhdGUuc3RhdGVdKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIpKVxuICAgICk7XG4gICAgdGhpcy5lbmFjdFN0YXRlQ2hhbmdlKGNoYW5nZSk7XG4gICAgaWYgKHN0YXRlID09IFwiY29ubmVjdGluZ1wiKSB7XG4gICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PSBcImNsb3NpbmdcIikge1xuICAgICAgdGhpcy5jbG9zZUltcGwoKTtcbiAgICB9XG4gIH1cbiAgc3RhcnRDb25uZWN0KCkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRDb25uZWN0KClcIixcbiAgICAgICAgXCJNdXN0IGJlIGluIGNvbm5lY3Rpbmcgc3RhdGUgdG8gY29ubmVjdCwgYnV0IHdhcyBcIiArIHRoaXMuc3RhdGUuc3RhdGVcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF1dGggPSB0aGlzLnJlYWx0aW1lLmF1dGg7XG4gICAgY29uc3QgY29ubmVjdENvdW50ID0gKyt0aGlzLmNvbm5lY3RDb3VudGVyO1xuICAgIGNvbnN0IGNvbm5lY3QgPSAoKSA9PiB7XG4gICAgICB0aGlzLmNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzKCk7XG4gICAgICB0aGlzLmdldFRyYW5zcG9ydFBhcmFtcygodHJhbnNwb3J0UGFyYW1zKSA9PiB7XG4gICAgICAgIGlmICh0cmFuc3BvcnRQYXJhbXMubW9kZSA9PT0gXCJyZWNvdmVyXCIgJiYgdHJhbnNwb3J0UGFyYW1zLm9wdGlvbnMucmVjb3Zlcikge1xuICAgICAgICAgIGNvbnN0IHJlY292ZXJ5Q29udGV4dCA9IGRlY29kZVJlY292ZXJ5S2V5KHRyYW5zcG9ydFBhcmFtcy5vcHRpb25zLnJlY292ZXIpO1xuICAgICAgICAgIGlmIChyZWNvdmVyeUNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuY2hhbm5lbHMucmVjb3ZlckNoYW5uZWxzKHJlY292ZXJ5Q29udGV4dC5jaGFubmVsU2VyaWFscyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0Q291bnQgIT09IHRoaXMuY29ubmVjdENvdW50ZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0Q29ubmVjdCgpXCIsIFwic3RhcnRpbmcgY29ubmVjdGlvblwiKTtcbiAgICB0aGlzLnN0YXJ0U3VzcGVuZFRpbWVyKCk7XG4gICAgdGhpcy5zdGFydFRyYW5zaXRpb25UaW1lcih0aGlzLnN0YXRlcy5jb25uZWN0aW5nKTtcbiAgICBpZiAoYXV0aC5tZXRob2QgPT09IFwiYmFzaWNcIikge1xuICAgICAgY29ubmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhdXRoQ2IgPSAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChjb25uZWN0Q291bnQgIT09IHRoaXMuY29ubmVjdENvdW50ZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHRoaXMuYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5lcnJvclJlYXNvbiAmJiBhdXRoX2RlZmF1bHQuaXNUb2tlbkVycih0aGlzLmVycm9yUmVhc29uKSkge1xuICAgICAgICB3aGVuUHJvbWlzZVNldHRsZXMoYXV0aC5fZm9yY2VOZXdUb2tlbihudWxsLCBudWxsKSwgYXV0aENiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyhhdXRoLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyhmYWxzZSksIGF1dGhDYik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qXG4gICAqIHRoZXJlIGFyZSwgYXQgbW9zdCwgdHdvIHRyYW5zcG9ydHMgYXZhaWxhYmxlIHdpdGggd2hpY2ggYSBjb25uZWN0aW9uIG1heVxuICAgKiBiZSBhdHRlbXB0ZWQ6IHdlYl9zb2NrZXQgYW5kL29yIGEgYmFzZSB0cmFuc3BvcnQgKHhocl9wb2xsaW5nIGluIGJyb3dzZXJzLFxuICAgKiBjb21ldCBpbiBub2RlanMpLiB3ZWJfc29ja2V0IGlzIGFsd2F5cyBwcmVmZXJyZWQsIGFuZCB0aGUgYmFzZSB0cmFuc3BvcnQgaXNcbiAgICogb25seSB1c2VkIGluIGNhc2Ugd2ViX3NvY2tldCBjb25uZWN0aXZpdHkgYXBwZWFycyB0byBiZSB1bmF2YWlsYWJsZS5cbiAgICpcbiAgICogY29ubmVjdEltcGwgYmVnaW5zIHRoZSB0cmFuc3BvcnQgc2VsZWN0aW9uIHByb2Nlc3MgYnkgY2hlY2tpbmcgd2hpY2ggdHJhbnNwb3J0c1xuICAgKiBhcmUgYXZhaWxhYmxlLCBhbmQgaWYgdGhlcmUgaXMgYSBjYWNoZWQgcHJlZmVyZW5jZS4gSXQgdGhlbiBkZWZlcnMgdG8gdGhlXG4gICAqIHRyYW5zcG9ydC1zcGVjaWZpYyBjb25uZWN0IG1ldGhvZHM6IGNvbm5lY3RXcyBhbmQgY29ubmVjdEJhc2UuXG4gICAqXG4gICAqIEl0IGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGludmFsaWRhdGluZyB0aGUgY2FjaGUgaW4gdGhlIGNhc2UgdGhhdCBhIGJhc2VcbiAgICogdHJhbnNwb3J0IHByZWZlcmVuY2UgaXMgc3RvcmVkIGJ1dCB3ZWIgc29ja2V0IGNvbm5lY3Rpdml0eSBpcyBub3cgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBoYW5kbGluZyBvZiB0aGUgY2FzZSB3aGVyZSB3ZSBuZWVkIHRvIGZhaWxvdmVyIGZyb20gd2ViX3NvY2tldCB0byB0aGUgYmFzZVxuICAgKiB0cmFuc3BvcnQgaXMgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbm5lY3RXcyBtZXRob2QuXG4gICAqL1xuICBjb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5zdGF0ZTtcbiAgICBpZiAoc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3Rpbmcuc3RhdGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0SW1wbCgpXCIsXG4gICAgICAgIFwiTXVzdCBiZSBpbiBjb25uZWN0aW5nIHN0YXRlIHRvIGNvbm5lY3QsIGJ1dCB3YXMgXCIgKyBzdGF0ZVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHJhbnNwb3J0UHJlZmVyZW5jZSA9IHRoaXMuZ2V0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuICAgIGlmICh0cmFuc3BvcnRQcmVmZXJlbmNlICYmIHRyYW5zcG9ydFByZWZlcmVuY2UgPT09IHRoaXMuYmFzZVRyYW5zcG9ydCAmJiB0aGlzLndlYlNvY2tldFRyYW5zcG9ydEF2YWlsYWJsZSkge1xuICAgICAgdGhpcy5jaGVja1dzQ29ubmVjdGl2aXR5KCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZykge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0SW1wbCgpOlwiLFxuICAgICAgICAgICAgXCJ3ZWIgc29ja2V0IGNvbm5lY3Rpdml0eSBhdmFpbGFibGUsIGNhbmNlbGxpbmcgY29ubmVjdGlvbiBhdHRlbXB0IHdpdGggXCIgKyB0aGlzLmJhc2VUcmFuc3BvcnRcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcbiAgICAgICAgICB0aGlzLmNvbm5lY3RXcyh0cmFuc3BvcnRQYXJhbXMsICsrdGhpcy5jb25uZWN0Q291bnRlcik7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKG5vb3AyKTtcbiAgICB9XG4gICAgaWYgKHRyYW5zcG9ydFByZWZlcmVuY2UgJiYgdHJhbnNwb3J0UHJlZmVyZW5jZSA9PT0gdGhpcy5iYXNlVHJhbnNwb3J0IHx8IHRoaXMuYmFzZVRyYW5zcG9ydCAmJiAhdGhpcy53ZWJTb2NrZXRUcmFuc3BvcnRBdmFpbGFibGUpIHtcbiAgICAgIHRoaXMuY29ubmVjdEJhc2UodHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbm5lY3RXcyh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG4gICAgfVxuICB9XG4gIC8qXG4gICAqIGNvbm5lY3RXcyBzdGFydHMgdHdvIHRpbWVycyB0byBtb25pdG9yIHRoZSBzdWNjZXNzIG9mIGEgd2ViX3NvY2tldCBjb25uZWN0aW9uIGF0dGVtcHQ6XG4gICAqIC0gd2ViU29ja2V0U2xvd1RpbWVyOiBpZiB0aGlzIHRpbWVyIGZpcmVzIGJlZm9yZSB0aGUgY29ubmVjdGlvbiBzdWNjZWVkcyxcbiAgICogICBjbSB3aWxsIHNpbXVsdGFuZW91c2x5IGNoZWNrIHdlYnNvY2tldCBhbmQgaHR0cC94aHIgY29ubmVjdGl2aXR5LiBpZiB0aGUgaHR0cFxuICAgKiAgIGNvbm5lY3Rpdml0eSBjaGVjayBmYWlscywgd2UgZ2l2ZSB1cCB0aGUgY29ubmVjdGlvbiBzZXF1ZW5jZSBlbnRpcmVseSBhbmRcbiAgICogICB0cmFuc2l0aW9uIHRvIGRpc2Nvbm5lY3RlZC4gaWYgdGhlIHdlYnNvY2tldCBjb25uZWN0aXZpdHkgY2hlY2sgZmFpbHMgdGhlblxuICAgKiAgIHdlIGFzc3VtZSBubyB3cyBjb25uZWN0aXZpdHkgYW5kIGZhaWxvdmVyIHRvIGJhc2UgdHJhbnNwb3J0LiBpbiB0aGUgY2FzZSB0aGF0XG4gICAqICAgdGhlIGNoZWNrcyBzdWNjZWVkLCB3ZSBjb250aW51ZSB3aXRoIHdlYnNvY2tldCBhbmQgd2FpdCBmb3IgaXQgdG8gdHJ5IGZhbGxiYWNrIGhvc3RzXG4gICAqICAgYW5kLCBpZiB1bnN1Y2Nlc3NmdWwsIHVsdGltYXRlbHkgdHJhbnNpdGlvbiB0byBkaXNjb25uZWN0ZWQuXG4gICAqIC0gd2ViU29ja2V0R2l2ZVVwVGltZXI6IGlmIHRoaXMgdGltZXIgZmlyZXMsIGFuZCB0aGUgcHJlY2VkaW5nIHdlYnNvY2tldFxuICAgKiAgIGNvbm5lY3Rpdml0eSBjaGVjayBpcyBzdGlsbCBwZW5kaW5nIHRoZW4gd2UgYXNzdW1lIHRoYXQgdGhlcmUgaXMgYW4gaXNzdWVcbiAgICogICB3aXRoIHRoZSB0cmFuc3BvcnQgYW5kIGZhbGxiYWNrIHRvIGJhc2UgdHJhbnNwb3J0LlxuICAgKi9cbiAgY29ubmVjdFdzKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdFdzKClcIik7XG4gICAgdGhpcy53c0NoZWNrUmVzdWx0ID0gbnVsbDtcbiAgICB0aGlzLmFiYW5kb25lZFdlYlNvY2tldCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnRXZWJTb2NrZXRTbG93VGltZXIoKTtcbiAgICB0aGlzLnN0YXJ0V2ViU29ja2V0R2l2ZVVwVGltZXIodHJhbnNwb3J0UGFyYW1zKTtcbiAgICB0aGlzLnRyeVRyYW5zcG9ydFdpdGhGYWxsYmFja3MoXCJ3ZWJfc29ja2V0XCIsIHRyYW5zcG9ydFBhcmFtcywgdHJ1ZSwgY29ubmVjdENvdW50LCAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy53c0NoZWNrUmVzdWx0ICE9PSBmYWxzZSAmJiAhdGhpcy5hYmFuZG9uZWRXZWJTb2NrZXQ7XG4gICAgfSk7XG4gIH1cbiAgY29ubmVjdEJhc2UodHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0QmFzZSgpXCIpO1xuICAgIGlmICh0aGlzLmJhc2VUcmFuc3BvcnQpIHtcbiAgICAgIHRoaXMudHJ5VHJhbnNwb3J0V2l0aEZhbGxiYWNrcyh0aGlzLmJhc2VUcmFuc3BvcnQsIHRyYW5zcG9ydFBhcmFtcywgZmFsc2UsIGNvbm5lY3RDb3VudCwgKCkgPT4gdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubm90aWZ5U3RhdGUoe1xuICAgICAgICBzdGF0ZTogXCJkaXNjb25uZWN0ZWRcIixcbiAgICAgICAgZXJyb3I6IG5ldyBFcnJvckluZm8oXCJObyB0cmFuc3BvcnRzIGxlZnQgdG8gdHJ5XCIsIDhlNCwgNDA0KVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHRyeVRyYW5zcG9ydFdpdGhGYWxsYmFja3ModHJhbnNwb3J0TmFtZSwgdHJhbnNwb3J0UGFyYW1zLCB3cywgY29ubmVjdENvdW50LCBzaG91bGRDb250aW51ZSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci50cnlUcmFuc3BvcnRXaXRoRmFsbGJhY2tzKClcIixcbiAgICAgIHRyYW5zcG9ydE5hbWVcbiAgICApO1xuICAgIGNvbnN0IGdpdmVVcCA9IChlcnIpID0+IHtcbiAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogdGhpcy5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUsIGVycm9yOiBlcnIgfSk7XG4gICAgfTtcbiAgICBjb25zdCBjYW5kaWRhdGVIb3N0cyA9IHRoaXMuZG9tYWlucy5zbGljZSgpO1xuICAgIGNvbnN0IGhvc3RBdHRlbXB0Q2IgPSAoZmF0YWwsIHRyYW5zcG9ydCkgPT4ge1xuICAgICAgaWYgKGNvbm5lY3RDb3VudCAhPT0gdGhpcy5jb25uZWN0Q291bnRlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXNob3VsZENvbnRpbnVlKCkpIHtcbiAgICAgICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgICAgIHRyYW5zcG9ydC5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0cmFuc3BvcnQgJiYgIWZhdGFsKSB7XG4gICAgICAgIHRyeUZhbGxiYWNrSG9zdHMoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhvc3QgPSBjYW5kaWRhdGVIb3N0cy5zaGlmdCgpO1xuICAgIGlmICghaG9zdCkge1xuICAgICAgZ2l2ZVVwKG5ldyBFcnJvckluZm8oXCJVbmFibGUgdG8gY29ubmVjdCAobm8gYXZhaWxhYmxlIGhvc3QpXCIsIDgwMDAzLCA0MDQpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJhbnNwb3J0UGFyYW1zLmhvc3QgPSBob3N0O1xuICAgIGNvbnN0IHRyeUZhbGxiYWNrSG9zdHMgPSAoKSA9PiB7XG4gICAgICBpZiAoIWNhbmRpZGF0ZUhvc3RzLmxlbmd0aCkge1xuICAgICAgICBnaXZlVXAobmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byBjb25uZWN0IChhbmQgbm8gbW9yZSBmYWxsYmFjayBob3N0cyB0byB0cnkpXCIsIDgwMDAzLCA0MDQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnJlYWx0aW1lLmh0dHAuY2hlY2tDb25uZWN0aXZpdHkpIHtcbiAgICAgICAgZ2l2ZVVwKG5ldyBQYXJ0aWFsRXJyb3JJbmZvKFwiSW50ZXJuYWwgZXJyb3I6IEh0dHAuY2hlY2tDb25uZWN0aXZpdHkgbm90IHNldFwiLCBudWxsLCA1MDApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hlblByb21pc2VTZXR0bGVzKFxuICAgICAgICB0aGlzLnJlYWx0aW1lLmh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKSxcbiAgICAgICAgKGVyciwgY29ubmVjdGl2aXR5KSA9PiB7XG4gICAgICAgICAgaWYgKGNvbm5lY3RDb3VudCAhPT0gdGhpcy5jb25uZWN0Q291bnRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXNob3VsZENvbnRpbnVlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZ2l2ZVVwKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY29ubmVjdGl2aXR5KSB7XG4gICAgICAgICAgICBnaXZlVXAobmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byBjb25uZWN0IChuZXR3b3JrIHVucmVhY2hhYmxlKVwiLCA4MDAwMywgNDA0KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyYW5zcG9ydFBhcmFtcy5ob3N0ID0gYXJyUG9wUmFuZG9tRWxlbWVudChjYW5kaWRhdGVIb3N0cyk7XG4gICAgICAgICAgdGhpcy50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgdHJhbnNwb3J0TmFtZSwgaG9zdEF0dGVtcHRDYik7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfTtcbiAgICBpZiAodGhpcy5mb3JjZUZhbGxiYWNrSG9zdCAmJiBjYW5kaWRhdGVIb3N0cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZm9yY2VGYWxsYmFja0hvc3QgPSBmYWxzZTtcbiAgICAgIHRyeUZhbGxiYWNrSG9zdHMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgdHJhbnNwb3J0TmFtZSwgaG9zdEF0dGVtcHRDYik7XG4gIH1cbiAgY2xvc2VJbXBsKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlSW1wbCgpXCIsIFwiY2xvc2luZyBjb25uZWN0aW9uXCIpO1xuICAgIHRoaXMuY2FuY2VsU3VzcGVuZFRpbWVyKCk7XG4gICAgdGhpcy5zdGFydFRyYW5zaXRpb25UaW1lcih0aGlzLnN0YXRlcy5jbG9zaW5nKTtcbiAgICBpZiAodGhpcy5wZW5kaW5nVHJhbnNwb3J0KSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2VJbXBsKClcIixcbiAgICAgICAgXCJDbG9zaW5nIHBlbmRpbmcgdHJhbnNwb3J0OiBcIiArIHRoaXMucGVuZGluZ1RyYW5zcG9ydFxuICAgICAgKTtcbiAgICAgIHRoaXMucGVuZGluZ1RyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hY3RpdmVQcm90b2NvbCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlSW1wbCgpXCIsXG4gICAgICAgIFwiQ2xvc2luZyBhY3RpdmUgdHJhbnNwb3J0OiBcIiArIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KClcbiAgICAgICk7XG4gICAgICB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLmNsb3NlKCk7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogXCJjbG9zZWRcIiB9KTtcbiAgfVxuICBvbkF1dGhVcGRhdGVkKHRva2VuRGV0YWlscywgY2FsbGJhY2spIHtcbiAgICB2YXIgX2EyO1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZS5zdGF0ZSkge1xuICAgICAgY2FzZSBcImNvbm5lY3RlZFwiOiB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKClcIixcbiAgICAgICAgICBcIlNlbmRpbmcgQVVUSCBtZXNzYWdlIG9uIGFjdGl2ZSB0cmFuc3BvcnRcIlxuICAgICAgICApO1xuICAgICAgICBjb25zdCBhY3RpdmVUcmFuc3BvcnQgPSAoX2EyID0gdGhpcy5hY3RpdmVQcm90b2NvbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXRUcmFuc3BvcnQoKTtcbiAgICAgICAgaWYgKGFjdGl2ZVRyYW5zcG9ydCAmJiBhY3RpdmVUcmFuc3BvcnQub25BdXRoVXBkYXRlZCkge1xuICAgICAgICAgIGFjdGl2ZVRyYW5zcG9ydC5vbkF1dGhVcGRhdGVkKHRva2VuRGV0YWlscyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXV0aE1zZyA9IGZyb21WYWx1ZXMoe1xuICAgICAgICAgIGFjdGlvbjogYWN0aW9ucy5BVVRILFxuICAgICAgICAgIGF1dGg6IHtcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiB0b2tlbkRldGFpbHMudG9rZW5cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlbmQoYXV0aE1zZyk7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLm9mZihmYWlsdXJlTGlzdGVuZXIpO1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRva2VuRGV0YWlscyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZhaWx1cmVMaXN0ZW5lciA9IChzdGF0ZUNoYW5nZSkgPT4ge1xuICAgICAgICAgIGlmIChzdGF0ZUNoYW5nZS5jdXJyZW50ID09PSBcImZhaWxlZFwiKSB7XG4gICAgICAgICAgICB0aGlzLm9mZihzdWNjZXNzTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5vZmYoZmFpbHVyZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCB0aGlzLmdldFN0YXRlRXJyb3IoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uY2UoXCJjb25uZWN0aW9uZGV0YWlsc1wiLCBzdWNjZXNzTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLm9uKFwiY29ubmVjdGlvbnN0YXRlXCIsIGZhaWx1cmVMaXN0ZW5lcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImNvbm5lY3RpbmdcIjpcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQoKVwiLFxuICAgICAgICAgIFwiQWJvcnRpbmcgY3VycmVudCBjb25uZWN0aW9uIGF0dGVtcHRzIGluIG9yZGVyIHRvIHN0YXJ0IGFnYWluIHdpdGggdGhlIG5ldyBhdXRoIGRldGFpbHNcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKClcIixcbiAgICAgICAgICBcIkNvbm5lY3Rpb24gc3RhdGUgaXMgXCIgKyB0aGlzLnN0YXRlLnN0YXRlICsgXCI7IHdhaXRpbmcgdW50aWwgZWl0aGVyIGNvbm5lY3RlZCBvciBmYWlsZWRcIlxuICAgICAgICApO1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChzdGF0ZUNoYW5nZSkgPT4ge1xuICAgICAgICAgIHN3aXRjaCAoc3RhdGVDaGFuZ2UuY3VycmVudCkge1xuICAgICAgICAgICAgY2FzZSBcImNvbm5lY3RlZFwiOlxuICAgICAgICAgICAgICB0aGlzLm9mZihsaXN0ZW5lcik7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRva2VuRGV0YWlscyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgICAgICAgY2FzZSBcImNsb3NlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInN1c3BlbmRlZFwiOlxuICAgICAgICAgICAgICB0aGlzLm9mZihsaXN0ZW5lcik7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCB0aGlzLmdldFN0YXRlRXJyb3IoKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uKFwiY29ubmVjdGlvbnN0YXRlXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc3RhdGUgPT09IFwiY29ubmVjdGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5zdGFydENvbm5lY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiBcImNvbm5lY3RpbmdcIiB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBkaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKVwiLFxuICAgICAgXCJEaXNjb25uZWN0aW5nIGFsbCB0cmFuc3BvcnRzXCJcbiAgICApO1xuICAgIHRoaXMuY29ubmVjdENvdW50ZXIrKztcbiAgICBpZiAodGhpcy5wZW5kaW5nVHJhbnNwb3J0KSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKVwiLFxuICAgICAgICBcIkRpc2Nvbm5lY3RpbmcgcGVuZGluZyB0cmFuc3BvcnQ6IFwiICsgdGhpcy5wZW5kaW5nVHJhbnNwb3J0XG4gICAgICApO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1RyYW5zcG9ydDtcbiAgICBpZiAodGhpcy5wcm9wb3NlZFRyYW5zcG9ydCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKClcIixcbiAgICAgICAgXCJEaXNjb25uZWN0aW5nIHByb3Bvc2VkIHRyYW5zcG9ydDogXCIgKyB0aGlzLnBlbmRpbmdUcmFuc3BvcnRcbiAgICAgICk7XG4gICAgICB0aGlzLnByb3Bvc2VkVHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1RyYW5zcG9ydDtcbiAgICBpZiAodGhpcy5hY3RpdmVQcm90b2NvbCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKClcIixcbiAgICAgICAgXCJEaXNjb25uZWN0aW5nIGFjdGl2ZSB0cmFuc3BvcnQ6IFwiICsgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKVxuICAgICAgKTtcbiAgICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgfVxuICAvKioqKioqKioqKioqKioqKioqXG4gICAqIGV2ZW50IHF1ZXVlaW5nXG4gICAqKioqKioqKioqKioqKioqKiovXG4gIHNlbmQobXNnLCBxdWV1ZUV2ZW50LCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDI7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChzdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJDb25uZWN0aW9uTWFuYWdlci5zZW5kKClcIiwgXCJzZW5kaW5nIGV2ZW50XCIpO1xuICAgICAgdGhpcy5zZW5kSW1wbChuZXcgUGVuZGluZ01lc3NhZ2UobXNnLCBjYWxsYmFjaykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaG91bGRRdWV1ZSA9IHF1ZXVlRXZlbnQgJiYgc3RhdGUucXVldWVFdmVudHM7XG4gICAgaWYgKCFzaG91bGRRdWV1ZSkge1xuICAgICAgY29uc3QgZXJyID0gXCJyZWplY3RpbmcgZXZlbnQsIHF1ZXVlRXZlbnQgd2FzIFwiICsgcXVldWVFdmVudCArIFwiLCBzdGF0ZSB3YXMgXCIgKyBzdGF0ZS5zdGF0ZTtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLnNlbmQoKVwiLCBlcnIpO1xuICAgICAgY2FsbGJhY2sodGhpcy5lcnJvclJlYXNvbiB8fCBuZXcgRXJyb3JJbmZvKGVyciwgOWU0LCA0MDApKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubG9nZ2VyLnNob3VsZExvZyhsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc2VuZCgpXCIsXG4gICAgICAgIFwicXVldWVpbmcgbXNnOyBcIiArIHN0cmluZ2lmeShcbiAgICAgICAgICBtc2csXG4gICAgICAgICAgdGhpcy5yZWFsdGltZS5fUmVhbHRpbWVQcmVzZW5jZSxcbiAgICAgICAgICB0aGlzLnJlYWx0aW1lLl9Bbm5vdGF0aW9ucyxcbiAgICAgICAgICB0aGlzLnJlYWx0aW1lLl9vYmplY3RzUGx1Z2luXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMucXVldWUobXNnLCBjYWxsYmFjayk7XG4gIH1cbiAgc2VuZEltcGwocGVuZGluZ01lc3NhZ2UpIHtcbiAgICBjb25zdCBtc2cgPSBwZW5kaW5nTWVzc2FnZS5tZXNzYWdlO1xuICAgIGlmIChwZW5kaW5nTWVzc2FnZS5hY2tSZXF1aXJlZCAmJiAhcGVuZGluZ01lc3NhZ2Uuc2VuZEF0dGVtcHRlZCkge1xuICAgICAgbXNnLm1zZ1NlcmlhbCA9IHRoaXMubXNnU2VyaWFsKys7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLmFjdGl2ZVByb3RvY29sLnNlbmQocGVuZGluZ01lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5zZW5kSW1wbCgpXCIsXG4gICAgICAgIFwiVW5leHBlY3RlZCBleGNlcHRpb24gaW4gdHJhbnNwb3J0LnNlbmQoKTogXCIgKyBlLnN0YWNrXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBxdWV1ZShtc2csIGNhbGxiYWNrKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ29ubmVjdGlvbk1hbmFnZXIucXVldWUoKVwiLCBcInF1ZXVlaW5nIGV2ZW50XCIpO1xuICAgIGNvbnN0IGxhc3RRdWV1ZWQgPSB0aGlzLnF1ZXVlZE1lc3NhZ2VzLmxhc3QoKTtcbiAgICBjb25zdCBtYXhTaXplID0gdGhpcy5vcHRpb25zLm1heE1lc3NhZ2VTaXplO1xuICAgIGlmIChsYXN0UXVldWVkICYmICFsYXN0UXVldWVkLnNlbmRBdHRlbXB0ZWQgJiYgYnVuZGxlV2l0aChsYXN0UXVldWVkLm1lc3NhZ2UsIG1zZywgbWF4U2l6ZSkpIHtcbiAgICAgIGlmICghbGFzdFF1ZXVlZC5tZXJnZWQpIHtcbiAgICAgICAgbGFzdFF1ZXVlZC5jYWxsYmFjayA9IG11bHRpY2FzdGVyX2RlZmF1bHQuY3JlYXRlKHRoaXMubG9nZ2VyLCBbbGFzdFF1ZXVlZC5jYWxsYmFja10pO1xuICAgICAgICBsYXN0UXVldWVkLm1lcmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBsYXN0UXVldWVkLmNhbGxiYWNrLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnF1ZXVlZE1lc3NhZ2VzLnB1c2gobmV3IFBlbmRpbmdNZXNzYWdlKG1zZywgY2FsbGJhY2spKTtcbiAgICB9XG4gIH1cbiAgc2VuZFF1ZXVlZE1lc3NhZ2VzKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5zZW5kUXVldWVkTWVzc2FnZXMoKVwiLFxuICAgICAgXCJzZW5kaW5nIFwiICsgdGhpcy5xdWV1ZWRNZXNzYWdlcy5jb3VudCgpICsgXCIgcXVldWVkIG1lc3NhZ2VzXCJcbiAgICApO1xuICAgIGxldCBwZW5kaW5nTWVzc2FnZTtcbiAgICB3aGlsZSAocGVuZGluZ01lc3NhZ2UgPSB0aGlzLnF1ZXVlZE1lc3NhZ2VzLnNoaWZ0KCkpXG4gICAgICB0aGlzLnNlbmRJbXBsKHBlbmRpbmdNZXNzYWdlKTtcbiAgfVxuICBxdWV1ZVBlbmRpbmdNZXNzYWdlcyhwZW5kaW5nTWVzc2FnZXMpIHtcbiAgICBpZiAocGVuZGluZ01lc3NhZ2VzICYmIHBlbmRpbmdNZXNzYWdlcy5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5xdWV1ZVBlbmRpbmdNZXNzYWdlcygpXCIsXG4gICAgICAgIFwicXVldWVpbmcgXCIgKyBwZW5kaW5nTWVzc2FnZXMubGVuZ3RoICsgXCIgcGVuZGluZyBtZXNzYWdlc1wiXG4gICAgICApO1xuICAgICAgdGhpcy5xdWV1ZWRNZXNzYWdlcy5wcmVwZW5kKHBlbmRpbmdNZXNzYWdlcyk7XG4gICAgfVxuICB9XG4gIGZhaWxRdWV1ZWRNZXNzYWdlcyhlcnIpIHtcbiAgICBjb25zdCBudW1RdWV1ZWQgPSB0aGlzLnF1ZXVlZE1lc3NhZ2VzLmNvdW50KCk7XG4gICAgaWYgKG51bVF1ZXVlZCA+IDApIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5mYWlsUXVldWVkTWVzc2FnZXMoKVwiLFxuICAgICAgICBcImZhaWxpbmcgXCIgKyBudW1RdWV1ZWQgKyBcIiBxdWV1ZWQgbWVzc2FnZXMsIGVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycilcbiAgICAgICk7XG4gICAgICB0aGlzLnF1ZXVlZE1lc3NhZ2VzLmNvbXBsZXRlQWxsTWVzc2FnZXMoZXJyKTtcbiAgICB9XG4gIH1cbiAgb25DaGFubmVsTWVzc2FnZShtZXNzYWdlLCB0cmFuc3BvcnQpIHtcbiAgICB0aGlzLnBlbmRpbmdDaGFubmVsTWVzc2FnZXNTdGF0ZS5xdWV1ZS5wdXNoKHsgbWVzc2FnZSwgdHJhbnNwb3J0IH0pO1xuICAgIGlmICghdGhpcy5wZW5kaW5nQ2hhbm5lbE1lc3NhZ2VzU3RhdGUuaXNQcm9jZXNzaW5nKSB7XG4gICAgICB0aGlzLnByb2Nlc3NOZXh0UGVuZGluZ0NoYW5uZWxNZXNzYWdlKCk7XG4gICAgfVxuICB9XG4gIHByb2Nlc3NOZXh0UGVuZGluZ0NoYW5uZWxNZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmdDaGFubmVsTWVzc2FnZXNTdGF0ZS5xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnBlbmRpbmdDaGFubmVsTWVzc2FnZXNTdGF0ZS5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgY29uc3QgcGVuZGluZ0NoYW5uZWxNZXNzYWdlID0gdGhpcy5wZW5kaW5nQ2hhbm5lbE1lc3NhZ2VzU3RhdGUucXVldWUuc2hpZnQoKTtcbiAgICAgIHRoaXMucHJvY2Vzc0NoYW5uZWxNZXNzYWdlKHBlbmRpbmdDaGFubmVsTWVzc2FnZS5tZXNzYWdlKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5wcm9jZXNzTmV4dFBlbmRpbmdDaGFubmVsTWVzc2FnZSgpIHJlY2VpdmVkIGVycm9yIFwiLFxuICAgICAgICAgIGVyclxuICAgICAgICApO1xuICAgICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHRoaXMucGVuZGluZ0NoYW5uZWxNZXNzYWdlc1N0YXRlLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb2Nlc3NOZXh0UGVuZGluZ0NoYW5uZWxNZXNzYWdlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0NoYW5uZWxNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBhd2FpdCB0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLnByb2Nlc3NDaGFubmVsTWVzc2FnZShtZXNzYWdlKTtcbiAgfVxuICBhc3luYyBwaW5nKCkge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKHRoaXMuc3RhdGUuc3RhdGUgIT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJVbmFibGUgdG8gcGluZyBzZXJ2aWNlOyBub3QgY29ubmVjdGVkXCIsIDRlNCwgNDAwKTtcbiAgICB9XG4gICAgY29uc3QgdHJhbnNwb3J0ID0gKF9hMiA9IHRoaXMuYWN0aXZlUHJvdG9jb2wpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0VHJhbnNwb3J0KCk7XG4gICAgaWYgKCF0cmFuc3BvcnQpIHtcbiAgICAgIHRocm93IHRoaXMuZ2V0U3RhdGVFcnJvcigpO1xuICAgIH1cbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uTWFuYWdlci5waW5nKClcIiwgXCJ0cmFuc3BvcnQgPSBcIiArIHRyYW5zcG9ydCk7XG4gICAgY29uc3QgcGluZ1N0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBpZCA9IGNoZWFwUmFuZFN0cigpO1xuICAgIHJldHVybiB3aXRoVGltZW91dEFzeW5jKFxuICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3Qgb25IZWFydGJlYXQgPSAocmVzcG9uc2VJZCkgPT4ge1xuICAgICAgICAgIGlmIChyZXNwb25zZUlkID09PSBpZCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0Lm9mZihcImhlYXJ0YmVhdFwiLCBvbkhlYXJ0YmVhdCk7XG4gICAgICAgICAgICByZXNvbHZlKERhdGUubm93KCkgLSBwaW5nU3RhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uKFwiaGVhcnRiZWF0XCIsIG9uSGVhcnRiZWF0KTtcbiAgICAgICAgdHJhbnNwb3J0LnBpbmcoaWQpO1xuICAgICAgfSksXG4gICAgICB0aGlzLm9wdGlvbnMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dCxcbiAgICAgIFwiVGltZW91dCB3YWl0aW5nIGZvciBoZWFydGJlYXQgcmVzcG9uc2VcIlxuICAgICk7XG4gIH1cbiAgYWJvcnQoZXJyb3IpIHtcbiAgICB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLmZhaWwoZXJyb3IpO1xuICB9XG4gIGdldFRyYW5zcG9ydFByZWZlcmVuY2UoKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSB8fCBoYXZlV2ViU3RvcmFnZSgpICYmICgoX2IgPSAoX2EyID0gUGxhdGZvcm0uV2ViU3RvcmFnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMiwgdHJhbnNwb3J0UHJlZmVyZW5jZU5hbWUpKTtcbiAgfVxuICBwZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSh0cmFuc3BvcnQpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICB0aGlzLnRyYW5zcG9ydFByZWZlcmVuY2UgPSB0cmFuc3BvcnQuc2hvcnROYW1lO1xuICAgIGlmIChoYXZlV2ViU3RvcmFnZSgpKSB7XG4gICAgICAoX2IgPSAoX2EyID0gUGxhdGZvcm0uV2ViU3RvcmFnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5zZXQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMiwgdHJhbnNwb3J0UHJlZmVyZW5jZU5hbWUsIHRyYW5zcG9ydC5zaG9ydE5hbWUpO1xuICAgIH1cbiAgfVxuICB1bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKCkge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSA9IG51bGw7XG4gICAgaWYgKGhhdmVXZWJTdG9yYWdlKCkpIHtcbiAgICAgIChfYiA9IChfYTIgPSBQbGF0Zm9ybS5XZWJTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnJlbW92ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EyLCB0cmFuc3BvcnRQcmVmZXJlbmNlTmFtZSk7XG4gICAgfVxuICB9XG4gIC8qIFRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBkdXJpbmcgY29ubmVjdGlvbiBhdHRlbXB0cywgc28gaW1wbGVtZW50cyBSU0E0YzEsIFJTQTRjMixcbiAgICogYW5kIFJTQTRkLiBJdCBpcyBnZW5lcmFsbHkgbm90IGludm9rZWQgZm9yIHNlcnZlcnNpZGUtdHJpZ2dlcmVkIHJlYXV0aHMgb3IgbWFudWFsXG4gICAqIHJlYXV0aHMsIHNvIFJTQTRjMyBkb2VzIG5vdCBhcHBseSwgZXhjZXB0IChwZXIgcGVyIFJTQTRkMSkgaW4gdGhlIGNhc2UgdGhhdCB0aGUgYXV0aFxuICAgKiBzZXJ2ZXIgcmV0dXJucyA0MDMuICovXG4gIGFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKGVycikge1xuICAgIGlmIChlcnIuY29kZSA9PT0gNDAxNzEpIHtcbiAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogXCJmYWlsZWRcIiwgZXJyb3I6IGVyciB9KTtcbiAgICB9IGVsc2UgaWYgKGVyci5jb2RlID09PSA0MDEwMikge1xuICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiBcImZhaWxlZFwiLCBlcnJvcjogZXJyIH0pO1xuICAgIH0gZWxzZSBpZiAoZXJyLnN0YXR1c0NvZGUgPT09IEh0dHBTdGF0dXNDb2Rlc19kZWZhdWx0LkZvcmJpZGRlbikge1xuICAgICAgY29uc3QgbXNnID0gXCJDbGllbnQgY29uZmlndXJlZCBhdXRoZW50aWNhdGlvbiBwcm92aWRlciByZXR1cm5lZCA0MDM7IGZhaWxpbmcgdGhlIGNvbm5lY3Rpb25cIjtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKClcIiwgbXNnKTtcbiAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogXCJmYWlsZWRcIiwgZXJyb3I6IG5ldyBFcnJvckluZm8obXNnLCA4MDAxOSwgNDAzLCBlcnIpIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtc2cgPSBcIkNsaWVudCBjb25maWd1cmVkIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIHJlcXVlc3QgZmFpbGVkXCI7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZVwiLCBtc2cpO1xuICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiB0aGlzLnN0YXRlLmZhaWxTdGF0ZSwgZXJyb3I6IG5ldyBFcnJvckluZm8obXNnLCA4MDAxOSwgNDAxLCBlcnIpIH0pO1xuICAgIH1cbiAgfVxuICBvbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKGNvbm5lY3Rpb25EZXRhaWxzLCB0cmFuc3BvcnQpIHtcbiAgICBpZiAoIWNvbm5lY3Rpb25EZXRhaWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY29ubmVjdGlvbkRldGFpbHMgPSBjb25uZWN0aW9uRGV0YWlscztcbiAgICBpZiAoY29ubmVjdGlvbkRldGFpbHMubWF4TWVzc2FnZVNpemUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5tYXhNZXNzYWdlU2l6ZSA9IGNvbm5lY3Rpb25EZXRhaWxzLm1heE1lc3NhZ2VTaXplO1xuICAgIH1cbiAgICBjb25zdCBjbGllbnRJZCA9IGNvbm5lY3Rpb25EZXRhaWxzLmNsaWVudElkO1xuICAgIGlmIChjbGllbnRJZCkge1xuICAgICAgY29uc3QgZXJyID0gdGhpcy5yZWFsdGltZS5hdXRoLl91bmNoZWNrZWRTZXRDbGllbnRJZChjbGllbnRJZCk7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLm9uQ29ubmVjdGlvbkRldGFpbHNVcGRhdGUoKVwiLCBlcnIubWVzc2FnZSk7XG4gICAgICAgIHRyYW5zcG9ydC5mYWlsKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29ubmVjdGlvblN0YXRlVHRsID0gY29ubmVjdGlvbkRldGFpbHMuY29ubmVjdGlvblN0YXRlVHRsO1xuICAgIGlmIChjb25uZWN0aW9uU3RhdGVUdGwpIHtcbiAgICAgIHRoaXMuY29ubmVjdGlvblN0YXRlVHRsID0gY29ubmVjdGlvblN0YXRlVHRsO1xuICAgIH1cbiAgICB0aGlzLm1heElkbGVJbnRlcnZhbCA9IGNvbm5lY3Rpb25EZXRhaWxzLm1heElkbGVJbnRlcnZhbDtcbiAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uZGV0YWlsc1wiLCBjb25uZWN0aW9uRGV0YWlscyk7XG4gIH1cbiAgY2hlY2tXc0Nvbm5lY3Rpdml0eSgpIHtcbiAgICBjb25zdCB3c0Nvbm5lY3Rpdml0eUNoZWNrVXJsID0gdGhpcy5vcHRpb25zLndzQ29ubmVjdGl2aXR5Q2hlY2tVcmwgfHwgZGVmYXVsdHNfZGVmYXVsdC53c0Nvbm5lY3Rpdml0eUNoZWNrVXJsO1xuICAgIGNvbnN0IHdzID0gbmV3IFBsYXRmb3JtLkNvbmZpZy5XZWJTb2NrZXQod3NDb25uZWN0aXZpdHlDaGVja1VybCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBmaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgd3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWZpbmlzaGVkKSB7XG4gICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB3cy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgd3Mub25jbG9zZSA9IHdzLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgIGlmICghZmluaXNoZWQpIHtcbiAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgc2Vzc2lvblJlY292ZXJ5TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnJlY292ZXJ5S2V5U3RvcmFnZU5hbWUgfHwgXCJhYmx5LWNvbm5lY3Rpb24tcmVjb3ZlcnlcIjtcbiAgfVxuICBnZXRTZXNzaW9uUmVjb3ZlckRhdGEoKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgcmV0dXJuIGhhdmVTZXNzaW9uU3RvcmFnZSgpICYmICgoX2IgPSAoX2EyID0gUGxhdGZvcm0uV2ViU3RvcmFnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXRTZXNzaW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIsIHRoaXMuc2Vzc2lvblJlY292ZXJ5TmFtZSgpKSk7XG4gIH1cbiAgc2V0U2Vzc2lvblJlY292ZXJEYXRhKHZhbHVlKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgcmV0dXJuIGhhdmVTZXNzaW9uU3RvcmFnZSgpICYmICgoX2IgPSAoX2EyID0gUGxhdGZvcm0uV2ViU3RvcmFnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5zZXRTZXNzaW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIsIHRoaXMuc2Vzc2lvblJlY292ZXJ5TmFtZSgpLCB2YWx1ZSkpO1xuICB9XG4gIGNsZWFyU2Vzc2lvblJlY292ZXJEYXRhKCkge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIHJldHVybiBoYXZlU2Vzc2lvblN0b3JhZ2UoKSAmJiAoKF9iID0gKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucmVtb3ZlU2Vzc2lvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EyLCB0aGlzLnNlc3Npb25SZWNvdmVyeU5hbWUoKSkpO1xuICB9XG59O1xudmFyIGNvbm5lY3Rpb25tYW5hZ2VyX2RlZmF1bHQgPSBDb25uZWN0aW9uTWFuYWdlcjtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L2Nvbm5lY3Rpb24udHNcbnZhciBDb25uZWN0aW9uID0gY2xhc3MgZXh0ZW5kcyBldmVudGVtaXR0ZXJfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKGFibHksIG9wdGlvbnMpIHtcbiAgICBzdXBlcihhYmx5LmxvZ2dlcik7XG4gICAgdGhpcy53aGVuU3RhdGUgPSAoc3RhdGUpID0+IHtcbiAgICAgIHJldHVybiBldmVudGVtaXR0ZXJfZGVmYXVsdC5wcm90b3R5cGUud2hlblN0YXRlLmNhbGwodGhpcywgc3RhdGUsIHRoaXMuc3RhdGUpO1xuICAgIH07XG4gICAgdGhpcy5hYmx5ID0gYWJseTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gbmV3IGNvbm5lY3Rpb25tYW5hZ2VyX2RlZmF1bHQoYWJseSwgb3B0aW9ucyk7XG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGUuc3RhdGU7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9yUmVhc29uID0gbnVsbDtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uKFwiY29ubmVjdGlvbnN0YXRlXCIsIChzdGF0ZUNoYW5nZSkgPT4ge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlID0gc3RhdGVDaGFuZ2UuY3VycmVudDtcbiAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChzdGF0ZSwgc3RhdGVDaGFuZ2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbihcInVwZGF0ZVwiLCAoc3RhdGVDaGFuZ2UpID0+IHtcbiAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCBzdGF0ZUNoYW5nZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBjb25uZWN0KCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbm5lY3Rpb24uY29ubmVjdCgpXCIsIFwiXCIpO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVxdWVzdFN0YXRlKHsgc3RhdGU6IFwiY29ubmVjdGluZ1wiIH0pO1xuICB9XG4gIGFzeW5jIHBpbmcoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbi5waW5nKClcIiwgXCJcIik7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucGluZygpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbm5lY3Rpb24uY2xvc2UoKVwiLCBcImNvbm5lY3Rpb25LZXkgPSBcIiArIHRoaXMua2V5KTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiBcImNsb3NpbmdcIiB9KTtcbiAgfVxuICBnZXQgcmVjb3ZlcnlLZXkoKSB7XG4gICAgdGhpcy5sb2dnZXIuZGVwcmVjYXRpb25XYXJuaW5nKFxuICAgICAgXCJUaGUgYENvbm5lY3Rpb24ucmVjb3ZlcnlLZXlgIGF0dHJpYnV0ZSBoYXMgYmVlbiByZXBsYWNlZCBieSB0aGUgYENvbm5lY3Rpb24uY3JlYXRlUmVjb3ZlcnlLZXkoKWAgbWV0aG9kLiBSZXBsYWNlIHlvdXIgdXNhZ2Ugb2YgYHJlY292ZXJ5S2V5YCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgYGNyZWF0ZVJlY292ZXJ5S2V5KClgLiBgcmVjb3ZlcnlLZXlgIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVSZWNvdmVyeUtleSgpO1xuICB9XG4gIGNyZWF0ZVJlY292ZXJ5S2V5KCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNyZWF0ZVJlY292ZXJ5S2V5KCk7XG4gIH1cbn07XG52YXIgY29ubmVjdGlvbl9kZWZhdWx0ID0gQ29ubmVjdGlvbjtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L2Jhc2VyZWFsdGltZS50c1xudmFyIF9CYXNlUmVhbHRpbWUgPSBjbGFzcyBfQmFzZVJlYWx0aW1lIGV4dGVuZHMgYmFzZWNsaWVudF9kZWZhdWx0IHtcbiAgLypcbiAgICogVGhlIHB1YmxpYyB0eXBpbmdzIGRlY2xhcmUgdGhhdCB0aGlzIG9ubHkgYWNjZXB0cyBhbiBvYmplY3QsIGJ1dCBzaW5jZSB3ZSB3YW50IHRvIGVtaXQgYSBnb29kIGVycm9yIG1lc3NhZ2UgaW4gdGhlIGNhc2Ugd2hlcmUgYSBub24tVHlwZVNjcmlwdCB1c2VyIGRvZXMgb25lIG9mIHRoZXNlIHRoaW5nczpcbiAgICpcbiAgICogMS4gcGFzc2VzIGEgc3RyaW5nICh3aGljaCBpcyBxdWl0ZSBsaWtlbHkgaWYgdGhleeKAmXJlIGUuZy4gbWlncmF0aW5nIGZyb20gdGhlIGRlZmF1bHQgdmFyaWFudCB0byB0aGUgbW9kdWxhciB2YXJpYW50KVxuICAgKiAyLiBwYXNzZXMgbm8gYXJndW1lbnQgYXQgYWxsXG4gICAqXG4gICAqIHRlbGwgdGhlIGNvbXBpbGVyIHRoYXQgdGhlc2UgY2FzZXMgYXJlIHBvc3NpYmxlIHNvIHRoYXQgaXQgZm9yY2VzIHVzIHRvIGhhbmRsZSB0aGVtLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfYTIsIF9iLCBfYywgX2Q7XG4gICAgc3VwZXIoZGVmYXVsdHNfZGVmYXVsdC5vYmplY3RpZnlPcHRpb25zKG9wdGlvbnMsIGZhbHNlLCBcIkJhc2VSZWFsdGltZVwiLCBsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyKSk7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVhbHRpbWUoKVwiLCBcIlwiKTtcbiAgICBpZiAodHlwZW9mIEVkZ2VSdW50aW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICBgQWJseS5SZWFsdGltZSBpbnN0YW5jZSBjYW5ub3QgYmUgdXNlZCBpbiBWZXJjZWwgRWRnZSBydW50aW1lLiBJZiB5b3UgYXJlIHJ1bm5pbmcgVmVyY2VsIEVkZ2UgZnVuY3Rpb25zLCBwbGVhc2UgcmVwbGFjZSB5b3VyIFwibmV3IEFibHkuUmVhbHRpbWUoKVwiIHdpdGggXCJuZXcgQWJseS5SZXN0KClcIiBhbmQgdXNlIEFibHkgUmVzdCBBUEkgaW5zdGVhZCBvZiB0aGUgUmVhbHRpbWUgQVBJLiBJZiB5b3UgYXJlIHNlcnZlci1yZW5kZXJpbmcgeW91ciBhcHBsaWNhdGlvbiBpbiB0aGUgVmVyY2VsIEVkZ2UgcnVudGltZSwgcGxlYXNlIHVzZSB0aGUgY29uZGl0aW9uIFwiaWYgKHR5cGVvZiBFZGdlUnVudGltZSA9PT0gJ3N0cmluZycpXCIgdG8gcHJldmVudCBpbnN0YW50aWF0aW5nIEFibHkuUmVhbHRpbWUgaW5zdGFuY2UgZHVyaW5nIFNTUiBpbiB0aGUgVmVyY2VsIEVkZ2UgcnVudGltZS5gLFxuICAgICAgICA0ZTQsXG4gICAgICAgIDQwMFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5fYWRkaXRpb25hbFRyYW5zcG9ydEltcGxlbWVudGF0aW9ucyA9IF9CYXNlUmVhbHRpbWUudHJhbnNwb3J0SW1wbGVtZW50YXRpb25zRnJvbVBsdWdpbnModGhpcy5vcHRpb25zLnBsdWdpbnMpO1xuICAgIHRoaXMuX1JlYWx0aW1lUHJlc2VuY2UgPSAoX2IgPSAoX2EyID0gdGhpcy5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuUmVhbHRpbWVQcmVzZW5jZSkgIT0gbnVsbCA/IF9iIDogbnVsbDtcbiAgICB0aGlzLl9vYmplY3RzUGx1Z2luID0gKF9kID0gKF9jID0gdGhpcy5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYy5PYmplY3RzKSAhPSBudWxsID8gX2QgOiBudWxsO1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBjb25uZWN0aW9uX2RlZmF1bHQodGhpcywgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLl9jaGFubmVscyA9IG5ldyBDaGFubmVsczIodGhpcyk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvQ29ubmVjdCAhPT0gZmFsc2UpXG4gICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgfVxuICBzdGF0aWMgdHJhbnNwb3J0SW1wbGVtZW50YXRpb25zRnJvbVBsdWdpbnMocGx1Z2lucykge1xuICAgIGNvbnN0IHRyYW5zcG9ydHMgPSB7fTtcbiAgICBpZiAocGx1Z2lucyA9PSBudWxsID8gdm9pZCAwIDogcGx1Z2lucy5XZWJTb2NrZXRUcmFuc3BvcnQpIHtcbiAgICAgIHRyYW5zcG9ydHNbVHJhbnNwb3J0TmFtZXMuV2ViU29ja2V0XSA9IHBsdWdpbnMuV2ViU29ja2V0VHJhbnNwb3J0O1xuICAgIH1cbiAgICBpZiAocGx1Z2lucyA9PSBudWxsID8gdm9pZCAwIDogcGx1Z2lucy5YSFJQb2xsaW5nKSB7XG4gICAgICB0cmFuc3BvcnRzW1RyYW5zcG9ydE5hbWVzLlhoclBvbGxpbmddID0gcGx1Z2lucy5YSFJQb2xsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3J0cztcbiAgfVxuICBnZXQgY2hhbm5lbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5uZWxzO1xuICB9XG4gIGNvbm5lY3QoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVhbHRpbWUuY29ubmVjdCgpXCIsIFwiXCIpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5jb25uZWN0KCk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVhbHRpbWUuY2xvc2UoKVwiLCBcIlwiKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgfVxufTtcbi8vIGludGVybmFsIEFQSSB0byBtYWtlIEV2ZW50RW1pdHRlciB1c2FibGUgaW4gb3RoZXIgU0RLc1xuX0Jhc2VSZWFsdGltZS5FdmVudEVtaXR0ZXIgPSBldmVudGVtaXR0ZXJfZGVmYXVsdDtcbnZhciBCYXNlUmVhbHRpbWUgPSBfQmFzZVJlYWx0aW1lO1xudmFyIENoYW5uZWxzMiA9IGNsYXNzIGV4dGVuZHMgZXZlbnRlbWl0dGVyX2RlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihyZWFsdGltZSkge1xuICAgIHN1cGVyKHJlYWx0aW1lLmxvZ2dlcik7XG4gICAgdGhpcy5yZWFsdGltZSA9IHJlYWx0aW1lO1xuICAgIHRoaXMuYWxsID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmVhbHRpbWUuY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5vbihcInRyYW5zcG9ydC5hY3RpdmVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5vblRyYW5zcG9ydEFjdGl2ZSgpO1xuICAgIH0pO1xuICB9XG4gIGNoYW5uZWxTZXJpYWxzKCkge1xuICAgIGxldCBzZXJpYWxzID0ge307XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGtleXNBcnJheSh0aGlzLmFsbCwgdHJ1ZSkpIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXTtcbiAgICAgIGlmIChjaGFubmVsLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCkge1xuICAgICAgICBzZXJpYWxzW25hbWVdID0gY2hhbm5lbC5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxzO1xuICB9XG4gIC8vIHJlY292ZXJDaGFubmVscyBnZXRzIHRoZSBnaXZlbiBjaGFubmVscyBhbmQgc2V0cyB0aGVpciBjaGFubmVsIHNlcmlhbHMuXG4gIHJlY292ZXJDaGFubmVscyhjaGFubmVsU2VyaWFscykge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBrZXlzQXJyYXkoY2hhbm5lbFNlcmlhbHMsIHRydWUpKSB7XG4gICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5nZXQobmFtZSk7XG4gICAgICBjaGFubmVsLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCA9IGNoYW5uZWxTZXJpYWxzW25hbWVdO1xuICAgIH1cbiAgfVxuICAvLyBBY2Nlc3MgdG8gdGhpcyBtZXRob2QgaXMgc3luY2hyb25pc2VkIGJ5IENvbm5lY3Rpb25NYW5hZ2VyI3Byb2Nlc3NDaGFubmVsTWVzc2FnZS5cbiAgYXN5bmMgcHJvY2Vzc0NoYW5uZWxNZXNzYWdlKG1zZykge1xuICAgIGNvbnN0IGNoYW5uZWxOYW1lID0gbXNnLmNoYW5uZWw7XG4gICAgaWYgKGNoYW5uZWxOYW1lID09PSB2b2lkIDApIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJDaGFubmVscy5wcm9jZXNzQ2hhbm5lbE1lc3NhZ2UoKVwiLFxuICAgICAgICBcInJlY2VpdmVkIGV2ZW50IHVuc3BlY2lmaWVkIGNoYW5uZWwsIGFjdGlvbiA9IFwiICsgbXNnLmFjdGlvblxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxOYW1lXTtcbiAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJDaGFubmVscy5wcm9jZXNzQ2hhbm5lbE1lc3NhZ2UoKVwiLFxuICAgICAgICBcInJlY2VpdmVkIGV2ZW50IGZvciBub24tZXhpc3RlbnQgY2hhbm5lbDogXCIgKyBjaGFubmVsTmFtZVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgY2hhbm5lbC5wcm9jZXNzTWVzc2FnZShtc2cpO1xuICB9XG4gIC8qIGNhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGJlY29tZXMgY29ubmVjdGVkOyByZWF0dGVtcHQgYXR0YWNoL2RldGFjaFxuICAgKiBmb3IgY2hhbm5lbHMgdGhhdCBhcmUgYXR0YWNoaW5nIG9yIGRldGFjaGluZy4gKi9cbiAgb25UcmFuc3BvcnRBY3RpdmUoKSB7XG4gICAgZm9yIChjb25zdCBjaGFubmVsTmFtZSBpbiB0aGlzLmFsbCkge1xuICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxOYW1lXTtcbiAgICAgIGlmIChjaGFubmVsLnN0YXRlID09PSBcImF0dGFjaGluZ1wiIHx8IGNoYW5uZWwuc3RhdGUgPT09IFwiZGV0YWNoaW5nXCIpIHtcbiAgICAgICAgY2hhbm5lbC5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuICAgICAgfSBlbHNlIGlmIChjaGFubmVsLnN0YXRlID09PSBcInN1c3BlbmRlZFwiKSB7XG4gICAgICAgIGNoYW5uZWwuX2F0dGFjaChmYWxzZSwgbnVsbCk7XG4gICAgICB9IGVsc2UgaWYgKGNoYW5uZWwuc3RhdGUgPT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgICBjaGFubmVsLnJlcXVlc3RTdGF0ZShcImF0dGFjaGluZ1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyogQ29ubmVjdGlvbiBpbnRlcnJ1cHRpb25zIChpZSB3aGVuIHRoZSBjb25uZWN0aW9uIHdpbGwgbm8gbG9uZ2VyIHF1ZXVlXG4gICAqIGV2ZW50cykgaW1wbHkgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VzIGZvciBhbnkgY2hhbm5lbCB3aGljaCBpcyBlaXRoZXJcbiAgICogYXR0YWNoZWQsIHBlbmRpbmcsIG9yIHdpbGwgYXR0ZW1wdCB0byBiZWNvbWUgYXR0YWNoZWQgaW4gdGhlIGZ1dHVyZSAqL1xuICBwcm9wb2dhdGVDb25uZWN0aW9uSW50ZXJydXB0aW9uKGNvbm5lY3Rpb25TdGF0ZSwgcmVhc29uKSB7XG4gICAgY29uc3QgY29ubmVjdGlvblN0YXRlVG9DaGFubmVsU3RhdGUgPSB7XG4gICAgICBjbG9zaW5nOiBcImRldGFjaGVkXCIsXG4gICAgICBjbG9zZWQ6IFwiZGV0YWNoZWRcIixcbiAgICAgIGZhaWxlZDogXCJmYWlsZWRcIixcbiAgICAgIHN1c3BlbmRlZDogXCJzdXNwZW5kZWRcIlxuICAgIH07XG4gICAgY29uc3QgZnJvbUNoYW5uZWxTdGF0ZXMgPSBbXCJhdHRhY2hpbmdcIiwgXCJhdHRhY2hlZFwiLCBcImRldGFjaGluZ1wiLCBcInN1c3BlbmRlZFwiXTtcbiAgICBjb25zdCB0b0NoYW5uZWxTdGF0ZSA9IGNvbm5lY3Rpb25TdGF0ZVRvQ2hhbm5lbFN0YXRlW2Nvbm5lY3Rpb25TdGF0ZV07XG4gICAgZm9yIChjb25zdCBjaGFubmVsSWQgaW4gdGhpcy5hbGwpIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsSWRdO1xuICAgICAgaWYgKGZyb21DaGFubmVsU3RhdGVzLmluY2x1ZGVzKGNoYW5uZWwuc3RhdGUpKSB7XG4gICAgICAgIGNoYW5uZWwubm90aWZ5U3RhdGUodG9DaGFubmVsU3RhdGUsIHJlYXNvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldChuYW1lLCBjaGFubmVsT3B0aW9ucykge1xuICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgbGV0IGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXTtcbiAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgIGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXSA9IG5ldyByZWFsdGltZWNoYW5uZWxfZGVmYXVsdCh0aGlzLnJlYWx0aW1lLCBuYW1lLCBjaGFubmVsT3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChjaGFubmVsT3B0aW9ucykge1xuICAgICAgaWYgKGNoYW5uZWwuX3Nob3VsZFJlYXR0YWNoVG9TZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zLCBjaGFubmVsLmNoYW5uZWxPcHRpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgIFwiQ2hhbm5lbHMuZ2V0KCkgY2Fubm90IGJlIHVzZWQgdG8gc2V0IGNoYW5uZWwgb3B0aW9ucyB0aGF0IHdvdWxkIGNhdXNlIHRoZSBjaGFubmVsIHRvIHJlYXR0YWNoLiBQbGVhc2UsIHVzZSBSZWFsdGltZUNoYW5uZWwuc2V0T3B0aW9ucygpIGluc3RlYWQuXCIsXG4gICAgICAgICAgNGU0LFxuICAgICAgICAgIDQwMFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hhbm5lbC5zZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5uZWw7XG4gIH1cbiAgZ2V0RGVyaXZlZChuYW1lLCBkZXJpdmVPcHRpb25zLCBjaGFubmVsT3B0aW9ucykge1xuICAgIGlmIChkZXJpdmVPcHRpb25zLmZpbHRlcikge1xuICAgICAgY29uc3QgZmlsdGVyID0gdG9CYXNlNjQoZGVyaXZlT3B0aW9ucy5maWx0ZXIpO1xuICAgICAgY29uc3QgbWF0Y2ggPSBtYXRjaERlcml2ZWRDaGFubmVsKG5hbWUpO1xuICAgICAgbmFtZSA9IGBbZmlsdGVyPSR7ZmlsdGVyfSR7bWF0Y2gucXVhbGlmaWVyUGFyYW19XSR7bWF0Y2guY2hhbm5lbE5hbWV9YDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0KG5hbWUsIGNoYW5uZWxPcHRpb25zKTtcbiAgfVxuICAvKiBJbmNsdWRlZCB0byBzdXBwb3J0IGNlcnRhaW4gbmljaGUgdXNlLWNhc2VzOyBtb3N0IHVzZXJzIHNob3VsZCBpZ25vcmUgdGhpcy5cbiAgICogUGxlYXNlIGRvIG5vdCB1c2UgdGhpcyB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcgKi9cbiAgcmVsZWFzZShuYW1lKSB7XG4gICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV07XG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlbGVhc2VFcnIgPSBjaGFubmVsLmdldFJlbGVhc2VFcnIoKTtcbiAgICBpZiAocmVsZWFzZUVycikge1xuICAgICAgdGhyb3cgcmVsZWFzZUVycjtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuYWxsW25hbWVdO1xuICB9XG59O1xudmFyIGJhc2VyZWFsdGltZV9kZWZhdWx0ID0gQmFzZVJlYWx0aW1lO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcHJlc2VuY2VtYXAudHNcbmZ1bmN0aW9uIG5ld2VyVGhhbihpdGVtLCBleGlzdGluZykge1xuICBpZiAoaXRlbS5pc1N5bnRoZXNpemVkKCkgfHwgZXhpc3RpbmcuaXNTeW50aGVzaXplZCgpKSB7XG4gICAgcmV0dXJuIGl0ZW0udGltZXN0YW1wID49IGV4aXN0aW5nLnRpbWVzdGFtcDtcbiAgfVxuICBjb25zdCBpdGVtT3JkZXJpbmdzID0gaXRlbS5wYXJzZUlkKCksIGV4aXN0aW5nT3JkZXJpbmdzID0gZXhpc3RpbmcucGFyc2VJZCgpO1xuICBpZiAoaXRlbU9yZGVyaW5ncy5tc2dTZXJpYWwgPT09IGV4aXN0aW5nT3JkZXJpbmdzLm1zZ1NlcmlhbCkge1xuICAgIHJldHVybiBpdGVtT3JkZXJpbmdzLmluZGV4ID4gZXhpc3RpbmdPcmRlcmluZ3MuaW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGl0ZW1PcmRlcmluZ3MubXNnU2VyaWFsID4gZXhpc3RpbmdPcmRlcmluZ3MubXNnU2VyaWFsO1xuICB9XG59XG52YXIgUHJlc2VuY2VNYXAgPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IocHJlc2VuY2UsIG1lbWJlcktleSwgbmV3ZXIgPSBuZXdlclRoYW4pIHtcbiAgICBzdXBlcihwcmVzZW5jZS5sb2dnZXIpO1xuICAgIHRoaXMucHJlc2VuY2UgPSBwcmVzZW5jZTtcbiAgICB0aGlzLm1hcCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuc3luY0luUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB0aGlzLnJlc2lkdWFsTWVtYmVycyA9IG51bGw7XG4gICAgdGhpcy5tZW1iZXJLZXkgPSBtZW1iZXJLZXk7XG4gICAgdGhpcy5uZXdlclRoYW4gPSBuZXdlcjtcbiAgfVxuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubWFwW2tleV07XG4gIH1cbiAgZ2V0Q2xpZW50KGNsaWVudElkKSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5tYXAsIHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1hcCkge1xuICAgICAgY29uc3QgaXRlbSA9IG1hcFtrZXldO1xuICAgICAgaWYgKGl0ZW0uY2xpZW50SWQgPT0gY2xpZW50SWQgJiYgaXRlbS5hY3Rpb24gIT0gXCJhYnNlbnRcIilcbiAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGlzdChwYXJhbXMpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLm1hcCwgY2xpZW50SWQgPSBwYXJhbXMgJiYgcGFyYW1zLmNsaWVudElkLCBjb25uZWN0aW9uSWQgPSBwYXJhbXMgJiYgcGFyYW1zLmNvbm5lY3Rpb25JZCwgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWFwKSB7XG4gICAgICBjb25zdCBpdGVtID0gbWFwW2tleV07XG4gICAgICBpZiAoaXRlbS5hY3Rpb24gPT09IFwiYWJzZW50XCIpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKGNsaWVudElkICYmIGNsaWVudElkICE9IGl0ZW0uY2xpZW50SWQpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKGNvbm5lY3Rpb25JZCAmJiBjb25uZWN0aW9uSWQgIT0gaXRlbS5jb25uZWN0aW9uSWQpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcHV0KGl0ZW0pIHtcbiAgICBpZiAoaXRlbS5hY3Rpb24gPT09IFwiZW50ZXJcIiB8fCBpdGVtLmFjdGlvbiA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgaXRlbSA9IHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXMoaXRlbSk7XG4gICAgICBpdGVtLmFjdGlvbiA9IFwicHJlc2VudFwiO1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSB0aGlzLm1hcCwga2V5ID0gdGhpcy5tZW1iZXJLZXkoaXRlbSk7XG4gICAgaWYgKHRoaXMucmVzaWR1YWxNZW1iZXJzKVxuICAgICAgZGVsZXRlIHRoaXMucmVzaWR1YWxNZW1iZXJzW2tleV07XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtID0gbWFwW2tleV07XG4gICAgaWYgKGV4aXN0aW5nSXRlbSAmJiAhdGhpcy5uZXdlclRoYW4oaXRlbSwgZXhpc3RpbmdJdGVtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtYXBba2V5XSA9IGl0ZW07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFsdWVzKCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMubWFwLCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtYXApIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBtYXBba2V5XTtcbiAgICAgIGlmIChpdGVtLmFjdGlvbiAhPSBcImFic2VudFwiKVxuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZW1vdmUoaXRlbSkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMubWFwLCBrZXkgPSB0aGlzLm1lbWJlcktleShpdGVtKTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSBtYXBba2V5XTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtICYmICF0aGlzLm5ld2VyVGhhbihpdGVtLCBleGlzdGluZ0l0ZW0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLnN5bmNJblByb2dyZXNzKSB7XG4gICAgICBpdGVtID0gcHJlc2VuY2VtZXNzYWdlX2RlZmF1bHQuZnJvbVZhbHVlcyhpdGVtKTtcbiAgICAgIGl0ZW0uYWN0aW9uID0gXCJhYnNlbnRcIjtcbiAgICAgIG1hcFtrZXldID0gaXRlbTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIG1hcFtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gISFleGlzdGluZ0l0ZW07XG4gIH1cbiAgc3RhcnRTeW5jKCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMubWFwLCBzeW5jSW5Qcm9ncmVzcyA9IHRoaXMuc3luY0luUHJvZ3Jlc3M7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIlByZXNlbmNlTWFwLnN0YXJ0U3luYygpXCIsXG4gICAgICBcImNoYW5uZWwgPSBcIiArIHRoaXMucHJlc2VuY2UuY2hhbm5lbC5uYW1lICsgXCI7IHN5bmNJblByb2dyZXNzID0gXCIgKyBzeW5jSW5Qcm9ncmVzc1xuICAgICk7XG4gICAgaWYgKCF0aGlzLnN5bmNJblByb2dyZXNzKSB7XG4gICAgICB0aGlzLnJlc2lkdWFsTWVtYmVycyA9IGNvcHkobWFwKTtcbiAgICAgIHRoaXMuc2V0SW5Qcm9ncmVzcyh0cnVlKTtcbiAgICB9XG4gIH1cbiAgZW5kU3luYygpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLm1hcCwgc3luY0luUHJvZ3Jlc3MgPSB0aGlzLnN5bmNJblByb2dyZXNzO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJQcmVzZW5jZU1hcC5lbmRTeW5jKClcIixcbiAgICAgIFwiY2hhbm5lbCA9IFwiICsgdGhpcy5wcmVzZW5jZS5jaGFubmVsLm5hbWUgKyBcIjsgc3luY0luUHJvZ3Jlc3MgPSBcIiArIHN5bmNJblByb2dyZXNzXG4gICAgKTtcbiAgICBpZiAoc3luY0luUHJvZ3Jlc3MpIHtcbiAgICAgIGZvciAoY29uc3QgbWVtYmVyS2V5IGluIG1hcCkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IG1hcFttZW1iZXJLZXldO1xuICAgICAgICBpZiAoZW50cnkuYWN0aW9uID09PSBcImFic2VudFwiKSB7XG4gICAgICAgICAgZGVsZXRlIG1hcFttZW1iZXJLZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnByZXNlbmNlLl9zeW50aGVzaXplTGVhdmVzKHZhbHVlc0FycmF5KHRoaXMucmVzaWR1YWxNZW1iZXJzKSk7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlcktleSBpbiB0aGlzLnJlc2lkdWFsTWVtYmVycykge1xuICAgICAgICBkZWxldGUgbWFwW21lbWJlcktleV07XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2lkdWFsTWVtYmVycyA9IG51bGw7XG4gICAgICB0aGlzLnNldEluUHJvZ3Jlc3MoZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJzeW5jXCIpO1xuICB9XG4gIHdhaXRTeW5jKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc3luY0luUHJvZ3Jlc3MgPSB0aGlzLnN5bmNJblByb2dyZXNzO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJQcmVzZW5jZU1hcC53YWl0U3luYygpXCIsXG4gICAgICBcImNoYW5uZWwgPSBcIiArIHRoaXMucHJlc2VuY2UuY2hhbm5lbC5uYW1lICsgXCI7IHN5bmNJblByb2dyZXNzID0gXCIgKyBzeW5jSW5Qcm9ncmVzc1xuICAgICk7XG4gICAgaWYgKCFzeW5jSW5Qcm9ncmVzcykge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vbmNlKFwic3luY1wiLCBjYWxsYmFjayk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5tYXAgPSB7fTtcbiAgICB0aGlzLnNldEluUHJvZ3Jlc3MoZmFsc2UpO1xuICAgIHRoaXMucmVzaWR1YWxNZW1iZXJzID0gbnVsbDtcbiAgfVxuICBzZXRJblByb2dyZXNzKGluUHJvZ3Jlc3MpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJQcmVzZW5jZU1hcC5zZXRJblByb2dyZXNzKClcIiwgXCJpblByb2dyZXNzID0gXCIgKyBpblByb2dyZXNzKTtcbiAgICB0aGlzLnN5bmNJblByb2dyZXNzID0gaW5Qcm9ncmVzcztcbiAgICB0aGlzLnByZXNlbmNlLnN5bmNDb21wbGV0ZSA9ICFpblByb2dyZXNzO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVhbHRpbWVwcmVzZW5jZS50c1xuZnVuY3Rpb24gZ2V0Q2xpZW50SWQocmVhbHRpbWVQcmVzZW5jZSkge1xuICByZXR1cm4gcmVhbHRpbWVQcmVzZW5jZS5jaGFubmVsLmNsaWVudC5hdXRoLmNsaWVudElkO1xufVxuZnVuY3Rpb24gaXNBbm9ueW1vdXNPcldpbGRjYXJkKHJlYWx0aW1lUHJlc2VuY2UpIHtcbiAgY29uc3QgcmVhbHRpbWUgPSByZWFsdGltZVByZXNlbmNlLmNoYW5uZWwuY2xpZW50O1xuICBjb25zdCBjbGllbnRJZCA9IHJlYWx0aW1lLmF1dGguY2xpZW50SWQ7XG4gIHJldHVybiAoIWNsaWVudElkIHx8IGNsaWVudElkID09PSBcIipcIikgJiYgcmVhbHRpbWUuY29ubmVjdGlvbi5zdGF0ZSA9PT0gXCJjb25uZWN0ZWRcIjtcbn1cbmZ1bmN0aW9uIHdhaXRBdHRhY2hlZChjaGFubmVsLCBjYWxsYmFjaywgYWN0aW9uKSB7XG4gIHN3aXRjaCAoY2hhbm5lbC5zdGF0ZSkge1xuICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgIGNhc2UgXCJzdXNwZW5kZWRcIjpcbiAgICAgIGFjdGlvbigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImluaXRpYWxpemVkXCI6XG4gICAgY2FzZSBcImRldGFjaGVkXCI6XG4gICAgY2FzZSBcImRldGFjaGluZ1wiOlxuICAgIGNhc2UgXCJhdHRhY2hpbmdcIjpcbiAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyhjaGFubmVsLmF0dGFjaCgpLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKGVycilcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYWN0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBjYWxsYmFjayhFcnJvckluZm8uZnJvbVZhbHVlcyhjaGFubmVsLmludmFsaWRTdGF0ZUVycm9yKCkpKTtcbiAgfVxufVxudmFyIFJlYWx0aW1lUHJlc2VuY2UgPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IoY2hhbm5lbCkge1xuICAgIHN1cGVyKGNoYW5uZWwubG9nZ2VyKTtcbiAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgIHRoaXMuc3luY0NvbXBsZXRlID0gZmFsc2U7XG4gICAgdGhpcy5tZW1iZXJzID0gbmV3IFByZXNlbmNlTWFwKHRoaXMsIChpdGVtKSA9PiBpdGVtLmNsaWVudElkICsgXCI6XCIgKyBpdGVtLmNvbm5lY3Rpb25JZCk7XG4gICAgdGhpcy5fbXlNZW1iZXJzID0gbmV3IFByZXNlbmNlTWFwKHRoaXMsIChpdGVtKSA9PiBpdGVtLmNsaWVudElkKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgZXZlbnRlbWl0dGVyX2RlZmF1bHQodGhpcy5sb2dnZXIpO1xuICAgIHRoaXMucGVuZGluZ1ByZXNlbmNlID0gW107XG4gIH1cbiAgYXN5bmMgZW50ZXIoZGF0YSkge1xuICAgIGlmIChpc0Fub255bW91c09yV2lsZGNhcmQodGhpcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJjbGllbnRJZCBtdXN0IGJlIHNwZWNpZmllZCB0byBlbnRlciBhIHByZXNlbmNlIGNoYW5uZWxcIiwgNDAwMTIsIDQwMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KHZvaWQgMCwgdm9pZCAwLCBkYXRhLCBcImVudGVyXCIpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZShkYXRhKSB7XG4gICAgaWYgKGlzQW5vbnltb3VzT3JXaWxkY2FyZCh0aGlzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcImNsaWVudElkIG11c3QgYmUgc3BlY2lmaWVkIHRvIHVwZGF0ZSBwcmVzZW5jZSBkYXRhXCIsIDQwMDEyLCA0MDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudCh2b2lkIDAsIHZvaWQgMCwgZGF0YSwgXCJ1cGRhdGVcIik7XG4gIH1cbiAgYXN5bmMgZW50ZXJDbGllbnQoY2xpZW50SWQsIGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudCh2b2lkIDAsIGNsaWVudElkLCBkYXRhLCBcImVudGVyXCIpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUNsaWVudChjbGllbnRJZCwgZGF0YSkge1xuICAgIHJldHVybiB0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KHZvaWQgMCwgY2xpZW50SWQsIGRhdGEsIFwidXBkYXRlXCIpO1xuICB9XG4gIGFzeW5jIF9lbnRlck9yVXBkYXRlQ2xpZW50KGlkLCBjbGllbnRJZCwgZGF0YSwgYWN0aW9uKSB7XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbDtcbiAgICBpZiAoIWNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuICAgICAgdGhyb3cgY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpO1xuICAgIH1cbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiUmVhbHRpbWVQcmVzZW5jZS5cIiArIGFjdGlvbiArIFwiQ2xpZW50KClcIixcbiAgICAgIFwiY2hhbm5lbCA9IFwiICsgY2hhbm5lbC5uYW1lICsgXCIsIGlkID0gXCIgKyBpZCArIFwiLCBjbGllbnQgPSBcIiArIChjbGllbnRJZCB8fCBcIihpbXBsaWNpdCkgXCIgKyBnZXRDbGllbnRJZCh0aGlzKSlcbiAgICApO1xuICAgIGNvbnN0IHByZXNlbmNlID0gcHJlc2VuY2VtZXNzYWdlX2RlZmF1bHQuZnJvbURhdGEoZGF0YSk7XG4gICAgcHJlc2VuY2UuYWN0aW9uID0gYWN0aW9uO1xuICAgIGlmIChpZCkge1xuICAgICAgcHJlc2VuY2UuaWQgPSBpZDtcbiAgICB9XG4gICAgaWYgKGNsaWVudElkKSB7XG4gICAgICBwcmVzZW5jZS5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgIH1cbiAgICBjb25zdCB3aXJlUHJlc01zZyA9IGF3YWl0IHByZXNlbmNlLmVuY29kZShjaGFubmVsLmNoYW5uZWxPcHRpb25zKTtcbiAgICBzd2l0Y2ggKGNoYW5uZWwuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgICAgICByZXR1cm4gY2hhbm5lbC5zZW5kUHJlc2VuY2UoW3dpcmVQcmVzTXNnXSk7XG4gICAgICBjYXNlIFwiaW5pdGlhbGl6ZWRcIjpcbiAgICAgIGNhc2UgXCJkZXRhY2hlZFwiOlxuICAgICAgICBjaGFubmVsLmF0dGFjaCgpO1xuICAgICAgY2FzZSBcImF0dGFjaGluZ1wiOlxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHRoaXMucGVuZGluZ1ByZXNlbmNlLnB1c2goe1xuICAgICAgICAgICAgcHJlc2VuY2U6IHdpcmVQcmVzTXNnLFxuICAgICAgICAgICAgY2FsbGJhY2s6IChlcnIpID0+IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgUGFydGlhbEVycm9ySW5mbyhcbiAgICAgICAgICBcIlVuYWJsZSB0byBcIiArIGFjdGlvbiArIFwiIHByZXNlbmNlIGNoYW5uZWwgd2hpbGUgaW4gXCIgKyBjaGFubmVsLnN0YXRlICsgXCIgc3RhdGVcIixcbiAgICAgICAgICA5MDAwMVxuICAgICAgICApO1xuICAgICAgICBlcnIuY29kZSA9IDkwMDAxO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGxlYXZlKGRhdGEpIHtcbiAgICBpZiAoaXNBbm9ueW1vdXNPcldpbGRjYXJkKHRoaXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiY2xpZW50SWQgbXVzdCBoYXZlIGJlZW4gc3BlY2lmaWVkIHRvIGVudGVyIG9yIGxlYXZlIGEgcHJlc2VuY2UgY2hhbm5lbFwiLCA0MDAxMiwgNDAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGVhdmVDbGllbnQodm9pZCAwLCBkYXRhKTtcbiAgfVxuICBhc3luYyBsZWF2ZUNsaWVudChjbGllbnRJZCwgZGF0YSkge1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG4gICAgaWYgKCFjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcbiAgICAgIHRocm93IGNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKTtcbiAgICB9XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lUHJlc2VuY2UubGVhdmVDbGllbnQoKVwiLFxuICAgICAgXCJsZWF2aW5nOyBjaGFubmVsID0gXCIgKyB0aGlzLmNoYW5uZWwubmFtZSArIFwiLCBjbGllbnQgPSBcIiArIGNsaWVudElkXG4gICAgKTtcbiAgICBjb25zdCBwcmVzZW5jZSA9IHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0LmZyb21EYXRhKGRhdGEpO1xuICAgIHByZXNlbmNlLmFjdGlvbiA9IFwibGVhdmVcIjtcbiAgICBpZiAoY2xpZW50SWQpIHtcbiAgICAgIHByZXNlbmNlLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgfVxuICAgIGNvbnN0IHdpcmVQcmVzTXNnID0gYXdhaXQgcHJlc2VuY2UuZW5jb2RlKGNoYW5uZWwuY2hhbm5lbE9wdGlvbnMpO1xuICAgIHN3aXRjaCAoY2hhbm5lbC5zdGF0ZSkge1xuICAgICAgY2FzZSBcImF0dGFjaGVkXCI6XG4gICAgICAgIHJldHVybiBjaGFubmVsLnNlbmRQcmVzZW5jZShbd2lyZVByZXNNc2ddKTtcbiAgICAgIGNhc2UgXCJhdHRhY2hpbmdcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdQcmVzZW5jZS5wdXNoKHtcbiAgICAgICAgICAgIHByZXNlbmNlOiB3aXJlUHJlc01zZyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoZXJyKSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJpbml0aWFsaXplZFwiOlxuICAgICAgY2FzZSBcImZhaWxlZFwiOiB7XG4gICAgICAgIHRocm93IG5ldyBQYXJ0aWFsRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGxlYXZlIHByZXNlbmNlIGNoYW5uZWwgKGluY29tcGF0aWJsZSBzdGF0ZSlcIiwgOTAwMDEpO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgY2hhbm5lbC5pbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgY29uc3Qgd2FpdEZvclN5bmMgPSAhcGFyYW1zIHx8IChcIndhaXRGb3JTeW5jXCIgaW4gcGFyYW1zID8gcGFyYW1zLndhaXRGb3JTeW5jIDogdHJ1ZSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGZ1bmN0aW9uIHJldHVybk1lbWJlcnMobWVtYmVycykge1xuICAgICAgICByZXNvbHZlKHBhcmFtcyA/IG1lbWJlcnMubGlzdChwYXJhbXMpIDogbWVtYmVycy52YWx1ZXMoKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jaGFubmVsLnN0YXRlID09PSBcInN1c3BlbmRlZFwiKSB7XG4gICAgICAgIGlmICh3YWl0Rm9yU3luYykge1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIEVycm9ySW5mby5mcm9tVmFsdWVzKHtcbiAgICAgICAgICAgICAgc3RhdHVzQ29kZTogNDAwLFxuICAgICAgICAgICAgICBjb2RlOiA5MTAwNSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogXCJQcmVzZW5jZSBzdGF0ZSBpcyBvdXQgb2Ygc3luYyBkdWUgdG8gY2hhbm5lbCBiZWluZyBpbiB0aGUgU1VTUEVOREVEIHN0YXRlXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm5NZW1iZXJzKHRoaXMubWVtYmVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2FpdEF0dGFjaGVkKFxuICAgICAgICB0aGlzLmNoYW5uZWwsXG4gICAgICAgIChlcnIpID0+IHJlamVjdChlcnIpLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgbWVtYmVycyA9IHRoaXMubWVtYmVycztcbiAgICAgICAgICBpZiAod2FpdEZvclN5bmMpIHtcbiAgICAgICAgICAgIG1lbWJlcnMud2FpdFN5bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybk1lbWJlcnMobWVtYmVycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuTWVtYmVycyhtZW1iZXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgaGlzdG9yeShwYXJhbXMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZWFsdGltZVByZXNlbmNlLmhpc3RvcnkoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMubmFtZSk7XG4gICAgY29uc3QgcmVzdE1peGluID0gdGhpcy5jaGFubmVsLmNsaWVudC5yZXN0LnByZXNlbmNlTWl4aW47XG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMudW50aWxBdHRhY2gpIHtcbiAgICAgIGlmICh0aGlzLmNoYW5uZWwuc3RhdGUgPT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgICBkZWxldGUgcGFyYW1zLnVudGlsQXR0YWNoO1xuICAgICAgICBwYXJhbXMuZnJvbV9zZXJpYWwgPSB0aGlzLmNoYW5uZWwucHJvcGVydGllcy5hdHRhY2hTZXJpYWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgIFwib3B0aW9uIHVudGlsQXR0YWNoIHJlcXVpcmVzIHRoZSBjaGFubmVsIHRvIGJlIGF0dGFjaGVkLCB3YXM6IFwiICsgdGhpcy5jaGFubmVsLnN0YXRlLFxuICAgICAgICAgIDRlNCxcbiAgICAgICAgICA0MDBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3RNaXhpbi5oaXN0b3J5KHRoaXMsIHBhcmFtcyk7XG4gIH1cbiAgc2V0UHJlc2VuY2UocHJlc2VuY2VTZXQsIGlzU3luYywgc3luY0NoYW5uZWxTZXJpYWwpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiUmVhbHRpbWVQcmVzZW5jZS5zZXRQcmVzZW5jZSgpXCIsXG4gICAgICBcInJlY2VpdmVkIHByZXNlbmNlIGZvciBcIiArIHByZXNlbmNlU2V0Lmxlbmd0aCArIFwiIHBhcnRpY2lwYW50czsgc3luY0NoYW5uZWxTZXJpYWwgPSBcIiArIHN5bmNDaGFubmVsU2VyaWFsXG4gICAgKTtcbiAgICBsZXQgc3luY0N1cnNvciwgbWF0Y2g7XG4gICAgY29uc3QgbWVtYmVycyA9IHRoaXMubWVtYmVycywgbXlNZW1iZXJzID0gdGhpcy5fbXlNZW1iZXJzLCBicm9hZGNhc3RNZXNzYWdlcyA9IFtdLCBjb25uSWQgPSB0aGlzLmNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkO1xuICAgIGlmIChpc1N5bmMpIHtcbiAgICAgIHRoaXMubWVtYmVycy5zdGFydFN5bmMoKTtcbiAgICAgIGlmIChzeW5jQ2hhbm5lbFNlcmlhbCAmJiAobWF0Y2ggPSBzeW5jQ2hhbm5lbFNlcmlhbC5tYXRjaCgvXltcXHctXSs6KC4qKSQvKSkpIHtcbiAgICAgICAgc3luY0N1cnNvciA9IG1hdGNoWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBwcmVzZW5jZSBvZiBwcmVzZW5jZVNldCkge1xuICAgICAgc3dpdGNoIChwcmVzZW5jZS5hY3Rpb24pIHtcbiAgICAgICAgY2FzZSBcImxlYXZlXCI6XG4gICAgICAgICAgaWYgKG1lbWJlcnMucmVtb3ZlKHByZXNlbmNlKSkge1xuICAgICAgICAgICAgYnJvYWRjYXN0TWVzc2FnZXMucHVzaChwcmVzZW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmVzZW5jZS5jb25uZWN0aW9uSWQgPT09IGNvbm5JZCAmJiAhcHJlc2VuY2UuaXNTeW50aGVzaXplZCgpKSB7XG4gICAgICAgICAgICBteU1lbWJlcnMucmVtb3ZlKHByZXNlbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlbnRlclwiOlxuICAgICAgICBjYXNlIFwicHJlc2VudFwiOlxuICAgICAgICBjYXNlIFwidXBkYXRlXCI6XG4gICAgICAgICAgaWYgKG1lbWJlcnMucHV0KHByZXNlbmNlKSkge1xuICAgICAgICAgICAgYnJvYWRjYXN0TWVzc2FnZXMucHVzaChwcmVzZW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmVzZW5jZS5jb25uZWN0aW9uSWQgPT09IGNvbm5JZCkge1xuICAgICAgICAgICAgbXlNZW1iZXJzLnB1dChwcmVzZW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNTeW5jICYmICFzeW5jQ3Vyc29yKSB7XG4gICAgICBtZW1iZXJzLmVuZFN5bmMoKTtcbiAgICAgIHRoaXMuY2hhbm5lbC5zeW5jQ2hhbm5lbFNlcmlhbCA9IG51bGw7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnJvYWRjYXN0TWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHByZXNlbmNlID0gYnJvYWRjYXN0TWVzc2FnZXNbaV07XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZW1pdChwcmVzZW5jZS5hY3Rpb24sIHByZXNlbmNlKTtcbiAgICB9XG4gIH1cbiAgb25BdHRhY2hlZChoYXNQcmVzZW5jZSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJSZWFsdGltZVByZXNlbmNlLm9uQXR0YWNoZWQoKVwiLFxuICAgICAgXCJjaGFubmVsID0gXCIgKyB0aGlzLmNoYW5uZWwubmFtZSArIFwiLCBoYXNQcmVzZW5jZSA9IFwiICsgaGFzUHJlc2VuY2VcbiAgICApO1xuICAgIGlmIChoYXNQcmVzZW5jZSkge1xuICAgICAgdGhpcy5tZW1iZXJzLnN0YXJ0U3luYygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zeW50aGVzaXplTGVhdmVzKHRoaXMubWVtYmVycy52YWx1ZXMoKSk7XG4gICAgICB0aGlzLm1lbWJlcnMuY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCgpO1xuICAgIGNvbnN0IHBlbmRpbmdQcmVzZW5jZSA9IHRoaXMucGVuZGluZ1ByZXNlbmNlLCBwZW5kaW5nUHJlc0NvdW50ID0gcGVuZGluZ1ByZXNlbmNlLmxlbmd0aDtcbiAgICBpZiAocGVuZGluZ1ByZXNDb3VudCkge1xuICAgICAgdGhpcy5wZW5kaW5nUHJlc2VuY2UgPSBbXTtcbiAgICAgIGNvbnN0IHByZXNlbmNlQXJyYXkgPSBbXTtcbiAgICAgIGNvbnN0IG11bHRpY2FzdGVyID0gbXVsdGljYXN0ZXJfZGVmYXVsdC5jcmVhdGUodGhpcy5sb2dnZXIpO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIlJlYWx0aW1lUHJlc2VuY2Uub25BdHRhY2hlZFwiLFxuICAgICAgICBcInNlbmRpbmcgXCIgKyBwZW5kaW5nUHJlc0NvdW50ICsgXCIgcXVldWVkIHByZXNlbmNlIG1lc3NhZ2VzXCJcbiAgICAgICk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlbmRpbmdQcmVzQ291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBldmVudCA9IHBlbmRpbmdQcmVzZW5jZVtpXTtcbiAgICAgICAgcHJlc2VuY2VBcnJheS5wdXNoKGV2ZW50LnByZXNlbmNlKTtcbiAgICAgICAgbXVsdGljYXN0ZXIucHVzaChldmVudC5jYWxsYmFjayk7XG4gICAgICB9XG4gICAgICB0aGlzLmNoYW5uZWwuc2VuZFByZXNlbmNlKHByZXNlbmNlQXJyYXkpLnRoZW4oKCkgPT4gbXVsdGljYXN0ZXIoKSkuY2F0Y2goKGVycikgPT4gbXVsdGljYXN0ZXIoZXJyKSk7XG4gICAgfVxuICB9XG4gIGFjdE9uQ2hhbm5lbFN0YXRlKHN0YXRlLCBoYXNQcmVzZW5jZSwgZXJyKSB7XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgY2FzZSBcImF0dGFjaGVkXCI6XG4gICAgICAgIHRoaXMub25BdHRhY2hlZChoYXNQcmVzZW5jZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRldGFjaGVkXCI6XG4gICAgICBjYXNlIFwiZmFpbGVkXCI6XG4gICAgICAgIHRoaXMuX2NsZWFyTXlNZW1iZXJzKCk7XG4gICAgICAgIHRoaXMubWVtYmVycy5jbGVhcigpO1xuICAgICAgY2FzZSBcInN1c3BlbmRlZFwiOlxuICAgICAgICB0aGlzLmZhaWxQZW5kaW5nUHJlc2VuY2UoZXJyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGZhaWxQZW5kaW5nUHJlc2VuY2UoZXJyKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZ1ByZXNlbmNlLmxlbmd0aCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5mYWlsUGVuZGluZ1ByZXNlbmNlXCIsXG4gICAgICAgIFwiY2hhbm5lbDsgbmFtZSA9IFwiICsgdGhpcy5jaGFubmVsLm5hbWUgKyBcIiwgZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKVxuICAgICAgKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wZW5kaW5nUHJlc2VuY2UubGVuZ3RoOyBpKyspXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nUHJlc2VuY2VbaV0uY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdQcmVzZW5jZSA9IFtdO1xuICAgIH1cbiAgfVxuICBfY2xlYXJNeU1lbWJlcnMoKSB7XG4gICAgdGhpcy5fbXlNZW1iZXJzLmNsZWFyKCk7XG4gIH1cbiAgX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQoKSB7XG4gICAgY29uc3QgbXlNZW1iZXJzID0gdGhpcy5fbXlNZW1iZXJzO1xuICAgIGNvbnN0IGNvbm5JZCA9IHRoaXMuY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uSWQ7XG4gICAgZm9yIChjb25zdCBtZW1iZXJLZXkgaW4gbXlNZW1iZXJzLm1hcCkge1xuICAgICAgY29uc3QgZW50cnkgPSBteU1lbWJlcnMubWFwW21lbWJlcktleV07XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiUmVhbHRpbWVQcmVzZW5jZS5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCgpXCIsXG4gICAgICAgICdBdXRvLXJlZW50ZXJpbmcgY2xpZW50SWQgXCInICsgZW50cnkuY2xpZW50SWQgKyAnXCIgaW50byB0aGUgcHJlc2VuY2Ugc2V0J1xuICAgICAgKTtcbiAgICAgIGNvbnN0IGlkID0gZW50cnkuY29ubmVjdGlvbklkID09PSBjb25uSWQgPyBlbnRyeS5pZCA6IHZvaWQgMDtcbiAgICAgIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQoaWQsIGVudHJ5LmNsaWVudElkLCBlbnRyeS5kYXRhLCBcImVudGVyXCIpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgY29uc3Qgd3JhcHBlZEVyciA9IG5ldyBFcnJvckluZm8oXCJQcmVzZW5jZSBhdXRvIHJlLWVudGVyIGZhaWxlZFwiLCA5MTAwNCwgNDAwLCBlcnIpO1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgIFwiUmVhbHRpbWVQcmVzZW5jZS5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCgpXCIsXG4gICAgICAgICAgXCJQcmVzZW5jZSBhdXRvIHJlLWVudGVyIGZhaWxlZDsgcmVhc29uID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSBuZXcgY2hhbm5lbHN0YXRlY2hhbmdlX2RlZmF1bHQodGhpcy5jaGFubmVsLnN0YXRlLCB0aGlzLmNoYW5uZWwuc3RhdGUsIHRydWUsIGZhbHNlLCB3cmFwcGVkRXJyKTtcbiAgICAgICAgdGhpcy5jaGFubmVsLmVtaXQoXCJ1cGRhdGVcIiwgY2hhbmdlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfc3ludGhlc2l6ZUxlYXZlcyhpdGVtcykge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnM7XG4gICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICBjb25zdCBwcmVzZW5jZSA9IHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICBhY3Rpb246IFwibGVhdmVcIixcbiAgICAgICAgY29ubmVjdGlvbklkOiBpdGVtLmNvbm5lY3Rpb25JZCxcbiAgICAgICAgY2xpZW50SWQ6IGl0ZW0uY2xpZW50SWQsXG4gICAgICAgIGRhdGE6IGl0ZW0uZGF0YSxcbiAgICAgICAgZW5jb2Rpbmc6IGl0ZW0uZW5jb2RpbmcsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgfSk7XG4gICAgICBzdWJzY3JpcHRpb25zLmVtaXQoXCJsZWF2ZVwiLCBwcmVzZW5jZSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgc3Vic2NyaWJlKC4uLl9hcmdzKSB7XG4gICAgY29uc3QgYXJncyA9IHJlYWx0aW1lY2hhbm5lbF9kZWZhdWx0LnByb2Nlc3NMaXN0ZW5lckFyZ3MoX2FyZ3MpO1xuICAgIGNvbnN0IGV2ZW50ID0gYXJnc1swXTtcbiAgICBjb25zdCBsaXN0ZW5lciA9IGFyZ3NbMV07XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbDtcbiAgICBpZiAoY2hhbm5lbC5zdGF0ZSA9PT0gXCJmYWlsZWRcIikge1xuICAgICAgdGhyb3cgRXJyb3JJbmZvLmZyb21WYWx1ZXMoY2hhbm5lbC5pbnZhbGlkU3RhdGVFcnJvcigpKTtcbiAgICB9XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgaWYgKGNoYW5uZWwuY2hhbm5lbE9wdGlvbnMuYXR0YWNoT25TdWJzY3JpYmUgIT09IGZhbHNlKSB7XG4gICAgICBhd2FpdCBjaGFubmVsLmF0dGFjaCgpO1xuICAgIH1cbiAgfVxuICB1bnN1YnNjcmliZSguLi5fYXJncykge1xuICAgIGNvbnN0IGFyZ3MgPSByZWFsdGltZWNoYW5uZWxfZGVmYXVsdC5wcm9jZXNzTGlzdGVuZXJBcmdzKF9hcmdzKTtcbiAgICBjb25zdCBldmVudCA9IGFyZ3NbMF07XG4gICAgY29uc3QgbGlzdGVuZXIgPSBhcmdzWzFdO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxufTtcbnZhciByZWFsdGltZXByZXNlbmNlX2RlZmF1bHQgPSBSZWFsdGltZVByZXNlbmNlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90cmFuc3BvcnQvd2Vic29ja2V0dHJhbnNwb3J0LnRzXG52YXIgc2hvcnROYW1lID0gVHJhbnNwb3J0TmFtZXMuV2ViU29ja2V0O1xuZnVuY3Rpb24gaXNOb2RlV2ViU29ja2V0KHdzKSB7XG4gIHJldHVybiAhIXdzLm9uO1xufVxudmFyIFdlYlNvY2tldFRyYW5zcG9ydCA9IGNsYXNzIGV4dGVuZHMgdHJhbnNwb3J0X2RlZmF1bHQge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG4gICAgc3VwZXIoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG4gICAgdGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWU7XG4gICAgcGFyYW1zLmhlYXJ0YmVhdHMgPSBQbGF0Zm9ybS5Db25maWcudXNlUHJvdG9jb2xIZWFydGJlYXRzO1xuICAgIHRoaXMud3NIb3N0ID0gcGFyYW1zLmhvc3Q7XG4gIH1cbiAgc3RhdGljIGlzQXZhaWxhYmxlKCkge1xuICAgIHJldHVybiAhIVBsYXRmb3JtLkNvbmZpZy5XZWJTb2NrZXQ7XG4gIH1cbiAgY3JlYXRlV2ViU29ja2V0KHVyaSwgY29ubmVjdFBhcmFtcykge1xuICAgIHRoaXMudXJpID0gdXJpICsgdG9RdWVyeVN0cmluZyhjb25uZWN0UGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFBsYXRmb3JtLkNvbmZpZy5XZWJTb2NrZXQodGhpcy51cmkpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIldlYlNvY2tldFRyYW5zcG9ydDsgdXJpPVwiICsgdGhpcy51cmk7XG4gIH1cbiAgY29ubmVjdCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpXCIsIFwic3RhcnRpbmdcIik7XG4gICAgdHJhbnNwb3J0X2RlZmF1bHQucHJvdG90eXBlLmNvbm5lY3QuY2FsbCh0aGlzKTtcbiAgICBjb25zdCBzZWxmMiA9IHRoaXMsIHBhcmFtcyA9IHRoaXMucGFyYW1zLCBvcHRpb25zID0gcGFyYW1zLm9wdGlvbnM7XG4gICAgY29uc3Qgd3NTY2hlbWUgPSBvcHRpb25zLnRscyA/IFwid3NzOi8vXCIgOiBcIndzOi8vXCI7XG4gICAgY29uc3Qgd3NVcmkgPSB3c1NjaGVtZSArIHRoaXMud3NIb3N0ICsgXCI6XCIgKyBkZWZhdWx0c19kZWZhdWx0LmdldFBvcnQob3B0aW9ucykgKyBcIi9cIjtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpXCIsIFwidXJpOiBcIiArIHdzVXJpKTtcbiAgICB3aGVuUHJvbWlzZVNldHRsZXMoXG4gICAgICB0aGlzLmF1dGguZ2V0QXV0aFBhcmFtcygpLFxuICAgICAgZnVuY3Rpb24oZXJyLCBhdXRoUGFyYW1zKSB7XG4gICAgICAgIGlmIChzZWxmMi5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJhbVN0ciA9IFwiXCI7XG4gICAgICAgIGZvciAoY29uc3QgcGFyYW0gaW4gYXV0aFBhcmFtcylcbiAgICAgICAgICBwYXJhbVN0ciArPSBcIiBcIiArIHBhcmFtICsgXCI6IFwiICsgYXV0aFBhcmFtc1twYXJhbV0gKyBcIjtcIjtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHNlbGYyLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpXCIsXG4gICAgICAgICAgXCJhdXRoUGFyYW1zOlwiICsgcGFyYW1TdHIgKyBcIiBlcnI6IFwiICsgZXJyXG4gICAgICAgICk7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBzZWxmMi5kaXNjb25uZWN0KGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbm5lY3RQYXJhbXMgPSBwYXJhbXMuZ2V0Q29ubmVjdFBhcmFtcyhhdXRoUGFyYW1zKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB3c0Nvbm5lY3Rpb24gPSBzZWxmMi53c0Nvbm5lY3Rpb24gPSBzZWxmMi5jcmVhdGVXZWJTb2NrZXQod3NVcmksIGNvbm5lY3RQYXJhbXMpO1xuICAgICAgICAgIHdzQ29ubmVjdGlvbi5iaW5hcnlUeXBlID0gUGxhdGZvcm0uQ29uZmlnLmJpbmFyeVR5cGU7XG4gICAgICAgICAgd3NDb25uZWN0aW9uLm9ub3BlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZjIub25Xc09wZW4oKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHdzQ29ubmVjdGlvbi5vbmNsb3NlID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHNlbGYyLm9uV3NDbG9zZShldik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3c0Nvbm5lY3Rpb24ub25tZXNzYWdlID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHNlbGYyLm9uV3NEYXRhKGV2LmRhdGEpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgd3NDb25uZWN0aW9uLm9uZXJyb3IgPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgc2VsZjIub25Xc0Vycm9yKGV2KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChpc05vZGVXZWJTb2NrZXQod3NDb25uZWN0aW9uKSkge1xuICAgICAgICAgICAgd3NDb25uZWN0aW9uLm9uKFwicGluZ1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgc2VsZjIub25BY3Rpdml0eSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgc2VsZjIubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgICAgXCJXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpXCIsXG4gICAgICAgICAgICBcIlVuZXhwZWN0ZWQgZXhjZXB0aW9uIGNyZWF0aW5nIHdlYnNvY2tldDogZXJyID0gXCIgKyAoZS5zdGFjayB8fCBlLm1lc3NhZ2UpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZWxmMi5kaXNjb25uZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBzZW5kKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB3c0Nvbm5lY3Rpb24gPSB0aGlzLndzQ29ubmVjdGlvbjtcbiAgICBpZiAoIXdzQ29ubmVjdGlvbikge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiV2ViU29ja2V0VHJhbnNwb3J0LnNlbmQoKVwiLCBcIk5vIHNvY2tldCBjb25uZWN0aW9uXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgd3NDb25uZWN0aW9uLnNlbmQoXG4gICAgICAgIHNlcmlhbGl6ZTIobWVzc2FnZSwgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fTXNnUGFjaywgdGhpcy5wYXJhbXMuZm9ybWF0KVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCBtc2cgPSBcIkV4Y2VwdGlvbiBmcm9tIHdzIGNvbm5lY3Rpb24gd2hlbiB0cnlpbmcgdG8gc2VuZDogXCIgKyBpbnNwZWN0RXJyb3IoZSk7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQuc2VuZCgpXCIsIG1zZyk7XG4gICAgICB0aGlzLmZpbmlzaChcImRpc2Nvbm5lY3RlZFwiLCBuZXcgRXJyb3JJbmZvKG1zZywgNWU0LCA1MDApKTtcbiAgICB9XG4gIH1cbiAgb25Xc0RhdGEoZGF0YSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJXZWJTb2NrZXRUcmFuc3BvcnQub25Xc0RhdGEoKVwiLFxuICAgICAgXCJkYXRhIHJlY2VpdmVkOyBsZW5ndGggPSBcIiArIGRhdGEubGVuZ3RoICsgXCI7IHR5cGUgPSBcIiArIHR5cGVvZiBkYXRhXG4gICAgKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5vblByb3RvY29sTWVzc2FnZShcbiAgICAgICAgZGVzZXJpYWxpemUoXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9Nc2dQYWNrLFxuICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVhbHRpbWUuX1JlYWx0aW1lUHJlc2VuY2UsXG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fQW5ub3RhdGlvbnMsXG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fb2JqZWN0c1BsdWdpbixcbiAgICAgICAgICB0aGlzLmZvcm1hdFxuICAgICAgICApXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJXZWJTb2NrZXRUcmFuc3BvcnQub25Xc0RhdGEoKVwiLFxuICAgICAgICBcIlVuZXhwZWN0ZWQgZXhjZXB0aW9uIGhhbmRpbmcgY2hhbm5lbCBtZXNzYWdlOiBcIiArIGUuc3RhY2tcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIG9uV3NPcGVuKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIldlYlNvY2tldFRyYW5zcG9ydC5vbldzT3BlbigpXCIsIFwib3BlbmVkIFdlYlNvY2tldFwiKTtcbiAgICB0aGlzLmVtaXQoXCJwcmVjb25uZWN0XCIpO1xuICB9XG4gIG9uV3NDbG9zZShldikge1xuICAgIGxldCB3YXNDbGVhbiwgY29kZTtcbiAgICBpZiAodHlwZW9mIGV2ID09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvZGUgPSBldi5jb2RlO1xuICAgICAgd2FzQ2xlYW4gPSBldi53YXNDbGVhbiB8fCBjb2RlID09PSAxZTM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgPSBldjtcbiAgICAgIHdhc0NsZWFuID0gY29kZSA9PSAxZTM7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLndzQ29ubmVjdGlvbjtcbiAgICBpZiAod2FzQ2xlYW4pIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIldlYlNvY2tldFRyYW5zcG9ydC5vbldzQ2xvc2UoKVwiLCBcIkNsZWFubHkgY2xvc2VkIFdlYlNvY2tldFwiKTtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvckluZm8oXCJXZWJzb2NrZXQgY2xvc2VkXCIsIDgwMDAzLCA0MDApO1xuICAgICAgdGhpcy5maW5pc2goXCJkaXNjb25uZWN0ZWRcIiwgZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbXNnID0gXCJVbmNsZWFuIGRpc2Nvbm5lY3Rpb24gb2YgV2ViU29ja2V0IDsgY29kZSA9IFwiICsgY29kZSwgZXJyID0gbmV3IEVycm9ySW5mbyhtc2csIDgwMDAzLCA0MDApO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NDbG9zZSgpXCIsIG1zZyk7XG4gICAgICB0aGlzLmZpbmlzaChcImRpc2Nvbm5lY3RlZFwiLCBlcnIpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJkaXNwb3NlZFwiKTtcbiAgfVxuICBvbldzRXJyb3IoZXJyKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIldlYlNvY2tldFRyYW5zcG9ydC5vbkVycm9yKClcIixcbiAgICAgIFwiRXJyb3IgZnJvbSBXZWJTb2NrZXQ6IFwiICsgZXJyLm1lc3NhZ2VcbiAgICApO1xuICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoRXJyb3IoZXJyLm1lc3NhZ2UpKTtcbiAgICB9KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIldlYlNvY2tldFRyYW5zcG9ydC5kaXNwb3NlKClcIiwgXCJcIik7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICBjb25zdCB3c0Nvbm5lY3Rpb24gPSB0aGlzLndzQ29ubmVjdGlvbjtcbiAgICBpZiAod3NDb25uZWN0aW9uKSB7XG4gICAgICB3c0Nvbm5lY3Rpb24ub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgICAgZGVsZXRlIHRoaXMud3NDb25uZWN0aW9uO1xuICAgICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiV2ViU29ja2V0VHJhbnNwb3J0LmRpc3Bvc2UoKVwiLCBcImNsb3Npbmcgd2Vic29ja2V0XCIpO1xuICAgICAgICBpZiAoIXdzQ29ubmVjdGlvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlYlNvY2tldFRyYW5zcG9ydC5kaXNwb3NlKCk6IHdzQ29ubmVjdGlvbiBpcyBub3QgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB3c0Nvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcbnZhciB3ZWJzb2NrZXR0cmFuc3BvcnRfZGVmYXVsdCA9IFdlYlNvY2tldFRyYW5zcG9ydDtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L2ZpbHRlcmVkc3Vic2NyaXB0aW9ucy50c1xudmFyIEZpbHRlcmVkU3Vic2NyaXB0aW9ucyA9IGNsYXNzIHtcbiAgc3RhdGljIHN1YnNjcmliZUZpbHRlcihjaGFubmVsLCBmaWx0ZXIsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgZmlsdGVyZWRMaXN0ZW5lciA9IChtKSA9PiB7XG4gICAgICB2YXIgX2EyLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICBjb25zdCBtYXBwaW5nID0ge1xuICAgICAgICBuYW1lOiBtLm5hbWUsXG4gICAgICAgIHJlZlRpbWVzZXJpYWw6IChfYiA9IChfYTIgPSBtLmV4dHJhcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5yZWYpID09IG51bGwgPyB2b2lkIDAgOiBfYi50aW1lc2VyaWFsLFxuICAgICAgICByZWZUeXBlOiAoX2QgPSAoX2MgPSBtLmV4dHJhcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnJlZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnR5cGUsXG4gICAgICAgIGlzUmVmOiAhISgoX2YgPSAoX2UgPSBtLmV4dHJhcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLnJlZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLnRpbWVzZXJpYWwpLFxuICAgICAgICBjbGllbnRJZDogbS5jbGllbnRJZFxuICAgICAgfTtcbiAgICAgIGlmIChPYmplY3QuZW50cmllcyhmaWx0ZXIpLmZpbmQoXG4gICAgICAgIChba2V5LCB2YWx1ZV0pID0+IHZhbHVlICE9PSB2b2lkIDAgPyBtYXBwaW5nW2tleV0gIT09IHZhbHVlIDogZmFsc2VcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIobSk7XG4gICAgfTtcbiAgICB0aGlzLmFkZEZpbHRlcmVkU3Vic2NyaXB0aW9uKGNoYW5uZWwsIGZpbHRlciwgbGlzdGVuZXIsIGZpbHRlcmVkTGlzdGVuZXIpO1xuICAgIGNoYW5uZWwuc3Vic2NyaXB0aW9ucy5vbihmaWx0ZXJlZExpc3RlbmVyKTtcbiAgfVxuICAvLyBBZGRzIGEgbmV3IGZpbHRlcmVkIHN1YnNjcmlwdGlvblxuICBzdGF0aWMgYWRkRmlsdGVyZWRTdWJzY3JpcHRpb24oY2hhbm5lbCwgZmlsdGVyLCByZWFsTGlzdGVuZXIsIGZpbHRlcmVkTGlzdGVuZXIpIHtcbiAgICB2YXIgX2EyO1xuICAgIGlmICghY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIGNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gICAgaWYgKGNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zLmhhcyhyZWFsTGlzdGVuZXIpKSB7XG4gICAgICBjb25zdCByZWFsTGlzdGVuZXJNYXAgPSBjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5nZXQocmVhbExpc3RlbmVyKTtcbiAgICAgIHJlYWxMaXN0ZW5lck1hcC5zZXQoZmlsdGVyLCAoKF9hMiA9IHJlYWxMaXN0ZW5lck1hcCA9PSBudWxsID8gdm9pZCAwIDogcmVhbExpc3RlbmVyTWFwLmdldChmaWx0ZXIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNvbmNhdChmaWx0ZXJlZExpc3RlbmVyKSkgfHwgW2ZpbHRlcmVkTGlzdGVuZXJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuc2V0KFxuICAgICAgICByZWFsTGlzdGVuZXIsXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtbZmlsdGVyLCBbZmlsdGVyZWRMaXN0ZW5lcl1dXSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXRBbmREZWxldGVGaWx0ZXJlZFN1YnNjcmlwdGlvbnMoY2hhbm5lbCwgZmlsdGVyLCByZWFsTGlzdGVuZXIpIHtcbiAgICBpZiAoIWNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmICghcmVhbExpc3RlbmVyICYmIGZpbHRlcikge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20oY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuZW50cmllcygpKS5tYXAoKFtrZXksIGZpbHRlck1hcHNdKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIGxldCBsaXN0ZW5lck1hcHMgPSBmaWx0ZXJNYXBzLmdldChmaWx0ZXIpO1xuICAgICAgICBmaWx0ZXJNYXBzLmRlbGV0ZShmaWx0ZXIpO1xuICAgICAgICBpZiAoZmlsdGVyTWFwcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgKF9hMiA9IGNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0ZW5lck1hcHM7XG4gICAgICB9KS5yZWR1Y2UoXG4gICAgICAgIChwcmV2LCBjdXIpID0+IGN1ciA/IHByZXYuY29uY2F0KC4uLmN1cikgOiBwcmV2LFxuICAgICAgICBbXVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFyZWFsTGlzdGVuZXIgfHwgIWNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zLmhhcyhyZWFsTGlzdGVuZXIpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHJlYWxMaXN0ZW5lck1hcCA9IGNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zLmdldChyZWFsTGlzdGVuZXIpO1xuICAgIGlmICghZmlsdGVyKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMyID0gQXJyYXkuZnJvbShyZWFsTGlzdGVuZXJNYXAudmFsdWVzKCkpLnJlZHVjZSgocHJldiwgY3VyKSA9PiBwcmV2LmNvbmNhdCguLi5jdXIpLCBbXSk7XG4gICAgICBjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5kZWxldGUocmVhbExpc3RlbmVyKTtcbiAgICAgIHJldHVybiBsaXN0ZW5lcnMyO1xuICAgIH1cbiAgICBsZXQgbGlzdGVuZXJzID0gcmVhbExpc3RlbmVyTWFwLmdldChmaWx0ZXIpO1xuICAgIHJlYWxMaXN0ZW5lck1hcC5kZWxldGUoZmlsdGVyKTtcbiAgICByZXR1cm4gbGlzdGVuZXJzIHx8IFtdO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvZGVmYXVsdHJlYWx0aW1lLnRzXG52YXIgX0RlZmF1bHRSZWFsdGltZSA9IGNsYXNzIF9EZWZhdWx0UmVhbHRpbWUgZXh0ZW5kcyBiYXNlcmVhbHRpbWVfZGVmYXVsdCB7XG4gIC8vIFRoZSBwdWJsaWMgdHlwaW5ncyBkZWNsYXJlIHRoYXQgdGhpcyByZXF1aXJlcyBhbiBhcmd1bWVudCB0byBiZSBwYXNzZWQsIGJ1dCBzaW5jZSB3ZSB3YW50IHRvIGVtaXQgYSBnb29kIGVycm9yIG1lc3NhZ2UgaW4gdGhlIGNhc2Ugd2hlcmUgYSBub24tVHlwZVNjcmlwdCB1c2VyIGRvZXMgbm90IHBhc3MgYW4gYXJndW1lbnQsIHRlbGwgdGhlIGNvbXBpbGVyIHRoYXQgdGhpcyBpcyBwb3NzaWJsZSBzbyB0aGF0IGl0IGZvcmNlcyB1cyB0byBoYW5kbGUgaXQuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyO1xuICAgIGNvbnN0IE1zZ1BhY2sgPSBfRGVmYXVsdFJlYWx0aW1lLl9Nc2dQYWNrO1xuICAgIGlmICghTXNnUGFjaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgRGVmYXVsdFJlYWx0aW1lLl9Nc2dQYWNrIHRvIGhhdmUgYmVlbiBzZXRcIik7XG4gICAgfVxuICAgIHN1cGVyKFxuICAgICAgZGVmYXVsdHNfZGVmYXVsdC5vYmplY3RpZnlPcHRpb25zKG9wdGlvbnMsIHRydWUsIFwiUmVhbHRpbWVcIiwgbG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlciwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgYWxsQ29tbW9uTW9kdWxhclBsdWdpbnMpLCB7XG4gICAgICAgIENyeXB0bzogKF9hMiA9IF9EZWZhdWx0UmVhbHRpbWUuQ3J5cHRvKSAhPSBudWxsID8gX2EyIDogdm9pZCAwLFxuICAgICAgICBNc2dQYWNrLFxuICAgICAgICBSZWFsdGltZVByZXNlbmNlOiB7XG4gICAgICAgICAgUmVhbHRpbWVQcmVzZW5jZTogcmVhbHRpbWVwcmVzZW5jZV9kZWZhdWx0LFxuICAgICAgICAgIFByZXNlbmNlTWVzc2FnZTogcHJlc2VuY2VtZXNzYWdlX2RlZmF1bHQsXG4gICAgICAgICAgV2lyZVByZXNlbmNlTWVzc2FnZVxuICAgICAgICB9LFxuICAgICAgICBBbm5vdGF0aW9uczoge1xuICAgICAgICAgIEFubm90YXRpb246IGFubm90YXRpb25fZGVmYXVsdCxcbiAgICAgICAgICBXaXJlQW5ub3RhdGlvbixcbiAgICAgICAgICBSZWFsdGltZUFubm90YXRpb25zOiByZWFsdGltZWFubm90YXRpb25zX2RlZmF1bHQsXG4gICAgICAgICAgUmVzdEFubm90YXRpb25zOiByZXN0YW5ub3RhdGlvbnNfZGVmYXVsdFxuICAgICAgICB9LFxuICAgICAgICBXZWJTb2NrZXRUcmFuc3BvcnQ6IHdlYnNvY2tldHRyYW5zcG9ydF9kZWZhdWx0LFxuICAgICAgICBNZXNzYWdlSW50ZXJhY3Rpb25zOiBGaWx0ZXJlZFN1YnNjcmlwdGlvbnNcbiAgICAgIH0pKVxuICAgICk7XG4gIH1cbiAgc3RhdGljIGdldCBDcnlwdG8oKSB7XG4gICAgaWYgKHRoaXMuX0NyeXB0byA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGlvbiBub3QgZW5hYmxlZDsgdXNlIGFibHkuZW5jcnlwdGlvbi5qcyBpbnN0ZWFkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fQ3J5cHRvO1xuICB9XG4gIHN0YXRpYyBzZXQgQ3J5cHRvKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fQ3J5cHRvID0gbmV3VmFsdWU7XG4gIH1cbn07XG5fRGVmYXVsdFJlYWx0aW1lLlV0aWxzID0gdXRpbHNfZXhwb3J0cztcbl9EZWZhdWx0UmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIgPSBjb25uZWN0aW9ubWFuYWdlcl9kZWZhdWx0O1xuX0RlZmF1bHRSZWFsdGltZS5Qcm90b2NvbE1lc3NhZ2UgPSBwcm90b2NvbG1lc3NhZ2VfZGVmYXVsdDtcbl9EZWZhdWx0UmVhbHRpbWUuX0NyeXB0byA9IG51bGw7XG5fRGVmYXVsdFJlYWx0aW1lLk1lc3NhZ2UgPSBEZWZhdWx0TWVzc2FnZTtcbl9EZWZhdWx0UmVhbHRpbWUuUHJlc2VuY2VNZXNzYWdlID0gRGVmYXVsdFByZXNlbmNlTWVzc2FnZTtcbl9EZWZhdWx0UmVhbHRpbWUuQW5ub3RhdGlvbiA9IERlZmF1bHRBbm5vdGF0aW9uO1xuX0RlZmF1bHRSZWFsdGltZS5fTXNnUGFjayA9IG51bGw7XG4vLyBVc2VkIGJ5IHRlc3RzXG5fRGVmYXVsdFJlYWx0aW1lLl9IdHRwID0gSHR0cDtcbl9EZWZhdWx0UmVhbHRpbWUuX1ByZXNlbmNlTWFwID0gUHJlc2VuY2VNYXA7XG5fRGVmYXVsdFJlYWx0aW1lLl9NZXNzYWdlRW5jb2RpbmcgPSBNZXNzYWdlRW5jb2Rpbmc7XG52YXIgRGVmYXVsdFJlYWx0aW1lID0gX0RlZmF1bHRSZWFsdGltZTtcblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9saWIvdXRpbC9obWFjLXNoYTI1Ni50c1xudmFyIHVpbnQ4QXJyYXkgPSBVaW50OEFycmF5O1xudmFyIHVpbnQzMkFycmF5ID0gVWludDMyQXJyYXk7XG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgREVGQVVMVF9TVEFURSA9IG5ldyB1aW50MzJBcnJheSg4KTtcbnZhciBST1VORF9DT05TVEFOVFMgPSBbXTtcbnZhciBNID0gbmV3IHVpbnQzMkFycmF5KDY0KTtcbmZ1bmN0aW9uIGdldEZyYWN0aW9uYWxCaXRzKG4yKSB7XG4gIHJldHVybiAobjIgLSAobjIgfCAwKSkgKiBwb3coMiwgMzIpIHwgMDtcbn1cbnZhciBuID0gMjtcbnZhciBuUHJpbWUgPSAwO1xud2hpbGUgKG5QcmltZSA8IDY0KSB7XG4gIGlzUHJpbWUgPSB0cnVlO1xuICBmb3IgKGZhY3RvciA9IDI7IGZhY3RvciA8PSBuIC8gMjsgZmFjdG9yKyspIHtcbiAgICBpZiAobiAlIGZhY3RvciA9PT0gMCkge1xuICAgICAgaXNQcmltZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNQcmltZSkge1xuICAgIGlmIChuUHJpbWUgPCA4KSB7XG4gICAgICBERUZBVUxUX1NUQVRFW25QcmltZV0gPSBnZXRGcmFjdGlvbmFsQml0cyhwb3cobiwgMSAvIDIpKTtcbiAgICB9XG4gICAgUk9VTkRfQ09OU1RBTlRTW25QcmltZV0gPSBnZXRGcmFjdGlvbmFsQml0cyhwb3cobiwgMSAvIDMpKTtcbiAgICBuUHJpbWUrKztcbiAgfVxuICBuKys7XG59XG52YXIgaXNQcmltZTtcbnZhciBmYWN0b3I7XG52YXIgTGl0dGxlRW5kaWFuID0gISFuZXcgdWludDhBcnJheShuZXcgdWludDMyQXJyYXkoWzFdKS5idWZmZXIpWzBdO1xuZnVuY3Rpb24gY29udmVydEVuZGlhbih3b3JkKSB7XG4gIGlmIChMaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gKFxuICAgICAgLy8gYnl0ZSAxIC0+IGJ5dGUgNFxuICAgICAgd29yZCA+Pj4gMjQgfCAvLyBieXRlIDIgLT4gYnl0ZSAzXG4gICAgICAod29yZCA+Pj4gMTYgJiAyNTUpIDw8IDggfCAvLyBieXRlIDMgLT4gYnl0ZSAyXG4gICAgICAod29yZCAmIDY1MjgwKSA8PCA4IHwgLy8gYnl0ZSA0IC0+IGJ5dGUgMVxuICAgICAgd29yZCA8PCAyNFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHdvcmQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJpZ2h0Um90YXRlKHdvcmQsIGJpdHMpIHtcbiAgcmV0dXJuIHdvcmQgPj4+IGJpdHMgfCB3b3JkIDw8IDMyIC0gYml0cztcbn1cbmZ1bmN0aW9uIHNoYTI1NihkYXRhKSB7XG4gIHZhciBTVEFURSA9IERFRkFVTFRfU1RBVEUuc2xpY2UoKTtcbiAgdmFyIGxlZ3RoID0gZGF0YS5sZW5ndGg7XG4gIHZhciBiaXRMZW5ndGggPSBsZWd0aCAqIDg7XG4gIHZhciBuZXdCaXRMZW5ndGggPSA1MTIgLSAoYml0TGVuZ3RoICsgNjQpICUgNTEyIC0gMSArIGJpdExlbmd0aCArIDY1O1xuICB2YXIgYnl0ZXMgPSBuZXcgdWludDhBcnJheShuZXdCaXRMZW5ndGggLyA4KTtcbiAgdmFyIHdvcmRzID0gbmV3IHVpbnQzMkFycmF5KGJ5dGVzLmJ1ZmZlcik7XG4gIGJ5dGVzLnNldChkYXRhLCAwKTtcbiAgYnl0ZXNbbGVndGhdID0gMTI4O1xuICB3b3Jkc1t3b3Jkcy5sZW5ndGggLSAxXSA9IGNvbnZlcnRFbmRpYW4oYml0TGVuZ3RoKTtcbiAgdmFyIHJvdW5kO1xuICBmb3IgKHZhciBibG9jayA9IDA7IGJsb2NrIDwgbmV3Qml0TGVuZ3RoIC8gMzI7IGJsb2NrICs9IDE2KSB7XG4gICAgdmFyIHdvcmtpbmdTdGF0ZSA9IFNUQVRFLnNsaWNlKCk7XG4gICAgZm9yIChyb3VuZCA9IDA7IHJvdW5kIDwgNjQ7IHJvdW5kKyspIHtcbiAgICAgIHZhciBNUm91bmQ7XG4gICAgICBpZiAocm91bmQgPCAxNikge1xuICAgICAgICBNUm91bmQgPSBjb252ZXJ0RW5kaWFuKHdvcmRzW2Jsb2NrICsgcm91bmRdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBnYW1tYTB4ID0gTVtyb3VuZCAtIDE1XTtcbiAgICAgICAgdmFyIGdhbW1hMXggPSBNW3JvdW5kIC0gMl07XG4gICAgICAgIE1Sb3VuZCA9IE1bcm91bmQgLSA3XSArIE1bcm91bmQgLSAxNl0gKyAocmlnaHRSb3RhdGUoZ2FtbWEweCwgNykgXiByaWdodFJvdGF0ZShnYW1tYTB4LCAxOCkgXiBnYW1tYTB4ID4+PiAzKSArIChyaWdodFJvdGF0ZShnYW1tYTF4LCAxNykgXiByaWdodFJvdGF0ZShnYW1tYTF4LCAxOSkgXiBnYW1tYTF4ID4+PiAxMCk7XG4gICAgICB9XG4gICAgICBNW3JvdW5kXSA9IE1Sb3VuZCB8PSAwO1xuICAgICAgdmFyIHQxID0gKHJpZ2h0Um90YXRlKHdvcmtpbmdTdGF0ZVs0XSwgNikgXiByaWdodFJvdGF0ZSh3b3JraW5nU3RhdGVbNF0sIDExKSBeIHJpZ2h0Um90YXRlKHdvcmtpbmdTdGF0ZVs0XSwgMjUpKSArICh3b3JraW5nU3RhdGVbNF0gJiB3b3JraW5nU3RhdGVbNV0gXiB+d29ya2luZ1N0YXRlWzRdICYgd29ya2luZ1N0YXRlWzZdKSArIHdvcmtpbmdTdGF0ZVs3XSArIE1Sb3VuZCArIFJPVU5EX0NPTlNUQU5UU1tyb3VuZF07XG4gICAgICB2YXIgdDIgPSAocmlnaHRSb3RhdGUod29ya2luZ1N0YXRlWzBdLCAyKSBeIHJpZ2h0Um90YXRlKHdvcmtpbmdTdGF0ZVswXSwgMTMpIF4gcmlnaHRSb3RhdGUod29ya2luZ1N0YXRlWzBdLCAyMikpICsgKHdvcmtpbmdTdGF0ZVswXSAmIHdvcmtpbmdTdGF0ZVsxXSBeIHdvcmtpbmdTdGF0ZVsyXSAmICh3b3JraW5nU3RhdGVbMF0gXiB3b3JraW5nU3RhdGVbMV0pKTtcbiAgICAgIGZvciAodmFyIGkgPSA3OyBpID4gMDsgaS0tKSB7XG4gICAgICAgIHdvcmtpbmdTdGF0ZVtpXSA9IHdvcmtpbmdTdGF0ZVtpIC0gMV07XG4gICAgICB9XG4gICAgICB3b3JraW5nU3RhdGVbMF0gPSB0MSArIHQyIHwgMDtcbiAgICAgIHdvcmtpbmdTdGF0ZVs0XSA9IHdvcmtpbmdTdGF0ZVs0XSArIHQxIHwgMDtcbiAgICB9XG4gICAgZm9yIChyb3VuZCA9IDA7IHJvdW5kIDwgODsgcm91bmQrKykge1xuICAgICAgU1RBVEVbcm91bmRdID0gU1RBVEVbcm91bmRdICsgd29ya2luZ1N0YXRlW3JvdW5kXSB8IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgdWludDhBcnJheShcbiAgICBuZXcgdWludDMyQXJyYXkoXG4gICAgICBTVEFURS5tYXAoZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0RW5kaWFuKHZhbCk7XG4gICAgICB9KVxuICAgICkuYnVmZmVyXG4gICk7XG59XG5mdW5jdGlvbiBobWFjMihrZXksIGRhdGEpIHtcbiAgaWYgKGtleS5sZW5ndGggPiA2NClcbiAgICBrZXkgPSBzaGEyNTYoa2V5KTtcbiAgaWYgKGtleS5sZW5ndGggPCA2NCkge1xuICAgIGNvbnN0IHRtcCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgICB0bXAuc2V0KGtleSwgMCk7XG4gICAga2V5ID0gdG1wO1xuICB9XG4gIHZhciBpbm5lcktleSA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIG91dGVyS2V5ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICBpbm5lcktleVtpXSA9IDU0IF4ga2V5W2ldO1xuICAgIG91dGVyS2V5W2ldID0gOTIgXiBrZXlbaV07XG4gIH1cbiAgdmFyIG1zZyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgNjQpO1xuICBtc2cuc2V0KGlubmVyS2V5LCAwKTtcbiAgbXNnLnNldChkYXRhLCA2NCk7XG4gIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheSg2NCArIDMyKTtcbiAgcmVzdWx0LnNldChvdXRlcktleSwgMCk7XG4gIHJlc3VsdC5zZXQoc2hhMjU2KG1zZyksIDY0KTtcbiAgcmV0dXJuIHNoYTI1NihyZXN1bHQpO1xufVxuXG4vLyBzcmMvcGxhdGZvcm0vd2ViL2xpYi91dGlsL2J1ZmZlcnV0aWxzLnRzXG52YXIgQnVmZmVyVXRpbHMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYmFzZTY0Q2hhclNldCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuICAgIHRoaXMuaGV4Q2hhclNldCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICB9XG4gIC8vIGh0dHBzOi8vZ2lzdC5naXRodWJ1c2VyY29udGVudC5jb20vam9ubGVpZ2h0b24vOTU4ODQxL3Jhdy9mMjAwZTMwZGZlOTUyMTJjMDE2NWNjZjFhZTAwMGNhNTFlOWRlODAzL2dpc3RmaWxlMS5qc1xuICB1aW50OFZpZXdUb0Jhc2U2NChieXRlcykge1xuICAgIGxldCBiYXNlNjQgPSBcIlwiO1xuICAgIGNvbnN0IGVuY29kaW5ncyA9IHRoaXMuYmFzZTY0Q2hhclNldDtcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBieXRlUmVtYWluZGVyID0gYnl0ZUxlbmd0aCAlIDM7XG4gICAgY29uc3QgbWFpbkxlbmd0aCA9IGJ5dGVMZW5ndGggLSBieXRlUmVtYWluZGVyO1xuICAgIGxldCBhLCBiLCBjLCBkO1xuICAgIGxldCBjaHVuaztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1haW5MZW5ndGg7IGkgPSBpICsgMykge1xuICAgICAgY2h1bmsgPSBieXRlc1tpXSA8PCAxNiB8IGJ5dGVzW2kgKyAxXSA8PCA4IHwgYnl0ZXNbaSArIDJdO1xuICAgICAgYSA9IChjaHVuayAmIDE2NTE1MDcyKSA+PiAxODtcbiAgICAgIGIgPSAoY2h1bmsgJiAyNTgwNDgpID4+IDEyO1xuICAgICAgYyA9IChjaHVuayAmIDQwMzIpID4+IDY7XG4gICAgICBkID0gY2h1bmsgJiA2MztcbiAgICAgIGJhc2U2NCArPSBlbmNvZGluZ3NbYV0gKyBlbmNvZGluZ3NbYl0gKyBlbmNvZGluZ3NbY10gKyBlbmNvZGluZ3NbZF07XG4gICAgfVxuICAgIGlmIChieXRlUmVtYWluZGVyID09IDEpIHtcbiAgICAgIGNodW5rID0gYnl0ZXNbbWFpbkxlbmd0aF07XG4gICAgICBhID0gKGNodW5rICYgMjUyKSA+PiAyO1xuICAgICAgYiA9IChjaHVuayAmIDMpIDw8IDQ7XG4gICAgICBiYXNlNjQgKz0gZW5jb2RpbmdzW2FdICsgZW5jb2RpbmdzW2JdICsgXCI9PVwiO1xuICAgIH0gZWxzZSBpZiAoYnl0ZVJlbWFpbmRlciA9PSAyKSB7XG4gICAgICBjaHVuayA9IGJ5dGVzW21haW5MZW5ndGhdIDw8IDggfCBieXRlc1ttYWluTGVuZ3RoICsgMV07XG4gICAgICBhID0gKGNodW5rICYgNjQ1MTIpID4+IDEwO1xuICAgICAgYiA9IChjaHVuayAmIDEwMDgpID4+IDQ7XG4gICAgICBjID0gKGNodW5rICYgMTUpIDw8IDI7XG4gICAgICBiYXNlNjQgKz0gZW5jb2RpbmdzW2FdICsgZW5jb2RpbmdzW2JdICsgZW5jb2RpbmdzW2NdICsgXCI9XCI7XG4gICAgfVxuICAgIHJldHVybiBiYXNlNjQ7XG4gIH1cbiAgYmFzZTY0VG9BcnJheUJ1ZmZlcihiYXNlNjQpIHtcbiAgICBjb25zdCBiaW5hcnlfc3RyaW5nID0gYXRvYiA9PSBudWxsID8gdm9pZCAwIDogYXRvYihiYXNlNjQpO1xuICAgIGNvbnN0IGxlbiA9IGJpbmFyeV9zdHJpbmcubGVuZ3RoO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBhc2NpaSA9IGJpbmFyeV9zdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgIGJ5dGVzW2ldID0gYXNjaWk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRvQXJyYXlCdWZmZXIoYnl0ZXMpO1xuICB9XG4gIGlzQnVmZmVyKGJ1ZmZlcikge1xuICAgIHJldHVybiBidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoYnVmZmVyKTtcbiAgfVxuICB0b0J1ZmZlcihidWZmZXIpIHtcbiAgICBpZiAoIUFycmF5QnVmZmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb252ZXJ0IHRvIEJ1ZmZlcjogYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBuZWNlc3NhcnkgdHlwZXNcIik7XG4gICAgfVxuICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgfVxuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYnVmZmVyKSkge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMudG9BcnJheUJ1ZmZlcihidWZmZXIpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyVXRpbHMudG9CdWZmZXIgZXhwZWN0ZWQgYW4gQXJyYXlCdWZmZXIgb3IgYSB2aWV3IG9udG8gb25lXCIpO1xuICB9XG4gIHRvQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4gICAgaWYgKCFBcnJheUJ1ZmZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29udmVydCB0byBBcnJheUJ1ZmZlcjogYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBuZWNlc3NhcnkgdHlwZXNcIik7XG4gICAgfVxuICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhidWZmZXIpKSB7XG4gICAgICByZXR1cm4gYnVmZmVyLmJ1ZmZlci5zbGljZShidWZmZXIuYnl0ZU9mZnNldCwgYnVmZmVyLmJ5dGVPZmZzZXQgKyBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZmZlclV0aWxzLnRvQXJyYXlCdWZmZXIgZXhwZWN0ZWQgYW4gQXJyYXlCdWZmZXIgb3IgYSB2aWV3IG9udG8gb25lXCIpO1xuICB9XG4gIGJhc2U2NEVuY29kZShidWZmZXIpIHtcbiAgICByZXR1cm4gdGhpcy51aW50OFZpZXdUb0Jhc2U2NCh0aGlzLnRvQnVmZmVyKGJ1ZmZlcikpO1xuICB9XG4gIGJhc2U2NFVybEVuY29kZShidWZmZXIpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlNjRFbmNvZGUoYnVmZmVyKS5yZXBsYWNlKC9cXCsvZywgXCItXCIpLnJlcGxhY2UoL1xcLy9nLCBcIl9cIikucmVwbGFjZSgvPSskLywgXCJcIik7XG4gIH1cbiAgYmFzZTY0RGVjb2RlKHN0cikge1xuICAgIGlmIChBcnJheUJ1ZmZlciAmJiBQbGF0Zm9ybS5Db25maWcuYXRvYikge1xuICAgICAgcmV0dXJuIHRoaXMuYmFzZTY0VG9BcnJheUJ1ZmZlcihzdHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBBcnJheUJ1ZmZlciB0byBleGlzdCBhbmQgUGxhdGZvcm0uQ29uZmlnLmF0b2IgdG8gYmUgY29uZmlndXJlZFwiKTtcbiAgICB9XG4gIH1cbiAgaGV4RW5jb2RlKGJ1ZmZlcikge1xuICAgIGNvbnN0IHVpbnQ4QXJyYXkyID0gdGhpcy50b0J1ZmZlcihidWZmZXIpO1xuICAgIHJldHVybiB1aW50OEFycmF5Mi5yZWR1Y2UoKGFjY3VtLCBieXRlKSA9PiBhY2N1bSArIGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgXCJcIik7XG4gIH1cbiAgaGV4RGVjb2RlKGhleEVuY29kZWRCeXRlcykge1xuICAgIGlmIChoZXhFbmNvZGVkQnl0ZXMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY3JlYXRlIGEgYnl0ZSBhcnJheSBmcm9tIGEgaGV4IHN0cmluZyBvZiBvZGQgbGVuZ3RoXCIpO1xuICAgIH1cbiAgICBjb25zdCB1aW50OEFycmF5MiA9IG5ldyBVaW50OEFycmF5KGhleEVuY29kZWRCeXRlcy5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVpbnQ4QXJyYXkyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB1aW50OEFycmF5MltpXSA9IHBhcnNlSW50KGhleEVuY29kZWRCeXRlcy5zbGljZSgyICogaSwgMiAqIChpICsgMSkpLCAxNik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRvQXJyYXlCdWZmZXIodWludDhBcnJheTIpO1xuICB9XG4gIHV0ZjhFbmNvZGUoc3RyaW5nKSB7XG4gICAgaWYgKFBsYXRmb3JtLkNvbmZpZy5UZXh0RW5jb2Rlcikge1xuICAgICAgY29uc3QgZW5jb2RlZEJ5dGVBcnJheSA9IG5ldyBQbGF0Zm9ybS5Db25maWcuVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyaW5nKTtcbiAgICAgIHJldHVybiB0aGlzLnRvQXJyYXlCdWZmZXIoZW5jb2RlZEJ5dGVBcnJheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIFRleHRFbmNvZGVyIHRvIGJlIGNvbmZpZ3VyZWRcIik7XG4gICAgfVxuICB9XG4gIC8qIEZvciB1dGY4IGRlY29kaW5nIHdlIGFwcGx5IHNsaWdodGx5IHN0cmljdGVyIGlucHV0IHZhbGlkYXRpb24gdGhhbiB0b1xuICAgKiBoZXhFbmNvZGUvYmFzZTY0RW5jb2RlL2V0YzogaW4gdGhvc2Ugd2UgYWNjZXB0IGFueXRoaW5nIHRoYXQgQnVmZmVyLmZyb21cbiAgICogY2FuIHRha2UgKGluIHBhcnRpY3VsYXIgYWxsb3dpbmcgc3RyaW5ncywgd2hpY2ggYXJlIGp1c3QgaW50ZXJwcmV0ZWQgYXNcbiAgICogYmluYXJ5KTsgaGVyZSB3ZSBlbnN1cmUgdGhhdCB0aGUgaW5wdXQgaXMgYWN0dWFsbHkgYSBidWZmZXIgc2luY2UgdHJ5aW5nXG4gICAqIHRvIHV0ZjgtZGVjb2RlIGEgc3RyaW5nIHRvIGFub3RoZXIgc3RyaW5nIGlzIGFsbW9zdCBjZXJ0YWlubHkgYSBtaXN0YWtlICovXG4gIHV0ZjhEZWNvZGUoYnVmZmVyKSB7XG4gICAgaWYgKCF0aGlzLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGlucHV0IG9mIHV0ZjhkZWNvZGUgdG8gYmUgYW4gYXJyYXlidWZmZXIgb3IgdHlwZWQgYXJyYXlcIik7XG4gICAgfVxuICAgIGlmIChUZXh0RGVjb2Rlcikge1xuICAgICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShidWZmZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBUZXh0RGVjb2RlciB0byBiZSBjb25maWd1cmVkXCIpO1xuICAgIH1cbiAgfVxuICBhcmVCdWZmZXJzRXF1YWwoYnVmZmVyMSwgYnVmZmVyMikge1xuICAgIGlmICghYnVmZmVyMSB8fCAhYnVmZmVyMilcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBhcnJheUJ1ZmZlcjEgPSB0aGlzLnRvQXJyYXlCdWZmZXIoYnVmZmVyMSk7XG4gICAgY29uc3QgYXJyYXlCdWZmZXIyID0gdGhpcy50b0FycmF5QnVmZmVyKGJ1ZmZlcjIpO1xuICAgIGlmIChhcnJheUJ1ZmZlcjEuYnl0ZUxlbmd0aCAhPSBhcnJheUJ1ZmZlcjIuYnl0ZUxlbmd0aClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBieXRlczEgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcjEpO1xuICAgIGNvbnN0IGJ5dGVzMiA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyMik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlczEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChieXRlczFbaV0gIT0gYnl0ZXMyW2ldKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGJ5dGVMZW5ndGgoYnVmZmVyKSB7XG4gICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhidWZmZXIpKSB7XG4gICAgICByZXR1cm4gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBhcnJheUJ1ZmZlclZpZXdUb0J1ZmZlcihhcnJheUJ1ZmZlclZpZXcpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5QnVmZmVyKGFycmF5QnVmZmVyVmlldyk7XG4gIH1cbiAgY29uY2F0KGJ1ZmZlcnMpIHtcbiAgICBjb25zdCBzdW1MZW5ndGggPSBidWZmZXJzLnJlZHVjZSgoYWNjLCB2KSA9PiBhY2MgKyB2LmJ5dGVMZW5ndGgsIDApO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHN1bUxlbmd0aCk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChjb25zdCBidWZmZXIgb2YgYnVmZmVycykge1xuICAgICAgY29uc3QgdWludDhBcnJheTIgPSB0aGlzLnRvQnVmZmVyKGJ1ZmZlcik7XG4gICAgICByZXN1bHQuc2V0KHVpbnQ4QXJyYXkyLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IHVpbnQ4QXJyYXkyLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuYnVmZmVyO1xuICB9XG4gIHNoYTI1NihtZXNzYWdlKSB7XG4gICAgY29uc3QgaGFzaCA9IHNoYTI1Nih0aGlzLnRvQnVmZmVyKG1lc3NhZ2UpKTtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5QnVmZmVyKGhhc2gpO1xuICB9XG4gIGhtYWNTaGEyNTYobWVzc2FnZSwga2V5KSB7XG4gICAgY29uc3QgaGFzaCA9IGhtYWMyKHRoaXMudG9CdWZmZXIoa2V5KSwgdGhpcy50b0J1ZmZlcihtZXNzYWdlKSk7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUJ1ZmZlcihoYXNoKTtcbiAgfVxufTtcbnZhciBidWZmZXJ1dGlsc19kZWZhdWx0ID0gbmV3IEJ1ZmZlclV0aWxzKCk7XG5cbi8vIHNyYy9wbGF0Zm9ybS93ZWIvbGliL3V0aWwvY3J5cHRvLnRzXG52YXIgY3JlYXRlQ3J5cHRvQ2xhc3MgPSBmdW5jdGlvbihjb25maWcsIGJ1ZmZlclV0aWxzKSB7XG4gIHZhciBERUZBVUxUX0FMR09SSVRITSA9IFwiYWVzXCI7XG4gIHZhciBERUZBVUxUX0tFWUxFTkdUSCA9IDI1NjtcbiAgdmFyIERFRkFVTFRfTU9ERSA9IFwiY2JjXCI7XG4gIHZhciBERUZBVUxUX0JMT0NLTEVOR1RIID0gMTY7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlQ2lwaGVyUGFyYW1zKHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMuYWxnb3JpdGhtID09PSBcImFlc1wiICYmIHBhcmFtcy5tb2RlID09PSBcImNiY1wiKSB7XG4gICAgICBpZiAocGFyYW1zLmtleUxlbmd0aCA9PT0gMTI4IHx8IHBhcmFtcy5rZXlMZW5ndGggPT09IDI1Nikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiVW5zdXBwb3J0ZWQga2V5IGxlbmd0aCBcIiArIHBhcmFtcy5rZXlMZW5ndGggKyBcIiBmb3IgYWVzLWNiYyBlbmNyeXB0aW9uLiBFbmNyeXB0aW9uIGtleSBtdXN0IGJlIDEyOCBvciAyNTYgYml0cyAoMTYgb3IgMzIgQVNDSUkgY2hhcmFjdGVycylcIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbm9ybWFsaXNlQmFzZTY0KHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShcIl9cIiwgXCIvXCIpLnJlcGxhY2UoXCItXCIsIFwiK1wiKTtcbiAgfVxuICBmdW5jdGlvbiBpc0NpcGhlclBhcmFtcyhwYXJhbXMpIHtcbiAgICByZXR1cm4gcGFyYW1zIGluc3RhbmNlb2YgQ2lwaGVyUGFyYW1zO1xuICB9XG4gIGNsYXNzIENpcGhlclBhcmFtcyB7XG4gICAgY29uc3RydWN0b3IoYWxnb3JpdGhtLCBrZXlMZW5ndGgsIG1vZGUsIGtleSkge1xuICAgICAgdGhpcy5hbGdvcml0aG0gPSBhbGdvcml0aG07XG4gICAgICB0aGlzLmtleUxlbmd0aCA9IGtleUxlbmd0aDtcbiAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgQ3J5cHRvMiB7XG4gICAgLyoqXG4gICAgICogT2J0YWluIGEgY29tcGxldGUgQ2lwaGVyUGFyYW1zIGluc3RhbmNlIGZyb20gdGhlIHByb3ZpZGVkIHBhcmFtcywgZmlsbGluZ1xuICAgICAqIGluIGFueSBub3QgcHJvdmlkZWQgd2l0aCBkZWZhdWx0IHZhbHVlcywgY2FsY3VsYXRpbmcgYSBrZXlMZW5ndGggZnJvbVxuICAgICAqIHRoZSBzdXBwbGllZCBrZXksIGFuZCB2YWxpZGF0aW5nIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHBhcmFtcyBhbiBvYmplY3QgY29udGFpbmluZyBhdCBhIG1pbmltdW0gYSBga2V5YCBrZXkgd2l0aCB2YWx1ZSB0aGVcbiAgICAgKiBrZXksIGFzIGVpdGhlciBhIGJpbmFyeSBvciBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZy5cbiAgICAgKiBNYXkgb3B0aW9uYWxseSBhbHNvIGNvbnRhaW46IGFsZ29yaXRobSAoZGVmYXVsdHMgdG8gQUVTKSxcbiAgICAgKiBtb2RlIChkZWZhdWx0cyB0byAnY2JjJylcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgIHZhciBrZXk7XG4gICAgICBpZiAoIXBhcmFtcy5rZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3J5cHRvLmdldERlZmF1bHRQYXJhbXM6IGEga2V5IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXJhbXMua2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGtleSA9IGJ1ZmZlclV0aWxzLnRvQXJyYXlCdWZmZXIoYnVmZmVyVXRpbHMuYmFzZTY0RGVjb2RlKG5vcm1hbGlzZUJhc2U2NChwYXJhbXMua2V5KSkpO1xuICAgICAgfSBlbHNlIGlmIChwYXJhbXMua2V5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAga2V5ID0gcGFyYW1zLmtleTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleSA9IGJ1ZmZlclV0aWxzLnRvQXJyYXlCdWZmZXIocGFyYW1zLmtleSk7XG4gICAgICB9XG4gICAgICB2YXIgYWxnb3JpdGhtID0gcGFyYW1zLmFsZ29yaXRobSB8fCBERUZBVUxUX0FMR09SSVRITTtcbiAgICAgIHZhciBrZXlMZW5ndGggPSBrZXkuYnl0ZUxlbmd0aCAqIDg7XG4gICAgICB2YXIgbW9kZSA9IHBhcmFtcy5tb2RlIHx8IERFRkFVTFRfTU9ERTtcbiAgICAgIHZhciBjaXBoZXJQYXJhbXMgPSBuZXcgQ2lwaGVyUGFyYW1zKGFsZ29yaXRobSwga2V5TGVuZ3RoLCBtb2RlLCBrZXkpO1xuICAgICAgaWYgKHBhcmFtcy5rZXlMZW5ndGggJiYgcGFyYW1zLmtleUxlbmd0aCAhPT0gY2lwaGVyUGFyYW1zLmtleUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtczogYSBrZXlMZW5ndGggb2YgXCIgKyBwYXJhbXMua2V5TGVuZ3RoICsgXCIgd2FzIHNwZWNpZmllZCwgYnV0IHRoZSBrZXkgYWN0dWFsbHkgaGFzIGxlbmd0aCBcIiArIGNpcGhlclBhcmFtcy5rZXlMZW5ndGhcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhbGlkYXRlQ2lwaGVyUGFyYW1zKGNpcGhlclBhcmFtcyk7XG4gICAgICByZXR1cm4gY2lwaGVyUGFyYW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIHJhbmRvbSBlbmNyeXB0aW9uIGtleSBmcm9tIHRoZSBzdXBwbGllZCBrZXlsZW5ndGggKG9yIHRoZVxuICAgICAqIGRlZmF1bHQga2V5TGVuZ3RoIGlmIG5vbmUgc3VwcGxpZWQpIGFzIGFuIEFycmF5QnVmZmVyXG4gICAgICogQHBhcmFtIGtleUxlbmd0aCAob3B0aW9uYWwpIHRoZSByZXF1aXJlZCBrZXlMZW5ndGggaW4gYml0c1xuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBnZW5lcmF0ZVJhbmRvbUtleShrZXlMZW5ndGgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjb25maWcuZ2V0UmFuZG9tQXJyYXlCdWZmZXIoKGtleUxlbmd0aCB8fCBERUZBVUxUX0tFWUxFTkdUSCkgLyA4KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJhbmRvbSBrZXk6IFwiICsgZXJyLm1lc3NhZ2UsIDQwMCwgNWU0LCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbDsgZ2V0IGEgQ2hhbm5lbENpcGhlciBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gY2lwaGVyUGFyYW1zXG4gICAgICogQHBhcmFtIHBhcmFtcyBlaXRoZXIgYSBDaXBoZXJQYXJhbXMgaW5zdGFuY2Ugb3Igc29tZSBzdWJzZXQgb2YgaXRzXG4gICAgICogZmllbGRzIHRoYXQgaW5jbHVkZXMgYSBrZXlcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2lwaGVyKHBhcmFtcywgbG9nZ2VyKSB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgdmFyIGNpcGhlclBhcmFtcyA9IGlzQ2lwaGVyUGFyYW1zKHBhcmFtcykgPyBwYXJhbXMgOiB0aGlzLmdldERlZmF1bHRQYXJhbXMocGFyYW1zKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNpcGhlclBhcmFtcyxcbiAgICAgICAgY2lwaGVyOiBuZXcgQ0JDQ2lwaGVyKGNpcGhlclBhcmFtcywgKF9hMiA9IHBhcmFtcy5pdikgIT0gbnVsbCA/IF9hMiA6IG51bGwsIGxvZ2dlcilcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIENyeXB0bzIuQ2lwaGVyUGFyYW1zID0gQ2lwaGVyUGFyYW1zO1xuICBDcnlwdG8yO1xuICBjbGFzcyBDQkNDaXBoZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcywgaXYsIGxvZ2dlcikge1xuICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICBpZiAoIWNyeXB0by5zdWJ0bGUpIHtcbiAgICAgICAgaWYgKGlzU2VjdXJlQ29udGV4dCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiQ3J5cHRvIG9wZXJhdGlvbnMgYXJlIG5vdCBwb3NzaWJsZSBzaW5jZSB0aGUgYnJvd3NlclxcdTIwMTlzIFN1YnRsZUNyeXB0byBjbGFzcyBpcyB1bmF2YWlsYWJsZSAocmVhc29uIHVua25vd24pLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkNyeXB0byBvcGVyYXRpb25zIGFyZSBpcyBub3QgcG9zc2libGUgc2luY2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgaXMgYSBub24tc2VjdXJlIGNvbnRleHQgYW5kIGhlbmNlIHRoZSBicm93c2VyXFx1MjAxOXMgU3VidGxlQ3J5cHRvIGNsYXNzIGlzIG5vdCBhdmFpbGFibGUuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmFsZ29yaXRobSA9IHBhcmFtcy5hbGdvcml0aG0gKyBcIi1cIiArIFN0cmluZyhwYXJhbXMua2V5TGVuZ3RoKSArIFwiLVwiICsgcGFyYW1zLm1vZGU7XG4gICAgICB0aGlzLndlYkNyeXB0b0FsZ29yaXRobSA9IHBhcmFtcy5hbGdvcml0aG0gKyBcIi1cIiArIHBhcmFtcy5tb2RlO1xuICAgICAgdGhpcy5rZXkgPSBidWZmZXJVdGlscy50b0FycmF5QnVmZmVyKHBhcmFtcy5rZXkpO1xuICAgICAgdGhpcy5pdiA9IGl2ID8gYnVmZmVyVXRpbHMudG9BcnJheUJ1ZmZlcihpdikgOiBudWxsO1xuICAgIH1cbiAgICBjb25jYXQoYnVmZmVyMSwgYnVmZmVyMikge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlcjEuYnl0ZUxlbmd0aCArIGJ1ZmZlcjIuYnl0ZUxlbmd0aCk7XG4gICAgICBjb25zdCBvdXRwdXRWaWV3ID0gbmV3IERhdGFWaWV3KG91dHB1dCk7XG4gICAgICBjb25zdCBidWZmZXIxVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXJVdGlscy50b0FycmF5QnVmZmVyKGJ1ZmZlcjEpKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyMVZpZXcuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dHB1dFZpZXcuc2V0SW50OChpLCBidWZmZXIxVmlldy5nZXRJbnQ4KGkpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJ1ZmZlcjJWaWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlclV0aWxzLnRvQXJyYXlCdWZmZXIoYnVmZmVyMikpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIyVmlldy5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0cHV0Vmlldy5zZXRJbnQ4KGJ1ZmZlcjFWaWV3LmJ5dGVMZW5ndGggKyBpLCBidWZmZXIyVmlldy5nZXRJbnQ4KGkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGFzeW5jIGVuY3J5cHQocGxhaW50ZXh0KSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJDQkNDaXBoZXIuZW5jcnlwdCgpXCIsIFwiXCIpO1xuICAgICAgY29uc3QgaXYgPSBhd2FpdCB0aGlzLmdldEl2KCk7XG4gICAgICBjb25zdCBjcnlwdG9LZXkgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcInJhd1wiLCB0aGlzLmtleSwgdGhpcy53ZWJDcnlwdG9BbGdvcml0aG0sIGZhbHNlLCBbXCJlbmNyeXB0XCJdKTtcbiAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmVuY3J5cHQoeyBuYW1lOiB0aGlzLndlYkNyeXB0b0FsZ29yaXRobSwgaXYgfSwgY3J5cHRvS2V5LCBwbGFpbnRleHQpO1xuICAgICAgcmV0dXJuIHRoaXMuY29uY2F0KGl2LCBjaXBoZXJ0ZXh0KTtcbiAgICB9XG4gICAgYXN5bmMgZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJDQkNDaXBoZXIuZGVjcnlwdCgpXCIsIFwiXCIpO1xuICAgICAgY29uc3QgY2lwaGVydGV4dEFycmF5QnVmZmVyID0gYnVmZmVyVXRpbHMudG9BcnJheUJ1ZmZlcihjaXBoZXJ0ZXh0KTtcbiAgICAgIGNvbnN0IGl2ID0gY2lwaGVydGV4dEFycmF5QnVmZmVyLnNsaWNlKDAsIERFRkFVTFRfQkxPQ0tMRU5HVEgpO1xuICAgICAgY29uc3QgY2lwaGVydGV4dEJvZHkgPSBjaXBoZXJ0ZXh0QXJyYXlCdWZmZXIuc2xpY2UoREVGQVVMVF9CTE9DS0xFTkdUSCk7XG4gICAgICBjb25zdCBjcnlwdG9LZXkgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcInJhd1wiLCB0aGlzLmtleSwgdGhpcy53ZWJDcnlwdG9BbGdvcml0aG0sIGZhbHNlLCBbXCJkZWNyeXB0XCJdKTtcbiAgICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmRlY3J5cHQoeyBuYW1lOiB0aGlzLndlYkNyeXB0b0FsZ29yaXRobSwgaXYgfSwgY3J5cHRvS2V5LCBjaXBoZXJ0ZXh0Qm9keSk7XG4gICAgfVxuICAgIGFzeW5jIGdldEl2KCkge1xuICAgICAgaWYgKHRoaXMuaXYpIHtcbiAgICAgICAgdmFyIGl2ID0gdGhpcy5pdjtcbiAgICAgICAgdGhpcy5pdiA9IG51bGw7XG4gICAgICAgIHJldHVybiBpdjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJhbmRvbUJsb2NrID0gYXdhaXQgY29uZmlnLmdldFJhbmRvbUFycmF5QnVmZmVyKERFRkFVTFRfQkxPQ0tMRU5HVEgpO1xuICAgICAgcmV0dXJuIGJ1ZmZlclV0aWxzLnRvQXJyYXlCdWZmZXIocmFuZG9tQmxvY2spO1xuICAgIH1cbiAgfVxuICByZXR1cm4gQ3J5cHRvMjtcbn07XG5cbi8vIHNyYy9jb21tb24vY29uc3RhbnRzL1hIUlN0YXRlcy50c1xudmFyIFhIUlN0YXRlcyA9IC8qIEBfX1BVUkVfXyAqLyAoKFhIUlN0YXRlczIpID0+IHtcbiAgWEhSU3RhdGVzMltYSFJTdGF0ZXMyW1wiUkVRX1NFTkRcIl0gPSAwXSA9IFwiUkVRX1NFTkRcIjtcbiAgWEhSU3RhdGVzMltYSFJTdGF0ZXMyW1wiUkVRX1JFQ1ZcIl0gPSAxXSA9IFwiUkVRX1JFQ1ZcIjtcbiAgWEhSU3RhdGVzMltYSFJTdGF0ZXMyW1wiUkVRX1JFQ1ZfUE9MTFwiXSA9IDJdID0gXCJSRVFfUkVDVl9QT0xMXCI7XG4gIFhIUlN0YXRlczJbWEhSU3RhdGVzMltcIlJFUV9SRUNWX1NUUkVBTVwiXSA9IDNdID0gXCJSRVFfUkVDVl9TVFJFQU1cIjtcbiAgcmV0dXJuIFhIUlN0YXRlczI7XG59KShYSFJTdGF0ZXMgfHwge30pO1xudmFyIFhIUlN0YXRlc19kZWZhdWx0ID0gWEhSU3RhdGVzO1xuXG4vLyBzcmMvcGxhdGZvcm0vd2ViL2xpYi9odHRwL2h0dHAudHNcbmZ1bmN0aW9uIGNyZWF0ZU1pc3NpbmdJbXBsZW1lbnRhdGlvbkVycm9yKCkge1xuICByZXR1cm4gbmV3IEVycm9ySW5mbyhcbiAgICBcIk5vIEhUVFAgcmVxdWVzdCBwbHVnaW4gcHJvdmlkZWQuIFByb3ZpZGUgYXQgbGVhc3Qgb25lIG9mIHRoZSBGZXRjaFJlcXVlc3Qgb3IgWEhSUmVxdWVzdCBwbHVnaW5zLlwiLFxuICAgIDQwMCxcbiAgICA0ZTRcbiAgKTtcbn1cbnZhciBfYTtcbnZhciBIdHRwMiA9IChfYSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy5jaGVja3NJblByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLmNoZWNrQ29ubmVjdGl2aXR5ID0gdm9pZCAwO1xuICAgIHRoaXMuc3VwcG9ydHNBdXRoSGVhZGVycyA9IGZhbHNlO1xuICAgIHRoaXMuc3VwcG9ydHNMaW5rSGVhZGVycyA9IGZhbHNlO1xuICAgIHZhciBfYTI7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQgIT0gbnVsbCA/IGNsaWVudCA6IG51bGw7XG4gICAgY29uc3QgY29ubmVjdGl2aXR5Q2hlY2tVcmwgPSAoY2xpZW50ID09IG51bGwgPyB2b2lkIDAgOiBjbGllbnQub3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1VybCkgfHwgZGVmYXVsdHNfZGVmYXVsdC5jb25uZWN0aXZpdHlDaGVja1VybDtcbiAgICBjb25zdCBjb25uZWN0aXZpdHlDaGVja1BhcmFtcyA9IChfYTIgPSBjbGllbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGNsaWVudC5vcHRpb25zLmNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zKSAhPSBudWxsID8gX2EyIDogbnVsbDtcbiAgICBjb25zdCBjb25uZWN0aXZpdHlVcmxJc0RlZmF1bHQgPSAhKGNsaWVudCA9PSBudWxsID8gdm9pZCAwIDogY2xpZW50Lm9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tVcmwpO1xuICAgIGNvbnN0IHJlcXVlc3RJbXBsZW1lbnRhdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgSHR0cDIuYnVuZGxlZFJlcXVlc3RJbXBsZW1lbnRhdGlvbnMpLCBjbGllbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGNsaWVudC5fYWRkaXRpb25hbEhUVFBSZXF1ZXN0SW1wbGVtZW50YXRpb25zKTtcbiAgICBjb25zdCB4aHJSZXF1ZXN0SW1wbGVtZW50YXRpb24gPSByZXF1ZXN0SW1wbGVtZW50YXRpb25zLlhIUlJlcXVlc3Q7XG4gICAgY29uc3QgZmV0Y2hSZXF1ZXN0SW1wbGVtZW50YXRpb24gPSByZXF1ZXN0SW1wbGVtZW50YXRpb25zLkZldGNoUmVxdWVzdDtcbiAgICBjb25zdCBoYXNJbXBsZW1lbnRhdGlvbiA9ICEhKHhoclJlcXVlc3RJbXBsZW1lbnRhdGlvbiB8fCBmZXRjaFJlcXVlc3RJbXBsZW1lbnRhdGlvbik7XG4gICAgaWYgKCFoYXNJbXBsZW1lbnRhdGlvbikge1xuICAgICAgdGhyb3cgY3JlYXRlTWlzc2luZ0ltcGxlbWVudGF0aW9uRXJyb3IoKTtcbiAgICB9XG4gICAgaWYgKFBsYXRmb3JtLkNvbmZpZy54aHJTdXBwb3J0ZWQgJiYgeGhyUmVxdWVzdEltcGxlbWVudGF0aW9uKSB7XG4gICAgICB0aGlzLnN1cHBvcnRzQXV0aEhlYWRlcnMgPSB0cnVlO1xuICAgICAgdGhpcy5SZXF1ZXN0ID0gYXN5bmMgZnVuY3Rpb24obWV0aG9kLCB1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICB2YXIgX2EzO1xuICAgICAgICAgIGNvbnN0IHJlcSA9IHhoclJlcXVlc3RJbXBsZW1lbnRhdGlvbi5jcmVhdGVSZXF1ZXN0KFxuICAgICAgICAgICAgdXJpLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfU0VORCxcbiAgICAgICAgICAgIChfYTMgPSBjbGllbnQgJiYgY2xpZW50Lm9wdGlvbnMudGltZW91dHMpICE9IG51bGwgPyBfYTMgOiBudWxsLFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBtZXRob2RcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlcS5vbmNlKFxuICAgICAgICAgICAgXCJjb21wbGV0ZVwiLFxuICAgICAgICAgICAgKGVycm9yLCBib2R5MiwgaGVhZGVyczIsIHVucGFja2VkLCBzdGF0dXNDb2RlKSA9PiByZXNvbHZlKHsgZXJyb3IsIGJvZHk6IGJvZHkyLCBoZWFkZXJzOiBoZWFkZXJzMiwgdW5wYWNrZWQsIHN0YXR1c0NvZGUgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlcS5leGVjKCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGlmIChjbGllbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGNsaWVudC5vcHRpb25zLmRpc2FibGVDb25uZWN0aXZpdHlDaGVjaykge1xuICAgICAgICB0aGlzLmNoZWNrQ29ubmVjdGl2aXR5ID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNoZWNrQ29ubmVjdGl2aXR5ID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9hMztcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICAgIFwiKFhIUlJlcXVlc3QpSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpXCIsXG4gICAgICAgICAgICBcIlNlbmRpbmc7IFwiICsgY29ubmVjdGl2aXR5Q2hlY2tVcmxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IHJlcXVlc3RSZXN1bHQgPSBhd2FpdCB0aGlzLmRvVXJpKFxuICAgICAgICAgICAgSHR0cE1ldGhvZHNfZGVmYXVsdC5HZXQsXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlDaGVja1VybCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgY29ubmVjdGl2aXR5Q2hlY2tQYXJhbXNcbiAgICAgICAgICApO1xuICAgICAgICAgIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoIWNvbm5lY3Rpdml0eVVybElzRGVmYXVsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gIXJlcXVlc3RSZXN1bHQuZXJyb3IgJiYgaXNTdWNjZXNzQ29kZShyZXF1ZXN0UmVzdWx0LnN0YXR1c0NvZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSAhcmVxdWVzdFJlc3VsdC5lcnJvciAmJiAoKF9hMyA9IHJlcXVlc3RSZXN1bHQuYm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5yZXBsYWNlKC9cXG4vLCBcIlwiKSkgPT0gXCJ5ZXNcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiKFhIUlJlcXVlc3QpSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpXCIsIFwiUmVzdWx0OiBcIiArIHJlc3VsdCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFBsYXRmb3JtLkNvbmZpZy5mZXRjaFN1cHBvcnRlZCAmJiBmZXRjaFJlcXVlc3RJbXBsZW1lbnRhdGlvbikge1xuICAgICAgdGhpcy5zdXBwb3J0c0F1dGhIZWFkZXJzID0gdHJ1ZTtcbiAgICAgIHRoaXMuUmVxdWVzdCA9IGFzeW5jIChtZXRob2QsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5KSA9PiB7XG4gICAgICAgIHJldHVybiBmZXRjaFJlcXVlc3RJbXBsZW1lbnRhdGlvbihtZXRob2QsIGNsaWVudCAhPSBudWxsID8gY2xpZW50IDogbnVsbCwgdXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHkpO1xuICAgICAgfTtcbiAgICAgIGlmIChjbGllbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGNsaWVudC5vcHRpb25zLmRpc2FibGVDb25uZWN0aXZpdHlDaGVjaykge1xuICAgICAgICB0aGlzLmNoZWNrQ29ubmVjdGl2aXR5ID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNoZWNrQ29ubmVjdGl2aXR5ID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9hMztcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICAgIFwiKEZldGNoKUh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKVwiLFxuICAgICAgICAgICAgXCJTZW5kaW5nOyBcIiArIGNvbm5lY3Rpdml0eUNoZWNrVXJsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCByZXF1ZXN0UmVzdWx0ID0gYXdhaXQgdGhpcy5kb1VyaShIdHRwTWV0aG9kc19kZWZhdWx0LkdldCwgY29ubmVjdGl2aXR5Q2hlY2tVcmwsIG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9ICFyZXF1ZXN0UmVzdWx0LmVycm9yICYmICgoX2EzID0gcmVxdWVzdFJlc3VsdC5ib2R5KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLnJlcGxhY2UoL1xcbi8sIFwiXCIpKSA9PSBcInllc1wiO1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIihGZXRjaClIdHRwLmNoZWNrQ29ubmVjdGl2aXR5KClcIiwgXCJSZXN1bHQ6IFwiICsgcmVzdWx0KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLlJlcXVlc3QgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gaGFzSW1wbGVtZW50YXRpb24gPyBuZXcgUGFydGlhbEVycm9ySW5mbyhcIm5vIHN1cHBvcnRlZCBIVFRQIHRyYW5zcG9ydHMgYXZhaWxhYmxlXCIsIG51bGwsIDQwMCkgOiBjcmVhdGVNaXNzaW5nSW1wbGVtZW50YXRpb25FcnJvcigpO1xuICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgZ2V0IGxvZ2dlcigpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hMiA9IHRoaXMuY2xpZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmxvZ2dlcikgIT0gbnVsbCA/IF9iIDogbG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlcjtcbiAgfVxuICBhc3luYyBkb1VyaShtZXRob2QsIHVyaSwgaGVhZGVycywgYm9keSwgcGFyYW1zKSB7XG4gICAgaWYgKCF0aGlzLlJlcXVlc3QpIHtcbiAgICAgIHJldHVybiB7IGVycm9yOiBuZXcgUGFydGlhbEVycm9ySW5mbyhcIlJlcXVlc3QgaW52b2tlZCBiZWZvcmUgYXNzaWduZWQgdG9cIiwgbnVsbCwgNTAwKSB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5SZXF1ZXN0KG1ldGhvZCwgdXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHkpO1xuICB9XG4gIHNob3VsZEZhbGxiYWNrKGVycm9ySW5mbykge1xuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSBlcnJvckluZm8uc3RhdHVzQ29kZTtcbiAgICByZXR1cm4gc3RhdHVzQ29kZSA9PT0gNDA4ICYmICFlcnJvckluZm8uY29kZSB8fCBzdGF0dXNDb2RlID09PSA0MDAgJiYgIWVycm9ySW5mby5jb2RlIHx8IHN0YXR1c0NvZGUgPj0gNTAwICYmIHN0YXR1c0NvZGUgPD0gNTA0O1xuICB9XG59LCBfYS5tZXRob2RzID0gW0h0dHBNZXRob2RzX2RlZmF1bHQuR2V0LCBIdHRwTWV0aG9kc19kZWZhdWx0LkRlbGV0ZSwgSHR0cE1ldGhvZHNfZGVmYXVsdC5Qb3N0LCBIdHRwTWV0aG9kc19kZWZhdWx0LlB1dCwgSHR0cE1ldGhvZHNfZGVmYXVsdC5QYXRjaF0sIF9hLm1ldGhvZHNXaXRob3V0Qm9keSA9IFtIdHRwTWV0aG9kc19kZWZhdWx0LkdldCwgSHR0cE1ldGhvZHNfZGVmYXVsdC5EZWxldGVdLCBfYS5tZXRob2RzV2l0aEJvZHkgPSBbSHR0cE1ldGhvZHNfZGVmYXVsdC5Qb3N0LCBIdHRwTWV0aG9kc19kZWZhdWx0LlB1dCwgSHR0cE1ldGhvZHNfZGVmYXVsdC5QYXRjaF0sIF9hKTtcbnZhciBodHRwX2RlZmF1bHQgPSBIdHRwMjtcblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9saWIvdXRpbC93ZWJzdG9yYWdlLnRzXG52YXIgdGVzdCA9IFwiYWJseWpzLXN0b3JhZ2UtdGVzdFwiO1xudmFyIGdsb2JhbE9iamVjdDMgPSB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHNlbGY7XG52YXIgV2Vic3RvcmFnZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGdsb2JhbE9iamVjdDMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSh0ZXN0LCB0ZXN0KTtcbiAgICAgIGdsb2JhbE9iamVjdDMuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSh0ZXN0KTtcbiAgICAgIHRoaXMuc2Vzc2lvblN1cHBvcnRlZCA9IHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5zZXNzaW9uU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBnbG9iYWxPYmplY3QzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKHRlc3QsIHRlc3QpO1xuICAgICAgZ2xvYmFsT2JqZWN0My5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0ZXN0KTtcbiAgICAgIHRoaXMubG9jYWxTdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMubG9jYWxTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KG5hbWUsIGZhbHNlKTtcbiAgfVxuICBnZXRTZXNzaW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KG5hbWUsIHRydWUpO1xuICB9XG4gIHJlbW92ZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbW92ZShuYW1lLCBmYWxzZSk7XG4gIH1cbiAgcmVtb3ZlU2Vzc2lvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbW92ZShuYW1lLCB0cnVlKTtcbiAgfVxuICBzZXQobmFtZSwgdmFsdWUsIHR0bCkge1xuICAgIHJldHVybiB0aGlzLl9zZXQobmFtZSwgdmFsdWUsIHR0bCwgZmFsc2UpO1xuICB9XG4gIHNldFNlc3Npb24obmFtZSwgdmFsdWUsIHR0bCkge1xuICAgIHJldHVybiB0aGlzLl9zZXQobmFtZSwgdmFsdWUsIHR0bCwgdHJ1ZSk7XG4gIH1cbiAgX3NldChuYW1lLCB2YWx1ZSwgdHRsLCBzZXNzaW9uKSB7XG4gICAgY29uc3Qgd3JhcHBlZFZhbHVlID0geyB2YWx1ZSB9O1xuICAgIGlmICh0dGwpIHtcbiAgICAgIHdyYXBwZWRWYWx1ZS5leHBpcmVzID0gRGF0ZS5ub3coKSArIHR0bDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZUludGVyZmFjZShzZXNzaW9uKS5zZXRJdGVtKG5hbWUsIEpTT04uc3RyaW5naWZ5KHdyYXBwZWRWYWx1ZSkpO1xuICB9XG4gIF9nZXQobmFtZSwgc2Vzc2lvbikge1xuICAgIGlmIChzZXNzaW9uICYmICF0aGlzLnNlc3Npb25TdXBwb3J0ZWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXNzaW9uIFN0b3JhZ2Ugbm90IHN1cHBvcnRlZFwiKTtcbiAgICBpZiAoIXNlc3Npb24gJiYgIXRoaXMubG9jYWxTdXBwb3J0ZWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2NhbCBTdG9yYWdlIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgY29uc3QgcmF3SXRlbSA9IHRoaXMuc3RvcmFnZUludGVyZmFjZShzZXNzaW9uKS5nZXRJdGVtKG5hbWUpO1xuICAgIGlmICghcmF3SXRlbSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHdyYXBwZWRWYWx1ZSA9IEpTT04ucGFyc2UocmF3SXRlbSk7XG4gICAgaWYgKHdyYXBwZWRWYWx1ZS5leHBpcmVzICYmIHdyYXBwZWRWYWx1ZS5leHBpcmVzIDwgRGF0ZS5ub3coKSkge1xuICAgICAgdGhpcy5zdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pLnJlbW92ZUl0ZW0obmFtZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHdyYXBwZWRWYWx1ZS52YWx1ZTtcbiAgfVxuICBfcmVtb3ZlKG5hbWUsIHNlc3Npb24pIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pLnJlbW92ZUl0ZW0obmFtZSk7XG4gIH1cbiAgc3RvcmFnZUludGVyZmFjZShzZXNzaW9uKSB7XG4gICAgcmV0dXJuIHNlc3Npb24gPyBnbG9iYWxPYmplY3QzLnNlc3Npb25TdG9yYWdlIDogZ2xvYmFsT2JqZWN0My5sb2NhbFN0b3JhZ2U7XG4gIH1cbn07XG52YXIgd2Vic3RvcmFnZV9kZWZhdWx0ID0gbmV3IFdlYnN0b3JhZ2UoKTtcblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9jb25maWcudHNcbnZhciBnbG9iYWxPYmplY3Q0ID0gZ2V0R2xvYmFsT2JqZWN0KCk7XG52YXIgaXNWZXJjZWxFZGdlUnVudGltZSA9IHR5cGVvZiBFZGdlUnVudGltZSA9PT0gXCJzdHJpbmdcIjtcbmlmICh0eXBlb2YgV2luZG93ID09PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA9PT0gXCJ1bmRlZmluZWRcIiAmJiAhaXNWZXJjZWxFZGdlUnVudGltZSkge1xuICBjb25zb2xlLmxvZyhcbiAgICBcIldhcm5pbmc6IHRoaXMgZGlzdHJpYnV0aW9uIG9mIEFibHkgaXMgaW50ZW5kZWQgZm9yIGJyb3dzZXJzLiBPbiBub2RlanMsIHBsZWFzZSB1c2UgdGhlICdhYmx5JyBwYWNrYWdlIG9uIG5wbVwiXG4gICk7XG59XG5mdW5jdGlvbiBhbGxvd0NvbWV0KCkge1xuICBjb25zdCBsb2MgPSBnbG9iYWxPYmplY3Q0LmxvY2F0aW9uO1xuICByZXR1cm4gIWdsb2JhbE9iamVjdDQuV2ViU29ja2V0IHx8ICFsb2MgfHwgIWxvYy5vcmlnaW4gfHwgbG9jLm9yaWdpbi5pbmRleE9mKFwiaHR0cFwiKSA+IC0xO1xufVxuZnVuY3Rpb24gaXNXZWJXb3JrZXJDb250ZXh0KCkge1xuICBpZiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxudmFyIHVzZXJBZ2VudCA9IGdsb2JhbE9iamVjdDQubmF2aWdhdG9yICYmIGdsb2JhbE9iamVjdDQubmF2aWdhdG9yLnVzZXJBZ2VudC50b1N0cmluZygpO1xudmFyIGN1cnJlbnRVcmwgPSBnbG9iYWxPYmplY3Q0LmxvY2F0aW9uICYmIGdsb2JhbE9iamVjdDQubG9jYXRpb24uaHJlZjtcbnZhciBDb25maWcgPSB7XG4gIGFnZW50OiBcImJyb3dzZXJcIixcbiAgbG9nVGltZXN0YW1wczogdHJ1ZSxcbiAgdXNlckFnZW50LFxuICBjdXJyZW50VXJsLFxuICBiaW5hcnlUeXBlOiBcImFycmF5YnVmZmVyXCIsXG4gIFdlYlNvY2tldDogZ2xvYmFsT2JqZWN0NC5XZWJTb2NrZXQsXG4gIGZldGNoU3VwcG9ydGVkOiAhIWdsb2JhbE9iamVjdDQuZmV0Y2gsXG4gIHhoclN1cHBvcnRlZDogZ2xvYmFsT2JqZWN0NC5YTUxIdHRwUmVxdWVzdCAmJiBcIndpdGhDcmVkZW50aWFsc1wiIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxuICBhbGxvd0NvbWV0OiBhbGxvd0NvbWV0KCksXG4gIHVzZVByb3RvY29sSGVhcnRiZWF0czogdHJ1ZSxcbiAgc3VwcG9ydHNCaW5hcnk6ICEhZ2xvYmFsT2JqZWN0NC5UZXh0RGVjb2RlcixcbiAgLyogUGVyIFBhZGR5IChodHRwczovL2FibHktcmVhbC10aW1lLnNsYWNrLmNvbS9hcmNoaXZlcy9DVVJMNFUyRlAvcDE3MDU2NzQ1Mzc3NjM0NzkpIHdlYiBpbnRlbnRpb25hbGx5IHByZWZlcnMgSlNPTiB0byBNZXNzYWdlUGFjazpcbiAgICpcbiAgICogPiBicm93c2Vycycgc3VwcG9ydCBmb3IgYmluYXJ5IHR5cGVzIGluIGdlbmVyYWwgd2FzIGhpc3RvcmljYWxseSBwb29yLCBhbmQgSlNPTiB0cmFuc3BvcnQgcGVyZm9ybWFuY2UgaXMgc2lnbmlmaWNhbnRseSBiZXR0ZXIgaW4gYSBicm93c2VyIHRoYW4gbXNncGFjay4gSW4gbW9kZXJuIGJyb3dzZXJzIHRoZW4gYmluYXJ5IGlzIHN1cHBvcnRlZCBjb25zaXN0ZW50bHksIGJ1dCBJJ2Qgc3RpbGwgZXhwZWN0IHRoYXQgSlNPTiBlbmNvZGUvZGVjb2RlIHBlcmZvcm1hbmNlIGlzIGRyYW1hdGljYWxseSBiZXR0ZXIgdGhhbiBtc2dwYWNrIGluIGEgYnJvd3Nlci5cbiAgICovXG4gIHByZWZlckJpbmFyeTogZmFsc2UsXG4gIEFycmF5QnVmZmVyOiBnbG9iYWxPYmplY3Q0LkFycmF5QnVmZmVyLFxuICBhdG9iOiBnbG9iYWxPYmplY3Q0LmF0b2IsXG4gIG5leHRUaWNrOiB0eXBlb2YgZ2xvYmFsT2JqZWN0NC5xdWV1ZU1pY3JvdGFzayA9PT0gXCJmdW5jdGlvblwiID8gKGYpID0+IGdsb2JhbE9iamVjdDQucXVldWVNaWNyb3Rhc2soZikgOiAoZikgPT4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmKSxcbiAgYWRkRXZlbnRMaXN0ZW5lcjogZ2xvYmFsT2JqZWN0NC5hZGRFdmVudExpc3RlbmVyLFxuICBpbnNwZWN0OiBKU09OLnN0cmluZ2lmeSxcbiAgc3RyaW5nQnl0ZVNpemU6IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBnbG9iYWxPYmplY3Q0LlRleHREZWNvZGVyICYmIG5ldyBnbG9iYWxPYmplY3Q0LlRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikubGVuZ3RoIHx8IHN0ci5sZW5ndGg7XG4gIH0sXG4gIFRleHRFbmNvZGVyOiBnbG9iYWxPYmplY3Q0LlRleHRFbmNvZGVyLFxuICBUZXh0RGVjb2RlcjogZ2xvYmFsT2JqZWN0NC5UZXh0RGVjb2RlcixcbiAgZ2V0UmFuZG9tQXJyYXlCdWZmZXI6IGFzeW5jIGZ1bmN0aW9uKGJ5dGVMZW5ndGgpIHtcbiAgICBjb25zdCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShieXRlTGVuZ3RoKTtcbiAgICBnbG9iYWxPYmplY3Q0LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZUFycmF5KTtcbiAgICByZXR1cm4gYnl0ZUFycmF5LmJ1ZmZlcjtcbiAgfSxcbiAgaXNXZWJ3b3JrZXI6IGlzV2ViV29ya2VyQ29udGV4dCgpLFxuICBwdXNoOiB7XG4gICAgcGxhdGZvcm06IFwiYnJvd3NlclwiIC8qIEJyb3dzZXIgKi8sXG4gICAgZm9ybUZhY3RvcjogXCJkZXNrdG9wXCIgLyogRGVza3RvcCAqLyxcbiAgICBzdG9yYWdlOiB3ZWJzdG9yYWdlX2RlZmF1bHRcbiAgfVxufTtcbnZhciBjb25maWdfZGVmYXVsdCA9IENvbmZpZztcblxuLy8gc3JjL2NvbW1vbi9saWIvdHJhbnNwb3J0L2NvbWV0dHJhbnNwb3J0LnRzXG5mdW5jdGlvbiBzaG91bGRCZUVycm9yQWN0aW9uKGVycikge1xuICBjb25zdCBVTlJFU09MVkFCTEVfRVJST1JfQ09ERVMgPSBbODAwMTUsIDgwMDE3LCA4MDAzMF07XG4gIGlmIChlcnIuY29kZSkge1xuICAgIGlmIChhdXRoX2RlZmF1bHQuaXNUb2tlbkVycihlcnIpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChVTlJFU09MVkFCTEVfRVJST1JfQ09ERVMuaW5jbHVkZXMoZXJyLmNvZGUpKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGVyci5jb2RlID49IDRlNCAmJiBlcnIuY29kZSA8IDVlNDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpIHtcbiAgaWYgKHNob3VsZEJlRXJyb3JBY3Rpb24oZXJyKSkge1xuICAgIHJldHVybiBbZnJvbVZhbHVlcyh7IGFjdGlvbjogYWN0aW9ucy5FUlJPUiwgZXJyb3I6IGVyciB9KV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtmcm9tVmFsdWVzKHsgYWN0aW9uOiBhY3Rpb25zLkRJU0NPTk5FQ1RFRCwgZXJyb3I6IGVyciB9KV07XG4gIH1cbn1cbnZhciBDb21ldFRyYW5zcG9ydCA9IGNsYXNzIGV4dGVuZHMgdHJhbnNwb3J0X2RlZmF1bHQge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG4gICAgc3VwZXIoXG4gICAgICBjb25uZWN0aW9uTWFuYWdlcixcbiAgICAgIGF1dGgsXG4gICAgICBwYXJhbXMsXG4gICAgICAvKiBiaW5hcnkgbm90IHN1cHBvcnRlZCBmb3IgY29tZXQgc28gZm9yY2UgSlNPTiBwcm90b2NvbCAqL1xuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgLyogSGlzdG9yaWNhbCBjb21tZW50LCBiYWNrIGZyb20gd2hlbiB3ZSBzdXBwb3J0ZWQgSlNPTlA6XG4gICAgICpcbiAgICAgKiA+IEZvciBjb21ldCwgd2UgY291bGQgZG8gdGhlIGF1dGggdXBkYXRlIGJ5IGFib3J0aW5nIHRoZSBjdXJyZW50IHJlY3YgYW5kXG4gICAgICogPiBzdGFydGluZyBhIG5ldyBvbmUgd2l0aCB0aGUgbmV3IHRva2VuLCB0aGF0J2QgYmUgc3VmZmljaWVudCBmb3IgcmVhbHRpbWUuXG4gICAgICogPiBQcm9ibGVtIGlzIEpTT05QIC0geW91IGNhbid0IGNhbmNlbCB0cnVseSBhYm9ydCBhIHJlY3Ygb25jZSBzdGFydGVkLiBTb1xuICAgICAqID4gd2UgbmVlZCB0byBzZW5kIGFuIEFVVEggZm9yIGpzb25wLiBJbiB3aGljaCBjYXNlIGl0J3Mgc2ltcGxlciB0byBrZWVwIGFsbFxuICAgICAqID4gY29tZXQgdHJhbnNwb3J0cyB0aGUgc2FtZSBhbmQgZG8gaXQgZm9yIGFsbCBvZiB0aGVtLiBTbyB3ZSBzZW5kIHRoZSBBVVRIXG4gICAgICogPiBpbnN0ZWFkLCBhbmQgZG9uJ3QgbmVlZCB0byBhYm9ydCB0aGUgcmVjdlxuICAgICAqXG4gICAgICogTm93IHRoYXQgd2XigJl2ZSBkcm9wcGVkIEpTT05QIHN1cHBvcnQsIHdlIG1heSBiZSBhYmxlIHRvIHJldmlzaXQgdGhlIGFib3ZlO1xuICAgICAqIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYWJseS9hYmx5LWpzL2lzc3Vlcy8xMjE0LlxuICAgICAqL1xuICAgIHRoaXMub25BdXRoVXBkYXRlZCA9ICh0b2tlbkRldGFpbHMpID0+IHtcbiAgICAgIHRoaXMuYXV0aFBhcmFtcyA9IHsgYWNjZXNzX3Rva2VuOiB0b2tlbkRldGFpbHMudG9rZW4gfTtcbiAgICB9O1xuICAgIHRoaXMuc3RyZWFtID0gXCJzdHJlYW1cIiBpbiBwYXJhbXMgPyBwYXJhbXMuc3RyZWFtIDogdHJ1ZTtcbiAgICB0aGlzLnNlbmRSZXF1ZXN0ID0gbnVsbDtcbiAgICB0aGlzLnJlY3ZSZXF1ZXN0ID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdDYWxsYmFjayA9IG51bGw7XG4gICAgdGhpcy5wZW5kaW5nSXRlbXMgPSBudWxsO1xuICB9XG4gIGNvbm5lY3QoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29tZXRUcmFuc3BvcnQuY29ubmVjdCgpXCIsIFwic3RhcnRpbmdcIik7XG4gICAgdHJhbnNwb3J0X2RlZmF1bHQucHJvdG90eXBlLmNvbm5lY3QuY2FsbCh0aGlzKTtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnBhcmFtcztcbiAgICBjb25zdCBvcHRpb25zID0gcGFyYW1zLm9wdGlvbnM7XG4gICAgY29uc3QgaG9zdCA9IHBhcmFtcy5ob3N0IHx8IG9wdGlvbnMucHJpbWFyeURvbWFpbjtcbiAgICBjb25zdCBwb3J0ID0gZGVmYXVsdHNfZGVmYXVsdC5nZXRQb3J0KG9wdGlvbnMpO1xuICAgIGNvbnN0IGNvbWV0U2NoZW1lID0gb3B0aW9ucy50bHMgPyBcImh0dHBzOi8vXCIgOiBcImh0dHA6Ly9cIjtcbiAgICB0aGlzLmJhc2VVcmkgPSBjb21ldFNjaGVtZSArIGhvc3QgKyBcIjpcIiArIHBvcnQgKyBcIi9jb21ldC9cIjtcbiAgICBjb25zdCBjb25uZWN0VXJpID0gdGhpcy5iYXNlVXJpICsgXCJjb25uZWN0XCI7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29tZXRUcmFuc3BvcnQuY29ubmVjdCgpXCIsIFwidXJpOiBcIiArIGNvbm5lY3RVcmkpO1xuICAgIHdoZW5Qcm9taXNlU2V0dGxlcyh0aGlzLmF1dGguZ2V0QXV0aFBhcmFtcygpLCAoZXJyLCBhdXRoUGFyYW1zKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXV0aFBhcmFtcyA9IGF1dGhQYXJhbXM7XG4gICAgICBjb25zdCBjb25uZWN0UGFyYW1zID0gdGhpcy5wYXJhbXMuZ2V0Q29ubmVjdFBhcmFtcyhhdXRoUGFyYW1zKTtcbiAgICAgIGlmIChcInN0cmVhbVwiIGluIGNvbm5lY3RQYXJhbXMpXG4gICAgICAgIHRoaXMuc3RyZWFtID0gY29ubmVjdFBhcmFtcy5zdHJlYW07XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQ29tZXRUcmFuc3BvcnQuY29ubmVjdCgpXCIsXG4gICAgICAgIFwiY29ubmVjdFBhcmFtczpcIiArIHRvUXVlcnlTdHJpbmcoY29ubmVjdFBhcmFtcylcbiAgICAgICk7XG4gICAgICBsZXQgcHJlY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBjb25uZWN0UmVxdWVzdCA9IHRoaXMucmVjdlJlcXVlc3QgPSB0aGlzLmNyZWF0ZVJlcXVlc3QoXG4gICAgICAgIGNvbm5lY3RVcmksXG4gICAgICAgIG51bGwsXG4gICAgICAgIGNvbm5lY3RQYXJhbXMsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHRoaXMuc3RyZWFtID8gWEhSU3RhdGVzX2RlZmF1bHQuUkVRX1JFQ1ZfU1RSRUFNIDogWEhSU3RhdGVzX2RlZmF1bHQuUkVRX1JFQ1ZcbiAgICAgICk7XG4gICAgICBjb25uZWN0UmVxdWVzdC5vbihcImRhdGFcIiwgKGRhdGEpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnJlY3ZSZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJlY29ubmVjdGVkKSB7XG4gICAgICAgICAgcHJlY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJwcmVjb25uZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICAgICAgfSk7XG4gICAgICBjb25uZWN0UmVxdWVzdC5vbihcImNvbXBsZXRlXCIsIChlcnIyKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5yZWN2UmVxdWVzdCkge1xuICAgICAgICAgIGVycjIgPSBlcnIyIHx8IG5ldyBFcnJvckluZm8oXCJSZXF1ZXN0IGNhbmNlbGxlZFwiLCA4MDAwMywgNDAwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlY3ZSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFwcmVjb25uZWN0ZWQgJiYgIWVycjIpIHtcbiAgICAgICAgICBwcmVjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZW1pdChcInByZWNvbm5lY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkFjdGl2aXR5KCk7XG4gICAgICAgIGlmIChlcnIyKSB7XG4gICAgICAgICAgaWYgKGVycjIuY29kZSkge1xuICAgICAgICAgICAgdGhpcy5vbkRhdGEocHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycjIpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KGVycjIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlY3YoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGNvbm5lY3RSZXF1ZXN0LmV4ZWMoKTtcbiAgICB9KTtcbiAgfVxuICByZXF1ZXN0Q2xvc2UoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29tZXRUcmFuc3BvcnQucmVxdWVzdENsb3NlKClcIik7XG4gICAgdGhpcy5fcmVxdWVzdENsb3NlT3JEaXNjb25uZWN0KHRydWUpO1xuICB9XG4gIHJlcXVlc3REaXNjb25uZWN0KCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbWV0VHJhbnNwb3J0LnJlcXVlc3REaXNjb25uZWN0KClcIik7XG4gICAgdGhpcy5fcmVxdWVzdENsb3NlT3JEaXNjb25uZWN0KGZhbHNlKTtcbiAgfVxuICBfcmVxdWVzdENsb3NlT3JEaXNjb25uZWN0KGNsb3NpbmcpIHtcbiAgICBjb25zdCBjbG9zZU9yRGlzY29ubmVjdFVyaSA9IGNsb3NpbmcgPyB0aGlzLmNsb3NlVXJpIDogdGhpcy5kaXNjb25uZWN0VXJpO1xuICAgIGlmIChjbG9zZU9yRGlzY29ubmVjdFVyaSkge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdChjbG9zZU9yRGlzY29ubmVjdFVyaSwgbnVsbCwgdGhpcy5hdXRoUGFyYW1zLCBudWxsLCBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfU0VORCk7XG4gICAgICByZXF1ZXN0Lm9uKFwiY29tcGxldGVcIiwgKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgICBcIkNvbWV0VHJhbnNwb3J0LnJlcXVlc3RcIiArIChjbG9zaW5nID8gXCJDbG9zZSgpXCIgOiBcIkRpc2Nvbm5lY3QoKVwiKSxcbiAgICAgICAgICAgIFwicmVxdWVzdCByZXR1cm5lZCBlcnIgPSBcIiArIGluc3BlY3RFcnJvcihlcnIpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLmZpbmlzaChcImRpc2Nvbm5lY3RlZFwiLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlcXVlc3QuZXhlYygpO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbWV0VHJhbnNwb3J0LmRpc3Bvc2UoKVwiLCBcIlwiKTtcbiAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLnJlY3ZSZXF1ZXN0KSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbWV0VHJhbnNwb3J0LmRpc3Bvc2UoKVwiLCBcImFib3J0aW5nIHJlY3YgcmVxdWVzdFwiKTtcbiAgICAgICAgdGhpcy5yZWN2UmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICB0aGlzLnJlY3ZSZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmluaXNoKFwiZGlzY29ubmVjdGVkXCIsIGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdC5kaXNjb25uZWN0ZWQoKSk7XG4gICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoXCJkaXNwb3NlZFwiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBvbkNvbm5lY3QobWVzc2FnZSkge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb25uZWN0aW9uU3RyID0gKF9hMiA9IG1lc3NhZ2UuY29ubmVjdGlvbkRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY29ubmVjdGlvbktleTtcbiAgICB0cmFuc3BvcnRfZGVmYXVsdC5wcm90b3R5cGUub25Db25uZWN0LmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgY29uc3QgYmFzZUNvbm5lY3Rpb25VcmkgPSB0aGlzLmJhc2VVcmkgKyBjb25uZWN0aW9uU3RyO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIkNvbWV0VHJhbnNwb3J0Lm9uQ29ubmVjdCgpXCIsIFwiYmFzZVVyaSA9IFwiICsgYmFzZUNvbm5lY3Rpb25VcmkpO1xuICAgIHRoaXMuc2VuZFVyaSA9IGJhc2VDb25uZWN0aW9uVXJpICsgXCIvc2VuZFwiO1xuICAgIHRoaXMucmVjdlVyaSA9IGJhc2VDb25uZWN0aW9uVXJpICsgXCIvcmVjdlwiO1xuICAgIHRoaXMuY2xvc2VVcmkgPSBiYXNlQ29ubmVjdGlvblVyaSArIFwiL2Nsb3NlXCI7XG4gICAgdGhpcy5kaXNjb25uZWN0VXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyBcIi9kaXNjb25uZWN0XCI7XG4gIH1cbiAgc2VuZChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuc2VuZFJlcXVlc3QpIHtcbiAgICAgIHRoaXMucGVuZGluZ0l0ZW1zID0gdGhpcy5wZW5kaW5nSXRlbXMgfHwgW107XG4gICAgICB0aGlzLnBlbmRpbmdJdGVtcy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nSXRlbXMgPSB0aGlzLnBlbmRpbmdJdGVtcyB8fCBbXTtcbiAgICBwZW5kaW5nSXRlbXMucHVzaChtZXNzYWdlKTtcbiAgICB0aGlzLnBlbmRpbmdJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5zZW5kSXRlbXMocGVuZGluZ0l0ZW1zKTtcbiAgfVxuICBzZW5kQW55UGVuZGluZygpIHtcbiAgICBjb25zdCBwZW5kaW5nSXRlbXMgPSB0aGlzLnBlbmRpbmdJdGVtcztcbiAgICBpZiAoIXBlbmRpbmdJdGVtcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBlbmRpbmdJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5zZW5kSXRlbXMocGVuZGluZ0l0ZW1zKTtcbiAgfVxuICBzZW5kSXRlbXMoaXRlbXMpIHtcbiAgICBjb25zdCBzZW5kUmVxdWVzdCA9IHRoaXMuc2VuZFJlcXVlc3QgPSB0aGlzLmNyZWF0ZVJlcXVlc3QoXG4gICAgICB0aGlzLnNlbmRVcmksXG4gICAgICBudWxsLFxuICAgICAgdGhpcy5hdXRoUGFyYW1zLFxuICAgICAgdGhpcy5lbmNvZGVSZXF1ZXN0KGl0ZW1zKSxcbiAgICAgIFhIUlN0YXRlc19kZWZhdWx0LlJFUV9TRU5EXG4gICAgKTtcbiAgICBzZW5kUmVxdWVzdC5vbihcImNvbXBsZXRlXCIsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgIGlmIChlcnIpXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgXCJDb21ldFRyYW5zcG9ydC5zZW5kSXRlbXMoKVwiLFxuICAgICAgICAgIFwib24gY29tcGxldGU6IGVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycilcbiAgICAgICAgKTtcbiAgICAgIHRoaXMuc2VuZFJlcXVlc3QgPSBudWxsO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUpIHtcbiAgICAgICAgICB0aGlzLm9uRGF0YShwcm90b2NvbE1lc3NhZ2VGcm9tUmF3RXJyb3IoZXJyKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kaXNjb25uZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgdGhpcy5vbkRhdGEoZGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wZW5kaW5nSXRlbXMpIHtcbiAgICAgICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMuc2VuZFJlcXVlc3QpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZEFueVBlbmRpbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNlbmRSZXF1ZXN0LmV4ZWMoKTtcbiAgfVxuICByZWN2KCkge1xuICAgIGlmICh0aGlzLnJlY3ZSZXF1ZXN0KVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByZWN2UmVxdWVzdCA9IHRoaXMucmVjdlJlcXVlc3QgPSB0aGlzLmNyZWF0ZVJlcXVlc3QoXG4gICAgICB0aGlzLnJlY3ZVcmksXG4gICAgICBudWxsLFxuICAgICAgdGhpcy5hdXRoUGFyYW1zLFxuICAgICAgbnVsbCxcbiAgICAgIHRoaXMuc3RyZWFtID8gWEhSU3RhdGVzX2RlZmF1bHQuUkVRX1JFQ1ZfU1RSRUFNIDogWEhSU3RhdGVzX2RlZmF1bHQuUkVRX1JFQ1ZfUE9MTFxuICAgICk7XG4gICAgcmVjdlJlcXVlc3Qub24oXCJkYXRhXCIsIChkYXRhKSA9PiB7XG4gICAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgICB9KTtcbiAgICByZWN2UmVxdWVzdC5vbihcImNvbXBsZXRlXCIsIChlcnIpID0+IHtcbiAgICAgIHRoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuICAgICAgdGhpcy5vbkFjdGl2aXR5KCk7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSkge1xuICAgICAgICAgIHRoaXMub25EYXRhKHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLnJlY3YoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJlY3ZSZXF1ZXN0LmV4ZWMoKTtcbiAgfVxuICBvbkRhdGEocmVzcG9uc2VEYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5kZWNvZGVSZXNwb25zZShyZXNwb25zZURhdGEpO1xuICAgICAgaWYgKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICB0aGlzLm9uUHJvdG9jb2xNZXNzYWdlKFxuICAgICAgICAgICAgZnJvbURlc2VyaWFsaXplZChcbiAgICAgICAgICAgICAgaXRlbXNbaV0sXG4gICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVhbHRpbWUuX1JlYWx0aW1lUHJlc2VuY2UsXG4gICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVhbHRpbWUuX0Fubm90YXRpb25zLFxuICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9vYmplY3RzUGx1Z2luXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiQ29tZXRUcmFuc3BvcnQub25EYXRhKClcIixcbiAgICAgICAgXCJVbmV4cGVjdGVkIGV4Y2VwdGlvbiBoYW5kaW5nIGNoYW5uZWwgZXZlbnQ6IFwiICsgZS5zdGFja1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZW5jb2RlUmVxdWVzdChyZXF1ZXN0SXRlbXMpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVxdWVzdEl0ZW1zKTtcbiAgfVxuICBkZWNvZGVSZXNwb25zZShyZXNwb25zZURhdGEpIHtcbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlRGF0YSA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2VEYXRhKTtcbiAgICByZXR1cm4gcmVzcG9uc2VEYXRhO1xuICB9XG59O1xudmFyIGNvbWV0dHJhbnNwb3J0X2RlZmF1bHQgPSBDb21ldFRyYW5zcG9ydDtcblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9saWIvaHR0cC9yZXF1ZXN0L3hocnJlcXVlc3QudHNcbmZ1bmN0aW9uIGlzQWJseUVycm9yKHJlc3BvbnNlQm9keSwgaGVhZGVycykge1xuICByZXR1cm4gYWxsVG9Mb3dlckNhc2Uoa2V5c0FycmF5KGhlYWRlcnMpKS5pbmNsdWRlcyhcIngtYWJseS1lcnJvcmNvZGVcIik7XG59XG5mdW5jdGlvbiBnZXRBYmx5RXJyb3IocmVzcG9uc2VCb2R5LCBoZWFkZXJzKSB7XG4gIGlmIChpc0FibHlFcnJvcihyZXNwb25zZUJvZHksIGhlYWRlcnMpKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlQm9keS5lcnJvciAmJiBFcnJvckluZm8uZnJvbVZhbHVlcyhyZXNwb25zZUJvZHkuZXJyb3IpO1xuICB9XG59XG52YXIgbm9vcDMgPSBmdW5jdGlvbigpIHtcbn07XG52YXIgaWRDb3VudGVyID0gMDtcbnZhciBwZW5kaW5nUmVxdWVzdHMgPSB7fTtcbmZ1bmN0aW9uIGdldEhlYWRlcih4aHIsIGhlYWRlcikge1xuICByZXR1cm4geGhyLmdldFJlc3BvbnNlSGVhZGVyICYmIHhoci5nZXRSZXNwb25zZUhlYWRlcihoZWFkZXIpO1xufVxuZnVuY3Rpb24gaXNFbmNvZGluZ0NodW5rZWQoeGhyKSB7XG4gIHJldHVybiB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIgJiYgKHhoci5nZXRSZXNwb25zZUhlYWRlcihcInRyYW5zZmVyLWVuY29kaW5nXCIpIHx8ICF4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJjb250ZW50LWxlbmd0aFwiKSk7XG59XG5mdW5jdGlvbiBnZXRIZWFkZXJzQXNPYmplY3QoeGhyKSB7XG4gIGNvbnN0IGhlYWRlclBhaXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnRyaW0oKS5zcGxpdChcIlxcclxcblwiKTtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlclBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGFydHMgPSBoZWFkZXJQYWlyc1tpXS5zcGxpdChcIjpcIikubWFwKCh4KSA9PiB4LnRyaW0oKSk7XG4gICAgaGVhZGVyc1twYXJ0c1swXS50b0xvd2VyQ2FzZSgpXSA9IHBhcnRzWzFdO1xuICB9XG4gIHJldHVybiBoZWFkZXJzO1xufVxudmFyIFhIUlJlcXVlc3QgPSBjbGFzcyBfWEhSUmVxdWVzdCBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbG9nZ2VyLCBtZXRob2QpIHtcbiAgICBzdXBlcihsb2dnZXIpO1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBwYXJhbXMucm5kID0gY2hlYXBSYW5kU3RyKCk7XG4gICAgdGhpcy51cmkgPSB1cmkgKyB0b1F1ZXJ5U3RyaW5nKHBhcmFtcyk7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycyB8fCB7fTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kID8gbWV0aG9kLnRvVXBwZXJDYXNlKCkgOiBpc05pbChib2R5KSA/IFwiR0VUXCIgOiBcIlBPU1RcIjtcbiAgICB0aGlzLnJlcXVlc3RNb2RlID0gcmVxdWVzdE1vZGU7XG4gICAgdGhpcy50aW1lb3V0cyA9IHRpbWVvdXRzO1xuICAgIHRoaXMudGltZWRPdXQgPSBmYWxzZTtcbiAgICB0aGlzLnJlcXVlc3RDb21wbGV0ZSA9IGZhbHNlO1xuICAgIHRoaXMuaWQgPSBTdHJpbmcoKytpZENvdW50ZXIpO1xuICAgIHBlbmRpbmdSZXF1ZXN0c1t0aGlzLmlkXSA9IHRoaXM7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZVJlcXVlc3QodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbG9nZ2VyLCBtZXRob2QpIHtcbiAgICBjb25zdCBfdGltZW91dHMgPSB0aW1lb3V0cyB8fCBkZWZhdWx0c19kZWZhdWx0LlRJTUVPVVRTO1xuICAgIHJldHVybiBuZXcgX1hIUlJlcXVlc3QoXG4gICAgICB1cmksXG4gICAgICBoZWFkZXJzLFxuICAgICAgY29weShwYXJhbXMpLFxuICAgICAgYm9keSxcbiAgICAgIHJlcXVlc3RNb2RlLFxuICAgICAgX3RpbWVvdXRzLFxuICAgICAgbG9nZ2VyLFxuICAgICAgbWV0aG9kXG4gICAgKTtcbiAgfVxuICBjb21wbGV0ZShlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG4gICAgaWYgKCF0aGlzLnJlcXVlc3RDb21wbGV0ZSkge1xuICAgICAgdGhpcy5yZXF1ZXN0Q29tcGxldGUgPSB0cnVlO1xuICAgICAgaWYgKCFlcnIgJiYgYm9keSkge1xuICAgICAgICB0aGlzLmVtaXQoXCJkYXRhXCIsIGJvZHkpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFwiY29tcGxldGVcIiwgZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgdGhpcy5kaXNwb3NlKCk7XG4gIH1cbiAgZXhlYygpIHtcbiAgICBsZXQgaGVhZGVycyA9IHRoaXMuaGVhZGVycztcbiAgICBjb25zdCB0aW1lb3V0ID0gdGhpcy5yZXF1ZXN0TW9kZSA9PSBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfU0VORCA/IHRoaXMudGltZW91dHMuaHR0cFJlcXVlc3RUaW1lb3V0IDogdGhpcy50aW1lb3V0cy5yZWN2VGltZW91dCwgdGltZXIgPSB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRpbWVkT3V0ID0gdHJ1ZTtcbiAgICAgIHhoci5hYm9ydCgpO1xuICAgIH0sIHRpbWVvdXQpLCBtZXRob2QgPSB0aGlzLm1ldGhvZCwgeGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKSwgYWNjZXB0ID0gaGVhZGVyc1tcImFjY2VwdFwiXTtcbiAgICBsZXQgYm9keSA9IHRoaXMuYm9keTtcbiAgICBsZXQgcmVzcG9uc2VUeXBlID0gXCJ0ZXh0XCI7XG4gICAgaWYgKCFhY2NlcHQpIHtcbiAgICAgIGhlYWRlcnNbXCJhY2NlcHRcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICB9IGVsc2UgaWYgKGFjY2VwdC5pbmRleE9mKFwiYXBwbGljYXRpb24veC1tc2dwYWNrXCIpID09PSAwKSB7XG4gICAgICByZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgfVxuICAgIGlmIChib2R5KSB7XG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gfHwgKGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICBpZiAoY29udGVudFR5cGUuaW5kZXhPZihcImFwcGxpY2F0aW9uL2pzb25cIikgPiAtMSAmJiB0eXBlb2YgYm9keSAhPSBcInN0cmluZ1wiKVxuICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgfVxuICAgIHhoci5vcGVuKG1ldGhvZCwgdGhpcy51cmksIHRydWUpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XG4gICAgaWYgKFwiYXV0aG9yaXphdGlvblwiIGluIGhlYWRlcnMpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGggaW4gaGVhZGVycylcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGgsIGhlYWRlcnNbaF0pO1xuICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IChlcnJvckV2ZW50LCBtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlMikgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBtZXNzYWdlICsgXCIgKGV2ZW50IHR5cGU6IFwiICsgZXJyb3JFdmVudC50eXBlICsgXCIpXCI7XG4gICAgICBpZiAoKF9hMiA9IHRoaXMgPT0gbnVsbCA/IHZvaWQgMCA6IHRoaXMueGhyKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnN0YXR1c1RleHQpXG4gICAgICAgIGVycm9yTWVzc2FnZSArPSBcIiwgY3VycmVudCBzdGF0dXNUZXh0IGlzIFwiICsgdGhpcy54aHIuc3RhdHVzVGV4dDtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIlJlcXVlc3Qub25cIiArIGVycm9yRXZlbnQudHlwZSArIFwiKClcIiwgZXJyb3JNZXNzYWdlKTtcbiAgICAgIHRoaXMuY29tcGxldGUobmV3IFBhcnRpYWxFcnJvckluZm8oZXJyb3JNZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlMikpO1xuICAgIH07XG4gICAgeGhyLm9uZXJyb3IgPSAoZXJyb3JFdmVudCkgPT4ge1xuICAgICAgZXJyb3JIYW5kbGVyKGVycm9yRXZlbnQsIFwiWEhSIGVycm9yIG9jY3VycmVkXCIsIG51bGwsIDQwMCk7XG4gICAgfTtcbiAgICB4aHIub25hYm9ydCA9IChlcnJvckV2ZW50KSA9PiB7XG4gICAgICBpZiAodGhpcy50aW1lZE91dCkge1xuICAgICAgICBlcnJvckhhbmRsZXIoZXJyb3JFdmVudCwgXCJSZXF1ZXN0IGFib3J0ZWQgZHVlIHRvIHJlcXVlc3QgdGltZW91dCBleHBpcmluZ1wiLCBudWxsLCA0MDgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JIYW5kbGVyKGVycm9yRXZlbnQsIFwiUmVxdWVzdCBjYW5jZWxsZWRcIiwgbnVsbCwgNDAwKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHhoci5vbnRpbWVvdXQgPSAoZXJyb3JFdmVudCkgPT4ge1xuICAgICAgZXJyb3JIYW5kbGVyKGVycm9yRXZlbnQsIFwiUmVxdWVzdCB0aW1lZCBvdXRcIiwgbnVsbCwgNDA4KTtcbiAgICB9O1xuICAgIGxldCBzdHJlYW1pbmc7XG4gICAgbGV0IHN0YXR1c0NvZGU7XG4gICAgbGV0IHN1Y2Nlc3NSZXNwb25zZTtcbiAgICBsZXQgc3RyZWFtUG9zID0gMDtcbiAgICBsZXQgdW5wYWNrZWQgPSBmYWxzZTtcbiAgICBjb25zdCBvblJlc3BvbnNlID0gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHN1Y2Nlc3NSZXNwb25zZSA9IHN0YXR1c0NvZGUgPCA0MDA7XG4gICAgICBpZiAoc3RhdHVzQ29kZSA9PSAyMDQpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZShudWxsLCBudWxsLCBudWxsLCBudWxsLCBzdGF0dXNDb2RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3RyZWFtaW5nID0gdGhpcy5yZXF1ZXN0TW9kZSA9PSBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfUkVDVl9TVFJFQU0gJiYgc3VjY2Vzc1Jlc3BvbnNlICYmIGlzRW5jb2RpbmdDaHVua2VkKHhocik7XG4gICAgfTtcbiAgICBjb25zdCBvbkVuZCA9ICgpID0+IHtcbiAgICAgIGxldCBwYXJzZWRSZXNwb25zZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gZ2V0SGVhZGVyKHhociwgXCJjb250ZW50LXR5cGVcIik7XG4gICAgICAgIGNvbnN0IGpzb24gPSBjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qc29uXCIpID49IDAgOiB4aHIucmVzcG9uc2VUeXBlID09IFwidGV4dFwiO1xuICAgICAgICBpZiAoanNvbikge1xuICAgICAgICAgIGNvbnN0IGpzb25SZXNwb25zZUJvZHkgPSB4aHIucmVzcG9uc2VUeXBlID09PSBcImFycmF5YnVmZmVyXCIgPyBQbGF0Zm9ybS5CdWZmZXJVdGlscy51dGY4RGVjb2RlKHhoci5yZXNwb25zZSkgOiBTdHJpbmcoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgaWYgKGpzb25SZXNwb25zZUJvZHkubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXJzZWRSZXNwb25zZSA9IEpTT04ucGFyc2UoanNvblJlc3BvbnNlQm9keSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZFJlc3BvbnNlID0ganNvblJlc3BvbnNlQm9keTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdW5wYWNrZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnNlZFJlc3BvbnNlID0geGhyLnJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWRSZXNwb25zZS5yZXNwb25zZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgc3RhdHVzQ29kZSA9IHBhcnNlZFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgICAgc3VjY2Vzc1Jlc3BvbnNlID0gc3RhdHVzQ29kZSA8IDQwMDtcbiAgICAgICAgICBoZWFkZXJzID0gcGFyc2VkUmVzcG9uc2UuaGVhZGVycztcbiAgICAgICAgICBwYXJzZWRSZXNwb25zZSA9IHBhcnNlZFJlc3BvbnNlLnJlc3BvbnNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhlYWRlcnMgPSBnZXRIZWFkZXJzQXNPYmplY3QoeGhyKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKG5ldyBQYXJ0aWFsRXJyb3JJbmZvKFwiTWFsZm9ybWVkIHJlc3BvbnNlIGJvZHkgZnJvbSBzZXJ2ZXI6IFwiICsgZS5tZXNzYWdlLCBudWxsLCA0MDApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHN1Y2Nlc3NSZXNwb25zZSB8fCBBcnJheS5pc0FycmF5KHBhcnNlZFJlc3BvbnNlKSkge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKG51bGwsIHBhcnNlZFJlc3BvbnNlLCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBlcnIgPSBnZXRBYmx5RXJyb3IocGFyc2VkUmVzcG9uc2UsIGhlYWRlcnMpO1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgZXJyID0gbmV3IFBhcnRpYWxFcnJvckluZm8oXG4gICAgICAgICAgXCJFcnJvciByZXNwb25zZSByZWNlaXZlZCBmcm9tIHNlcnZlcjogXCIgKyBzdGF0dXNDb2RlICsgXCIgYm9keSB3YXM6IFwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QocGFyc2VkUmVzcG9uc2UpLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgc3RhdHVzQ29kZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5jb21wbGV0ZShlcnIsIHBhcnNlZFJlc3BvbnNlLCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBvblByb2dyZXNzKCkge1xuICAgICAgY29uc3QgcmVzcG9uc2VUZXh0ID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgIGNvbnN0IGJvZHlFbmQgPSByZXNwb25zZVRleHQubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBpZHgsIGNodW5rO1xuICAgICAgd2hpbGUgKHN0cmVhbVBvcyA8IGJvZHlFbmQgJiYgKGlkeCA9IHJlc3BvbnNlVGV4dC5pbmRleE9mKFwiXFxuXCIsIHN0cmVhbVBvcykpID4gLTEpIHtcbiAgICAgICAgY2h1bmsgPSByZXNwb25zZVRleHQuc2xpY2Uoc3RyZWFtUG9zLCBpZHgpO1xuICAgICAgICBzdHJlYW1Qb3MgPSBpZHggKyAxO1xuICAgICAgICBvbkNodW5rKGNodW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb25DaHVuayA9IChjaHVuaykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2h1bmsgPSBKU09OLnBhcnNlKGNodW5rKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZShuZXcgUGFydGlhbEVycm9ySW5mbyhcIk1hbGZvcm1lZCByZXNwb25zZSBib2R5IGZyb20gc2VydmVyOiBcIiArIGUubWVzc2FnZSwgbnVsbCwgNDAwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgY2h1bmspO1xuICAgIH07XG4gICAgY29uc3Qgb25TdHJlYW1FbmQgPSAoKSA9PiB7XG4gICAgICBvblByb2dyZXNzKCk7XG4gICAgICB0aGlzLnN0cmVhbUNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHJlYWR5U3RhdGUgPSB4aHIucmVhZHlTdGF0ZTtcbiAgICAgIGlmIChyZWFkeVN0YXRlIDwgMylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHhoci5zdGF0dXMgIT09IDApIHtcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHN0YXR1c0NvZGUgPSB4aHIuc3RhdHVzO1xuICAgICAgICAgIG9uUmVzcG9uc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVhZHlTdGF0ZSA9PSAzICYmIHN0cmVhbWluZykge1xuICAgICAgICAgIG9uUHJvZ3Jlc3MoKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICBpZiAoc3RyZWFtaW5nKVxuICAgICAgICAgICAgb25TdHJlYW1FbmQoKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBvbkVuZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB4aHIuc2VuZChib2R5KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGNvbnN0IHhociA9IHRoaXMueGhyO1xuICAgIGlmICh4aHIpIHtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9IG5vb3AzO1xuICAgICAgdGhpcy54aHIgPSBudWxsO1xuICAgICAgY29uc3QgdGltZXIgPSB0aGlzLnRpbWVyO1xuICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnJlcXVlc3RDb21wbGV0ZSlcbiAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgfVxuICAgIGRlbGV0ZSBwZW5kaW5nUmVxdWVzdHNbdGhpcy5pZF07XG4gIH1cbn07XG52YXIgeGhycmVxdWVzdF9kZWZhdWx0ID0gWEhSUmVxdWVzdDtcblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9saWIvdHJhbnNwb3J0L3hocnBvbGxpbmd0cmFuc3BvcnQudHNcbnZhciBzaG9ydE5hbWUyID0gVHJhbnNwb3J0TmFtZXMuWGhyUG9sbGluZztcbnZhciBYSFJQb2xsaW5nVHJhbnNwb3J0ID0gY2xhc3MgZXh0ZW5kcyBjb21ldHRyYW5zcG9ydF9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykge1xuICAgIHN1cGVyKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuICAgIHRoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lMjtcbiAgICBwYXJhbXMuc3RyZWFtID0gZmFsc2U7XG4gICAgdGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWUyO1xuICB9XG4gIHN0YXRpYyBpc0F2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gISEoUGxhdGZvcm0uQ29uZmlnLnhoclN1cHBvcnRlZCAmJiBQbGF0Zm9ybS5Db25maWcuYWxsb3dDb21ldCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiWEhSUG9sbGluZ1RyYW5zcG9ydDsgdXJpPVwiICsgdGhpcy5iYXNlVXJpICsgXCI7IGlzQ29ubmVjdGVkPVwiICsgdGhpcy5pc0Nvbm5lY3RlZDtcbiAgfVxuICBjcmVhdGVSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSkge1xuICAgIHJldHVybiB4aHJyZXF1ZXN0X2RlZmF1bHQuY3JlYXRlUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRoaXMudGltZW91dHMsIHRoaXMubG9nZ2VyKTtcbiAgfVxufTtcbnZhciB4aHJwb2xsaW5ndHJhbnNwb3J0X2RlZmF1bHQgPSBYSFJQb2xsaW5nVHJhbnNwb3J0O1xuXG4vLyBzcmMvcGxhdGZvcm0vd2ViL2xpYi90cmFuc3BvcnQvaW5kZXgudHNcbnZhciBvcmRlciA9IFtcInhocl9wb2xsaW5nXCJdO1xudmFyIGRlZmF1bHRUcmFuc3BvcnRzID0ge1xuICBvcmRlcixcbiAgYnVuZGxlZEltcGxlbWVudGF0aW9uczoge1xuICAgIHdlYl9zb2NrZXQ6IHdlYnNvY2tldHRyYW5zcG9ydF9kZWZhdWx0LFxuICAgIHhocl9wb2xsaW5nOiB4aHJwb2xsaW5ndHJhbnNwb3J0X2RlZmF1bHRcbiAgfVxufTtcbnZhciB0cmFuc3BvcnRfZGVmYXVsdDIgPSBkZWZhdWx0VHJhbnNwb3J0cztcblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9saWIvdXRpbC9kZWZhdWx0cy50c1xudmFyIERlZmF1bHRzMiA9IHtcbiAgY29ubmVjdGl2aXR5Q2hlY2tVcmw6IFwiaHR0cHM6Ly9pbnRlcm5ldC11cC5hYmx5LXJlYWx0aW1lLmNvbS9pcy10aGUtaW50ZXJuZXQtdXAudHh0XCIsXG4gIHdzQ29ubmVjdGl2aXR5Q2hlY2tVcmw6IFwid3NzOi8vd3MtdXAuYWJseS1yZWFsdGltZS5jb21cIixcbiAgLyogT3JkZXIgbWF0dGVycyBoZXJlOiB0aGUgYmFzZSB0cmFuc3BvcnQgaXMgdGhlIGxlZnRtb3N0IG9uZSBpbiB0aGVcbiAgICogaW50ZXJzZWN0aW9uIG9mIGJhc2VUcmFuc3BvcnRPcmRlciBhbmQgdGhlIHRyYW5zcG9ydHMgY2xpZW50T3B0aW9uIHRoYXQnc1xuICAgKiBzdXBwb3J0ZWQuICovXG4gIGRlZmF1bHRUcmFuc3BvcnRzOiBbVHJhbnNwb3J0TmFtZXMuWGhyUG9sbGluZywgVHJhbnNwb3J0TmFtZXMuV2ViU29ja2V0XVxufTtcbnZhciBkZWZhdWx0c19kZWZhdWx0MiA9IERlZmF1bHRzMjtcblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9saWIvdXRpbC9tc2dwYWNrLnRzXG5mdW5jdGlvbiBpbnNwZWN0KGJ1ZmZlcikge1xuICBpZiAoYnVmZmVyID09PSB2b2lkIDApXG4gICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gIGxldCB2aWV3O1xuICBsZXQgdHlwZTtcbiAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgdHlwZSA9IFwiQXJyYXlCdWZmZXJcIjtcbiAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gIH0gZWxzZSBpZiAoYnVmZmVyIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICB0eXBlID0gXCJEYXRhVmlld1wiO1xuICAgIHZpZXcgPSBidWZmZXI7XG4gIH1cbiAgaWYgKCF2aWV3KVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShidWZmZXIpO1xuICBjb25zdCBieXRlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSA+IDIwKSB7XG4gICAgICBieXRlcy5wdXNoKFwiLi4uXCIpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCBieXRlXyA9IHZpZXcuZ2V0VWludDgoaSkudG9TdHJpbmcoMTYpO1xuICAgIGlmIChieXRlXy5sZW5ndGggPT09IDEpXG4gICAgICBieXRlXyA9IFwiMFwiICsgYnl0ZV87XG4gICAgYnl0ZXMucHVzaChieXRlXyk7XG4gIH1cbiAgcmV0dXJuIFwiPFwiICsgdHlwZSArIFwiIFwiICsgYnl0ZXMuam9pbihcIiBcIikgKyBcIj5cIjtcbn1cbmZ1bmN0aW9uIHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQsIHN0cmluZykge1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZVBvaW50IDwgMTI4KSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDAgJiAxMjcgfCAwKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY29kZVBvaW50IDwgMjA0OCkge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiA2ICYgMzEgfCAxOTIpO1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiAwICYgNjMgfCAxMjgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjb2RlUG9pbnQgPCA2NTUzNikge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiAxMiAmIDE1IHwgMjI0KTtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gNiAmIDYzIHwgMTI4KTtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gMCAmIDYzIHwgMTI4KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY29kZVBvaW50IDwgMTExNDExMikge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiAxOCAmIDcgfCAyNDApO1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiAxMiAmIDYzIHwgMTI4KTtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gNiAmIDYzIHwgMTI4KTtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gMCAmIDYzIHwgMTI4KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgY29kZXBvaW50IFwiICsgY29kZVBvaW50KTtcbiAgfVxufVxuZnVuY3Rpb24gdXRmOFJlYWQodmlldywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgbGV0IHN0cmluZyA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSBvZmZzZXQsIGVuZCA9IG9mZnNldCArIGxlbmd0aDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgY29uc3QgYnl0ZV8gPSB2aWV3LmdldFVpbnQ4KGkpO1xuICAgIGlmICgoYnl0ZV8gJiAxMjgpID09PSAwKSB7XG4gICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlXyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKChieXRlXyAmIDIyNCkgPT09IDE5Mikge1xuICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGJ5dGVfICYgMTUpIDw8IDYgfCB2aWV3LmdldFVpbnQ4KCsraSkgJiA2Myk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKChieXRlXyAmIDI0MCkgPT09IDIyNCkge1xuICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIChieXRlXyAmIDE1KSA8PCAxMiB8ICh2aWV3LmdldFVpbnQ4KCsraSkgJiA2MykgPDwgNiB8ICh2aWV3LmdldFVpbnQ4KCsraSkgJiA2MykgPDwgMFxuICAgICAgKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoKGJ5dGVfICYgMjQ4KSA9PT0gMjQwKSB7XG4gICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgKGJ5dGVfICYgNykgPDwgMTggfCAodmlldy5nZXRVaW50OCgrK2kpICYgNjMpIDw8IDEyIHwgKHZpZXcuZ2V0VWludDgoKytpKSAmIDYzKSA8PCA2IHwgKHZpZXcuZ2V0VWludDgoKytpKSAmIDYzKSA8PCAwXG4gICAgICApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnl0ZSBcIiArIGJ5dGVfLnRvU3RyaW5nKDE2KSk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZztcbn1cbmZ1bmN0aW9uIHV0ZjhCeXRlQ291bnQoc3RyaW5nKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gc3RyaW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlUG9pbnQgPCAxMjgpIHtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNvZGVQb2ludCA8IDIwNDgpIHtcbiAgICAgIGNvdW50ICs9IDI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNvZGVQb2ludCA8IDY1NTM2KSB7XG4gICAgICBjb3VudCArPSAzO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjb2RlUG9pbnQgPCAxMTE0MTEyKSB7XG4gICAgICBjb3VudCArPSA0O1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBjb2RlcG9pbnQgXCIgKyBjb2RlUG9pbnQpO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn1cbmZ1bmN0aW9uIGVuY29kZTIodmFsdWUsIHNwYXJzZSkge1xuICBjb25zdCBzaXplID0gc2l6ZW9mKHZhbHVlLCBzcGFyc2UpO1xuICBpZiAoc2l6ZSA9PT0gMClcbiAgICByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoc2l6ZSk7XG4gIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgX2VuY29kZSh2YWx1ZSwgdmlldywgMCwgc3BhcnNlKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbnZhciBTSF9MXzMyID0gKDEgPDwgMTYpICogKDEgPDwgMTYpO1xudmFyIFNIX1JfMzIgPSAxIC8gU0hfTF8zMjtcbmZ1bmN0aW9uIGdldEludDY0KHZpZXcsIG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgcmV0dXJuIHZpZXcuZ2V0SW50MzIob2Zmc2V0KSAqIFNIX0xfMzIgKyB2aWV3LmdldFVpbnQzMihvZmZzZXQgKyA0KTtcbn1cbmZ1bmN0aW9uIGdldFVpbnQ2NCh2aWV3LCBvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHJldHVybiB2aWV3LmdldFVpbnQzMihvZmZzZXQpICogU0hfTF8zMiArIHZpZXcuZ2V0VWludDMyKG9mZnNldCArIDQpO1xufVxuZnVuY3Rpb24gc2V0SW50NjQodmlldywgb2Zmc2V0LCB2YWwpIHtcbiAgaWYgKHZhbCA8IDkyMjMzNzIwMzY4NTQ3NzZlMykge1xuICAgIHZpZXcuc2V0SW50MzIob2Zmc2V0LCBNYXRoLmZsb29yKHZhbCAqIFNIX1JfMzIpKTtcbiAgICB2aWV3LnNldEludDMyKG9mZnNldCArIDQsIHZhbCAmIC0xKTtcbiAgfSBlbHNlIHtcbiAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIDIxNDc0ODM2NDcpO1xuICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCArIDQsIDIxNDc0ODM2NDcpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRVaW50NjQodmlldywgb2Zmc2V0LCB2YWwpIHtcbiAgaWYgKHZhbCA8IDE4NDQ2NzQ0MDczNzA5NTUyZTMpIHtcbiAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIE1hdGguZmxvb3IodmFsICogU0hfUl8zMikpO1xuICAgIHZpZXcuc2V0SW50MzIob2Zmc2V0ICsgNCwgdmFsICYgLTEpO1xuICB9IGVsc2Uge1xuICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgNDI5NDk2NzI5NSk7XG4gICAgdmlldy5zZXRVaW50MzIob2Zmc2V0ICsgNCwgNDI5NDk2NzI5NSk7XG4gIH1cbn1cbnZhciBEZWNvZGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih2aWV3LCBvZmZzZXQpIHtcbiAgICB0aGlzLm1hcCA9IChsZW5ndGgpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0ge307XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMucGFyc2UoKTtcbiAgICAgICAgdmFsdWVba2V5XSA9IHRoaXMucGFyc2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIHRoaXMuYmluID0gKGxlbmd0aCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBuZXcgQXJyYXlCdWZmZXIobGVuZ3RoKTtcbiAgICAgIG5ldyBVaW50OEFycmF5KHZhbHVlKS5zZXQobmV3IFVpbnQ4QXJyYXkodGhpcy52aWV3LmJ1ZmZlciwgdGhpcy5vZmZzZXQsIGxlbmd0aCksIDApO1xuICAgICAgdGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgdGhpcy5idWYgPSB0aGlzLmJpbjtcbiAgICB0aGlzLnN0ciA9IChsZW5ndGgpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdXRmOFJlYWQodGhpcy52aWV3LCB0aGlzLm9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIHRoaXMuYXJyYXkgPSAobGVuZ3RoKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZVtpXSA9IHRoaXMucGFyc2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIHRoaXMuZXh0ID0gKGxlbmd0aCkgPT4ge1xuICAgICAgdGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdGhpcy52aWV3LmdldEludDgodGhpcy5vZmZzZXQpLFxuICAgICAgICBkYXRhOiB0aGlzLmJ1ZihsZW5ndGgpXG4gICAgICB9O1xuICAgIH07XG4gICAgdGhpcy5wYXJzZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5vZmZzZXQpO1xuICAgICAgbGV0IHZhbHVlLCBsZW5ndGg7XG4gICAgICBpZiAoKHR5cGUgJiAxMjgpID09PSAwKSB7XG4gICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgICAgaWYgKCh0eXBlICYgMjQwKSA9PT0gMTI4KSB7XG4gICAgICAgIGxlbmd0aCA9IHR5cGUgJiAxNTtcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAoKHR5cGUgJiAyNDApID09PSAxNDQpIHtcbiAgICAgICAgbGVuZ3RoID0gdHlwZSAmIDE1O1xuICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheShsZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKCh0eXBlICYgMjI0KSA9PT0gMTYwKSB7XG4gICAgICAgIGxlbmd0aCA9IHR5cGUgJiAzMTtcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyKGxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAoKHR5cGUgJiAyMjQpID09PSAyMjQpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0SW50OCh0aGlzLm9mZnNldCk7XG4gICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIDE5MjpcbiAgICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDE5MzpcbiAgICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIGNhc2UgMTk0OlxuICAgICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYXNlIDE5NTpcbiAgICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlIDE5NjpcbiAgICAgICAgICBsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICAgIHJldHVybiB0aGlzLmJpbihsZW5ndGgpO1xuICAgICAgICBjYXNlIDE5NzpcbiAgICAgICAgICBsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDE2KHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICByZXR1cm4gdGhpcy5iaW4obGVuZ3RoKTtcbiAgICAgICAgY2FzZSAxOTg6XG4gICAgICAgICAgbGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmluKGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMTk5OlxuICAgICAgICAgIGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjAwOlxuICAgICAgICAgIGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgIHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xuICAgICAgICBjYXNlIDIwMTpcbiAgICAgICAgICBsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5leHQobGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyMDI6XG4gICAgICAgICAgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0RmxvYXQzMih0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIwMzpcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMudmlldy5nZXRGbG9hdDY0KHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gOTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjA0OlxuICAgICAgICAgIHZhbHVlID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjA1OlxuICAgICAgICAgIHZhbHVlID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIwNjpcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSAyMDc6XG4gICAgICAgICAgdmFsdWUgPSBnZXRVaW50NjQodGhpcy52aWV3LCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIwODpcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMudmlldy5nZXRJbnQ4KHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjA5OlxuICAgICAgICAgIHZhbHVlID0gdGhpcy52aWV3LmdldEludDE2KHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjEwOlxuICAgICAgICAgIHZhbHVlID0gdGhpcy52aWV3LmdldEludDMyKHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjExOlxuICAgICAgICAgIHZhbHVlID0gZ2V0SW50NjQodGhpcy52aWV3LCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIxMjpcbiAgICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjEzOlxuICAgICAgICAgIGxlbmd0aCA9IDI7XG4gICAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICByZXR1cm4gdGhpcy5leHQobGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyMTQ6XG4gICAgICAgICAgbGVuZ3RoID0gNDtcbiAgICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICAgIHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xuICAgICAgICBjYXNlIDIxNTpcbiAgICAgICAgICBsZW5ndGggPSA4O1xuICAgICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjE2OlxuICAgICAgICAgIGxlbmd0aCA9IDE2O1xuICAgICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjE3OlxuICAgICAgICAgIGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3RyKGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjE4OlxuICAgICAgICAgIGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0cihsZW5ndGgpO1xuICAgICAgICBjYXNlIDIxOTpcbiAgICAgICAgICBsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdHIobGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyMjA6XG4gICAgICAgICAgbGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkobGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyMjE6XG4gICAgICAgICAgbGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkobGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyMjI6XG4gICAgICAgICAgbGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWFwKGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjIzOlxuICAgICAgICAgIGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgIHJldHVybiB0aGlzLm1hcChsZW5ndGgpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlIDB4XCIgKyB0eXBlLnRvU3RyaW5nKDE2KSk7XG4gICAgfTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgIHRoaXMudmlldyA9IHZpZXc7XG4gIH1cbn07XG5mdW5jdGlvbiBkZWNvZGUyKGJ1ZmZlcikge1xuICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgRGVjb2Rlcih2aWV3KTtcbiAgY29uc3QgdmFsdWUgPSBkZWNvZGVyLnBhcnNlKCk7XG4gIGlmIChkZWNvZGVyLm9mZnNldCAhPT0gYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKGJ1ZmZlci5ieXRlTGVuZ3RoIC0gZGVjb2Rlci5vZmZzZXQgKyBcIiB0cmFpbGluZyBieXRlc1wiKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZW5jb2RlYWJsZUtleXModmFsdWUsIHNwYXJzZSkge1xuICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcihmdW5jdGlvbihlKSB7XG4gICAgY29uc3QgdmFsID0gdmFsdWVbZV0sIHR5cGUgPSB0eXBlb2YgdmFsO1xuICAgIHJldHVybiAoIXNwYXJzZSB8fCB2YWwgIT09IHZvaWQgMCAmJiB2YWwgIT09IG51bGwpICYmIChcImZ1bmN0aW9uXCIgIT09IHR5cGUgfHwgISF2YWwudG9KU09OKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBfZW5jb2RlKHZhbHVlLCB2aWV3LCBvZmZzZXQsIHNwYXJzZSkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdXRmOEJ5dGVDb3VudCh2YWx1ZSk7XG4gICAgaWYgKGxlbmd0aCA8IDMyKSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgbGVuZ3RoIHwgMTYwKTtcbiAgICAgIHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQgKyAxLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gMSArIGxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8IDI1Nikge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDIxNyk7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIDEsIGxlbmd0aCk7XG4gICAgICB1dGY4V3JpdGUodmlldywgb2Zmc2V0ICsgMiwgdmFsdWUpO1xuICAgICAgcmV0dXJuIDIgKyBsZW5ndGg7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPCA2NTUzNikge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDIxOCk7XG4gICAgICB2aWV3LnNldFVpbnQxNihvZmZzZXQgKyAxLCBsZW5ndGgpO1xuICAgICAgdXRmOFdyaXRlKHZpZXcsIG9mZnNldCArIDMsIHZhbHVlKTtcbiAgICAgIHJldHVybiAzICsgbGVuZ3RoO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoIDwgNDI5NDk2NzI5Nikge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDIxOSk7XG4gICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQgKyAxLCBsZW5ndGgpO1xuICAgICAgdXRmOFdyaXRlKHZpZXcsIG9mZnNldCArIDUsIHZhbHVlKTtcbiAgICAgIHJldHVybiA1ICsgbGVuZ3RoO1xuICAgIH1cbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3ICYmIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLmJ1ZmZlcjtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA8IDI1Nikge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDE5Nik7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIDEsIGxlbmd0aCk7XG4gICAgICBuZXcgVWludDhBcnJheSh2aWV3LmJ1ZmZlcikuc2V0KG5ldyBVaW50OEFycmF5KHZhbHVlKSwgb2Zmc2V0ICsgMik7XG4gICAgICByZXR1cm4gMiArIGxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8IDY1NTM2KSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMTk3KTtcbiAgICAgIHZpZXcuc2V0VWludDE2KG9mZnNldCArIDEsIGxlbmd0aCk7XG4gICAgICBuZXcgVWludDhBcnJheSh2aWV3LmJ1ZmZlcikuc2V0KG5ldyBVaW50OEFycmF5KHZhbHVlKSwgb2Zmc2V0ICsgMyk7XG4gICAgICByZXR1cm4gMyArIGxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8IDQyOTQ5NjcyOTYpIHtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAxOTgpO1xuICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0ICsgMSwgbGVuZ3RoKTtcbiAgICAgIG5ldyBVaW50OEFycmF5KHZpZXcuYnVmZmVyKS5zZXQobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCBvZmZzZXQgKyA1KTtcbiAgICAgIHJldHVybiA1ICsgbGVuZ3RoO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDIwMyk7XG4gICAgICB2aWV3LnNldEZsb2F0NjQob2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIDk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgICBpZiAodmFsdWUgPCAxMjgpIHtcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPCAyNTYpIHtcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDIwNCk7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA8IDY1NTM2KSB7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAyMDUpO1xuICAgICAgICB2aWV3LnNldFVpbnQxNihvZmZzZXQgKyAxLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiAzO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlIDwgNDI5NDk2NzI5Nikge1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMjA2KTtcbiAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gNTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA8IDE4NDQ2NzQ0MDczNzA5NTUyZTMpIHtcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDIwNyk7XG4gICAgICAgIHNldFVpbnQ2NCh2aWV3LCBvZmZzZXQgKyAxLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiA5O1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBiaWcgMHhcIiArIHZhbHVlLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+PSAtMzIpIHtcbiAgICAgIHZpZXcuc2V0SW50OChvZmZzZXQsIHZhbHVlKTtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPj0gLTEyOCkge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDIwOCk7XG4gICAgICB2aWV3LnNldEludDgob2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+PSAtMzI3NjgpIHtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAyMDkpO1xuICAgICAgdmlldy5zZXRJbnQxNihvZmZzZXQgKyAxLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gMztcbiAgICB9XG4gICAgaWYgKHZhbHVlID49IC0yMTQ3NDgzNjQ4KSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMjEwKTtcbiAgICAgIHZpZXcuc2V0SW50MzIob2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIDU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+PSAtOTIyMzM3MjAzNjg1NDc3NmUzKSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMjExKTtcbiAgICAgIHNldEludDY0KHZpZXcsIG9mZnNldCArIDEsIHZhbHVlKTtcbiAgICAgIHJldHVybiA5O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgdG9vIHNtYWxsIC0weFwiICsgKC12YWx1ZSkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAoc3BhcnNlKVxuICAgICAgcmV0dXJuIDA7XG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDIxMik7XG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQgKyAxLCAwKTtcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIDIsIDApO1xuICAgIHJldHVybiAzO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIGlmIChzcGFyc2UpXG4gICAgICByZXR1cm4gMDtcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMTkyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgdmFsdWUgPyAxOTUgOiAxOTQpO1xuICAgIHJldHVybiAxO1xuICB9XG4gIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZS50b0pTT04pXG4gICAgcmV0dXJuIF9lbmNvZGUodmFsdWUudG9KU09OKCksIHZpZXcsIG9mZnNldCwgc3BhcnNlKTtcbiAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICBsZXQgbGVuZ3RoLCBzaXplID0gMDtcbiAgICBsZXQga2V5cztcbiAgICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IGVuY29kZWFibGVLZXlzKHZhbHVlLCBzcGFyc2UpO1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPCAxNikge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIGxlbmd0aCB8IChpc0FycmF5ID8gMTQ0IDogMTI4KSk7XG4gICAgICBzaXplID0gMTtcbiAgICB9IGVsc2UgaWYgKGxlbmd0aCA8IDY1NTM2KSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgaXNBcnJheSA/IDIyMCA6IDIyMik7XG4gICAgICB2aWV3LnNldFVpbnQxNihvZmZzZXQgKyAxLCBsZW5ndGgpO1xuICAgICAgc2l6ZSA9IDM7XG4gICAgfSBlbHNlIGlmIChsZW5ndGggPCA0Mjk0OTY3Mjk2KSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgaXNBcnJheSA/IDIyMSA6IDIyMyk7XG4gICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQgKyAxLCBsZW5ndGgpO1xuICAgICAgc2l6ZSA9IDU7XG4gICAgfVxuICAgIGlmIChpc0FycmF5KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNpemUgKz0gX2VuY29kZSh2YWx1ZVtpXSwgdmlldywgb2Zmc2V0ICsgc2l6ZSwgc3BhcnNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgc2l6ZSArPSBfZW5jb2RlKGtleSwgdmlldywgb2Zmc2V0ICsgc2l6ZSk7XG4gICAgICAgIHNpemUgKz0gX2VuY29kZSh2YWx1ZVtrZXldLCB2aWV3LCBvZmZzZXQgKyBzaXplLCBzcGFyc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiAwO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGUgXCIgKyB0eXBlKTtcbn1cbmZ1bmN0aW9uIHNpemVvZih2YWx1ZSwgc3BhcnNlKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdXRmOEJ5dGVDb3VudCh2YWx1ZSk7XG4gICAgaWYgKGxlbmd0aCA8IDMyKSB7XG4gICAgICByZXR1cm4gMSArIGxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8IDI1Nikge1xuICAgICAgcmV0dXJuIDIgKyBsZW5ndGg7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPCA2NTUzNikge1xuICAgICAgcmV0dXJuIDMgKyBsZW5ndGg7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPCA0Mjk0OTY3Mjk2KSB7XG4gICAgICByZXR1cm4gNSArIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5idWZmZXI7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPCAyNTYpIHtcbiAgICAgIHJldHVybiAyICsgbGVuZ3RoO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoIDwgNjU1MzYpIHtcbiAgICAgIHJldHVybiAzICsgbGVuZ3RoO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoIDwgNDI5NDk2NzI5Nikge1xuICAgICAgcmV0dXJuIDUgKyBsZW5ndGg7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKVxuICAgICAgcmV0dXJuIDk7XG4gICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgIGlmICh2YWx1ZSA8IDEyOClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBpZiAodmFsdWUgPCAyNTYpXG4gICAgICAgIHJldHVybiAyO1xuICAgICAgaWYgKHZhbHVlIDwgNjU1MzYpXG4gICAgICAgIHJldHVybiAzO1xuICAgICAgaWYgKHZhbHVlIDwgNDI5NDk2NzI5NilcbiAgICAgICAgcmV0dXJuIDU7XG4gICAgICBpZiAodmFsdWUgPCAxODQ0Njc0NDA3MzcwOTU1MmUzKVxuICAgICAgICByZXR1cm4gOTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciB0b28gYmlnIDB4XCIgKyB2YWx1ZS50b1N0cmluZygxNikpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPj0gLTMyKVxuICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKHZhbHVlID49IC0xMjgpXG4gICAgICByZXR1cm4gMjtcbiAgICBpZiAodmFsdWUgPj0gLTMyNzY4KVxuICAgICAgcmV0dXJuIDM7XG4gICAgaWYgKHZhbHVlID49IC0yMTQ3NDgzNjQ4KVxuICAgICAgcmV0dXJuIDU7XG4gICAgaWYgKHZhbHVlID49IC05MjIzMzcyMDM2ODU0Nzc2ZTMpXG4gICAgICByZXR1cm4gOTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgdG9vIHNtYWxsIC0weFwiICsgdmFsdWUudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwiYm9vbGVhblwiKVxuICAgIHJldHVybiAxO1xuICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgcmV0dXJuIHNwYXJzZSA/IDAgOiAxO1xuICBpZiAodmFsdWUgPT09IHZvaWQgMClcbiAgICByZXR1cm4gc3BhcnNlID8gMCA6IDM7XG4gIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZS50b0pTT04pXG4gICAgcmV0dXJuIHNpemVvZih2YWx1ZS50b0pTT04oKSwgc3BhcnNlKTtcbiAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICBsZXQgbGVuZ3RoLCBzaXplID0gMDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2l6ZSArPSBzaXplb2YodmFsdWVbaV0sIHNwYXJzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleXMgPSBlbmNvZGVhYmxlS2V5cyh2YWx1ZSwgc3BhcnNlKTtcbiAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBzaXplICs9IHNpemVvZihrZXkpICsgc2l6ZW9mKHZhbHVlW2tleV0sIHNwYXJzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsZW5ndGggPCAxNikge1xuICAgICAgcmV0dXJuIDEgKyBzaXplO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoIDwgNjU1MzYpIHtcbiAgICAgIHJldHVybiAzICsgc2l6ZTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8IDQyOTQ5NjcyOTYpIHtcbiAgICAgIHJldHVybiA1ICsgc2l6ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXkgb3Igb2JqZWN0IHRvbyBsb25nIDB4XCIgKyBsZW5ndGgudG9TdHJpbmcoMTYpKTtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiAwO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGUgXCIgKyB0eXBlKTtcbn1cbnZhciBtc2dwYWNrX2RlZmF1bHQgPSB7XG4gIGVuY29kZTogZW5jb2RlMixcbiAgZGVjb2RlOiBkZWNvZGUyLFxuICBpbnNwZWN0LFxuICB1dGY4V3JpdGUsXG4gIHV0ZjhSZWFkLFxuICB1dGY4Qnl0ZUNvdW50XG59O1xuXG4vLyBzcmMvcGxhdGZvcm0vd2ViL2xpYi9odHRwL3JlcXVlc3QvZmV0Y2hyZXF1ZXN0LnRzXG5mdW5jdGlvbiBpc0FibHlFcnJvcjIocmVzcG9uc2VCb2R5LCBoZWFkZXJzKSB7XG4gIHJldHVybiAhIWhlYWRlcnMuZ2V0KFwieC1hYmx5LWVycm9yY29kZVwiKTtcbn1cbmZ1bmN0aW9uIGdldEFibHlFcnJvcjIocmVzcG9uc2VCb2R5LCBoZWFkZXJzKSB7XG4gIGlmIChpc0FibHlFcnJvcjIocmVzcG9uc2VCb2R5LCBoZWFkZXJzKSkge1xuICAgIHJldHVybiByZXNwb25zZUJvZHkuZXJyb3IgJiYgRXJyb3JJbmZvLmZyb21WYWx1ZXMocmVzcG9uc2VCb2R5LmVycm9yKTtcbiAgfVxufVxuZnVuY3Rpb24gY29udmVydEhlYWRlcnMoaGVhZGVycykge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaFJlcXVlc3QobWV0aG9kLCBjbGllbnQsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5KSB7XG4gIGNvbnN0IGZldGNoSGVhZGVycyA9IG5ldyBIZWFkZXJzKGhlYWRlcnMgfHwge30pO1xuICBjb25zdCBfbWV0aG9kID0gbWV0aG9kID8gbWV0aG9kLnRvVXBwZXJDYXNlKCkgOiBpc05pbChib2R5KSA/IFwiR0VUXCIgOiBcIlBPU1RcIjtcbiAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgbGV0IHRpbWVvdXQ7XG4gIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChcbiAgICAgICgpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICByZXNvbHZlKHsgZXJyb3I6IG5ldyBQYXJ0aWFsRXJyb3JJbmZvKFwiUmVxdWVzdCB0aW1lZCBvdXRcIiwgbnVsbCwgNDA4KSB9KTtcbiAgICAgIH0sXG4gICAgICBjbGllbnQgPyBjbGllbnQub3B0aW9ucy50aW1lb3V0cy5odHRwUmVxdWVzdFRpbWVvdXQgOiBkZWZhdWx0c19kZWZhdWx0LlRJTUVPVVRTLmh0dHBSZXF1ZXN0VGltZW91dFxuICAgICk7XG4gIH0pO1xuICBjb25zdCByZXF1ZXN0SW5pdCA9IHtcbiAgICBtZXRob2Q6IF9tZXRob2QsXG4gICAgaGVhZGVyczogZmV0Y2hIZWFkZXJzLFxuICAgIGJvZHksXG4gICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxuICB9O1xuICBpZiAoIVBsYXRmb3JtLkNvbmZpZy5pc1dlYndvcmtlcikge1xuICAgIHJlcXVlc3RJbml0LmNyZWRlbnRpYWxzID0gZmV0Y2hIZWFkZXJzLmhhcyhcImF1dGhvcml6YXRpb25cIikgPyBcImluY2x1ZGVcIiA6IFwic2FtZS1vcmlnaW5cIjtcbiAgfVxuICBjb25zdCByZXN1bHRQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMgfHwge30pO1xuICAgICAgdXJsUGFyYW1zLnNldChcInJuZFwiLCBjaGVhcFJhbmRTdHIoKSk7XG4gICAgICBjb25zdCBwcmVwYXJlZFVSSSA9IHVyaSArIFwiP1wiICsgdXJsUGFyYW1zO1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZ2V0R2xvYmFsT2JqZWN0KCkuZmV0Y2gocHJlcGFyZWRVUkksIHJlcXVlc3RJbml0KTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIGlmIChyZXMuc3RhdHVzID09IDIwNCkge1xuICAgICAgICByZXR1cm4geyBlcnJvcjogbnVsbCwgc3RhdHVzQ29kZTogcmVzLnN0YXR1cyB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXMuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG4gICAgICBsZXQgYm9keTI7XG4gICAgICBpZiAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtbXNncGFja1wiKSA+IC0xKSB7XG4gICAgICAgIGJvZHkyID0gYXdhaXQgcmVzLmFycmF5QnVmZmVyKCk7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qc29uXCIpID4gLTEpIHtcbiAgICAgICAgYm9keTIgPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYm9keTIgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgdW5wYWNrZWQgPSAhIWNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluZGV4T2YoXCJhcHBsaWNhdGlvbi94LW1zZ3BhY2tcIikgPT09IC0xO1xuICAgICAgY29uc3QgaGVhZGVyczIgPSBjb252ZXJ0SGVhZGVycyhyZXMuaGVhZGVycyk7XG4gICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICBjb25zdCBlcnJvciA9IGdldEFibHlFcnJvcjIoYm9keTIsIHJlcy5oZWFkZXJzKSB8fCBuZXcgUGFydGlhbEVycm9ySW5mbyhcbiAgICAgICAgICBcIkVycm9yIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gc2VydmVyOiBcIiArIHJlcy5zdGF0dXMgKyBcIiBib2R5IHdhczogXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChib2R5MiksXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICByZXMuc3RhdHVzXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB7IGVycm9yLCBib2R5OiBib2R5MiwgaGVhZGVyczogaGVhZGVyczIsIHVucGFja2VkLCBzdGF0dXNDb2RlOiByZXMuc3RhdHVzIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBlcnJvcjogbnVsbCwgYm9keTogYm9keTIsIGhlYWRlcnM6IGhlYWRlcnMyLCB1bnBhY2tlZCwgc3RhdHVzQ29kZTogcmVzLnN0YXR1cyB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgIH1cbiAgfSkoKTtcbiAgcmV0dXJuIFByb21pc2UucmFjZShbdGltZW91dFByb21pc2UsIHJlc3VsdFByb21pc2VdKTtcbn1cblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9saWIvaHR0cC9yZXF1ZXN0L2luZGV4LnRzXG52YXIgZGVmYXVsdEJ1bmRsZWRSZXF1ZXN0SW1wbGVtZW50YXRpb25zID0ge1xuICBYSFJSZXF1ZXN0OiB4aHJyZXF1ZXN0X2RlZmF1bHQsXG4gIEZldGNoUmVxdWVzdDogZmV0Y2hSZXF1ZXN0XG59O1xuXG4vLyBzcmMvcGxhdGZvcm0vd2ViL2luZGV4LnRzXG52YXIgQ3J5cHRvID0gY3JlYXRlQ3J5cHRvQ2xhc3MoY29uZmlnX2RlZmF1bHQsIGJ1ZmZlcnV0aWxzX2RlZmF1bHQpO1xuUGxhdGZvcm0uQ3J5cHRvID0gQ3J5cHRvO1xuUGxhdGZvcm0uQnVmZmVyVXRpbHMgPSBidWZmZXJ1dGlsc19kZWZhdWx0O1xuUGxhdGZvcm0uSHR0cCA9IGh0dHBfZGVmYXVsdDtcblBsYXRmb3JtLkNvbmZpZyA9IGNvbmZpZ19kZWZhdWx0O1xuUGxhdGZvcm0uVHJhbnNwb3J0cyA9IHRyYW5zcG9ydF9kZWZhdWx0MjtcblBsYXRmb3JtLldlYlN0b3JhZ2UgPSB3ZWJzdG9yYWdlX2RlZmF1bHQ7XG5mb3IgKGNvbnN0IGNsaWVudENsYXNzIG9mIFtEZWZhdWx0UmVzdCwgRGVmYXVsdFJlYWx0aW1lXSkge1xuICBjbGllbnRDbGFzcy5DcnlwdG8gPSBDcnlwdG87XG4gIGNsaWVudENsYXNzLl9Nc2dQYWNrID0gbXNncGFja19kZWZhdWx0O1xufVxuaHR0cF9kZWZhdWx0LmJ1bmRsZWRSZXF1ZXN0SW1wbGVtZW50YXRpb25zID0gZGVmYXVsdEJ1bmRsZWRSZXF1ZXN0SW1wbGVtZW50YXRpb25zO1xubG9nZ2VyX2RlZmF1bHQuaW5pdExvZ0hhbmRsZXJzKCk7XG5QbGF0Zm9ybS5EZWZhdWx0cyA9IGdldERlZmF1bHRzKGRlZmF1bHRzX2RlZmF1bHQyKTtcbmlmIChQbGF0Zm9ybS5Db25maWcuYWdlbnQpIHtcbiAgUGxhdGZvcm0uRGVmYXVsdHMuYWdlbnQgKz0gXCIgXCIgKyBQbGF0Zm9ybS5Db25maWcuYWdlbnQ7XG59XG52YXIgd2ViX2RlZmF1bHQgPSB7XG4gIEVycm9ySW5mbyxcbiAgUmVzdDogRGVmYXVsdFJlc3QsXG4gIFJlYWx0aW1lOiBEZWZhdWx0UmVhbHRpbWUsXG4gIG1zZ3BhY2s6IG1zZ3BhY2tfZGVmYXVsdCxcbiAgbWFrZVByb3RvY29sTWVzc2FnZUZyb21EZXNlcmlhbGl6ZWQ6IG1ha2VGcm9tRGVzZXJpYWxpemVkV2l0aERlcGVuZGVuY2llc1xufTtcbmlmICh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiKSB7XG4gIHZhciBfX2NwID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgICBpZiAoKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIpIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhmcm9tKSkge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBrZXksIHtcbiAgICAgICAgICBnZXQ6ICgpID0+IGZyb21ba2V5XSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhKGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0bztcbiAgfTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfX2NwKG1vZHVsZS5leHBvcnRzLCBleHBvcnRzKTtcbn1cbnJldHVybiBtb2R1bGUuZXhwb3J0cztcbn0pKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJseS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ably/build/ably.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/dequal/dist/index.mjs":
/*!********************************************!*\
  !*** ./node_modules/dequal/dist/index.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dequal: () => (/* binding */ dequal)\n/* harmony export */ });\nvar has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nfunction dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kZXF1YWwvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL25vZGVfbW9kdWxlcy9kZXF1YWwvZGlzdC9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGZpbmQoaXRlciwgdGFyLCBrZXkpIHtcblx0Zm9yIChrZXkgb2YgaXRlci5rZXlzKCkpIHtcblx0XHRpZiAoZGVxdWFsKGtleSwgdGFyKSkgcmV0dXJuIGtleTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVxdWFsKGZvbywgYmFyKSB7XG5cdHZhciBjdG9yLCBsZW4sIHRtcDtcblx0aWYgKGZvbyA9PT0gYmFyKSByZXR1cm4gdHJ1ZTtcblxuXHRpZiAoZm9vICYmIGJhciAmJiAoY3Rvcj1mb28uY29uc3RydWN0b3IpID09PSBiYXIuY29uc3RydWN0b3IpIHtcblx0XHRpZiAoY3RvciA9PT0gRGF0ZSkgcmV0dXJuIGZvby5nZXRUaW1lKCkgPT09IGJhci5nZXRUaW1lKCk7XG5cdFx0aWYgKGN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGZvby50b1N0cmluZygpID09PSBiYXIudG9TdHJpbmcoKTtcblxuXHRcdGlmIChjdG9yID09PSBBcnJheSkge1xuXHRcdFx0aWYgKChsZW49Zm9vLmxlbmd0aCkgPT09IGJhci5sZW5ndGgpIHtcblx0XHRcdFx0d2hpbGUgKGxlbi0tICYmIGRlcXVhbChmb29bbGVuXSwgYmFyW2xlbl0pKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBsZW4gPT09IC0xO1xuXHRcdH1cblxuXHRcdGlmIChjdG9yID09PSBTZXQpIHtcblx0XHRcdGlmIChmb28uc2l6ZSAhPT0gYmFyLnNpemUpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChsZW4gb2YgZm9vKSB7XG5cdFx0XHRcdHRtcCA9IGxlbjtcblx0XHRcdFx0aWYgKHRtcCAmJiB0eXBlb2YgdG1wID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdHRtcCA9IGZpbmQoYmFyLCB0bXApO1xuXHRcdFx0XHRcdGlmICghdG1wKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFiYXIuaGFzKHRtcCkpIHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmIChjdG9yID09PSBNYXApIHtcblx0XHRcdGlmIChmb28uc2l6ZSAhPT0gYmFyLnNpemUpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChsZW4gb2YgZm9vKSB7XG5cdFx0XHRcdHRtcCA9IGxlblswXTtcblx0XHRcdFx0aWYgKHRtcCAmJiB0eXBlb2YgdG1wID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdHRtcCA9IGZpbmQoYmFyLCB0bXApO1xuXHRcdFx0XHRcdGlmICghdG1wKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFkZXF1YWwobGVuWzFdLCBiYXIuZ2V0KHRtcCkpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoY3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcblx0XHRcdGZvbyA9IG5ldyBVaW50OEFycmF5KGZvbyk7XG5cdFx0XHRiYXIgPSBuZXcgVWludDhBcnJheShiYXIpO1xuXHRcdH0gZWxzZSBpZiAoY3RvciA9PT0gRGF0YVZpZXcpIHtcblx0XHRcdGlmICgobGVuPWZvby5ieXRlTGVuZ3RoKSA9PT0gYmFyLmJ5dGVMZW5ndGgpIHtcblx0XHRcdFx0d2hpbGUgKGxlbi0tICYmIGZvby5nZXRJbnQ4KGxlbikgPT09IGJhci5nZXRJbnQ4KGxlbikpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGxlbiA9PT0gLTE7XG5cdFx0fVxuXG5cdFx0aWYgKEFycmF5QnVmZmVyLmlzVmlldyhmb28pKSB7XG5cdFx0XHRpZiAoKGxlbj1mb28uYnl0ZUxlbmd0aCkgPT09IGJhci5ieXRlTGVuZ3RoKSB7XG5cdFx0XHRcdHdoaWxlIChsZW4tLSAmJiBmb29bbGVuXSA9PT0gYmFyW2xlbl0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGxlbiA9PT0gLTE7XG5cdFx0fVxuXG5cdFx0aWYgKCFjdG9yIHx8IHR5cGVvZiBmb28gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRsZW4gPSAwO1xuXHRcdFx0Zm9yIChjdG9yIGluIGZvbykge1xuXHRcdFx0XHRpZiAoaGFzLmNhbGwoZm9vLCBjdG9yKSAmJiArK2xlbiAmJiAhaGFzLmNhbGwoYmFyLCBjdG9yKSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZiAoIShjdG9yIGluIGJhcikgfHwgIWRlcXVhbChmb29bY3Rvcl0sIGJhcltjdG9yXSkpIHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBPYmplY3Qua2V5cyhiYXIpLmxlbmd0aCA9PT0gbGVuO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmb28gIT09IGZvbyAmJiBiYXIgIT09IGJhcjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/dequal/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/dequal/lite/index.mjs":
/*!********************************************!*\
  !*** ./node_modules/dequal/lite/index.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dequal: () => (/* binding */ dequal)\n/* harmony export */ });\nvar has = Object.prototype.hasOwnProperty;\n\nfunction dequal(foo, bar) {\n\tvar ctor, len;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kZXF1YWwvbGl0ZS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvZGVxdWFsL2xpdGUvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5leHBvcnQgZnVuY3Rpb24gZGVxdWFsKGZvbywgYmFyKSB7XG5cdHZhciBjdG9yLCBsZW47XG5cdGlmIChmb28gPT09IGJhcikgcmV0dXJuIHRydWU7XG5cblx0aWYgKGZvbyAmJiBiYXIgJiYgKGN0b3I9Zm9vLmNvbnN0cnVjdG9yKSA9PT0gYmFyLmNvbnN0cnVjdG9yKSB7XG5cdFx0aWYgKGN0b3IgPT09IERhdGUpIHJldHVybiBmb28uZ2V0VGltZSgpID09PSBiYXIuZ2V0VGltZSgpO1xuXHRcdGlmIChjdG9yID09PSBSZWdFeHApIHJldHVybiBmb28udG9TdHJpbmcoKSA9PT0gYmFyLnRvU3RyaW5nKCk7XG5cblx0XHRpZiAoY3RvciA9PT0gQXJyYXkpIHtcblx0XHRcdGlmICgobGVuPWZvby5sZW5ndGgpID09PSBiYXIubGVuZ3RoKSB7XG5cdFx0XHRcdHdoaWxlIChsZW4tLSAmJiBkZXF1YWwoZm9vW2xlbl0sIGJhcltsZW5dKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbGVuID09PSAtMTtcblx0XHR9XG5cblx0XHRpZiAoIWN0b3IgfHwgdHlwZW9mIGZvbyA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGxlbiA9IDA7XG5cdFx0XHRmb3IgKGN0b3IgaW4gZm9vKSB7XG5cdFx0XHRcdGlmIChoYXMuY2FsbChmb28sIGN0b3IpICYmICsrbGVuICYmICFoYXMuY2FsbChiYXIsIGN0b3IpKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlmICghKGN0b3IgaW4gYmFyKSB8fCAhZGVxdWFsKGZvb1tjdG9yXSwgYmFyW2N0b3JdKSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE9iamVjdC5rZXlzKGJhcikubGVuZ3RoID09PSBsZW47XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZvbyAhPT0gZm9vICYmIGJhciAhPT0gYmFyO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/dequal/lite/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/image.js":
/*!*********************************************!*\
  !*** ./node_modules/next/dist/api/image.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* reexport default from dynamic */ _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default.a)\n/* harmony export */ });\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/lib/image-external */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js\");\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n//# sourceMappingURL=image.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2ltYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF1RDtBQUNWOztBQUU3QyIsInNvdXJjZXMiOlsiL1VzZXJzL2lzaGFxYmVsbG8vV2Vic2l0ZS9oYXZlbnJpZGVfZnVsbF9hcHAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9hcGkvaW1hZ2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4uL3NoYXJlZC9saWIvaW1hZ2UtZXh0ZXJuYWwnO1xuZXhwb3J0ICogZnJvbSAnLi4vc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbCc7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/image.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/navigation.js":
/*!**************************************************!*\
  !*** ./node_modules/next/dist/api/navigation.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceMappingURL=navigation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdEOztBQUVoRCIsInNvdXJjZXMiOlsiL1VzZXJzL2lzaGFxYmVsbG8vV2Vic2l0ZS9oYXZlbnJpZGVfZnVsbF9hcHAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9hcGkvbmF2aWdhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuLi9jbGllbnQvY29tcG9uZW50cy9uYXZpZ2F0aW9uJztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2aWdhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fishaqbello%2FWebsite%2Fhavenride_full_app%2Fapp%2Fdriver%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!***********************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fishaqbello%2FWebsite%2Fhavenride_full_app%2Fapp%2Fdriver%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \***********************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/driver/page.tsx */ \"(app-pages-browser)/./app/driver/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZpc2hhcWJlbGxvJTJGV2Vic2l0ZSUyRmhhdmVucmlkZV9mdWxsX2FwcCUyRmFwcCUyRmRyaXZlciUyRnBhZ2UudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsb0tBQXFHIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9hcHAvZHJpdmVyL3BhZ2UudHN4XCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fishaqbello%2FWebsite%2Fhavenride_full_app%2Fapp%2Fdriver%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/app-dir/link.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/app-dir/link.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    /**\n * A React component that extends the HTML `<a>` element to provide\n * [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)\n * and client-side navigation. This is the primary way to navigate between routes in Next.js.\n *\n * @remarks\n * - Prefetching is only enabled in production.\n *\n * @see https://nextjs.org/docs/app/api-reference/components/link\n */ default: function() {\n        return LinkComponent;\n    },\n    useLinkStatus: function() {\n        return useLinkStatus;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _formaturl = __webpack_require__(/*! ../../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _usemergedref = __webpack_require__(/*! ../use-merged-ref */ \"(app-pages-browser)/./node_modules/next/dist/client/use-merged-ref.js\");\nconst _utils = __webpack_require__(/*! ../../shared/lib/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _addbasepath = __webpack_require__(/*! ../add-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/add-base-path.js\");\nconst _warnonce = __webpack_require__(/*! ../../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _links = __webpack_require__(/*! ../components/links */ \"(app-pages-browser)/./node_modules/next/dist/client/components/links.js\");\nconst _islocalurl = __webpack_require__(/*! ../../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _approuterinstance = __webpack_require__(/*! ../components/app-router-instance */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-instance.js\");\nconst _erroronce = __webpack_require__(/*! ../../shared/lib/utils/error-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/error-once.js\");\nconst _segmentcache = __webpack_require__(/*! ../components/segment-cache */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache.js\");\nfunction isModifiedEvent(event) {\n    const eventTarget = event.currentTarget;\n    const target = eventTarget.getAttribute('target');\n    return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n    event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate) {\n    const { nodeName } = e.currentTarget;\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === 'A';\n    if (isAnchorNodeName && isModifiedEvent(e) || e.currentTarget.hasAttribute('download')) {\n        // ignore click for browser’s default behavior\n        return;\n    }\n    if (!(0, _islocalurl.isLocalURL)(href)) {\n        if (replace) {\n            // browser default behavior does not replace the history state\n            // so we need to do it manually\n            e.preventDefault();\n            location.replace(href);\n        }\n        // ignore click for browser’s default behavior\n        return;\n    }\n    e.preventDefault();\n    if (onNavigate) {\n        let isDefaultPrevented = false;\n        onNavigate({\n            preventDefault: ()=>{\n                isDefaultPrevented = true;\n            }\n        });\n        if (isDefaultPrevented) {\n            return;\n        }\n    }\n    _react.default.startTransition(()=>{\n        (0, _approuterinstance.dispatchNavigateAction)(as || href, replace ? 'replace' : 'push', scroll != null ? scroll : true, linkInstanceRef.current);\n    });\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === 'string') {\n        return urlObjOrString;\n    }\n    return (0, _formaturl.formatUrl)(urlObjOrString);\n}\nfunction LinkComponent(props) {\n    _s();\n    const [linkStatus, setOptimisticLinkStatus] = (0, _react.useOptimistic)(_links.IDLE_LINK_STATUS);\n    let children;\n    const linkInstanceRef = (0, _react.useRef)(null);\n    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, onNavigate, ref: forwardedRef, unstable_dynamicOnHover, ...restProps } = props;\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === 'string' || typeof children === 'number')) {\n        children = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            children: children\n        });\n    }\n    const router = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);\n    const prefetchEnabled = prefetchProp !== false;\n    const fetchStrategy = prefetchProp !== false ? getFetchStrategyFromPrefetchProp(prefetchProp) : _segmentcache.FetchStrategy.PPR;\n    if (true) {\n        function createPropError(args) {\n            return Object.defineProperty(new Error(\"Failed prop type: The prop `\" + args.key + \"` expects a \" + args.expected + \" in `<Link>`, but got `\" + args.actual + \"` instead.\" + ( true ? \"\\nOpen your browser's console to view the Component stack trace.\" : 0)), \"__NEXT_ERROR_CODE\", {\n                value: \"E319\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === 'href') {\n                if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {\n                    throw createPropError({\n                        key,\n                        expected: '`string` or `object`',\n                        actual: props[key] === null ? 'null' : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            unstable_dynamicOnHover: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true,\n            onNavigate: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === 'as') {\n                if (props[key] && valType !== 'string' && valType !== 'object') {\n                    throw createPropError({\n                        key,\n                        expected: '`string` or `object`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'onClick' || key === 'onMouseEnter' || key === 'onTouchStart' || key === 'onNavigate') {\n                if (props[key] && valType !== 'function') {\n                    throw createPropError({\n                        key,\n                        expected: '`function`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'legacyBehavior' || key === 'unstable_dynamicOnHover') {\n                if (props[key] != null && valType !== 'boolean') {\n                    throw createPropError({\n                        key,\n                        expected: '`boolean`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'prefetch') {\n                if (props[key] != null && valType !== 'boolean' && props[key] !== 'auto' && props[key] !== 'unstable_forceStale') {\n                    throw createPropError({\n                        key,\n                        expected: '`boolean | \"auto\" | \"unstable_forceStale\"`',\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n    }\n    if (true) {\n        if (props.locale) {\n            (0, _warnonce.warnOnce)('The `locale` prop is not supported in `next/link` while using the `app` router. Read more about app router internalization: https://nextjs.org/docs/app/building-your-application/routing/internationalization');\n        }\n        if (!asProp) {\n            let href;\n            if (typeof hrefProp === 'string') {\n                href = hrefProp;\n            } else if (typeof hrefProp === 'object' && typeof hrefProp.pathname === 'string') {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                const hasDynamicSegment = href.split('/').some((segment)=>segment.startsWith('[') && segment.endsWith(']'));\n                if (hasDynamicSegment) {\n                    throw Object.defineProperty(new Error(\"Dynamic href `\" + href + \"` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href\"), \"__NEXT_ERROR_CODE\", {\n                        value: \"E267\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n        }\n    }\n    const { href, as } = _react.default.useMemo({\n        \"LinkComponent.useMemo\": ()=>{\n            const resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n    }[\"LinkComponent.useMemo\"], [\n        hrefProp,\n        asProp\n    ]);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link');\n            }\n            if (onMouseEnterProp) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw Object.defineProperty(new Error(\"No children were passed to <Link> with `href` of `\" + hrefProp + \"` but one child is required https://nextjs.org/docs/messages/link-no-children\"), \"__NEXT_ERROR_CODE\", {\n                        value: \"E320\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                throw Object.defineProperty(new Error(\"Multiple children were passed to <Link> with `href` of `\" + hrefProp + \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\" + ( true ? \" \\nOpen your browser's console to view the Component stack trace.\" : 0)), \"__NEXT_ERROR_CODE\", {\n                    value: \"E266\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        } else {}\n    } else {\n        if (true) {\n            if ((children == null ? void 0 : children.type) === 'a') {\n                throw Object.defineProperty(new Error('Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E209\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === 'object' && child.ref : forwardedRef;\n    // Use a callback ref to attach an IntersectionObserver to the anchor tag on\n    // mount. In the future we will also use this to keep track of all the\n    // currently mounted <Link> instances, e.g. so we can re-prefetch them after\n    // a revalidation or refresh.\n    const observeLinkVisibilityOnMount = _react.default.useCallback({\n        \"LinkComponent.useCallback[observeLinkVisibilityOnMount]\": (element)=>{\n            if (router !== null) {\n                linkInstanceRef.current = (0, _links.mountLinkInstance)(element, href, router, fetchStrategy, prefetchEnabled, setOptimisticLinkStatus);\n            }\n            return ({\n                \"LinkComponent.useCallback[observeLinkVisibilityOnMount]\": ()=>{\n                    if (linkInstanceRef.current) {\n                        (0, _links.unmountLinkForCurrentNavigation)(linkInstanceRef.current);\n                        linkInstanceRef.current = null;\n                    }\n                    (0, _links.unmountPrefetchableInstance)(element);\n                }\n            })[\"LinkComponent.useCallback[observeLinkVisibilityOnMount]\"];\n        }\n    }[\"LinkComponent.useCallback[observeLinkVisibilityOnMount]\"], [\n        prefetchEnabled,\n        href,\n        router,\n        fetchStrategy,\n        setOptimisticLinkStatus\n    ]);\n    const mergedRef = (0, _usemergedref.useMergedRef)(observeLinkVisibilityOnMount, childRef);\n    const childProps = {\n        ref: mergedRef,\n        onClick (e) {\n            if (true) {\n                if (!e) {\n                    throw Object.defineProperty(new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E312\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n            if (!legacyBehavior && typeof onClick === 'function') {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === 'function') {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === 'function') {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === 'function') {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled || \"development\" === 'development') {\n                return;\n            }\n            const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true;\n            (0, _links.onNavigationIntent)(e.currentTarget, upgradeToDynamicPrefetch);\n        },\n        onTouchStart:  false ? 0 : function onTouchStart(e) {\n            if (!legacyBehavior && typeof onTouchStartProp === 'function') {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === 'function') {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled) {\n                return;\n            }\n            const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true;\n            (0, _links.onNavigationIntent)(e.currentTarget, upgradeToDynamicPrefetch);\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the basePath.\n    if ((0, _utils.isAbsoluteUrl)(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === 'a' && !('href' in child.props)) {\n        childProps.href = (0, _addbasepath.addBasePath)(as);\n    }\n    let link;\n    if (legacyBehavior) {\n        if (true) {\n            (0, _erroronce.errorOnce)('`legacyBehavior` is deprecated and will be removed in a future ' + 'release. A codemod is available to upgrade your components:\\n\\n' + 'npx @next/codemod@latest new-link .\\n\\n' + 'Learn more: https://nextjs.org/docs/app/building-your-application/upgrading/codemods#remove-a-tags-from-link-components');\n        }\n        link = /*#__PURE__*/ _react.default.cloneElement(child, childProps);\n    } else {\n        link = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            ...restProps,\n            ...childProps,\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(LinkStatusContext.Provider, {\n        value: linkStatus,\n        children: link\n    });\n}\n_s(LinkComponent, \"MNV6IdWv8Lu3MKc7Fm4v59uGRY0=\");\n_c = LinkComponent;\nconst LinkStatusContext = /*#__PURE__*/ (0, _react.createContext)(_links.IDLE_LINK_STATUS);\nconst useLinkStatus = ()=>{\n    return (0, _react.useContext)(LinkStatusContext);\n};\nfunction getFetchStrategyFromPrefetchProp(prefetchProp) {\n    if (false) {} else {\n        return prefetchProp === null || prefetchProp === 'auto' ? _segmentcache.FetchStrategy.PPR : // (although invalid values should've been filtered out by prop validation in dev)\n        _segmentcache.FetchStrategy.Full;\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\nvar _c;\n$RefreshReg$(_c, \"LinkComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FwcC1kaXIvbGluay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQW9UQTs7Ozs7Ozs7O0NBU0MsR0FDRCxPQWthQztlQWxhdUJBOztJQXdhWEMsYUFBYTtlQUFiQTs7Ozs7NkVBcHVCMkQ7dUNBRTlDOzJEQUNPOzBDQUNKO21DQUNDO3lDQUNGO3NDQUNIO21DQVNsQjt3Q0FDb0I7K0NBQ1k7dUNBQ2I7MENBSW5CO0FBME1QLFNBQVNDLGdCQUFnQkMsS0FBdUI7SUFDOUMsTUFBTUMsY0FBY0QsTUFBTUUsYUFBYTtJQUN2QyxNQUFNQyxTQUFTRixZQUFZRyxZQUFZLENBQUM7SUFDeEMsT0FDR0QsVUFBVUEsV0FBVyxXQUN0QkgsTUFBTUssT0FBTyxJQUNiTCxNQUFNTSxPQUFPLElBQ2JOLE1BQU1PLFFBQVEsSUFDZFAsTUFBTVEsTUFBTSxJQUFJLDZCQUE2QjtJQUM1Q1IsTUFBTVMsV0FBVyxJQUFJVCxNQUFNUyxXQUFXLENBQUNDLEtBQUssS0FBSztBQUV0RDtBQUVBLFNBQVNDLFlBQ1BDLENBQW1CLEVBQ25CQyxJQUFZLEVBQ1pDLEVBQVUsRUFDVkMsZUFBcUQsRUFDckRDLE9BQWlCLEVBQ2pCQyxNQUFnQixFQUNoQkMsVUFBbUM7SUFFbkMsTUFBTSxFQUFFQyxRQUFRLEVBQUUsR0FBR1AsRUFBRVYsYUFBYTtJQUVwQyxrREFBa0Q7SUFDbEQsTUFBTWtCLG1CQUFtQkQsU0FBU0UsV0FBVyxPQUFPO0lBRXBELElBQ0dELG9CQUFvQnJCLGdCQUFnQmEsTUFDckNBLEVBQUVWLGFBQWEsQ0FBQ29CLFlBQVksQ0FBQyxhQUM3QjtRQUNBLDhDQUE4QztRQUM5QztJQUNGO0lBRUEsSUFBSSxDQUFDQyxDQUFBQSxHQUFBQSxZQUFBQSxVQUFBQSxFQUFXVixPQUFPO1FBQ3JCLElBQUlHLFNBQVM7WUFDWCw4REFBOEQ7WUFDOUQsK0JBQStCO1lBQy9CSixFQUFFWSxjQUFj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QztJQUNwQixPQUFPLElBQ0wsQ0FBQ3VDLGtCQUNEUCxZQUNDbUQsTUFBTU0sSUFBSSxLQUFLLE9BQU8sQ0FBRSxXQUFVTixNQUFNL0QsS0FBQUEsR0FDekM7UUFDQStFLFdBQVdwRyxJQUFJLEdBQUcyRyxDQUFBQSxHQUFBQSxhQUFBQSxXQUFXLEVBQUMxRztJQUNoQztJQUVBLElBQUkyRztJQUVKLElBQUlwRSxnQkFBZ0I7UUFDbEIsSUFBSWMsSUFBb0IsRUFBb0I7WUFDMUN1RCxDQUFBQSxHQUFBQSxXQUFBQSxTQUFBQSxFQUNFLG9FQUNFLG9FQUNBLDRDQUNBO1FBRU47UUFDQUQsT0FBQUEsV0FBQUEsR0FBTzlGLE9BQUFBLE9BQUssQ0FBQ2dHLFlBQVksQ0FBQzFCLE9BQU9nQjtJQUNuQyxPQUFPO1FBQ0xRLE9BQUFBLFdBQUFBLEdBQ0UscUJBQUMvRCxLQUFBQTtZQUFHLEdBQUdELFNBQVM7WUFBRyxHQUFHd0QsVUFBVTtzQkFDN0IxRTs7SUFHUDtJQUVBLHFCQUNFLHFCQUFDcUYsa0JBQWtCQyxRQUFRO1FBQUNDLE9BQU8zRjtrQkFDaENzRjs7QUFHUDs7S0FsYXdCNUg7QUFvYXhCLE1BQU0rSCxvQkFBQUEsV0FBQUEsR0FBb0JHLENBQUFBLEdBQUFBLE9BQUFBLGFBQUFBLEVBRXhCekYsT0FBQUEsZ0JBQWdCO0FBRVgsTUFBTXhDLGdCQUFnQjtJQUMzQixPQUFPOEQsQ0FBQUEsR0FBQUEsT0FBQUEsVUFBQUEsRUFBV2dFO0FBQ3BCO0FBRUEsU0FBUzVELGlDQUNQbkIsWUFBK0Q7SUFFL0QsSUFDRXNCLEtBQ3VDLEVBQ3ZDLEVBb0JELE1BQU07UUFDTCxPQUFPdEIsaUJBQWlCLFFBQVFBLGlCQUFpQixTQUU3QyxjQUNBb0IsYUFBYSxDQUFDQyxHQUFHLEdBRWpCLDREQUg4RixzQkFJWjtRQUNsRkQsY0FBQUEsYUFBYSxDQUFDa0UsSUFBSTtJQUN4QjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvc3JjL2NsaWVudC9hcHAtZGlyL2xpbmsudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlT3B0aW1pc3RpYywgdXNlUmVmIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgdHlwZSB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB7IGZvcm1hdFVybCB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwnXG5pbXBvcnQgeyBBcHBSb3V0ZXJDb250ZXh0IH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyB1c2VNZXJnZWRSZWYgfSBmcm9tICcuLi91c2UtbWVyZ2VkLXJlZidcbmltcG9ydCB7IGlzQWJzb2x1dGVVcmwgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3V0aWxzJ1xuaW1wb3J0IHsgYWRkQmFzZVBhdGggfSBmcm9tICcuLi9hZGQtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3V0aWxzL3dhcm4tb25jZSdcbmltcG9ydCB0eXBlIHsgUEVORElOR19MSU5LX1NUQVRVUyB9IGZyb20gJy4uL2NvbXBvbmVudHMvbGlua3MnXG5pbXBvcnQge1xuICBJRExFX0xJTktfU1RBVFVTLFxuICBtb3VudExpbmtJbnN0YW5jZSxcbiAgb25OYXZpZ2F0aW9uSW50ZW50LFxuICB1bm1vdW50TGlua0ZvckN1cnJlbnROYXZpZ2F0aW9uLFxuICB1bm1vdW50UHJlZmV0Y2hhYmxlSW5zdGFuY2UsXG4gIHR5cGUgTGlua0luc3RhbmNlLFxufSBmcm9tICcuLi9jb21wb25lbnRzL2xpbmtzJ1xuaW1wb3J0IHsgaXNMb2NhbFVSTCB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWxvY2FsLXVybCdcbmltcG9ydCB7IGRpc3BhdGNoTmF2aWdhdGVBY3Rpb24gfSBmcm9tICcuLi9jb21wb25lbnRzL2FwcC1yb3V0ZXItaW5zdGFuY2UnXG5pbXBvcnQgeyBlcnJvck9uY2UgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3V0aWxzL2Vycm9yLW9uY2UnXG5pbXBvcnQge1xuICBGZXRjaFN0cmF0ZWd5LFxuICB0eXBlIFByZWZldGNoVGFza0ZldGNoU3RyYXRlZ3ksXG59IGZyb20gJy4uL2NvbXBvbmVudHMvc2VnbWVudC1jYWNoZSdcblxudHlwZSBVcmwgPSBzdHJpbmcgfCBVcmxPYmplY3RcbnR5cGUgUmVxdWlyZWRLZXlzPFQ+ID0ge1xuICBbSyBpbiBrZXlvZiBUXS0/OiB7fSBleHRlbmRzIFBpY2s8VCwgSz4gPyBuZXZlciA6IEtcbn1ba2V5b2YgVF1cbnR5cGUgT3B0aW9uYWxLZXlzPFQ+ID0ge1xuICBbSyBpbiBrZXlvZiBUXS0/OiB7fSBleHRlbmRzIFBpY2s8VCwgSz4gPyBLIDogbmV2ZXJcbn1ba2V5b2YgVF1cblxudHlwZSBPbk5hdmlnYXRlRXZlbnRIYW5kbGVyID0gKGV2ZW50OiB7IHByZXZlbnREZWZhdWx0OiAoKSA9PiB2b2lkIH0pID0+IHZvaWRcblxudHlwZSBJbnRlcm5hbExpbmtQcm9wcyA9IHtcbiAgLyoqXG4gICAqICoqUmVxdWlyZWQqKi4gVGhlIHBhdGggb3IgVVJMIHRvIG5hdmlnYXRlIHRvLiBJdCBjYW4gYWxzbyBiZSBhbiBvYmplY3QgKHNpbWlsYXIgdG8gYFVSTGApLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c3hcbiAgICogLy8gTmF2aWdhdGUgdG8gL2Rhc2hib2FyZDpcbiAgICogPExpbmsgaHJlZj1cIi9kYXNoYm9hcmRcIj5EYXNoYm9hcmQ8L0xpbms+XG4gICAqXG4gICAqIC8vIE5hdmlnYXRlIHRvIC9hYm91dD9uYW1lPXRlc3Q6XG4gICAqIDxMaW5rIGhyZWY9e3sgcGF0aG5hbWU6ICcvYWJvdXQnLCBxdWVyeTogeyBuYW1lOiAndGVzdCcgfSB9fT5cbiAgICogICBBYm91dFxuICAgKiA8L0xpbms+XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiAtIEZvciBleHRlcm5hbCBVUkxzLCB1c2UgYSBmdWxseSBxdWFsaWZpZWQgVVJMIHN1Y2ggYXMgYGh0dHBzOi8vLi4uYC5cbiAgICogLSBJbiB0aGUgQXBwIFJvdXRlciwgZHluYW1pYyByb3V0ZXMgbXVzdCBub3QgaW5jbHVkZSBicmFja2V0ZWQgc2VnbWVudHMgaW4gYGhyZWZgLlxuICAgKi9cbiAgaHJlZjogVXJsXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHYxMC4wLjA6IGBocmVmYCBwcm9wcyBwb2ludGluZyB0byBhIGR5bmFtaWMgcm91dGUgYXJlXG4gICAqIGF1dG9tYXRpY2FsbHkgcmVzb2x2ZWQgYW5kIG5vIGxvbmdlciByZXF1aXJlIHRoZSBgYXNgIHByb3AuXG4gICAqL1xuICBhcz86IFVybFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoZSBjdXJyZW50IGBoaXN0b3J5YCBzdGF0ZSBpbnN0ZWFkIG9mIGFkZGluZyBhIG5ldyBVUkwgaW50byB0aGUgc3RhY2suXG4gICAqXG4gICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c3hcbiAgICogPExpbmsgaHJlZj1cIi9hYm91dFwiIHJlcGxhY2U+XG4gICAqICAgQWJvdXQgKHJlcGxhY2VzIHRoZSBoaXN0b3J5IHN0YXRlKVxuICAgKiA8L0xpbms+XG4gICAqIGBgYFxuICAgKi9cbiAgcmVwbGFjZT86IGJvb2xlYW5cblxuICAvKipcbiAgICogV2hldGhlciB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBzY3JvbGwgYmVoYXZpb3IuIElmIGB0cnVlYCwgTmV4dC5qcyBhdHRlbXB0cyB0byBtYWludGFpblxuICAgKiB0aGUgc2Nyb2xsIHBvc2l0aW9uIGlmIHRoZSBuZXdseSBuYXZpZ2F0ZWQgcGFnZSBpcyBzdGlsbCB2aXNpYmxlLiBJZiBub3QsIGl0IHNjcm9sbHMgdG8gdGhlIHRvcC5cbiAgICpcbiAgICogSWYgYGZhbHNlYCwgTmV4dC5qcyB3aWxsIG5vdCBtb2RpZnkgdGhlIHNjcm9sbCBiZWhhdmlvciBhdCBhbGwuXG4gICAqXG4gICAqIEBkZWZhdWx0VmFsdWUgYHRydWVgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzeFxuICAgKiA8TGluayBocmVmPVwiL2Rhc2hib2FyZFwiIHNjcm9sbD17ZmFsc2V9PlxuICAgKiAgIE5vIGF1dG8gc2Nyb2xsXG4gICAqIDwvTGluaz5cbiAgICogYGBgXG4gICAqL1xuICBzY3JvbGw/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgcGF0aCBvZiB0aGUgY3VycmVudCBwYWdlIHdpdGhvdXQgcmVydW5uaW5nIGRhdGEgZmV0Y2hpbmcgbWV0aG9kc1xuICAgKiBsaWtlIGBnZXRTdGF0aWNQcm9wc2AsIGBnZXRTZXJ2ZXJTaWRlUHJvcHNgLCBvciBgZ2V0SW5pdGlhbFByb3BzYC5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogYHNoYWxsb3dgIG9ubHkgYXBwbGllcyB0byB0aGUgUGFnZXMgUm91dGVyLiBGb3IgdGhlIEFwcCBSb3V0ZXIsIHNlZSB0aGVcbiAgICogW2ZvbGxvd2luZyBkb2N1bWVudGF0aW9uXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yb3V0aW5nL2xpbmtpbmctYW5kLW5hdmlnYXRpbmcjdXNpbmctdGhlLW5hdGl2ZS1oaXN0b3J5LWFwaSkuXG4gICAqXG4gICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c3hcbiAgICogPExpbmsgaHJlZj1cIi9ibG9nXCIgc2hhbGxvdz5cbiAgICogICBTaGFsbG93IG5hdmlnYXRpb25cbiAgICogPC9MaW5rPlxuICAgKiBgYGBcbiAgICovXG4gIHNoYWxsb3c/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBgTGlua2AgdG8gcGFzcyBpdHMgYGhyZWZgIHRvIHRoZSBjaGlsZCBjb21wb25lbnQuIFVzZWZ1bCBpZiB0aGUgY2hpbGQgaXMgYSBjdXN0b21cbiAgICogY29tcG9uZW50IHRoYXQgd3JhcHMgYW4gYDxhPmAgdGFnLCBvciBpZiB5b3UncmUgdXNpbmcgY2VydGFpbiBzdHlsaW5nIGxpYnJhcmllcy5cbiAgICpcbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzeFxuICAgKiA8TGluayBocmVmPVwiL2Rhc2hib2FyZFwiIHBhc3NIcmVmPlxuICAgKiAgIDxNeVN0eWxlZEFuY2hvcj5EYXNoYm9hcmQ8L015U3R5bGVkQW5jaG9yPlxuICAgKiA8L0xpbms+XG4gICAqIGBgYFxuICAgKi9cbiAgcGFzc0hyZWY/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIFByZWZldGNoIHRoZSBwYWdlIGluIHRoZSBiYWNrZ3JvdW5kLlxuICAgKiBBbnkgYDxMaW5rIC8+YCB0aGF0IGlzIGluIHRoZSB2aWV3cG9ydCAoaW5pdGlhbGx5IG9yIHRocm91Z2ggc2Nyb2xsKSB3aWxsIGJlIHByZWZldGNoZWQuXG4gICAqIFByZWZldGNoIGNhbiBiZSBkaXNhYmxlZCBieSBwYXNzaW5nIGBwcmVmZXRjaD17ZmFsc2V9YC5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogUHJlZmV0Y2hpbmcgaXMgb25seSBlbmFibGVkIGluIHByb2R1Y3Rpb24uXG4gICAqXG4gICAqIC0gSW4gdGhlICoqQXBwIFJvdXRlcioqOlxuICAgKiAgIC0gYFwiYXV0b1wiYCwgYG51bGxgLCBgdW5kZWZpbmVkYCAoZGVmYXVsdCk6IFByZWZldGNoIGJlaGF2aW9yIGRlcGVuZHMgb24gc3RhdGljIHZzIGR5bmFtaWMgcm91dGVzOlxuICAgKiAgICAgLSBTdGF0aWMgcm91dGVzOiBmdWxseSBwcmVmZXRjaGVkXG4gICAqICAgICAtIER5bmFtaWMgcm91dGVzOiBwYXJ0aWFsIHByZWZldGNoIHRvIHRoZSBuZWFyZXN0IHNlZ21lbnQgd2l0aCBhIGBsb2FkaW5nLmpzYFxuICAgKiAgIC0gYHRydWVgOiBBbHdheXMgcHJlZmV0Y2ggdGhlIGZ1bGwgcm91dGUgYW5kIGRhdGEuXG4gICAqICAgLSBgZmFsc2VgOiBEaXNhYmxlIHByZWZldGNoaW5nIG9uIGJvdGggdmlld3BvcnQgYW5kIGhvdmVyLlxuICAgKiAtIEluIHRoZSAqKlBhZ2VzIFJvdXRlcioqOlxuICAgKiAgIC0gYHRydWVgIChkZWZhdWx0KTogUHJlZmV0Y2hlcyB0aGUgcm91dGUgYW5kIGRhdGEgaW4gdGhlIGJhY2tncm91bmQgb24gdmlld3BvcnQgb3IgaG92ZXIuXG4gICAqICAgLSBgZmFsc2VgOiBQcmVmZXRjaCBvbmx5IG9uIGhvdmVyLCBub3Qgb24gdmlld3BvcnQuXG4gICAqXG4gICAqIEBkZWZhdWx0VmFsdWUgYHRydWVgIChQYWdlcyBSb3V0ZXIpIG9yIGBudWxsYCAoQXBwIFJvdXRlcilcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHN4XG4gICAqIDxMaW5rIGhyZWY9XCIvZGFzaGJvYXJkXCIgcHJlZmV0Y2g9e2ZhbHNlfT5cbiAgICogICBEYXNoYm9hcmRcbiAgICogPC9MaW5rPlxuICAgKiBgYGBcbiAgICovXG4gIHByZWZldGNoPzogYm9vbGVhbiB8ICdhdXRvJyB8IG51bGwgfCAndW5zdGFibGVfZm9yY2VTdGFsZSdcblxuICAvKipcbiAgICogKHVuc3RhYmxlKSBTd2l0Y2ggdG8gYSBmdWxsIHByZWZldGNoIG9uIGhvdmVyLiBFZmZlY3RpdmVseSB0aGUgc2FtZSBhc1xuICAgKiB1cGRhdGluZyB0aGUgcHJlZmV0Y2ggcHJvcCB0byBgdHJ1ZWAgaW4gYSBtb3VzZSBldmVudC5cbiAgICovXG4gIHVuc3RhYmxlX2R5bmFtaWNPbkhvdmVyPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBUaGUgYWN0aXZlIGxvY2FsZSBpcyBhdXRvbWF0aWNhbGx5IHByZXBlbmRlZCBpbiB0aGUgUGFnZXMgUm91dGVyLiBgbG9jYWxlYCBhbGxvd3MgZm9yIHByb3ZpZGluZ1xuICAgKiBhIGRpZmZlcmVudCBsb2NhbGUsIG9yIGNhbiBiZSBzZXQgdG8gYGZhbHNlYCB0byBvcHQgb3V0IG9mIGF1dG9tYXRpYyBsb2NhbGUgYmVoYXZpb3IuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIE5vdGU6IGxvY2FsZSBvbmx5IGFwcGxpZXMgaW4gdGhlIFBhZ2VzIFJvdXRlciBhbmQgaXMgaWdub3JlZCBpbiB0aGUgQXBwIFJvdXRlci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHN4XG4gICAqIC8vIFVzZSB0aGUgJ2ZyJyBsb2NhbGU6XG4gICAqIDxMaW5rIGhyZWY9XCIvYWJvdXRcIiBsb2NhbGU9XCJmclwiPlxuICAgKiAgIEFib3V0IChGcmVuY2gpXG4gICAqIDwvTGluaz5cbiAgICpcbiAgICogLy8gRGlzYWJsZSBsb2NhbGUgcHJlZml4OlxuICAgKiA8TGluayBocmVmPVwiL2Fib3V0XCIgbG9jYWxlPXtmYWxzZX0+XG4gICAqICAgQWJvdXQgKG5vIGxvY2FsZSBwcmVmaXgpXG4gICAqIDwvTGluaz5cbiAgICogYGBgXG4gICAqL1xuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZVxuXG4gIC8qKlxuICAgKiBFbmFibGUgbGVnYWN5IGxpbmsgYmVoYXZpb3IsIHJlcXVpcmluZyBhbiBgPGE+YCB0YWcgdG8gd3JhcCB0aGUgY2hpbGQgY29udGVudFxuICAgKiBpZiB0aGUgY2hpbGQgaXMgYSBzdHJpbmcgb3IgbnVtYmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MTZcbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2NvbW1pdC80ODllNjVlZDk4NTQ0ZTY5YjBhZmQ3ZTBjZmMzZjlmNmMyYjgwM2I3XG4gICAqL1xuICBsZWdhY3lCZWhhdmlvcj86IGJvb2xlYW5cblxuICAvKipcbiAgICogT3B0aW9uYWwgZXZlbnQgaGFuZGxlciBmb3Igd2hlbiB0aGUgbW91c2UgcG9pbnRlciBpcyBtb3ZlZCBvbnRvIHRoZSBgPExpbms+YC5cbiAgICovXG4gIG9uTW91c2VFbnRlcj86IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyPEhUTUxBbmNob3JFbGVtZW50PlxuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBldmVudCBoYW5kbGVyIGZvciB3aGVuIHRoZSBgPExpbms+YCBpcyB0b3VjaGVkLlxuICAgKi9cbiAgb25Ub3VjaFN0YXJ0PzogUmVhY3QuVG91Y2hFdmVudEhhbmRsZXI8SFRNTEFuY2hvckVsZW1lbnQ+XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGV2ZW50IGhhbmRsZXIgZm9yIHdoZW4gdGhlIGA8TGluaz5gIGlzIGNsaWNrZWQuXG4gICAqL1xuICBvbkNsaWNrPzogUmVhY3QuTW91c2VFdmVudEhhbmRsZXI8SFRNTEFuY2hvckVsZW1lbnQ+XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGV2ZW50IGhhbmRsZXIgZm9yIHdoZW4gdGhlIGA8TGluaz5gIGlzIG5hdmlnYXRlZC5cbiAgICovXG4gIG9uTmF2aWdhdGU/OiBPbk5hdmlnYXRlRXZlbnRIYW5kbGVyXG59XG5cbi8vIFRPRE8tQVBQOiBJbmNsdWRlIHRoZSBmdWxsIHNldCBvZiBBbmNob3IgcHJvcHNcbi8vIGFkZGluZyB0aGlzIHRvIHRoZSBwdWJsaWNseSBleHBvcnRlZCB0eXBlIGN1cnJlbnRseSBicmVha3MgZXhpc3RpbmcgYXBwc1xuXG4vLyBgUm91dGVJbmZlclR5cGVgIGlzIGEgc3R1YiBoZXJlIHRvIGF2b2lkIGJyZWFraW5nIGB0eXBlZFJvdXRlc2Agd2hlbiB0aGUgdHlwZVxuLy8gaXNuJ3QgZ2VuZXJhdGVkIHlldC4gSXQgd2lsbCBiZSByZXBsYWNlZCB3aGVuIHR5cGUgZ2VuZXJhdGlvbiBydW5zLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuZXhwb3J0IHR5cGUgTGlua1Byb3BzPFJvdXRlSW5mZXJUeXBlID0gYW55PiA9IEludGVybmFsTGlua1Byb3BzXG50eXBlIExpbmtQcm9wc1JlcXVpcmVkID0gUmVxdWlyZWRLZXlzPExpbmtQcm9wcz5cbnR5cGUgTGlua1Byb3BzT3B0aW9uYWwgPSBPcHRpb25hbEtleXM8T21pdDxJbnRlcm5hbExpbmtQcm9wcywgJ2xvY2FsZSc+PlxuXG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQpOiBib29sZWFuIHtcbiAgY29uc3QgZXZlbnRUYXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0IGFzIEhUTUxBbmNob3JFbGVtZW50IHwgU1ZHQUVsZW1lbnRcbiAgY29uc3QgdGFyZ2V0ID0gZXZlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKVxuICByZXR1cm4gKFxuICAgICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSAnX3NlbGYnKSB8fFxuICAgIGV2ZW50Lm1ldGFLZXkgfHxcbiAgICBldmVudC5jdHJsS2V5IHx8XG4gICAgZXZlbnQuc2hpZnRLZXkgfHxcbiAgICBldmVudC5hbHRLZXkgfHwgLy8gdHJpZ2dlcnMgcmVzb3VyY2UgZG93bmxvYWRcbiAgICAoZXZlbnQubmF0aXZlRXZlbnQgJiYgZXZlbnQubmF0aXZlRXZlbnQud2hpY2ggPT09IDIpXG4gIClcbn1cblxuZnVuY3Rpb24gbGlua0NsaWNrZWQoXG4gIGU6IFJlYWN0Lk1vdXNlRXZlbnQsXG4gIGhyZWY6IHN0cmluZyxcbiAgYXM6IHN0cmluZyxcbiAgbGlua0luc3RhbmNlUmVmOiBSZWFjdC5SZWZPYmplY3Q8TGlua0luc3RhbmNlIHwgbnVsbD4sXG4gIHJlcGxhY2U/OiBib29sZWFuLFxuICBzY3JvbGw/OiBib29sZWFuLFxuICBvbk5hdmlnYXRlPzogT25OYXZpZ2F0ZUV2ZW50SGFuZGxlclxuKTogdm9pZCB7XG4gIGNvbnN0IHsgbm9kZU5hbWUgfSA9IGUuY3VycmVudFRhcmdldFxuXG4gIC8vIGFuY2hvcnMgaW5zaWRlIGFuIHN2ZyBoYXZlIGEgbG93ZXJjYXNlIG5vZGVOYW1lXG4gIGNvbnN0IGlzQW5jaG9yTm9kZU5hbWUgPSBub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQSdcblxuICBpZiAoXG4gICAgKGlzQW5jaG9yTm9kZU5hbWUgJiYgaXNNb2RpZmllZEV2ZW50KGUpKSB8fFxuICAgIGUuY3VycmVudFRhcmdldC5oYXNBdHRyaWJ1dGUoJ2Rvd25sb2FkJylcbiAgKSB7XG4gICAgLy8gaWdub3JlIGNsaWNrIGZvciBicm93c2Vy4oCZcyBkZWZhdWx0IGJlaGF2aW9yXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoIWlzTG9jYWxVUkwoaHJlZikpIHtcbiAgICBpZiAocmVwbGFjZSkge1xuICAgICAgLy8gYnJvd3NlciBkZWZhdWx0IGJlaGF2aW9yIGRvZXMgbm90IHJlcGxhY2UgdGhlIGhpc3Rvcnkgc3RhdGVcbiAgICAgIC8vIHNvIHdlIG5lZWQgdG8gZG8gaXQgbWFudWFsbHlcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgbG9jYXRpb24ucmVwbGFjZShocmVmKVxuICAgIH1cblxuICAgIC8vIGlnbm9yZSBjbGljayBmb3IgYnJvd3NlcuKAmXMgZGVmYXVsdCBiZWhhdmlvclxuICAgIHJldHVyblxuICB9XG5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgaWYgKG9uTmF2aWdhdGUpIHtcbiAgICBsZXQgaXNEZWZhdWx0UHJldmVudGVkID0gZmFsc2VcblxuICAgIG9uTmF2aWdhdGUoe1xuICAgICAgcHJldmVudERlZmF1bHQ6ICgpID0+IHtcbiAgICAgICAgaXNEZWZhdWx0UHJldmVudGVkID0gdHJ1ZVxuICAgICAgfSxcbiAgICB9KVxuXG4gICAgaWYgKGlzRGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgUmVhY3Quc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICBkaXNwYXRjaE5hdmlnYXRlQWN0aW9uKFxuICAgICAgYXMgfHwgaHJlZixcbiAgICAgIHJlcGxhY2UgPyAncmVwbGFjZScgOiAncHVzaCcsXG4gICAgICBzY3JvbGwgPz8gdHJ1ZSxcbiAgICAgIGxpbmtJbnN0YW5jZVJlZi5jdXJyZW50XG4gICAgKVxuICB9KVxufVxuXG5mdW5jdGlvbiBmb3JtYXRTdHJpbmdPclVybCh1cmxPYmpPclN0cmluZzogVXJsT2JqZWN0IHwgc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKHR5cGVvZiB1cmxPYmpPclN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdXJsT2JqT3JTdHJpbmdcbiAgfVxuXG4gIHJldHVybiBmb3JtYXRVcmwodXJsT2JqT3JTdHJpbmcpXG59XG5cbi8qKlxuICogQSBSZWFjdCBjb21wb25lbnQgdGhhdCBleHRlbmRzIHRoZSBIVE1MIGA8YT5gIGVsZW1lbnQgdG8gcHJvdmlkZVxuICogW3ByZWZldGNoaW5nXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yb3V0aW5nL2xpbmtpbmctYW5kLW5hdmlnYXRpbmcjMi1wcmVmZXRjaGluZylcbiAqIGFuZCBjbGllbnQtc2lkZSBuYXZpZ2F0aW9uLiBUaGlzIGlzIHRoZSBwcmltYXJ5IHdheSB0byBuYXZpZ2F0ZSBiZXR3ZWVuIHJvdXRlcyBpbiBOZXh0LmpzLlxuICpcbiAqIEByZW1hcmtzXG4gKiAtIFByZWZldGNoaW5nIGlzIG9ubHkgZW5hYmxlZCBpbiBwcm9kdWN0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9saW5rXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIExpbmtDb21wb25lbnQoXG4gIHByb3BzOiBMaW5rUHJvcHMgJiB7XG4gICAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxuICAgIHJlZjogUmVhY3QuUmVmPEhUTUxBbmNob3JFbGVtZW50PlxuICB9XG4pIHtcbiAgY29uc3QgW2xpbmtTdGF0dXMsIHNldE9wdGltaXN0aWNMaW5rU3RhdHVzXSA9IHVzZU9wdGltaXN0aWMoSURMRV9MSU5LX1NUQVRVUylcblxuICBsZXQgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxuXG4gIGNvbnN0IGxpbmtJbnN0YW5jZVJlZiA9IHVzZVJlZjxMaW5rSW5zdGFuY2UgfCBudWxsPihudWxsKVxuXG4gIGNvbnN0IHtcbiAgICBocmVmOiBocmVmUHJvcCxcbiAgICBhczogYXNQcm9wLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblByb3AsXG4gICAgcHJlZmV0Y2g6IHByZWZldGNoUHJvcCA9IG51bGwsXG4gICAgcGFzc0hyZWYsXG4gICAgcmVwbGFjZSxcbiAgICBzaGFsbG93LFxuICAgIHNjcm9sbCxcbiAgICBvbkNsaWNrLFxuICAgIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVyUHJvcCxcbiAgICBvblRvdWNoU3RhcnQ6IG9uVG91Y2hTdGFydFByb3AsXG4gICAgbGVnYWN5QmVoYXZpb3IgPSBmYWxzZSxcbiAgICBvbk5hdmlnYXRlLFxuICAgIHJlZjogZm9yd2FyZGVkUmVmLFxuICAgIHVuc3RhYmxlX2R5bmFtaWNPbkhvdmVyLFxuICAgIC4uLnJlc3RQcm9wc1xuICB9ID0gcHJvcHNcblxuICBjaGlsZHJlbiA9IGNoaWxkcmVuUHJvcFxuXG4gIGlmIChcbiAgICBsZWdhY3lCZWhhdmlvciAmJlxuICAgICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZHJlbiA9PT0gJ251bWJlcicpXG4gICkge1xuICAgIGNoaWxkcmVuID0gPGE+e2NoaWxkcmVufTwvYT5cbiAgfVxuXG4gIGNvbnN0IHJvdXRlciA9IFJlYWN0LnVzZUNvbnRleHQoQXBwUm91dGVyQ29udGV4dClcblxuICBjb25zdCBwcmVmZXRjaEVuYWJsZWQgPSBwcmVmZXRjaFByb3AgIT09IGZhbHNlXG5cbiAgY29uc3QgZmV0Y2hTdHJhdGVneSA9XG4gICAgcHJlZmV0Y2hQcm9wICE9PSBmYWxzZVxuICAgICAgPyBnZXRGZXRjaFN0cmF0ZWd5RnJvbVByZWZldGNoUHJvcChwcmVmZXRjaFByb3ApXG4gICAgICA6IC8vIFRPRE86IGl0IG1ha2VzIG5vIHNlbnNlIHRvIGFzc2lnbiBhIGZldGNoU3RyYXRlZ3kgd2hlbiBwcmVmZXRjaGluZyBpcyBkaXNhYmxlZC5cbiAgICAgICAgRmV0Y2hTdHJhdGVneS5QUFJcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVByb3BFcnJvcihhcmdzOiB7XG4gICAgICBrZXk6IHN0cmluZ1xuICAgICAgZXhwZWN0ZWQ6IHN0cmluZ1xuICAgICAgYWN0dWFsOiBzdHJpbmdcbiAgICB9KSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHByb3AgdHlwZTogVGhlIHByb3AgXFxgJHthcmdzLmtleX1cXGAgZXhwZWN0cyBhICR7YXJncy5leHBlY3RlZH0gaW4gXFxgPExpbms+XFxgLCBidXQgZ290IFxcYCR7YXJncy5hY3R1YWx9XFxgIGluc3RlYWQuYCArXG4gICAgICAgICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IFwiXFxuT3BlbiB5b3VyIGJyb3dzZXIncyBjb25zb2xlIHRvIHZpZXcgdGhlIENvbXBvbmVudCBzdGFjayB0cmFjZS5cIlxuICAgICAgICAgICAgOiAnJylcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgIGNvbnN0IHJlcXVpcmVkUHJvcHNHdWFyZDogUmVjb3JkPExpbmtQcm9wc1JlcXVpcmVkLCB0cnVlPiA9IHtcbiAgICAgIGhyZWY6IHRydWUsXG4gICAgfSBhcyBjb25zdFxuICAgIGNvbnN0IHJlcXVpcmVkUHJvcHM6IExpbmtQcm9wc1JlcXVpcmVkW10gPSBPYmplY3Qua2V5cyhcbiAgICAgIHJlcXVpcmVkUHJvcHNHdWFyZFxuICAgICkgYXMgTGlua1Byb3BzUmVxdWlyZWRbXVxuICAgIHJlcXVpcmVkUHJvcHMuZm9yRWFjaCgoa2V5OiBMaW5rUHJvcHNSZXF1aXJlZCkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gJ2hyZWYnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9wc1trZXldID09IG51bGwgfHxcbiAgICAgICAgICAodHlwZW9mIHByb3BzW2tleV0gIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwcm9wc1trZXldICE9PSAnb2JqZWN0JylcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2Agb3IgYG9iamVjdGAnLFxuICAgICAgICAgICAgYWN0dWFsOiBwcm9wc1trZXldID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHByb3BzW2tleV0sXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBjb25zdCBfOiBuZXZlciA9IGtleVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgIGNvbnN0IG9wdGlvbmFsUHJvcHNHdWFyZDogUmVjb3JkPExpbmtQcm9wc09wdGlvbmFsLCB0cnVlPiA9IHtcbiAgICAgIGFzOiB0cnVlLFxuICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgIHNjcm9sbDogdHJ1ZSxcbiAgICAgIHNoYWxsb3c6IHRydWUsXG4gICAgICBwYXNzSHJlZjogdHJ1ZSxcbiAgICAgIHByZWZldGNoOiB0cnVlLFxuICAgICAgdW5zdGFibGVfZHluYW1pY09uSG92ZXI6IHRydWUsXG4gICAgICBvbkNsaWNrOiB0cnVlLFxuICAgICAgb25Nb3VzZUVudGVyOiB0cnVlLFxuICAgICAgb25Ub3VjaFN0YXJ0OiB0cnVlLFxuICAgICAgbGVnYWN5QmVoYXZpb3I6IHRydWUsXG4gICAgICBvbk5hdmlnYXRlOiB0cnVlLFxuICAgIH0gYXMgY29uc3RcbiAgICBjb25zdCBvcHRpb25hbFByb3BzOiBMaW5rUHJvcHNPcHRpb25hbFtdID0gT2JqZWN0LmtleXMoXG4gICAgICBvcHRpb25hbFByb3BzR3VhcmRcbiAgICApIGFzIExpbmtQcm9wc09wdGlvbmFsW11cbiAgICBvcHRpb25hbFByb3BzLmZvckVhY2goKGtleTogTGlua1Byb3BzT3B0aW9uYWwpID0+IHtcbiAgICAgIGNvbnN0IHZhbFR5cGUgPSB0eXBlb2YgcHJvcHNba2V5XVxuXG4gICAgICBpZiAoa2V5ID09PSAnYXMnKSB7XG4gICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09ICdzdHJpbmcnICYmIHZhbFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2Agb3IgYG9iamVjdGAnLFxuICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGtleSA9PT0gJ29uQ2xpY2snIHx8XG4gICAgICAgIGtleSA9PT0gJ29uTW91c2VFbnRlcicgfHxcbiAgICAgICAga2V5ID09PSAnb25Ub3VjaFN0YXJ0JyB8fFxuICAgICAgICBrZXkgPT09ICdvbk5hdmlnYXRlJ1xuICAgICAgKSB7XG4gICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgZnVuY3Rpb25gJyxcbiAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBrZXkgPT09ICdyZXBsYWNlJyB8fFxuICAgICAgICBrZXkgPT09ICdzY3JvbGwnIHx8XG4gICAgICAgIGtleSA9PT0gJ3NoYWxsb3cnIHx8XG4gICAgICAgIGtleSA9PT0gJ3Bhc3NIcmVmJyB8fFxuICAgICAgICBrZXkgPT09ICdsZWdhY3lCZWhhdmlvcicgfHxcbiAgICAgICAga2V5ID09PSAndW5zdGFibGVfZHluYW1pY09uSG92ZXInXG4gICAgICApIHtcbiAgICAgICAgaWYgKHByb3BzW2tleV0gIT0gbnVsbCAmJiB2YWxUeXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgYm9vbGVhbmAnLFxuICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAncHJlZmV0Y2gnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9wc1trZXldICE9IG51bGwgJiZcbiAgICAgICAgICB2YWxUeXBlICE9PSAnYm9vbGVhbicgJiZcbiAgICAgICAgICBwcm9wc1trZXldICE9PSAnYXV0bycgJiZcbiAgICAgICAgICBwcm9wc1trZXldICE9PSAndW5zdGFibGVfZm9yY2VTdGFsZSdcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnYGJvb2xlYW4gfCBcImF1dG9cIiB8IFwidW5zdGFibGVfZm9yY2VTdGFsZVwiYCcsXG4gICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGUsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBjb25zdCBfOiBuZXZlciA9IGtleVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChwcm9wcy5sb2NhbGUpIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICAnVGhlIGBsb2NhbGVgIHByb3AgaXMgbm90IHN1cHBvcnRlZCBpbiBgbmV4dC9saW5rYCB3aGlsZSB1c2luZyB0aGUgYGFwcGAgcm91dGVyLiBSZWFkIG1vcmUgYWJvdXQgYXBwIHJvdXRlciBpbnRlcm5hbGl6YXRpb246IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JvdXRpbmcvaW50ZXJuYXRpb25hbGl6YXRpb24nXG4gICAgICApXG4gICAgfVxuICAgIGlmICghYXNQcm9wKSB7XG4gICAgICBsZXQgaHJlZjogc3RyaW5nIHwgdW5kZWZpbmVkXG4gICAgICBpZiAodHlwZW9mIGhyZWZQcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICBocmVmID0gaHJlZlByb3BcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHR5cGVvZiBocmVmUHJvcCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdHlwZW9mIGhyZWZQcm9wLnBhdGhuYW1lID09PSAnc3RyaW5nJ1xuICAgICAgKSB7XG4gICAgICAgIGhyZWYgPSBocmVmUHJvcC5wYXRobmFtZVxuICAgICAgfVxuXG4gICAgICBpZiAoaHJlZikge1xuICAgICAgICBjb25zdCBoYXNEeW5hbWljU2VnbWVudCA9IGhyZWZcbiAgICAgICAgICAuc3BsaXQoJy8nKVxuICAgICAgICAgIC5zb21lKChzZWdtZW50KSA9PiBzZWdtZW50LnN0YXJ0c1dpdGgoJ1snKSAmJiBzZWdtZW50LmVuZHNXaXRoKCddJykpXG5cbiAgICAgICAgaWYgKGhhc0R5bmFtaWNTZWdtZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYER5bmFtaWMgaHJlZiBcXGAke2hyZWZ9XFxgIGZvdW5kIGluIDxMaW5rPiB3aGlsZSB1c2luZyB0aGUgXFxgL2FwcFxcYCByb3V0ZXIsIHRoaXMgaXMgbm90IHN1cHBvcnRlZC4gUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9hcHAtZGlyLWR5bmFtaWMtaHJlZmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCB7IGhyZWYsIGFzIH0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCByZXNvbHZlZEhyZWYgPSBmb3JtYXRTdHJpbmdPclVybChocmVmUHJvcClcbiAgICByZXR1cm4ge1xuICAgICAgaHJlZjogcmVzb2x2ZWRIcmVmLFxuICAgICAgYXM6IGFzUHJvcCA/IGZvcm1hdFN0cmluZ09yVXJsKGFzUHJvcCkgOiByZXNvbHZlZEhyZWYsXG4gICAgfVxuICB9LCBbaHJlZlByb3AsIGFzUHJvcF0pXG5cbiAgLy8gVGhpcyB3aWxsIHJldHVybiB0aGUgZmlyc3QgY2hpbGQsIGlmIG11bHRpcGxlIGFyZSBwcm92aWRlZCBpdCB3aWxsIHRocm93IGFuIGVycm9yXG4gIGxldCBjaGlsZDogYW55XG4gIGlmIChsZWdhY3lCZWhhdmlvcikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBcIm9uQ2xpY2tcIiB3YXMgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IFwibGVnYWN5QmVoYXZpb3JcIiB3YXMgc2V0LiBUaGUgbGVnYWN5IGJlaGF2aW9yIHJlcXVpcmVzIG9uQ2xpY2sgYmUgc2V0IG9uIHRoZSBjaGlsZCBvZiBuZXh0L2xpbmtgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmIChvbk1vdXNlRW50ZXJQcm9wKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgXCJvbk1vdXNlRW50ZXJcIiB3YXMgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IFwibGVnYWN5QmVoYXZpb3JcIiB3YXMgc2V0LiBUaGUgbGVnYWN5IGJlaGF2aW9yIHJlcXVpcmVzIG9uTW91c2VFbnRlciBiZSBzZXQgb24gdGhlIGNoaWxkIG9mIG5leHQvbGlua2BcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY2hpbGQgPSBSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgTm8gY2hpbGRyZW4gd2VyZSBwYXNzZWQgdG8gPExpbms+IHdpdGggXFxgaHJlZlxcYCBvZiBcXGAke2hyZWZQcm9wfVxcYCBidXQgb25lIGNoaWxkIGlzIHJlcXVpcmVkIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2xpbmstbm8tY2hpbGRyZW5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgTXVsdGlwbGUgY2hpbGRyZW4gd2VyZSBwYXNzZWQgdG8gPExpbms+IHdpdGggXFxgaHJlZlxcYCBvZiBcXGAke2hyZWZQcm9wfVxcYCBidXQgb25seSBvbmUgY2hpbGQgaXMgc3VwcG9ydGVkIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2xpbmstbXVsdGlwbGUtY2hpbGRyZW5gICtcbiAgICAgICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICA/IFwiIFxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCJcbiAgICAgICAgICAgICAgOiAnJylcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZCA9IFJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgaWYgKChjaGlsZHJlbiBhcyBhbnkpPy50eXBlID09PSAnYScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIDxMaW5rPiB3aXRoIDxhPiBjaGlsZC4gUGxlYXNlIHJlbW92ZSA8YT4gb3IgdXNlIDxMaW5rIGxlZ2FjeUJlaGF2aW9yPi5cXG5MZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLW5ldy1saW5rLXdpdGgtZXh0cmEtYW5jaG9yJ1xuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgY2hpbGRSZWY6IGFueSA9IGxlZ2FjeUJlaGF2aW9yXG4gICAgPyBjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnICYmIGNoaWxkLnJlZlxuICAgIDogZm9yd2FyZGVkUmVmXG5cbiAgLy8gVXNlIGEgY2FsbGJhY2sgcmVmIHRvIGF0dGFjaCBhbiBJbnRlcnNlY3Rpb25PYnNlcnZlciB0byB0aGUgYW5jaG9yIHRhZyBvblxuICAvLyBtb3VudC4gSW4gdGhlIGZ1dHVyZSB3ZSB3aWxsIGFsc28gdXNlIHRoaXMgdG8ga2VlcCB0cmFjayBvZiBhbGwgdGhlXG4gIC8vIGN1cnJlbnRseSBtb3VudGVkIDxMaW5rPiBpbnN0YW5jZXMsIGUuZy4gc28gd2UgY2FuIHJlLXByZWZldGNoIHRoZW0gYWZ0ZXJcbiAgLy8gYSByZXZhbGlkYXRpb24gb3IgcmVmcmVzaC5cbiAgY29uc3Qgb2JzZXJ2ZUxpbmtWaXNpYmlsaXR5T25Nb3VudCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChlbGVtZW50OiBIVE1MQW5jaG9yRWxlbWVudCB8IFNWR0FFbGVtZW50KSA9PiB7XG4gICAgICBpZiAocm91dGVyICE9PSBudWxsKSB7XG4gICAgICAgIGxpbmtJbnN0YW5jZVJlZi5jdXJyZW50ID0gbW91bnRMaW5rSW5zdGFuY2UoXG4gICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICBocmVmLFxuICAgICAgICAgIHJvdXRlcixcbiAgICAgICAgICBmZXRjaFN0cmF0ZWd5LFxuICAgICAgICAgIHByZWZldGNoRW5hYmxlZCxcbiAgICAgICAgICBzZXRPcHRpbWlzdGljTGlua1N0YXR1c1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChsaW5rSW5zdGFuY2VSZWYuY3VycmVudCkge1xuICAgICAgICAgIHVubW91bnRMaW5rRm9yQ3VycmVudE5hdmlnYXRpb24obGlua0luc3RhbmNlUmVmLmN1cnJlbnQpXG4gICAgICAgICAgbGlua0luc3RhbmNlUmVmLmN1cnJlbnQgPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgdW5tb3VudFByZWZldGNoYWJsZUluc3RhbmNlKGVsZW1lbnQpXG4gICAgICB9XG4gICAgfSxcbiAgICBbcHJlZmV0Y2hFbmFibGVkLCBocmVmLCByb3V0ZXIsIGZldGNoU3RyYXRlZ3ksIHNldE9wdGltaXN0aWNMaW5rU3RhdHVzXVxuICApXG5cbiAgY29uc3QgbWVyZ2VkUmVmID0gdXNlTWVyZ2VkUmVmKG9ic2VydmVMaW5rVmlzaWJpbGl0eU9uTW91bnQsIGNoaWxkUmVmKVxuXG4gIGNvbnN0IGNoaWxkUHJvcHM6IHtcbiAgICBvblRvdWNoU3RhcnQ/OiBSZWFjdC5Ub3VjaEV2ZW50SGFuZGxlcjxIVE1MQW5jaG9yRWxlbWVudD5cbiAgICBvbk1vdXNlRW50ZXI6IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyPEhUTUxBbmNob3JFbGVtZW50PlxuICAgIG9uQ2xpY2s6IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyPEhUTUxBbmNob3JFbGVtZW50PlxuICAgIGhyZWY/OiBzdHJpbmdcbiAgICByZWY/OiBhbnlcbiAgfSA9IHtcbiAgICByZWY6IG1lcmdlZFJlZixcbiAgICBvbkNsaWNrKGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICghZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBDb21wb25lbnQgcmVuZGVyZWQgaW5zaWRlIG5leHQvbGluayBoYXMgdG8gcGFzcyBjbGljayBldmVudCB0byBcIm9uQ2xpY2tcIiBwcm9wLmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFsZWdhY3lCZWhhdmlvciAmJiB0eXBlb2Ygb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvbkNsaWNrKGUpXG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgbGVnYWN5QmVoYXZpb3IgJiZcbiAgICAgICAgY2hpbGQucHJvcHMgJiZcbiAgICAgICAgdHlwZW9mIGNoaWxkLnByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbidcbiAgICAgICkge1xuICAgICAgICBjaGlsZC5wcm9wcy5vbkNsaWNrKGUpXG4gICAgICB9XG5cbiAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBsaW5rQ2xpY2tlZChlLCBocmVmLCBhcywgbGlua0luc3RhbmNlUmVmLCByZXBsYWNlLCBzY3JvbGwsIG9uTmF2aWdhdGUpXG4gICAgfSxcbiAgICBvbk1vdXNlRW50ZXIoZSkge1xuICAgICAgaWYgKCFsZWdhY3lCZWhhdmlvciAmJiB0eXBlb2Ygb25Nb3VzZUVudGVyUHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvbk1vdXNlRW50ZXJQcm9wKGUpXG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgbGVnYWN5QmVoYXZpb3IgJiZcbiAgICAgICAgY2hpbGQucHJvcHMgJiZcbiAgICAgICAgdHlwZW9mIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgKSB7XG4gICAgICAgIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlcihlKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKCFwcmVmZXRjaEVuYWJsZWQgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVwZ3JhZGVUb0R5bmFtaWNQcmVmZXRjaCA9IHVuc3RhYmxlX2R5bmFtaWNPbkhvdmVyID09PSB0cnVlXG4gICAgICBvbk5hdmlnYXRpb25JbnRlbnQoXG4gICAgICAgIGUuY3VycmVudFRhcmdldCBhcyBIVE1MQW5jaG9yRWxlbWVudCB8IFNWR0FFbGVtZW50LFxuICAgICAgICB1cGdyYWRlVG9EeW5hbWljUHJlZmV0Y2hcbiAgICAgIClcbiAgICB9LFxuICAgIG9uVG91Y2hTdGFydDogcHJvY2Vzcy5lbnYuX19ORVhUX0xJTktfTk9fVE9VQ0hfU1RBUlRcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XG4gICAgICAgICAgaWYgKCFsZWdhY3lCZWhhdmlvciAmJiB0eXBlb2Ygb25Ub3VjaFN0YXJ0UHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb25Ub3VjaFN0YXJ0UHJvcChlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGxlZ2FjeUJlaGF2aW9yICYmXG4gICAgICAgICAgICBjaGlsZC5wcm9wcyAmJlxuICAgICAgICAgICAgdHlwZW9mIGNoaWxkLnByb3BzLm9uVG91Y2hTdGFydCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgY2hpbGQucHJvcHMub25Ub3VjaFN0YXJ0KGUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghcHJlZmV0Y2hFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB1cGdyYWRlVG9EeW5hbWljUHJlZmV0Y2ggPSB1bnN0YWJsZV9keW5hbWljT25Ib3ZlciA9PT0gdHJ1ZVxuICAgICAgICAgIG9uTmF2aWdhdGlvbkludGVudChcbiAgICAgICAgICAgIGUuY3VycmVudFRhcmdldCBhcyBIVE1MQW5jaG9yRWxlbWVudCB8IFNWR0FFbGVtZW50LFxuICAgICAgICAgICAgdXBncmFkZVRvRHluYW1pY1ByZWZldGNoXG4gICAgICAgICAgKVxuICAgICAgICB9LFxuICB9XG5cbiAgLy8gSWYgY2hpbGQgaXMgYW4gPGE+IHRhZyBhbmQgZG9lc24ndCBoYXZlIGEgaHJlZiBhdHRyaWJ1dGUsIG9yIGlmIHRoZSAncGFzc0hyZWYnIHByb3BlcnR5IGlzXG4gIC8vIGRlZmluZWQsIHdlIHNwZWNpZnkgdGhlIGN1cnJlbnQgJ2hyZWYnLCBzbyB0aGF0IHJlcGV0aXRpb24gaXMgbm90IG5lZWRlZCBieSB0aGUgdXNlci5cbiAgLy8gSWYgdGhlIHVybCBpcyBhYnNvbHV0ZSwgd2UgY2FuIGJ5cGFzcyB0aGUgbG9naWMgdG8gcHJlcGVuZCB0aGUgYmFzZVBhdGguXG4gIGlmIChpc0Fic29sdXRlVXJsKGFzKSkge1xuICAgIGNoaWxkUHJvcHMuaHJlZiA9IGFzXG4gIH0gZWxzZSBpZiAoXG4gICAgIWxlZ2FjeUJlaGF2aW9yIHx8XG4gICAgcGFzc0hyZWYgfHxcbiAgICAoY2hpbGQudHlwZSA9PT0gJ2EnICYmICEoJ2hyZWYnIGluIGNoaWxkLnByb3BzKSlcbiAgKSB7XG4gICAgY2hpbGRQcm9wcy5ocmVmID0gYWRkQmFzZVBhdGgoYXMpXG4gIH1cblxuICBsZXQgbGluazogUmVhY3QuUmVhY3ROb2RlXG5cbiAgaWYgKGxlZ2FjeUJlaGF2aW9yKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBlcnJvck9uY2UoXG4gICAgICAgICdgbGVnYWN5QmVoYXZpb3JgIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSAnICtcbiAgICAgICAgICAncmVsZWFzZS4gQSBjb2RlbW9kIGlzIGF2YWlsYWJsZSB0byB1cGdyYWRlIHlvdXIgY29tcG9uZW50czpcXG5cXG4nICtcbiAgICAgICAgICAnbnB4IEBuZXh0L2NvZGVtb2RAbGF0ZXN0IG5ldy1saW5rIC5cXG5cXG4nICtcbiAgICAgICAgICAnTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vdXBncmFkaW5nL2NvZGVtb2RzI3JlbW92ZS1hLXRhZ3MtZnJvbS1saW5rLWNvbXBvbmVudHMnXG4gICAgICApXG4gICAgfVxuICAgIGxpbmsgPSBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIGNoaWxkUHJvcHMpXG4gIH0gZWxzZSB7XG4gICAgbGluayA9IChcbiAgICAgIDxhIHsuLi5yZXN0UHJvcHN9IHsuLi5jaGlsZFByb3BzfT5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9hPlxuICAgIClcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPExpbmtTdGF0dXNDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtsaW5rU3RhdHVzfT5cbiAgICAgIHtsaW5rfVxuICAgIDwvTGlua1N0YXR1c0NvbnRleHQuUHJvdmlkZXI+XG4gIClcbn1cblxuY29uc3QgTGlua1N0YXR1c0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PFxuICB0eXBlb2YgUEVORElOR19MSU5LX1NUQVRVUyB8IHR5cGVvZiBJRExFX0xJTktfU1RBVFVTXG4+KElETEVfTElOS19TVEFUVVMpXG5cbmV4cG9ydCBjb25zdCB1c2VMaW5rU3RhdHVzID0gKCkgPT4ge1xuICByZXR1cm4gdXNlQ29udGV4dChMaW5rU3RhdHVzQ29udGV4dClcbn1cblxuZnVuY3Rpb24gZ2V0RmV0Y2hTdHJhdGVneUZyb21QcmVmZXRjaFByb3AoXG4gIHByZWZldGNoUHJvcDogRXhjbHVkZTxMaW5rUHJvcHNbJ3ByZWZldGNoJ10sIHVuZGVmaW5lZCB8IGZhbHNlPlxuKTogUHJlZmV0Y2hUYXNrRmV0Y2hTdHJhdGVneSB7XG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5fX05FWFRfQ0FDSEVfQ09NUE9ORU5UUyAmJlxuICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRVxuICApIHtcbiAgICAvLyBJbiB0aGUgbmV3IGltcGxlbWVudGF0aW9uOlxuICAgIC8vIC0gYHByZWZldGNoPXt0cnVlfWAgaXMgYSBydW50aW1lIHByZWZldGNoXG4gICAgLy8gICAoaW5jbHVkZXMgY2FjaGVkIElPICsgcGFyYW1zICsgY29va2llcywgd2l0aCBkeW5hbWljIGhvbGVzIGZvciB1bmNhY2hlZCBJTykuXG4gICAgLy8gLSBgdW5zdGFibGVfZm9yY2VTdGFsZWAgaXMgYSBcImZ1bGxcIiBwcmVmZXRjaFxuICAgIC8vICAgKGZvcmNlcyBpbmNsdXNpb24gb2YgYWxsIGR5bmFtaWMgZGF0YSwgaS5lLiB0aGUgb2xkIGJlaGF2aW9yIG9mIGBwcmVmZXRjaD17dHJ1ZX1gKVxuICAgIGlmIChwcmVmZXRjaFByb3AgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBGZXRjaFN0cmF0ZWd5LlBQUlJ1bnRpbWVcbiAgICB9XG4gICAgaWYgKHByZWZldGNoUHJvcCA9PT0gJ3Vuc3RhYmxlX2ZvcmNlU3RhbGUnKSB7XG4gICAgICByZXR1cm4gRmV0Y2hTdHJhdGVneS5GdWxsXG4gICAgfVxuXG4gICAgLy8gYG51bGxgIG9yIGBcImF1dG9cImA6IHRoaXMgaXMgdGhlIGRlZmF1bHQgXCJhdXRvXCIgbW9kZSwgd2hlcmUgd2Ugd2lsbCBwcmVmZXRjaCBwYXJ0aWFsbHkgaWYgdGhlIGxpbmsgaXMgaW4gdGhlIHZpZXdwb3J0LlxuICAgIC8vIFRoaXMgd2lsbCBhbHNvIGluY2x1ZGUgaW52YWxpZCBwcm9wIHZhbHVlcyB0aGF0IGRvbid0IG1hdGNoIHRoZSB0eXBlcyBzcGVjaWZpZWQgaGVyZS5cbiAgICAvLyAoYWx0aG91Z2ggdGhvc2Ugc2hvdWxkJ3ZlIGJlZW4gZmlsdGVyZWQgb3V0IGJ5IHByb3AgdmFsaWRhdGlvbiBpbiBkZXYpXG4gICAgcHJlZmV0Y2hQcm9wIHNhdGlzZmllcyBudWxsIHwgJ2F1dG8nXG4gICAgLy8gSW4gYGNsaWVudFNlZ21lbnRDYWNoZWAsIHdlIGRlZmF1bHQgdG8gUFBSLCBhbmQgd2UnbGwgZGlzY292ZXIgd2hldGhlciBvciBub3QgdGhlIHJvdXRlIHN1cHBvcnRzIGl0IHdpdGggdGhlIGluaXRpYWwgcHJlZmV0Y2guXG4gICAgLy8gSWYgd2UncmUgbm90IHVzaW5nIGBjbGllbnRTZWdtZW50Q2FjaGVgLCB0aGlzIHdpbGwgYmUgY29udmVydGVkIGludG8gYSBgUHJlZmV0Y2hLaW5kLkFVVE9gLlxuICAgIHJldHVybiBGZXRjaFN0cmF0ZWd5LlBQUlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmVmZXRjaFByb3AgPT09IG51bGwgfHwgcHJlZmV0Y2hQcm9wID09PSAnYXV0bydcbiAgICAgID8gLy8gSW4gYGNsaWVudFNlZ21lbnRDYWNoZWAsIHdlIGRlZmF1bHQgdG8gUFBSLCBhbmQgd2UnbGwgZGlzY292ZXIgd2hldGhlciBvciBub3QgdGhlIHJvdXRlIHN1cHBvcnRzIGl0IHdpdGggdGhlIGluaXRpYWwgcHJlZmV0Y2guXG4gICAgICAgIC8vIElmIHdlJ3JlIG5vdCB1c2luZyBgY2xpZW50U2VnbWVudENhY2hlYCwgdGhpcyB3aWxsIGJlIGNvbnZlcnRlZCBpbnRvIGEgYFByZWZldGNoS2luZC5BVVRPYC5cbiAgICAgICAgRmV0Y2hTdHJhdGVneS5QUFJcbiAgICAgIDogLy8gSW4gdGhlIG9sZCBpbXBsZW1lbnRhdGlvbiB3aXRob3V0IHJ1bnRpbWUgcHJlZmV0Y2hlcywgYHByZWZldGNoPXt0cnVlfWAgZm9yY2VzIGFsbCBkeW5hbWljIGRhdGEgdG8gYmUgcHJlZmV0Y2hlZC5cbiAgICAgICAgLy8gVG8gcHJlc2VydmUgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIGFueXRoaW5nIG90aGVyIHRoYW4gYGZhbHNlYCwgYG51bGxgLCBvciBgXCJhdXRvXCJgIHJlc3VsdHMgaW4gYSBmdWxsIHByZWZldGNoLlxuICAgICAgICAvLyAoYWx0aG91Z2ggaW52YWxpZCB2YWx1ZXMgc2hvdWxkJ3ZlIGJlZW4gZmlsdGVyZWQgb3V0IGJ5IHByb3AgdmFsaWRhdGlvbiBpbiBkZXYpXG4gICAgICAgIEZldGNoU3RyYXRlZ3kuRnVsbFxuICB9XG59XG4iXSwibmFtZXMiOlsiTGlua0NvbXBvbmVudCIsInVzZUxpbmtTdGF0dXMiLCJpc01vZGlmaWVkRXZlbnQiLCJldmVudCIsImV2ZW50VGFyZ2V0IiwiY3VycmVudFRhcmdldCIsInRhcmdldCIsImdldEF0dHJpYnV0ZSIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJuYXRpdmVFdmVudCIsIndoaWNoIiwibGlua0NsaWNrZWQiLCJlIiwiaHJlZiIsImFzIiwibGlua0luc3RhbmNlUmVmIiwicmVwbGFjZSIsInNjcm9sbCIsIm9uTmF2aWdhdGUiLCJub2RlTmFtZSIsImlzQW5jaG9yTm9kZU5hbWUiLCJ0b1VwcGVyQ2FzZSIsImhhc0F0dHJpYnV0ZSIsImlzTG9jYWxVUkwiLCJwcmV2ZW50RGVmYXVsdCIsImxvY2F0aW9uIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiUmVhY3QiLCJzdGFydFRyYW5zaXRpb24iLCJkaXNwYXRjaE5hdmlnYXRlQWN0aW9uIiwiY3VycmVudCIsImZvcm1hdFN0cmluZ09yVXJsIiwidXJsT2JqT3JTdHJpbmciLCJmb3JtYXRVcmwiLCJwcm9wcyIsImxpbmtTdGF0dXMiLCJzZXRPcHRpbWlzdGljTGlua1N0YXR1cyIsInVzZU9wdGltaXN0aWMiLCJJRExFX0xJTktfU1RBVFVTIiwiY2hpbGRyZW4iLCJ1c2VSZWYiLCJocmVmUHJvcCIsImFzUHJvcCIsImNoaWxkcmVuUHJvcCIsInByZWZldGNoIiwicHJlZmV0Y2hQcm9wIiwicGFzc0hyZWYiLCJzaGFsbG93Iiwib25DbGljayIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VFbnRlclByb3AiLCJvblRvdWNoU3RhcnQiLCJvblRvdWNoU3RhcnRQcm9wIiwibGVnYWN5QmVoYXZpb3IiLCJyZWYiLCJmb3J3YXJkZWRSZWYiLCJ1bnN0YWJsZV9keW5hbWljT25Ib3ZlciIsInJlc3RQcm9wcyIsImEiLCJyb3V0ZXIiLCJ1c2VDb250ZXh0IiwiQXBwUm91dGVyQ29udGV4dCIsInByZWZldGNoRW5hYmxlZCIsImZldGNoU3RyYXRlZ3kiLCJnZXRGZXRjaFN0cmF0ZWd5RnJvbVByZWZldGNoUHJvcCIsIkZldGNoU3RyYXRlZ3kiLCJQUFIiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJjcmVhdGVQcm9wRXJyb3IiLCJhcmdzIiwiRXJyb3IiLCJrZXkiLCJleHBlY3RlZCIsImFjdHVhbCIsIndpbmRvdyIsInJlcXVpcmVkUHJvcHNHdWFyZCIsInJlcXVpcmVkUHJvcHMiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsIl8iLCJvcHRpb25hbFByb3BzR3VhcmQiLCJvcHRpb25hbFByb3BzIiwidmFsVHlwZSIsImxvY2FsZSIsIndhcm5PbmNlIiwicGF0aG5hbWUiLCJoYXNEeW5hbWljU2VnbWVudCIsInNwbGl0Iiwic29tZSIsInNlZ21lbnQiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJ1c2VNZW1vIiwicmVzb2x2ZWRIcmVmIiwiY2hpbGQiLCJjb25zb2xlIiwid2FybiIsIkNoaWxkcmVuIiwib25seSIsImVyciIsInR5cGUiLCJjaGlsZFJlZiIsIm9ic2VydmVMaW5rVmlzaWJpbGl0eU9uTW91bnQiLCJ1c2VDYWxsYmFjayIsImVsZW1lbnQiLCJtb3VudExpbmtJbnN0YW5jZSIsInVubW91bnRMaW5rRm9yQ3VycmVudE5hdmlnYXRpb24iLCJ1bm1vdW50UHJlZmV0Y2hhYmxlSW5zdGFuY2UiLCJtZXJnZWRSZWYiLCJ1c2VNZXJnZWRSZWYiLCJjaGlsZFByb3BzIiwiZGVmYXVsdFByZXZlbnRlZCIsInVwZ3JhZGVUb0R5bmFtaWNQcmVmZXRjaCIsIm9uTmF2aWdhdGlvbkludGVudCIsIl9fTkVYVF9MSU5LX05PX1RPVUNIX1NUQVJUIiwidW5kZWZpbmVkIiwiaXNBYnNvbHV0ZVVybCIsImFkZEJhc2VQYXRoIiwibGluayIsImVycm9yT25jZSIsImNsb25lRWxlbWVudCIsIkxpbmtTdGF0dXNDb250ZXh0IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsImNyZWF0ZUNvbnRleHQiLCJfX05FWFRfQ0FDSEVfQ09NUE9ORU5UUyIsIl9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSIsIlBQUlJ1bnRpbWUiLCJGdWxsIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-dir/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/image-component.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/client/image-component.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Image\", ({\n    enumerable: true,\n    get: function() {\n        return Image;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"));\nconst _head = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/head */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\"));\nconst _getimgprops = __webpack_require__(/*! ../shared/lib/get-img-props */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imageconfig = __webpack_require__(/*! ../shared/lib/image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nconst _warnonce = __webpack_require__(/*! ../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\"));\nconst _usemergedref = __webpack_require__(/*! ./use-merged-ref */ \"(app-pages-browser)/./node_modules/next/dist/client/use-merged-ref.js\");\n// This is replaced by webpack define plugin\nconst configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]};\nif (false) {}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput) {\n    const src = img == null ? void 0 : img.src;\n    if (!img || img['data-loaded-src'] === src) {\n        return;\n    }\n    img['data-loaded-src'] = src;\n    const p = 'decode' in img ? img.decode() : Promise.resolve();\n    p.catch(()=>{}).then(()=>{\n        if (!img.parentElement || !img.isConnected) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        if (placeholder !== 'empty') {\n            setBlurComplete(true);\n        }\n        if (onLoadRef == null ? void 0 : onLoadRef.current) {\n            // Since we don't have the SyntheticEvent here,\n            // we must create one with the same shape.\n            // See https://reactjs.org/docs/events.html\n            const event = new Event('load');\n            Object.defineProperty(event, 'target', {\n                writable: false,\n                value: img\n            });\n            let prevented = false;\n            let stopped = false;\n            onLoadRef.current({\n                ...event,\n                nativeEvent: event,\n                currentTarget: img,\n                target: img,\n                isDefaultPrevented: ()=>prevented,\n                isPropagationStopped: ()=>stopped,\n                persist: ()=>{},\n                preventDefault: ()=>{\n                    prevented = true;\n                    event.preventDefault();\n                },\n                stopPropagation: ()=>{\n                    stopped = true;\n                    event.stopPropagation();\n                }\n            });\n        }\n        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n            onLoadingCompleteRef.current(img);\n        }\n        if (true) {\n            const origSrc = new URL(src, 'http://n').searchParams.get('url') || src;\n            if (img.getAttribute('data-nimg') === 'fill') {\n                if (!unoptimized && (!sizesInput || sizesInput === '100vw')) {\n                    let widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;\n                    if (widthViewportRatio < 0.6) {\n                        if (sizesInput === '100vw') {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" prop and \"sizes\" prop of \"100vw\", but image is not rendered at full viewport width. Please adjust \"sizes\" to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        } else {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        }\n                    }\n                }\n                if (img.parentElement) {\n                    const { position } = window.getComputedStyle(img.parentElement);\n                    const valid = [\n                        'absolute',\n                        'fixed',\n                        'relative'\n                    ];\n                    if (!valid.includes(position)) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and parent element with invalid \"position\". Provided \"' + position + '\" should be one of ' + valid.map(String).join(',') + \".\");\n                    }\n                }\n                if (img.height === 0) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.');\n                }\n            }\n            const heightModified = img.height.toString() !== img.getAttribute('height');\n            const widthModified = img.width.toString() !== img.getAttribute('width');\n            if (heightModified && !widthModified || !heightModified && widthModified) {\n                (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles \\'width: \"auto\"\\' or \\'height: \"auto\"\\' to maintain the aspect ratio.');\n            }\n        }\n    });\n}\nfunction getDynamicProps(fetchPriority) {\n    if (Boolean(_react.use)) {\n        // In React 19.0.0 or newer, we must use camelCase\n        // prop to avoid \"Warning: Invalid DOM property\".\n        // See https://github.com/facebook/react/pull/25927\n        return {\n            fetchPriority\n        };\n    }\n    // In React 18.2.0 or older, we must use lowercase prop\n    // to avoid \"Warning: Invalid DOM property\".\n    return {\n        fetchpriority: fetchPriority\n    };\n}\nconst ImageElement = /*#__PURE__*/ (0, _react.forwardRef)((param, forwardedRef)=>{\n    let { src, srcSet, sizes, height, width, decoding, className, style, fetchPriority, placeholder, loading, unoptimized, fill, onLoadRef, onLoadingCompleteRef, setBlurComplete, setShowAltText, sizesInput, onLoad, onError, ...rest } = param;\n    const ownRef = (0, _react.useCallback)((img)=>{\n        if (!img) {\n            return;\n        }\n        if (onError) {\n            // If the image has an error before react hydrates, then the error is lost.\n            // The workaround is to wait until the image is mounted which is after hydration,\n            // then we set the src again to trigger the error handler (if there was an error).\n            // eslint-disable-next-line no-self-assign\n            img.src = img.src;\n        }\n        if (true) {\n            if (!src) {\n                console.error('Image is missing required \"src\" property:', img);\n            }\n            if (img.getAttribute('alt') === null) {\n                console.error('Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.');\n            }\n        }\n        if (img.complete) {\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n        }\n    }, [\n        src,\n        placeholder,\n        onLoadRef,\n        onLoadingCompleteRef,\n        setBlurComplete,\n        onError,\n        unoptimized,\n        sizesInput\n    ]);\n    const ref = (0, _usemergedref.useMergedRef)(forwardedRef, ownRef);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"img\", {\n        ...rest,\n        ...getDynamicProps(fetchPriority),\n        // It's intended to keep `loading` before `src` because React updates\n        // props in order which causes Safari/Firefox to not lazy load properly.\n        // See https://github.com/facebook/react/issues/25883\n        loading: loading,\n        width: width,\n        height: height,\n        decoding: decoding,\n        \"data-nimg\": fill ? 'fill' : '1',\n        className: className,\n        style: style,\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        sizes: sizes,\n        srcSet: srcSet,\n        src: src,\n        ref: ref,\n        onLoad: (event)=>{\n            const img = event.currentTarget;\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n        },\n        onError: (event)=>{\n            // if the real image fails to load, this will ensure \"alt\" is visible\n            setShowAltText(true);\n            if (placeholder !== 'empty') {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    });\n});\nfunction ImagePreload(param) {\n    let { isAppRouter, imgAttributes } = param;\n    const opts = {\n        as: 'image',\n        imageSrcSet: imgAttributes.srcSet,\n        imageSizes: imgAttributes.sizes,\n        crossOrigin: imgAttributes.crossOrigin,\n        referrerPolicy: imgAttributes.referrerPolicy,\n        ...getDynamicProps(imgAttributes.fetchPriority)\n    };\n    if (isAppRouter && _reactdom.default.preload) {\n        _reactdom.default.preload(imgAttributes.src, opts);\n        return null;\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_head.default, {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n            rel: \"preload\",\n            // Note how we omit the `href` attribute, as it would only be relevant\n            // for browsers that do not support `imagesrcset`, and in those cases\n            // it would cause the incorrect image to be preloaded.\n            //\n            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n            href: imgAttributes.srcSet ? undefined : imgAttributes.src,\n            ...opts\n        }, '__nimg-' + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)\n    });\n}\n_c = ImagePreload;\nconst Image = /*#__PURE__*/ (0, _react.forwardRef)((props, forwardedRef)=>{\n    const pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);\n    const config = (0, _react.useMemo)(()=>{\n        var _c_qualities;\n        const c = configEnv || configContext || _imageconfig.imageConfigDefault;\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        const qualities = (_c_qualities = c.qualities) == null ? void 0 : _c_qualities.sort((a, b)=>a - b);\n        return {\n            ...c,\n            allSizes,\n            deviceSizes,\n            qualities\n        };\n    }, [\n        configContext\n    ]);\n    const { onLoad, onLoadingComplete } = props;\n    const onLoadRef = (0, _react.useRef)(onLoad);\n    (0, _react.useEffect)(()=>{\n        onLoadRef.current = onLoad;\n    }, [\n        onLoad\n    ]);\n    const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);\n    (0, _react.useEffect)(()=>{\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    const [blurComplete, setBlurComplete] = (0, _react.useState)(false);\n    const [showAltText, setShowAltText] = (0, _react.useState)(false);\n    const { props: imgAttributes, meta: imgMeta } = (0, _getimgprops.getImgProps)(props, {\n        defaultLoader: _imageloader.default,\n        imgConf: config,\n        blurComplete,\n        showAltText\n    });\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(ImageElement, {\n                ...imgAttributes,\n                unoptimized: imgMeta.unoptimized,\n                placeholder: imgMeta.placeholder,\n                fill: imgMeta.fill,\n                onLoadRef: onLoadRef,\n                onLoadingCompleteRef: onLoadingCompleteRef,\n                setBlurComplete: setBlurComplete,\n                setShowAltText: setShowAltText,\n                sizesInput: props.sizes,\n                ref: forwardedRef\n            }),\n            imgMeta.priority ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ImagePreload, {\n                isAppRouter: isAppRouter,\n                imgAttributes: imgAttributes\n            }) : null\n        ]\n    });\n});\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=image-component.js.map\nvar _c;\n$RefreshReg$(_c, \"ImagePreload\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2ltYWdlLWNvbXBvbmVudC5qcyIsIm1hcHBpbmdzIjoiOzs7O3lDQXFXYUE7OztlQUFBQTs7Ozs7OzZFQTFWTjsrRUFDYzsyRUFDSjt5Q0FDVzt5Q0FZTzs2REFDQTtzQ0FDVjt3REFDSztrRkFHSjswQ0FDRztBQUU3Qiw0Q0FBNEM7QUFDNUMsTUFBTUMsWUFBWUMsME5BQTZCO0FBRS9DLElBQUksS0FBNkIsRUFBRSxFQUVsQztBQW1CRCwwRUFBMEU7QUFDMUUsaURBQWlEO0FBQ2pELFNBQVNNLGNBQ1BDLEdBQTJCLEVBQzNCQyxXQUE2QixFQUM3QkMsU0FBcUQsRUFDckRDLG9CQUEyRSxFQUMzRUMsZUFBcUMsRUFDckNDLFdBQW9CLEVBQ3BCQyxVQUE4QjtJQUU5QixNQUFNQyxNQUFNUCxPQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxJQUFLTyxHQUFHO0lBQ3BCLElBQUksQ0FBQ1AsT0FBT0EsR0FBRyxDQUFDLGtCQUFrQixLQUFLTyxLQUFLO1FBQzFDO0lBQ0Y7SUFDQVAsR0FBRyxDQUFDLGtCQUFrQixHQUFHTztJQUN6QixNQUFNQyxJQUFJLFlBQVlSLE1BQU1BLElBQUlTLE1BQU0sS0FBS0MsUUFBUUMsT0FBTztJQUMxREgsRUFBRUksS0FBSyxDQUFDLEtBQU8sR0FBR0MsSUFBSSxDQUFDO1FBQ3JCLElBQUksQ0FBQ2IsSUFBSWMsYUFBYSxJQUFJLENBQUNkLElBQUllLFdBQVcsRUFBRTtZQUMxQyx3Q0FBd0M7WUFDeEMsdUJBQXVCO1lBQ3ZCLHNDQUFzQztZQUN0QyxzQkFBc0I7WUFDdEIsdUJBQXVCO1lBQ3ZCO1FBQ0Y7UUFDQSxJQUFJZCxnQkFBZ0IsU0FBUztZQUMzQkcsZ0JBQWdCO1FBQ2xCO1FBQ0EsSUFBSUYsYUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsVUFBV2MsT0FBTyxFQUFFO1lBQ3RCLCtDQUErQztZQUMvQywwQ0FBMEM7WUFDMUMsMkNBQTJDO1lBQzND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YUE7Z0JBQ2JDLGVBQWVBO2lCQUVmOzs7QUFHViIsInNvdXJjZXMiOlsiL1VzZXJzL2lzaGFxYmVsbG8vc3JjL2NsaWVudC9pbWFnZS1jb21wb25lbnQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgUmVhY3QsIHtcbiAgdXNlUmVmLFxuICB1c2VFZmZlY3QsXG4gIHVzZUNhbGxiYWNrLFxuICB1c2VDb250ZXh0LFxuICB1c2VNZW1vLFxuICB1c2VTdGF0ZSxcbiAgZm9yd2FyZFJlZixcbiAgdXNlLFxufSBmcm9tICdyZWFjdCdcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nXG5pbXBvcnQgSGVhZCBmcm9tICcuLi9zaGFyZWQvbGliL2hlYWQnXG5pbXBvcnQgeyBnZXRJbWdQcm9wcyB9IGZyb20gJy4uL3NoYXJlZC9saWIvZ2V0LWltZy1wcm9wcydcbmltcG9ydCB0eXBlIHtcbiAgSW1hZ2VQcm9wcyxcbiAgSW1nUHJvcHMsXG4gIE9uTG9hZCxcbiAgT25Mb2FkaW5nQ29tcGxldGUsXG4gIFBsYWNlaG9sZGVyVmFsdWUsXG59IGZyb20gJy4uL3NoYXJlZC9saWIvZ2V0LWltZy1wcm9wcydcbmltcG9ydCB0eXBlIHtcbiAgSW1hZ2VDb25maWdDb21wbGV0ZSxcbiAgSW1hZ2VMb2FkZXJQcm9wcyxcbn0gZnJvbSAnLi4vc2hhcmVkL2xpYi9pbWFnZS1jb25maWcnXG5pbXBvcnQgeyBpbWFnZUNvbmZpZ0RlZmF1bHQgfSBmcm9tICcuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZydcbmltcG9ydCB7IEltYWdlQ29uZmlnQ29udGV4dCB9IGZyb20gJy4uL3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyB3YXJuT25jZSB9IGZyb20gJy4uL3NoYXJlZC9saWIvdXRpbHMvd2Fybi1vbmNlJ1xuaW1wb3J0IHsgUm91dGVyQ29udGV4dCB9IGZyb20gJy4uL3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5cbi8vIFRoaXMgaXMgcmVwbGFjZWQgYnkgd2VicGFjayBhbGlhc1xuaW1wb3J0IGRlZmF1bHRMb2FkZXIgZnJvbSAnbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtbG9hZGVyJ1xuaW1wb3J0IHsgdXNlTWVyZ2VkUmVmIH0gZnJvbSAnLi91c2UtbWVyZ2VkLXJlZidcblxuLy8gVGhpcyBpcyByZXBsYWNlZCBieSB3ZWJwYWNrIGRlZmluZSBwbHVnaW5cbmNvbnN0IGNvbmZpZ0VudiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9JTUFHRV9PUFRTIGFzIGFueSBhcyBJbWFnZUNvbmZpZ0NvbXBsZXRlXG5cbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICA7KGdsb2JhbFRoaXMgYXMgYW55KS5fX05FWFRfSU1BR0VfSU1QT1JURUQgPSB0cnVlXG59XG5cbmV4cG9ydCB0eXBlIHsgSW1hZ2VMb2FkZXJQcm9wcyB9XG5leHBvcnQgdHlwZSBJbWFnZUxvYWRlciA9IChwOiBJbWFnZUxvYWRlclByb3BzKSA9PiBzdHJpbmdcblxudHlwZSBJbWdFbGVtZW50V2l0aERhdGFQcm9wID0gSFRNTEltYWdlRWxlbWVudCAmIHtcbiAgJ2RhdGEtbG9hZGVkLXNyYyc6IHN0cmluZyB8IHVuZGVmaW5lZFxufVxuXG50eXBlIEltYWdlRWxlbWVudFByb3BzID0gSW1nUHJvcHMgJiB7XG4gIHVub3B0aW1pemVkOiBib29sZWFuXG4gIHBsYWNlaG9sZGVyOiBQbGFjZWhvbGRlclZhbHVlXG4gIG9uTG9hZFJlZjogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxPbkxvYWQgfCB1bmRlZmluZWQ+XG4gIG9uTG9hZGluZ0NvbXBsZXRlUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PE9uTG9hZGluZ0NvbXBsZXRlIHwgdW5kZWZpbmVkPlxuICBzZXRCbHVyQ29tcGxldGU6IChiOiBib29sZWFuKSA9PiB2b2lkXG4gIHNldFNob3dBbHRUZXh0OiAoYjogYm9vbGVhbikgPT4gdm9pZFxuICBzaXplc0lucHV0OiBzdHJpbmcgfCB1bmRlZmluZWRcbn1cblxuLy8gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8zOTc3NzgzMy8yNjY1MzUgZm9yIHdoeSB3ZSB1c2UgdGhpcyByZWZcbi8vIGhhbmRsZXIgaW5zdGVhZCBvZiB0aGUgaW1nJ3Mgb25Mb2FkIGF0dHJpYnV0ZS5cbmZ1bmN0aW9uIGhhbmRsZUxvYWRpbmcoXG4gIGltZzogSW1nRWxlbWVudFdpdGhEYXRhUHJvcCxcbiAgcGxhY2Vob2xkZXI6IFBsYWNlaG9sZGVyVmFsdWUsXG4gIG9uTG9hZFJlZjogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxPbkxvYWQgfCB1bmRlZmluZWQ+LFxuICBvbkxvYWRpbmdDb21wbGV0ZVJlZjogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxPbkxvYWRpbmdDb21wbGV0ZSB8IHVuZGVmaW5lZD4sXG4gIHNldEJsdXJDb21wbGV0ZTogKGI6IGJvb2xlYW4pID0+IHZvaWQsXG4gIHVub3B0aW1pemVkOiBib29sZWFuLFxuICBzaXplc0lucHV0OiBzdHJpbmcgfCB1bmRlZmluZWRcbikge1xuICBjb25zdCBzcmMgPSBpbWc/LnNyY1xuICBpZiAoIWltZyB8fCBpbWdbJ2RhdGEtbG9hZGVkLXNyYyddID09PSBzcmMpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpbWdbJ2RhdGEtbG9hZGVkLXNyYyddID0gc3JjXG4gIGNvbnN0IHAgPSAnZGVjb2RlJyBpbiBpbWcgPyBpbWcuZGVjb2RlKCkgOiBQcm9taXNlLnJlc29sdmUoKVxuICBwLmNhdGNoKCgpID0+IHt9KS50aGVuKCgpID0+IHtcbiAgICBpZiAoIWltZy5wYXJlbnRFbGVtZW50IHx8ICFpbWcuaXNDb25uZWN0ZWQpIHtcbiAgICAgIC8vIEV4aXQgZWFybHkgaW4gY2FzZSBvZiByYWNlIGNvbmRpdGlvbjpcbiAgICAgIC8vIC0gb25sb2FkKCkgaXMgY2FsbGVkXG4gICAgICAvLyAtIGRlY29kZSgpIGlzIGNhbGxlZCBidXQgaW5jb21wbGV0ZVxuICAgICAgLy8gLSB1bm1vdW50IGlzIGNhbGxlZFxuICAgICAgLy8gLSBkZWNvZGUoKSBjb21wbGV0ZXNcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAocGxhY2Vob2xkZXIgIT09ICdlbXB0eScpIHtcbiAgICAgIHNldEJsdXJDb21wbGV0ZSh0cnVlKVxuICAgIH1cbiAgICBpZiAob25Mb2FkUmVmPy5jdXJyZW50KSB7XG4gICAgICAvLyBTaW5jZSB3ZSBkb24ndCBoYXZlIHRoZSBTeW50aGV0aWNFdmVudCBoZXJlLFxuICAgICAgLy8gd2UgbXVzdCBjcmVhdGUgb25lIHdpdGggdGhlIHNhbWUgc2hhcGUuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2V2ZW50cy5odG1sXG4gICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgnbG9hZCcpXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnQsICd0YXJnZXQnLCB7IHdyaXRhYmxlOiBmYWxzZSwgdmFsdWU6IGltZyB9KVxuICAgICAgbGV0IHByZXZlbnRlZCA9IGZhbHNlXG4gICAgICBsZXQgc3RvcHBlZCA9IGZhbHNlXG4gICAgICBvbkxvYWRSZWYuY3VycmVudCh7XG4gICAgICAgIC4uLmV2ZW50LFxuICAgICAgICBuYXRpdmVFdmVudDogZXZlbnQsXG4gICAgICAgIGN1cnJlbnRUYXJnZXQ6IGltZyxcbiAgICAgICAgdGFyZ2V0OiBpbWcsXG4gICAgICAgIGlzRGVmYXVsdFByZXZlbnRlZDogKCkgPT4gcHJldmVudGVkLFxuICAgICAgICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogKCkgPT4gc3RvcHBlZCxcbiAgICAgICAgcGVyc2lzdDogKCkgPT4ge30sXG4gICAgICAgIHByZXZlbnREZWZhdWx0OiAoKSA9PiB7XG4gICAgICAgICAgcHJldmVudGVkID0gdHJ1ZVxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgc3RvcHBlZCA9IHRydWVcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKG9uTG9hZGluZ0NvbXBsZXRlUmVmPy5jdXJyZW50KSB7XG4gICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50KGltZylcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnN0IG9yaWdTcmMgPSBuZXcgVVJMKHNyYywgJ2h0dHA6Ly9uJykuc2VhcmNoUGFyYW1zLmdldCgndXJsJykgfHwgc3JjXG4gICAgICBpZiAoaW1nLmdldEF0dHJpYnV0ZSgnZGF0YS1uaW1nJykgPT09ICdmaWxsJykge1xuICAgICAgICBpZiAoIXVub3B0aW1pemVkICYmICghc2l6ZXNJbnB1dCB8fCBzaXplc0lucHV0ID09PSAnMTAwdncnKSkge1xuICAgICAgICAgIGxldCB3aWR0aFZpZXdwb3J0UmF0aW8gPVxuICAgICAgICAgICAgaW1nLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC8gd2luZG93LmlubmVyV2lkdGhcbiAgICAgICAgICBpZiAod2lkdGhWaWV3cG9ydFJhdGlvIDwgMC42KSB7XG4gICAgICAgICAgICBpZiAoc2l6ZXNJbnB1dCA9PT0gJzEwMHZ3Jykge1xuICAgICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke29yaWdTcmN9XCIgaGFzIFwiZmlsbFwiIHByb3AgYW5kIFwic2l6ZXNcIiBwcm9wIG9mIFwiMTAwdndcIiwgYnV0IGltYWdlIGlzIG5vdCByZW5kZXJlZCBhdCBmdWxsIHZpZXdwb3J0IHdpZHRoLiBQbGVhc2UgYWRqdXN0IFwic2l6ZXNcIiB0byBpbXByb3ZlIHBhZ2UgcGVyZm9ybWFuY2UuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI3NpemVzYFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke29yaWdTcmN9XCIgaGFzIFwiZmlsbFwiIGJ1dCBpcyBtaXNzaW5nIFwic2l6ZXNcIiBwcm9wLiBQbGVhc2UgYWRkIGl0IHRvIGltcHJvdmUgcGFnZSBwZXJmb3JtYW5jZS4gUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2Ujc2l6ZXNgXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltZy5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgY29uc3QgeyBwb3NpdGlvbiB9ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoaW1nLnBhcmVudEVsZW1lbnQpXG4gICAgICAgICAgY29uc3QgdmFsaWQgPSBbJ2Fic29sdXRlJywgJ2ZpeGVkJywgJ3JlbGF0aXZlJ11cbiAgICAgICAgICBpZiAoIXZhbGlkLmluY2x1ZGVzKHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7b3JpZ1NyY31cIiBoYXMgXCJmaWxsXCIgYW5kIHBhcmVudCBlbGVtZW50IHdpdGggaW52YWxpZCBcInBvc2l0aW9uXCIuIFByb3ZpZGVkIFwiJHtwb3NpdGlvbn1cIiBzaG91bGQgYmUgb25lIG9mICR7dmFsaWRcbiAgICAgICAgICAgICAgICAubWFwKFN0cmluZylcbiAgICAgICAgICAgICAgICAuam9pbignLCcpfS5gXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbWcuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke29yaWdTcmN9XCIgaGFzIFwiZmlsbFwiIGFuZCBhIGhlaWdodCB2YWx1ZSBvZiAwLiBUaGlzIGlzIGxpa2VseSBiZWNhdXNlIHRoZSBwYXJlbnQgZWxlbWVudCBvZiB0aGUgaW1hZ2UgaGFzIG5vdCBiZWVuIHN0eWxlZCB0byBoYXZlIGEgc2V0IGhlaWdodC5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhlaWdodE1vZGlmaWVkID1cbiAgICAgICAgaW1nLmhlaWdodC50b1N0cmluZygpICE9PSBpbWcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKVxuICAgICAgY29uc3Qgd2lkdGhNb2RpZmllZCA9IGltZy53aWR0aC50b1N0cmluZygpICE9PSBpbWcuZ2V0QXR0cmlidXRlKCd3aWR0aCcpXG4gICAgICBpZiAoXG4gICAgICAgIChoZWlnaHRNb2RpZmllZCAmJiAhd2lkdGhNb2RpZmllZCkgfHxcbiAgICAgICAgKCFoZWlnaHRNb2RpZmllZCAmJiB3aWR0aE1vZGlmaWVkKVxuICAgICAgKSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7b3JpZ1NyY31cIiBoYXMgZWl0aGVyIHdpZHRoIG9yIGhlaWdodCBtb2RpZmllZCwgYnV0IG5vdCB0aGUgb3RoZXIuIElmIHlvdSB1c2UgQ1NTIHRvIGNoYW5nZSB0aGUgc2l6ZSBvZiB5b3VyIGltYWdlLCBhbHNvIGluY2x1ZGUgdGhlIHN0eWxlcyAnd2lkdGg6IFwiYXV0b1wiJyBvciAnaGVpZ2h0OiBcImF1dG9cIicgdG8gbWFpbnRhaW4gdGhlIGFzcGVjdCByYXRpby5gXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGdldER5bmFtaWNQcm9wcyhcbiAgZmV0Y2hQcmlvcml0eT86IHN0cmluZ1xuKTogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gIGlmIChCb29sZWFuKHVzZSkpIHtcbiAgICAvLyBJbiBSZWFjdCAxOS4wLjAgb3IgbmV3ZXIsIHdlIG11c3QgdXNlIGNhbWVsQ2FzZVxuICAgIC8vIHByb3AgdG8gYXZvaWQgXCJXYXJuaW5nOiBJbnZhbGlkIERPTSBwcm9wZXJ0eVwiLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yNTkyN1xuICAgIHJldHVybiB7IGZldGNoUHJpb3JpdHkgfVxuICB9XG4gIC8vIEluIFJlYWN0IDE4LjIuMCBvciBvbGRlciwgd2UgbXVzdCB1c2UgbG93ZXJjYXNlIHByb3BcbiAgLy8gdG8gYXZvaWQgXCJXYXJuaW5nOiBJbnZhbGlkIERPTSBwcm9wZXJ0eVwiLlxuICByZXR1cm4geyBmZXRjaHByaW9yaXR5OiBmZXRjaFByaW9yaXR5IH1cbn1cblxuY29uc3QgSW1hZ2VFbGVtZW50ID0gZm9yd2FyZFJlZjxIVE1MSW1hZ2VFbGVtZW50IHwgbnVsbCwgSW1hZ2VFbGVtZW50UHJvcHM+KFxuICAoXG4gICAge1xuICAgICAgc3JjLFxuICAgICAgc3JjU2V0LFxuICAgICAgc2l6ZXMsXG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aCxcbiAgICAgIGRlY29kaW5nLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICAgc3R5bGUsXG4gICAgICBmZXRjaFByaW9yaXR5LFxuICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICBsb2FkaW5nLFxuICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICBmaWxsLFxuICAgICAgb25Mb2FkUmVmLFxuICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYsXG4gICAgICBzZXRCbHVyQ29tcGxldGUsXG4gICAgICBzZXRTaG93QWx0VGV4dCxcbiAgICAgIHNpemVzSW5wdXQsXG4gICAgICBvbkxvYWQsXG4gICAgICBvbkVycm9yLFxuICAgICAgLi4ucmVzdFxuICAgIH0sXG4gICAgZm9yd2FyZGVkUmVmXG4gICkgPT4ge1xuICAgIGNvbnN0IG93blJlZiA9IHVzZUNhbGxiYWNrKFxuICAgICAgKGltZzogSW1nRWxlbWVudFdpdGhEYXRhUHJvcCB8IG51bGwpID0+IHtcbiAgICAgICAgaWYgKCFpbWcpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgIC8vIElmIHRoZSBpbWFnZSBoYXMgYW4gZXJyb3IgYmVmb3JlIHJlYWN0IGh5ZHJhdGVzLCB0aGVuIHRoZSBlcnJvciBpcyBsb3N0LlxuICAgICAgICAgIC8vIFRoZSB3b3JrYXJvdW5kIGlzIHRvIHdhaXQgdW50aWwgdGhlIGltYWdlIGlzIG1vdW50ZWQgd2hpY2ggaXMgYWZ0ZXIgaHlkcmF0aW9uLFxuICAgICAgICAgIC8vIHRoZW4gd2Ugc2V0IHRoZSBzcmMgYWdhaW4gdG8gdHJpZ2dlciB0aGUgZXJyb3IgaGFuZGxlciAoaWYgdGhlcmUgd2FzIGFuIGVycm9yKS5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICAgICAgICBpbWcuc3JjID0gaW1nLnNyY1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKCFzcmMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEltYWdlIGlzIG1pc3NpbmcgcmVxdWlyZWQgXCJzcmNcIiBwcm9wZXJ0eTpgLCBpbWcpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbWcuZ2V0QXR0cmlidXRlKCdhbHQnKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgYEltYWdlIGlzIG1pc3NpbmcgcmVxdWlyZWQgXCJhbHRcIiBwcm9wZXJ0eS4gUGxlYXNlIGFkZCBBbHRlcm5hdGl2ZSBUZXh0IHRvIGRlc2NyaWJlIHRoZSBpbWFnZSBmb3Igc2NyZWVuIHJlYWRlcnMgYW5kIHNlYXJjaCBlbmdpbmVzLmBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltZy5jb21wbGV0ZSkge1xuICAgICAgICAgIGhhbmRsZUxvYWRpbmcoXG4gICAgICAgICAgICBpbWcsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgICAgIG9uTG9hZFJlZixcbiAgICAgICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLFxuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlLFxuICAgICAgICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICAgICAgICBzaXplc0lucHV0XG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW1xuICAgICAgICBzcmMsXG4gICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICBvbkxvYWRSZWYsXG4gICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLFxuICAgICAgICBzZXRCbHVyQ29tcGxldGUsXG4gICAgICAgIG9uRXJyb3IsXG4gICAgICAgIHVub3B0aW1pemVkLFxuICAgICAgICBzaXplc0lucHV0LFxuICAgICAgXVxuICAgIClcblxuICAgIGNvbnN0IHJlZiA9IHVzZU1lcmdlZFJlZihmb3J3YXJkZWRSZWYsIG93blJlZilcblxuICAgIHJldHVybiAoXG4gICAgICA8aW1nXG4gICAgICAgIHsuLi5yZXN0fVxuICAgICAgICB7Li4uZ2V0RHluYW1pY1Byb3BzKGZldGNoUHJpb3JpdHkpfVxuICAgICAgICAvLyBJdCdzIGludGVuZGVkIHRvIGtlZXAgYGxvYWRpbmdgIGJlZm9yZSBgc3JjYCBiZWNhdXNlIFJlYWN0IHVwZGF0ZXNcbiAgICAgICAgLy8gcHJvcHMgaW4gb3JkZXIgd2hpY2ggY2F1c2VzIFNhZmFyaS9GaXJlZm94IHRvIG5vdCBsYXp5IGxvYWQgcHJvcGVybHkuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzI1ODgzXG4gICAgICAgIGxvYWRpbmc9e2xvYWRpbmd9XG4gICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgIGRlY29kaW5nPXtkZWNvZGluZ31cbiAgICAgICAgZGF0YS1uaW1nPXtmaWxsID8gJ2ZpbGwnIDogJzEnfVxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICAgICAgc3R5bGU9e3N0eWxlfVxuICAgICAgICAvLyBJdCdzIGludGVuZGVkIHRvIGtlZXAgYHNyY2AgdGhlIGxhc3QgYXR0cmlidXRlIGJlY2F1c2UgUmVhY3QgdXBkYXRlc1xuICAgICAgICAvLyBhdHRyaWJ1dGVzIGluIG9yZGVyLiBJZiB3ZSBrZWVwIGBzcmNgIHRoZSBmaXJzdCBvbmUsIFNhZmFyaSB3aWxsXG4gICAgICAgIC8vIGltbWVkaWF0ZWx5IHN0YXJ0IHRvIGZldGNoIGBzcmNgLCBiZWZvcmUgYHNpemVzYCBhbmQgYHNyY1NldGAgYXJlIGV2ZW5cbiAgICAgICAgLy8gdXBkYXRlZCBieSBSZWFjdC4gVGhhdCBjYXVzZXMgbXVsdGlwbGUgdW5uZWNlc3NhcnkgcmVxdWVzdHMgaWYgYHNyY1NldGBcbiAgICAgICAgLy8gYW5kIGBzaXplc2AgYXJlIGRlZmluZWQuXG4gICAgICAgIC8vIFRoaXMgYnVnIGNhbm5vdCBiZSByZXByb2R1Y2VkIGluIENocm9tZSBvciBGaXJlZm94LlxuICAgICAgICBzaXplcz17c2l6ZXN9XG4gICAgICAgIHNyY1NldD17c3JjU2V0fVxuICAgICAgICBzcmM9e3NyY31cbiAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgIG9uTG9hZD17KGV2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgaW1nID0gZXZlbnQuY3VycmVudFRhcmdldCBhcyBJbWdFbGVtZW50V2l0aERhdGFQcm9wXG4gICAgICAgICAgaGFuZGxlTG9hZGluZyhcbiAgICAgICAgICAgIGltZyxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgb25Mb2FkUmVmLFxuICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYsXG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUsXG4gICAgICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgICAgIHNpemVzSW5wdXRcbiAgICAgICAgICApXG4gICAgICAgIH19XG4gICAgICAgIG9uRXJyb3I9eyhldmVudCkgPT4ge1xuICAgICAgICAgIC8vIGlmIHRoZSByZWFsIGltYWdlIGZhaWxzIHRvIGxvYWQsIHRoaXMgd2lsbCBlbnN1cmUgXCJhbHRcIiBpcyB2aXNpYmxlXG4gICAgICAgICAgc2V0U2hvd0FsdFRleHQodHJ1ZSlcbiAgICAgICAgICBpZiAocGxhY2Vob2xkZXIgIT09ICdlbXB0eScpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSByZWFsIGltYWdlIGZhaWxzIHRvIGxvYWQsIHRoaXMgd2lsbCBzdGlsbCByZW1vdmUgdGhlIHBsYWNlaG9sZGVyLlxuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICBvbkVycm9yKGV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfX1cbiAgICAgIC8+XG4gICAgKVxuICB9XG4pXG5cbmZ1bmN0aW9uIEltYWdlUHJlbG9hZCh7XG4gIGlzQXBwUm91dGVyLFxuICBpbWdBdHRyaWJ1dGVzLFxufToge1xuICBpc0FwcFJvdXRlcjogYm9vbGVhblxuICBpbWdBdHRyaWJ1dGVzOiBJbWdQcm9wc1xufSkge1xuICBjb25zdCBvcHRzOiBSZWFjdERPTS5QcmVsb2FkT3B0aW9ucyA9IHtcbiAgICBhczogJ2ltYWdlJyxcbiAgICBpbWFnZVNyY1NldDogaW1nQXR0cmlidXRlcy5zcmNTZXQsXG4gICAgaW1hZ2VTaXplczogaW1nQXR0cmlidXRlcy5zaXplcyxcbiAgICBjcm9zc09yaWdpbjogaW1nQXR0cmlidXRlcy5jcm9zc09yaWdpbixcbiAgICByZWZlcnJlclBvbGljeTogaW1nQXR0cmlidXRlcy5yZWZlcnJlclBvbGljeSxcbiAgICAuLi5nZXREeW5hbWljUHJvcHMoaW1nQXR0cmlidXRlcy5mZXRjaFByaW9yaXR5KSxcbiAgfVxuXG4gIGlmIChpc0FwcFJvdXRlciAmJiBSZWFjdERPTS5wcmVsb2FkKSB7XG4gICAgUmVhY3RET00ucHJlbG9hZChpbWdBdHRyaWJ1dGVzLnNyYywgb3B0cylcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8SGVhZD5cbiAgICAgIDxsaW5rXG4gICAgICAgIGtleT17XG4gICAgICAgICAgJ19fbmltZy0nICtcbiAgICAgICAgICBpbWdBdHRyaWJ1dGVzLnNyYyArXG4gICAgICAgICAgaW1nQXR0cmlidXRlcy5zcmNTZXQgK1xuICAgICAgICAgIGltZ0F0dHJpYnV0ZXMuc2l6ZXNcbiAgICAgICAgfVxuICAgICAgICByZWw9XCJwcmVsb2FkXCJcbiAgICAgICAgLy8gTm90ZSBob3cgd2Ugb21pdCB0aGUgYGhyZWZgIGF0dHJpYnV0ZSwgYXMgaXQgd291bGQgb25seSBiZSByZWxldmFudFxuICAgICAgICAvLyBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBgaW1hZ2VzcmNzZXRgLCBhbmQgaW4gdGhvc2UgY2FzZXNcbiAgICAgICAgLy8gaXQgd291bGQgY2F1c2UgdGhlIGluY29ycmVjdCBpbWFnZSB0byBiZSBwcmVsb2FkZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI2F0dHItbGluay1pbWFnZXNyY3NldFxuICAgICAgICBocmVmPXtpbWdBdHRyaWJ1dGVzLnNyY1NldCA/IHVuZGVmaW5lZCA6IGltZ0F0dHJpYnV0ZXMuc3JjfVxuICAgICAgICB7Li4ub3B0c31cbiAgICAgIC8+XG4gICAgPC9IZWFkPlxuICApXG59XG5cbi8qKlxuICogVGhlIGBJbWFnZWAgY29tcG9uZW50IGlzIHVzZWQgdG8gb3B0aW1pemUgaW1hZ2VzLlxuICpcbiAqIFJlYWQgbW9yZTogW05leHQuanMgZG9jczogYEltYWdlYF0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9pbWFnZSlcbiAqL1xuZXhwb3J0IGNvbnN0IEltYWdlID0gZm9yd2FyZFJlZjxIVE1MSW1hZ2VFbGVtZW50IHwgbnVsbCwgSW1hZ2VQcm9wcz4oXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgcGFnZXNSb3V0ZXIgPSB1c2VDb250ZXh0KFJvdXRlckNvbnRleHQpXG4gICAgLy8gV2UncmUgaW4gdGhlIGFwcCBkaXJlY3RvcnkgaWYgdGhlcmUgaXMgbm8gcGFnZXMgcm91dGVyLlxuICAgIGNvbnN0IGlzQXBwUm91dGVyID0gIXBhZ2VzUm91dGVyXG5cbiAgICBjb25zdCBjb25maWdDb250ZXh0ID0gdXNlQ29udGV4dChJbWFnZUNvbmZpZ0NvbnRleHQpXG4gICAgY29uc3QgY29uZmlnID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICBjb25zdCBjID0gY29uZmlnRW52IHx8IGNvbmZpZ0NvbnRleHQgfHwgaW1hZ2VDb25maWdEZWZhdWx0XG4gICAgICBjb25zdCBhbGxTaXplcyA9IFsuLi5jLmRldmljZVNpemVzLCAuLi5jLmltYWdlU2l6ZXNdLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAgICAgY29uc3QgZGV2aWNlU2l6ZXMgPSBjLmRldmljZVNpemVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAgICAgY29uc3QgcXVhbGl0aWVzID0gYy5xdWFsaXRpZXM/LnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAgICAgcmV0dXJuIHsgLi4uYywgYWxsU2l6ZXMsIGRldmljZVNpemVzLCBxdWFsaXRpZXMgfVxuICAgIH0sIFtjb25maWdDb250ZXh0XSlcblxuICAgIGNvbnN0IHsgb25Mb2FkLCBvbkxvYWRpbmdDb21wbGV0ZSB9ID0gcHJvcHNcbiAgICBjb25zdCBvbkxvYWRSZWYgPSB1c2VSZWYob25Mb2FkKVxuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIG9uTG9hZFJlZi5jdXJyZW50ID0gb25Mb2FkXG4gICAgfSwgW29uTG9hZF0pXG5cbiAgICBjb25zdCBvbkxvYWRpbmdDb21wbGV0ZVJlZiA9IHVzZVJlZihvbkxvYWRpbmdDb21wbGV0ZSlcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50ID0gb25Mb2FkaW5nQ29tcGxldGVcbiAgICB9LCBbb25Mb2FkaW5nQ29tcGxldGVdKVxuXG4gICAgY29uc3QgW2JsdXJDb21wbGV0ZSwgc2V0Qmx1ckNvbXBsZXRlXSA9IHVzZVN0YXRlKGZhbHNlKVxuICAgIGNvbnN0IFtzaG93QWx0VGV4dCwgc2V0U2hvd0FsdFRleHRdID0gdXNlU3RhdGUoZmFsc2UpXG5cbiAgICBjb25zdCB7IHByb3BzOiBpbWdBdHRyaWJ1dGVzLCBtZXRhOiBpbWdNZXRhIH0gPSBnZXRJbWdQcm9wcyhwcm9wcywge1xuICAgICAgZGVmYXVsdExvYWRlcixcbiAgICAgIGltZ0NvbmY6IGNvbmZpZyxcbiAgICAgIGJsdXJDb21wbGV0ZSxcbiAgICAgIHNob3dBbHRUZXh0LFxuICAgIH0pXG5cbiAgICByZXR1cm4gKFxuICAgICAgPD5cbiAgICAgICAge1xuICAgICAgICAgIDxJbWFnZUVsZW1lbnRcbiAgICAgICAgICAgIHsuLi5pbWdBdHRyaWJ1dGVzfVxuICAgICAgICAgICAgdW5vcHRpbWl6ZWQ9e2ltZ01ldGEudW5vcHRpbWl6ZWR9XG4gICAgICAgICAgICBwbGFjZWhvbGRlcj17aW1nTWV0YS5wbGFjZWhvbGRlcn1cbiAgICAgICAgICAgIGZpbGw9e2ltZ01ldGEuZmlsbH1cbiAgICAgICAgICAgIG9uTG9hZFJlZj17b25Mb2FkUmVmfVxuICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWY9e29uTG9hZGluZ0NvbXBsZXRlUmVmfVxuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlPXtzZXRCbHVyQ29tcGxldGV9XG4gICAgICAgICAgICBzZXRTaG93QWx0VGV4dD17c2V0U2hvd0FsdFRleHR9XG4gICAgICAgICAgICBzaXplc0lucHV0PXtwcm9wcy5zaXplc31cbiAgICAgICAgICAgIHJlZj17Zm9yd2FyZGVkUmVmfVxuICAgICAgICAgIC8+XG4gICAgICAgIH1cbiAgICAgICAge2ltZ01ldGEucHJpb3JpdHkgPyAoXG4gICAgICAgICAgPEltYWdlUHJlbG9hZFxuICAgICAgICAgICAgaXNBcHBSb3V0ZXI9e2lzQXBwUm91dGVyfVxuICAgICAgICAgICAgaW1nQXR0cmlidXRlcz17aW1nQXR0cmlidXRlc31cbiAgICAgICAgICAvPlxuICAgICAgICApIDogbnVsbH1cbiAgICAgIDwvPlxuICAgIClcbiAgfVxuKVxuIl0sIm5hbWVzIjpbIkltYWdlIiwiY29uZmlnRW52IiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JTUFHRV9PUFRTIiwid2luZG93IiwiZ2xvYmFsVGhpcyIsIl9fTkVYVF9JTUFHRV9JTVBPUlRFRCIsImhhbmRsZUxvYWRpbmciLCJpbWciLCJwbGFjZWhvbGRlciIsIm9uTG9hZFJlZiIsIm9uTG9hZGluZ0NvbXBsZXRlUmVmIiwic2V0Qmx1ckNvbXBsZXRlIiwidW5vcHRpbWl6ZWQiLCJzaXplc0lucHV0Iiwic3JjIiwicCIsImRlY29kZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiY2F0Y2giLCJ0aGVuIiwicGFyZW50RWxlbWVudCIsImlzQ29ubmVjdGVkIiwiY3VycmVudCIsImV2ZW50IiwiRXZlbnQiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIndyaXRhYmxlIiwidmFsdWUiLCJwcmV2ZW50ZWQiLCJzdG9wcGVkIiwibmF0aXZlRXZlbnQiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0IiwiaXNEZWZhdWx0UHJldmVudGVkIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJwZXJzaXN0IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJOT0RFX0VOViIsIm9yaWdTcmMiLCJVUkwiLCJzZWFyY2hQYXJhbXMiLCJnZXQiLCJnZXRBdHRyaWJ1dGUiLCJ3aWR0aFZpZXdwb3J0UmF0aW8iLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aWR0aCIsImlubmVyV2lkdGgiLCJ3YXJuT25jZSIsInBvc2l0aW9uIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInZhbGlkIiwiaW5jbHVkZXMiLCJtYXAiLCJTdHJpbmciLCJqb2luIiwiaGVpZ2h0IiwiaGVpZ2h0TW9kaWZpZWQiLCJ0b1N0cmluZyIsIndpZHRoTW9kaWZpZWQiLCJnZXREeW5hbWljUHJvcHMiLCJmZXRjaFByaW9yaXR5IiwiQm9vbGVhbiIsInVzZSIsImZldGNocHJpb3JpdHkiLCJJbWFnZUVsZW1lbnQiLCJmb3J3YXJkUmVmIiwiZm9yd2FyZGVkUmVmIiwic3JjU2V0Iiwic2l6ZXMiLCJkZWNvZGluZyIsImNsYXNzTmFtZSIsInN0eWxlIiwibG9hZGluZyIsImZpbGwiLCJzZXRTaG93QWx0VGV4dCIsIm9uTG9hZCIsIm9uRXJyb3IiLCJyZXN0Iiwib3duUmVmIiwidXNlQ2FsbGJhY2siLCJjb25zb2xlIiwiZXJyb3IiLCJjb21wbGV0ZSIsInJlZiIsInVzZU1lcmdlZFJlZiIsImRhdGEtbmltZyIsIkltYWdlUHJlbG9hZCIsImlzQXBwUm91dGVyIiwiaW1nQXR0cmlidXRlcyIsIm9wdHMiLCJhcyIsImltYWdlU3JjU2V0IiwiaW1hZ2VTaXplcyIsImNyb3NzT3JpZ2luIiwicmVmZXJyZXJQb2xpY3kiLCJSZWFjdERPTSIsInByZWxvYWQiLCJIZWFkIiwibGluayIsInJlbCIsImhyZWYiLCJ1bmRlZmluZWQiLCJwcm9wcyIsInBhZ2VzUm91dGVyIiwidXNlQ29udGV4dCIsIlJvdXRlckNvbnRleHQiLCJjb25maWdDb250ZXh0IiwiSW1hZ2VDb25maWdDb250ZXh0IiwiY29uZmlnIiwidXNlTWVtbyIsImMiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJhbGxTaXplcyIsImRldmljZVNpemVzIiwic29ydCIsImEiLCJiIiwicXVhbGl0aWVzIiwib25Mb2FkaW5nQ29tcGxldGUiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJibHVyQ29tcGxldGUiLCJ1c2VTdGF0ZSIsInNob3dBbHRUZXh0IiwibWV0YSIsImltZ01ldGEiLCJnZXRJbWdQcm9wcyIsImRlZmF1bHRMb2FkZXIiLCJpbWdDb25mIiwicHJpb3JpdHkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/image-component.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/use-merged-ref.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/client/use-merged-ref.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useMergedRef\", ({\n    enumerable: true,\n    get: function() {\n        return useMergedRef;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nfunction useMergedRef(refA, refB) {\n    const cleanupA = (0, _react.useRef)(null);\n    const cleanupB = (0, _react.useRef)(null);\n    // NOTE: In theory, we could skip the wrapping if only one of the refs is non-null.\n    // (this happens often if the user doesn't pass a ref to Link/Form/Image)\n    // But this can cause us to leak a cleanup-ref into user code (e.g. via `<Link legacyBehavior>`),\n    // and the user might pass that ref into ref-merging library that doesn't support cleanup refs\n    // (because it hasn't been updated for React 19)\n    // which can then cause things to blow up, because a cleanup-returning ref gets called with `null`.\n    // So in practice, it's safer to be defensive and always wrap the ref, even on React 19.\n    return (0, _react.useCallback)((current)=>{\n        if (current === null) {\n            const cleanupFnA = cleanupA.current;\n            if (cleanupFnA) {\n                cleanupA.current = null;\n                cleanupFnA();\n            }\n            const cleanupFnB = cleanupB.current;\n            if (cleanupFnB) {\n                cleanupB.current = null;\n                cleanupFnB();\n            }\n        } else {\n            if (refA) {\n                cleanupA.current = applyRef(refA, current);\n            }\n            if (refB) {\n                cleanupB.current = applyRef(refB, current);\n            }\n        }\n    }, [\n        refA,\n        refB\n    ]);\n}\nfunction applyRef(refA, current) {\n    if (typeof refA === 'function') {\n        const cleanup = refA(current);\n        if (typeof cleanup === 'function') {\n            return cleanup;\n        } else {\n            return ()=>refA(null);\n        }\n    } else {\n        refA.current = current;\n        return ()=>{\n            refA.current = null;\n        };\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-merged-ref.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1tZXJnZWQtcmVmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Z0RBU2dCQTs7O2VBQUFBOzs7bUNBVDhCO0FBU3ZDLFNBQVNBLGFBQ2RDLElBQW1CLEVBQ25CQyxJQUFtQjtJQUVuQixNQUFNQyxXQUFXQyxDQUFBQSxHQUFBQSxPQUFBQSxNQUFBQSxFQUE0QjtJQUM3QyxNQUFNQyxXQUFXRCxDQUFBQSxHQUFBQSxPQUFBQSxNQUFBQSxFQUE0QjtJQUU3QyxtRkFBbUY7SUFDbkYseUVBQXlFO0lBQ3pFLGlHQUFpRztJQUNqRyw4RkFBOEY7SUFDOUYsZ0RBQWdEO0lBQ2hELG1HQUFtRztJQUNuRyx3RkFBd0Y7SUFDeEYsT0FBT0UsQ0FBQUEsR0FBQUEsT0FBQUEsV0FBQUEsRUFDTCxDQUFDQztRQUNDLElBQUlBLFlBQVksTUFBTTtZQUNwQixNQUFNQyxhQUFhTCxTQUFTSSxPQUFPO1lBQ25DLElBQUlDLFlBQVk7Z0JBQ2RMLFNBQVNJLE9BQU8sR0FBRztnQkFDbkJDO1lBQ0Y7WUFDQSxNQUFNQyxhQUFhSixTQUFTRSxPQUFPO1lBQ25DLElBQUlFLFlBQVk7Z0JBQ2RKLFNBQVNFLE9BQU8sR0FBRztnQkFDbkJFO1lBQ0Y7UUFDRixPQUFPO1lBQ0wsSUFBSVIsTUFBTTtnQkFDUkUsU0FBU0ksT0FBTyxHQUFHRyxTQUFTVCxNQUFNTTtZQUNwQztZQUNBLElBQUlMLE1BQU07Z0JBQ1JHLFNBQVNFLE9BQU8sR0FBR0csU0FBU1IsTUFBTUs7WUFDcEM7UUFDRjtJQUNGLEdBQ0E7UUFBQ047UUFBTUM7S0FBSztBQUVoQjtBQUVBLFNBQVNRLFNBQ1BULElBQWdDLEVBQ2hDTSxPQUFpQjtJQUVqQixJQUFJLE9BQU9OLFNBQVMsWUFBWTtRQUM5QixNQUFNVSxVQUFVVixLQUFLTTtRQUNyQixJQUFJLE9BQU9JLFlBQVksWUFBWTtZQUNqQyxPQUFPQTtRQUNULE9BQU87WUFDTCxPQUFPLElBQU1WLEtBQUs7UUFDcEI7SUFDRixPQUFPO1FBQ0xBLEtBQUtNLE9BQU8sR0FBR0E7UUFDZixPQUFPO1lBQ0xOLEtBQUtNLE9BQU8sR0FBRztRQUNqQjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL3NyYy9jbGllbnQvdXNlLW1lcmdlZC1yZWYudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiwgdHlwZSBSZWYgfSBmcm9tICdyZWFjdCdcblxuLy8gVGhpcyBpcyBhIGNvbXBhdGliaWxpdHkgaG9vayB0byBzdXBwb3J0IFJlYWN0IDE4IGFuZCAxOSByZWZzLlxuLy8gSW4gMTksIGEgY2xlYW51cCBmdW5jdGlvbiBmcm9tIHJlZnMgbWF5IGJlIHJldHVybmVkLlxuLy8gSW4gMTgsIHJldHVybmluZyBhIGNsZWFudXAgZnVuY3Rpb24gY3JlYXRlcyBhIHdhcm5pbmcuXG4vLyBTaW5jZSB3ZSB0YWtlIHVzZXJzcGFjZSByZWZzLCB3ZSBkb24ndCBrbm93IGFoZWFkIG9mIHRpbWUgaWYgYSBjbGVhbnVwIGZ1bmN0aW9uIHdpbGwgYmUgcmV0dXJuZWQuXG4vLyBUaGlzIGltcGxlbWVudHMgY2xlYW51cCBmdW5jdGlvbnMgd2l0aCB0aGUgb2xkIGJlaGF2aW9yIGluIDE4LlxuLy8gV2Uga25vdyByZWZzIGFyZSBhbHdheXMgY2FsbGVkIGFsdGVybmF0aW5nIHdpdGggYG51bGxgIGFuZCB0aGVuIGBUYC5cbi8vIFNvIGEgY2FsbCB3aXRoIGBudWxsYCBtZWFucyB3ZSBuZWVkIHRvIGNhbGwgdGhlIHByZXZpb3VzIGNsZWFudXAgZnVuY3Rpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFJlZjxURWxlbWVudD4oXG4gIHJlZkE6IFJlZjxURWxlbWVudD4sXG4gIHJlZkI6IFJlZjxURWxlbWVudD5cbik6IFJlZjxURWxlbWVudD4ge1xuICBjb25zdCBjbGVhbnVwQSA9IHVzZVJlZjwoKCkgPT4gdm9pZCkgfCBudWxsPihudWxsKVxuICBjb25zdCBjbGVhbnVwQiA9IHVzZVJlZjwoKCkgPT4gdm9pZCkgfCBudWxsPihudWxsKVxuXG4gIC8vIE5PVEU6IEluIHRoZW9yeSwgd2UgY291bGQgc2tpcCB0aGUgd3JhcHBpbmcgaWYgb25seSBvbmUgb2YgdGhlIHJlZnMgaXMgbm9uLW51bGwuXG4gIC8vICh0aGlzIGhhcHBlbnMgb2Z0ZW4gaWYgdGhlIHVzZXIgZG9lc24ndCBwYXNzIGEgcmVmIHRvIExpbmsvRm9ybS9JbWFnZSlcbiAgLy8gQnV0IHRoaXMgY2FuIGNhdXNlIHVzIHRvIGxlYWsgYSBjbGVhbnVwLXJlZiBpbnRvIHVzZXIgY29kZSAoZS5nLiB2aWEgYDxMaW5rIGxlZ2FjeUJlaGF2aW9yPmApLFxuICAvLyBhbmQgdGhlIHVzZXIgbWlnaHQgcGFzcyB0aGF0IHJlZiBpbnRvIHJlZi1tZXJnaW5nIGxpYnJhcnkgdGhhdCBkb2Vzbid0IHN1cHBvcnQgY2xlYW51cCByZWZzXG4gIC8vIChiZWNhdXNlIGl0IGhhc24ndCBiZWVuIHVwZGF0ZWQgZm9yIFJlYWN0IDE5KVxuICAvLyB3aGljaCBjYW4gdGhlbiBjYXVzZSB0aGluZ3MgdG8gYmxvdyB1cCwgYmVjYXVzZSBhIGNsZWFudXAtcmV0dXJuaW5nIHJlZiBnZXRzIGNhbGxlZCB3aXRoIGBudWxsYC5cbiAgLy8gU28gaW4gcHJhY3RpY2UsIGl0J3Mgc2FmZXIgdG8gYmUgZGVmZW5zaXZlIGFuZCBhbHdheXMgd3JhcCB0aGUgcmVmLCBldmVuIG9uIFJlYWN0IDE5LlxuICByZXR1cm4gdXNlQ2FsbGJhY2soXG4gICAgKGN1cnJlbnQ6IFRFbGVtZW50IHwgbnVsbCk6IHZvaWQgPT4ge1xuICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY2xlYW51cEZuQSA9IGNsZWFudXBBLmN1cnJlbnRcbiAgICAgICAgaWYgKGNsZWFudXBGbkEpIHtcbiAgICAgICAgICBjbGVhbnVwQS5jdXJyZW50ID0gbnVsbFxuICAgICAgICAgIGNsZWFudXBGbkEoKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsZWFudXBGbkIgPSBjbGVhbnVwQi5jdXJyZW50XG4gICAgICAgIGlmIChjbGVhbnVwRm5CKSB7XG4gICAgICAgICAgY2xlYW51cEIuY3VycmVudCA9IG51bGxcbiAgICAgICAgICBjbGVhbnVwRm5CKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlZkEpIHtcbiAgICAgICAgICBjbGVhbnVwQS5jdXJyZW50ID0gYXBwbHlSZWYocmVmQSwgY3VycmVudClcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmQikge1xuICAgICAgICAgIGNsZWFudXBCLmN1cnJlbnQgPSBhcHBseVJlZihyZWZCLCBjdXJyZW50KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBbcmVmQSwgcmVmQl1cbiAgKVxufVxuXG5mdW5jdGlvbiBhcHBseVJlZjxURWxlbWVudD4oXG4gIHJlZkE6IE5vbk51bGxhYmxlPFJlZjxURWxlbWVudD4+LFxuICBjdXJyZW50OiBURWxlbWVudFxuKSB7XG4gIGlmICh0eXBlb2YgcmVmQSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IGNsZWFudXAgPSByZWZBKGN1cnJlbnQpXG4gICAgaWYgKHR5cGVvZiBjbGVhbnVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gY2xlYW51cFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKCkgPT4gcmVmQShudWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZWZBLmN1cnJlbnQgPSBjdXJyZW50XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJlZkEuY3VycmVudCA9IG51bGxcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJ1c2VNZXJnZWRSZWYiLCJyZWZBIiwicmVmQiIsImNsZWFudXBBIiwidXNlUmVmIiwiY2xlYW51cEIiLCJ1c2VDYWxsYmFjayIsImN1cnJlbnQiLCJjbGVhbnVwRm5BIiwiY2xlYW51cEZuQiIsImFwcGx5UmVmIiwiY2xlYW51cCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/use-merged-ref.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/picomatch/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n(()=>{\"use strict\";var t={170:(t,e,u)=>{const n=u(510);const isWindows=()=>{if(typeof navigator!==\"undefined\"&&navigator.platform){const t=navigator.platform.toLowerCase();return t===\"win32\"||t===\"windows\"}if(typeof process!==\"undefined\"&&process.platform){return process.platform===\"win32\"}return false};function picomatch(t,e,u=false){if(e&&(e.windows===null||e.windows===undefined)){e={...e,windows:isWindows()}}return n(t,e,u)}Object.assign(picomatch,n);t.exports=picomatch},154:t=>{const e=\"\\\\\\\\/\";const u=`[^${e}]`;const n=\"\\\\.\";const o=\"\\\\+\";const s=\"\\\\?\";const r=\"\\\\/\";const a=\"(?=.)\";const i=\"[^/]\";const c=`(?:${r}|$)`;const p=`(?:^|${r})`;const l=`${n}{1,2}${c}`;const f=`(?!${n})`;const A=`(?!${p}${l})`;const _=`(?!${n}{0,1}${c})`;const R=`(?!${l})`;const E=`[^.${r}]`;const h=`${i}*?`;const g=\"/\";const b={DOT_LITERAL:n,PLUS_LITERAL:o,QMARK_LITERAL:s,SLASH_LITERAL:r,ONE_CHAR:a,QMARK:i,END_ANCHOR:c,DOTS_SLASH:l,NO_DOT:f,NO_DOTS:A,NO_DOT_SLASH:_,NO_DOTS_SLASH:R,QMARK_NO_DOT:E,STAR:h,START_ANCHOR:p,SEP:g};const C={...b,SLASH_LITERAL:`[${e}]`,QMARK:u,STAR:`${u}*?`,DOTS_SLASH:`${n}{1,2}(?:[${e}]|$)`,NO_DOT:`(?!${n})`,NO_DOTS:`(?!(?:^|[${e}])${n}{1,2}(?:[${e}]|$))`,NO_DOT_SLASH:`(?!${n}{0,1}(?:[${e}]|$))`,NO_DOTS_SLASH:`(?!${n}{1,2}(?:[${e}]|$))`,QMARK_NO_DOT:`[^.${e}]`,START_ANCHOR:`(?:^|[${e}])`,END_ANCHOR:`(?:[${e}]|$)`,SEP:\"\\\\\"};const y={alnum:\"a-zA-Z0-9\",alpha:\"a-zA-Z\",ascii:\"\\\\x00-\\\\x7F\",blank:\" \\\\t\",cntrl:\"\\\\x00-\\\\x1F\\\\x7F\",digit:\"0-9\",graph:\"\\\\x21-\\\\x7E\",lower:\"a-z\",print:\"\\\\x20-\\\\x7E \",punct:\"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",space:\" \\\\t\\\\r\\\\n\\\\v\\\\f\",upper:\"A-Z\",word:\"A-Za-z0-9_\",xdigit:\"A-Fa-f0-9\"};t.exports={MAX_LENGTH:1024*64,POSIX_REGEX_SOURCE:y,REGEX_BACKSLASH:/\\\\(?![*+?^${}(|)[\\]])/g,REGEX_NON_SPECIAL_CHARS:/^[^@![\\].,$*+?^{}()|\\\\/]+/,REGEX_SPECIAL_CHARS:/[-*+?.^${}(|)[\\]]/,REGEX_SPECIAL_CHARS_BACKREF:/(\\\\?)((\\W)(\\3*))/g,REGEX_SPECIAL_CHARS_GLOBAL:/([-*+?.^${}(|)[\\]])/g,REGEX_REMOVE_BACKSLASH:/(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,REPLACEMENTS:{\"***\":\"*\",\"**/**\":\"**\",\"**/**/**\":\"**\"},CHAR_0:48,CHAR_9:57,CHAR_UPPERCASE_A:65,CHAR_LOWERCASE_A:97,CHAR_UPPERCASE_Z:90,CHAR_LOWERCASE_Z:122,CHAR_LEFT_PARENTHESES:40,CHAR_RIGHT_PARENTHESES:41,CHAR_ASTERISK:42,CHAR_AMPERSAND:38,CHAR_AT:64,CHAR_BACKWARD_SLASH:92,CHAR_CARRIAGE_RETURN:13,CHAR_CIRCUMFLEX_ACCENT:94,CHAR_COLON:58,CHAR_COMMA:44,CHAR_DOT:46,CHAR_DOUBLE_QUOTE:34,CHAR_EQUAL:61,CHAR_EXCLAMATION_MARK:33,CHAR_FORM_FEED:12,CHAR_FORWARD_SLASH:47,CHAR_GRAVE_ACCENT:96,CHAR_HASH:35,CHAR_HYPHEN_MINUS:45,CHAR_LEFT_ANGLE_BRACKET:60,CHAR_LEFT_CURLY_BRACE:123,CHAR_LEFT_SQUARE_BRACKET:91,CHAR_LINE_FEED:10,CHAR_NO_BREAK_SPACE:160,CHAR_PERCENT:37,CHAR_PLUS:43,CHAR_QUESTION_MARK:63,CHAR_RIGHT_ANGLE_BRACKET:62,CHAR_RIGHT_CURLY_BRACE:125,CHAR_RIGHT_SQUARE_BRACKET:93,CHAR_SEMICOLON:59,CHAR_SINGLE_QUOTE:39,CHAR_SPACE:32,CHAR_TAB:9,CHAR_UNDERSCORE:95,CHAR_VERTICAL_LINE:124,CHAR_ZERO_WIDTH_NOBREAK_SPACE:65279,extglobChars(t){return{\"!\":{type:\"negate\",open:\"(?:(?!(?:\",close:`))${t.STAR})`},\"?\":{type:\"qmark\",open:\"(?:\",close:\")?\"},\"+\":{type:\"plus\",open:\"(?:\",close:\")+\"},\"*\":{type:\"star\",open:\"(?:\",close:\")*\"},\"@\":{type:\"at\",open:\"(?:\",close:\")\"}}},globChars(t){return t===true?C:b}}},697:(t,e,u)=>{const n=u(154);const o=u(96);const{MAX_LENGTH:s,POSIX_REGEX_SOURCE:r,REGEX_NON_SPECIAL_CHARS:a,REGEX_SPECIAL_CHARS_BACKREF:i,REPLACEMENTS:c}=n;const expandRange=(t,e)=>{if(typeof e.expandRange===\"function\"){return e.expandRange(...t,e)}t.sort();const u=`[${t.join(\"-\")}]`;try{new RegExp(u)}catch(e){return t.map((t=>o.escapeRegex(t))).join(\"..\")}return u};const syntaxError=(t,e)=>`Missing ${t}: \"${e}\" - use \"\\\\\\\\${e}\" to match literal characters`;const parse=(t,e)=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected a string\")}t=c[t]||t;const u={...e};const p=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;let l=t.length;if(l>p){throw new SyntaxError(`Input length: ${l}, exceeds maximum allowed length: ${p}`)}const f={type:\"bos\",value:\"\",output:u.prepend||\"\"};const A=[f];const _=u.capture?\"\":\"?:\";const R=n.globChars(u.windows);const E=n.extglobChars(R);const{DOT_LITERAL:h,PLUS_LITERAL:g,SLASH_LITERAL:b,ONE_CHAR:C,DOTS_SLASH:y,NO_DOT:$,NO_DOT_SLASH:x,NO_DOTS_SLASH:S,QMARK:H,QMARK_NO_DOT:v,STAR:d,START_ANCHOR:L}=R;const globstar=t=>`(${_}(?:(?!${L}${t.dot?y:h}).)*?)`;const T=u.dot?\"\":$;const O=u.dot?H:v;let k=u.bash===true?globstar(u):d;if(u.capture){k=`(${k})`}if(typeof u.noext===\"boolean\"){u.noextglob=u.noext}const m={input:t,index:-1,start:0,dot:u.dot===true,consumed:\"\",output:\"\",prefix:\"\",backtrack:false,negated:false,brackets:0,braces:0,parens:0,quotes:0,globstar:false,tokens:A};t=o.removePrefix(t,m);l=t.length;const w=[];const N=[];const I=[];let B=f;let G;const eos=()=>m.index===l-1;const D=m.peek=(e=1)=>t[m.index+e];const M=m.advance=()=>t[++m.index]||\"\";const remaining=()=>t.slice(m.index+1);const consume=(t=\"\",e=0)=>{m.consumed+=t;m.index+=e};const append=t=>{m.output+=t.output!=null?t.output:t.value;consume(t.value)};const negate=()=>{let t=1;while(D()===\"!\"&&(D(2)!==\"(\"||D(3)===\"?\")){M();m.start++;t++}if(t%2===0){return false}m.negated=true;m.start++;return true};const increment=t=>{m[t]++;I.push(t)};const decrement=t=>{m[t]--;I.pop()};const push=t=>{if(B.type===\"globstar\"){const e=m.braces>0&&(t.type===\"comma\"||t.type===\"brace\");const u=t.extglob===true||w.length&&(t.type===\"pipe\"||t.type===\"paren\");if(t.type!==\"slash\"&&t.type!==\"paren\"&&!e&&!u){m.output=m.output.slice(0,-B.output.length);B.type=\"star\";B.value=\"*\";B.output=k;m.output+=B.output}}if(w.length&&t.type!==\"paren\"){w[w.length-1].inner+=t.value}if(t.value||t.output)append(t);if(B&&B.type===\"text\"&&t.type===\"text\"){B.output=(B.output||B.value)+t.value;B.value+=t.value;return}t.prev=B;A.push(t);B=t};const extglobOpen=(t,e)=>{const n={...E[e],conditions:1,inner:\"\"};n.prev=B;n.parens=m.parens;n.output=m.output;const o=(u.capture?\"(\":\"\")+n.open;increment(\"parens\");push({type:t,value:e,output:m.output?\"\":C});push({type:\"paren\",extglob:true,value:M(),output:o});w.push(n)};const extglobClose=t=>{let n=t.close+(u.capture?\")\":\"\");let o;if(t.type===\"negate\"){let s=k;if(t.inner&&t.inner.length>1&&t.inner.includes(\"/\")){s=globstar(u)}if(s!==k||eos()||/^\\)+$/.test(remaining())){n=t.close=`)$))${s}`}if(t.inner.includes(\"*\")&&(o=remaining())&&/^\\.[^\\\\/.]+$/.test(o)){const u=parse(o,{...e,fastpaths:false}).output;n=t.close=`)${u})${s})`}if(t.prev.type===\"bos\"){m.negatedExtglob=true}}push({type:\"paren\",extglob:true,value:G,output:n});decrement(\"parens\")};if(u.fastpaths!==false&&!/(^[*!]|[/()[\\]{}\"])/.test(t)){let n=false;let s=t.replace(i,((t,e,u,o,s,r)=>{if(o===\"\\\\\"){n=true;return t}if(o===\"?\"){if(e){return e+o+(s?H.repeat(s.length):\"\")}if(r===0){return O+(s?H.repeat(s.length):\"\")}return H.repeat(u.length)}if(o===\".\"){return h.repeat(u.length)}if(o===\"*\"){if(e){return e+o+(s?k:\"\")}return k}return e?t:`\\\\${t}`}));if(n===true){if(u.unescape===true){s=s.replace(/\\\\/g,\"\")}else{s=s.replace(/\\\\+/g,(t=>t.length%2===0?\"\\\\\\\\\":t?\"\\\\\":\"\"))}}if(s===t&&u.contains===true){m.output=t;return m}m.output=o.wrapOutput(s,m,e);return m}while(!eos()){G=M();if(G===\"\\0\"){continue}if(G===\"\\\\\"){const t=D();if(t===\"/\"&&u.bash!==true){continue}if(t===\".\"||t===\";\"){continue}if(!t){G+=\"\\\\\";push({type:\"text\",value:G});continue}const e=/^\\\\+/.exec(remaining());let n=0;if(e&&e[0].length>2){n=e[0].length;m.index+=n;if(n%2!==0){G+=\"\\\\\"}}if(u.unescape===true){G=M()}else{G+=M()}if(m.brackets===0){push({type:\"text\",value:G});continue}}if(m.brackets>0&&(G!==\"]\"||B.value===\"[\"||B.value===\"[^\")){if(u.posix!==false&&G===\":\"){const t=B.value.slice(1);if(t.includes(\"[\")){B.posix=true;if(t.includes(\":\")){const t=B.value.lastIndexOf(\"[\");const e=B.value.slice(0,t);const u=B.value.slice(t+2);const n=r[u];if(n){B.value=e+n;m.backtrack=true;M();if(!f.output&&A.indexOf(B)===1){f.output=C}continue}}}}if(G===\"[\"&&D()!==\":\"||G===\"-\"&&D()===\"]\"){G=`\\\\${G}`}if(G===\"]\"&&(B.value===\"[\"||B.value===\"[^\")){G=`\\\\${G}`}if(u.posix===true&&G===\"!\"&&B.value===\"[\"){G=\"^\"}B.value+=G;append({value:G});continue}if(m.quotes===1&&G!=='\"'){G=o.escapeRegex(G);B.value+=G;append({value:G});continue}if(G==='\"'){m.quotes=m.quotes===1?0:1;if(u.keepQuotes===true){push({type:\"text\",value:G})}continue}if(G===\"(\"){increment(\"parens\");push({type:\"paren\",value:G});continue}if(G===\")\"){if(m.parens===0&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"(\"))}const t=w[w.length-1];if(t&&m.parens===t.parens+1){extglobClose(w.pop());continue}push({type:\"paren\",value:G,output:m.parens?\")\":\"\\\\)\"});decrement(\"parens\");continue}if(G===\"[\"){if(u.nobracket===true||!remaining().includes(\"]\")){if(u.nobracket!==true&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"closing\",\"]\"))}G=`\\\\${G}`}else{increment(\"brackets\")}push({type:\"bracket\",value:G});continue}if(G===\"]\"){if(u.nobracket===true||B&&B.type===\"bracket\"&&B.value.length===1){push({type:\"text\",value:G,output:`\\\\${G}`});continue}if(m.brackets===0){if(u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"[\"))}push({type:\"text\",value:G,output:`\\\\${G}`});continue}decrement(\"brackets\");const t=B.value.slice(1);if(B.posix!==true&&t[0]===\"^\"&&!t.includes(\"/\")){G=`/${G}`}B.value+=G;append({value:G});if(u.literalBrackets===false||o.hasRegexChars(t)){continue}const e=o.escapeRegex(B.value);m.output=m.output.slice(0,-B.value.length);if(u.literalBrackets===true){m.output+=e;B.value=e;continue}B.value=`(${_}${e}|${B.value})`;m.output+=B.value;continue}if(G===\"{\"&&u.nobrace!==true){increment(\"braces\");const t={type:\"brace\",value:G,output:\"(\",outputIndex:m.output.length,tokensIndex:m.tokens.length};N.push(t);push(t);continue}if(G===\"}\"){const t=N[N.length-1];if(u.nobrace===true||!t){push({type:\"text\",value:G,output:G});continue}let e=\")\";if(t.dots===true){const t=A.slice();const n=[];for(let e=t.length-1;e>=0;e--){A.pop();if(t[e].type===\"brace\"){break}if(t[e].type!==\"dots\"){n.unshift(t[e].value)}}e=expandRange(n,u);m.backtrack=true}if(t.comma!==true&&t.dots!==true){const u=m.output.slice(0,t.outputIndex);const n=m.tokens.slice(t.tokensIndex);t.value=t.output=\"\\\\{\";G=e=\"\\\\}\";m.output=u;for(const t of n){m.output+=t.output||t.value}}push({type:\"brace\",value:G,output:e});decrement(\"braces\");N.pop();continue}if(G===\"|\"){if(w.length>0){w[w.length-1].conditions++}push({type:\"text\",value:G});continue}if(G===\",\"){let t=G;const e=N[N.length-1];if(e&&I[I.length-1]===\"braces\"){e.comma=true;t=\"|\"}push({type:\"comma\",value:G,output:t});continue}if(G===\"/\"){if(B.type===\"dot\"&&m.index===m.start+1){m.start=m.index+1;m.consumed=\"\";m.output=\"\";A.pop();B=f;continue}push({type:\"slash\",value:G,output:b});continue}if(G===\".\"){if(m.braces>0&&B.type===\"dot\"){if(B.value===\".\")B.output=h;const t=N[N.length-1];B.type=\"dots\";B.output+=G;B.value+=G;t.dots=true;continue}if(m.braces+m.parens===0&&B.type!==\"bos\"&&B.type!==\"slash\"){push({type:\"text\",value:G,output:h});continue}push({type:\"dot\",value:G,output:h});continue}if(G===\"?\"){const t=B&&B.value===\"(\";if(!t&&u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"qmark\",G);continue}if(B&&B.type===\"paren\"){const t=D();let e=G;if(B.value===\"(\"&&!/[!=<:]/.test(t)||t===\"<\"&&!/<([!=]|\\w+>)/.test(remaining())){e=`\\\\${G}`}push({type:\"text\",value:G,output:e});continue}if(u.dot!==true&&(B.type===\"slash\"||B.type===\"bos\")){push({type:\"qmark\",value:G,output:v});continue}push({type:\"qmark\",value:G,output:H});continue}if(G===\"!\"){if(u.noextglob!==true&&D()===\"(\"){if(D(2)!==\"?\"||!/[!=<:]/.test(D(3))){extglobOpen(\"negate\",G);continue}}if(u.nonegate!==true&&m.index===0){negate();continue}}if(G===\"+\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"plus\",G);continue}if(B&&B.value===\"(\"||u.regex===false){push({type:\"plus\",value:G,output:g});continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\"||B.type===\"brace\")||m.parens>0){push({type:\"plus\",value:G});continue}push({type:\"plus\",value:g});continue}if(G===\"@\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){push({type:\"at\",extglob:true,value:G,output:\"\"});continue}push({type:\"text\",value:G});continue}if(G!==\"*\"){if(G===\"$\"||G===\"^\"){G=`\\\\${G}`}const t=a.exec(remaining());if(t){G+=t[0];m.index+=t[0].length}push({type:\"text\",value:G});continue}if(B&&(B.type===\"globstar\"||B.star===true)){B.type=\"star\";B.star=true;B.value+=G;B.output=k;m.backtrack=true;m.globstar=true;consume(G);continue}let e=remaining();if(u.noextglob!==true&&/^\\([^?]/.test(e)){extglobOpen(\"star\",G);continue}if(B.type===\"star\"){if(u.noglobstar===true){consume(G);continue}const n=B.prev;const o=n.prev;const s=n.type===\"slash\"||n.type===\"bos\";const r=o&&(o.type===\"star\"||o.type===\"globstar\");if(u.bash===true&&(!s||e[0]&&e[0]!==\"/\")){push({type:\"star\",value:G,output:\"\"});continue}const a=m.braces>0&&(n.type===\"comma\"||n.type===\"brace\");const i=w.length&&(n.type===\"pipe\"||n.type===\"paren\");if(!s&&n.type!==\"paren\"&&!a&&!i){push({type:\"star\",value:G,output:\"\"});continue}while(e.slice(0,3)===\"/**\"){const u=t[m.index+4];if(u&&u!==\"/\"){break}e=e.slice(3);consume(\"/**\",3)}if(n.type===\"bos\"&&eos()){B.type=\"globstar\";B.value+=G;B.output=globstar(u);m.output=B.output;m.globstar=true;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&!r&&eos()){m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=globstar(u)+(u.strictSlashes?\")\":\"|$)\");B.value+=G;m.globstar=true;m.output+=n.output+B.output;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&e[0]===\"/\"){const t=e[1]!==void 0?\"|$\":\"\";m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=`${globstar(u)}${b}|${b}${t})`;B.value+=G;m.output+=n.output+B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}if(n.type===\"bos\"&&e[0]===\"/\"){B.type=\"globstar\";B.value+=G;B.output=`(?:^|${b}|${globstar(u)}${b})`;m.output=B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}m.output=m.output.slice(0,-B.output.length);B.type=\"globstar\";B.output=globstar(u);B.value+=G;m.output+=B.output;m.globstar=true;consume(G);continue}const n={type:\"star\",value:G,output:k};if(u.bash===true){n.output=\".*?\";if(B.type===\"bos\"||B.type===\"slash\"){n.output=T+n.output}push(n);continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\")&&u.regex===true){n.output=G;push(n);continue}if(m.index===m.start||B.type===\"slash\"||B.type===\"dot\"){if(B.type===\"dot\"){m.output+=x;B.output+=x}else if(u.dot===true){m.output+=S;B.output+=S}else{m.output+=T;B.output+=T}if(D()!==\"*\"){m.output+=C;B.output+=C}}push(n)}while(m.brackets>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"]\"));m.output=o.escapeLast(m.output,\"[\");decrement(\"brackets\")}while(m.parens>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\")\"));m.output=o.escapeLast(m.output,\"(\");decrement(\"parens\")}while(m.braces>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"}\"));m.output=o.escapeLast(m.output,\"{\");decrement(\"braces\")}if(u.strictSlashes!==true&&(B.type===\"star\"||B.type===\"bracket\")){push({type:\"maybe_slash\",value:\"\",output:`${b}?`})}if(m.backtrack===true){m.output=\"\";for(const t of m.tokens){m.output+=t.output!=null?t.output:t.value;if(t.suffix){m.output+=t.suffix}}}return m};parse.fastpaths=(t,e)=>{const u={...e};const r=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;const a=t.length;if(a>r){throw new SyntaxError(`Input length: ${a}, exceeds maximum allowed length: ${r}`)}t=c[t]||t;const{DOT_LITERAL:i,SLASH_LITERAL:p,ONE_CHAR:l,DOTS_SLASH:f,NO_DOT:A,NO_DOTS:_,NO_DOTS_SLASH:R,STAR:E,START_ANCHOR:h}=n.globChars(u.windows);const g=u.dot?_:A;const b=u.dot?R:A;const C=u.capture?\"\":\"?:\";const y={negated:false,prefix:\"\"};let $=u.bash===true?\".*?\":E;if(u.capture){$=`(${$})`}const globstar=t=>{if(t.noglobstar===true)return $;return`(${C}(?:(?!${h}${t.dot?f:i}).)*?)`};const create=t=>{switch(t){case\"*\":return`${g}${l}${$}`;case\".*\":return`${i}${l}${$}`;case\"*.*\":return`${g}${$}${i}${l}${$}`;case\"*/*\":return`${g}${$}${p}${l}${b}${$}`;case\"**\":return g+globstar(u);case\"**/*\":return`(?:${g}${globstar(u)}${p})?${b}${l}${$}`;case\"**/*.*\":return`(?:${g}${globstar(u)}${p})?${b}${$}${i}${l}${$}`;case\"**/.*\":return`(?:${g}${globstar(u)}${p})?${i}${l}${$}`;default:{const e=/^(.*?)\\.(\\w+)$/.exec(t);if(!e)return;const u=create(e[1]);if(!u)return;return u+i+e[2]}}};const x=o.removePrefix(t,y);let S=create(x);if(S&&u.strictSlashes!==true){S+=`${p}?`}return S};t.exports=parse},510:(t,e,u)=>{const n=u(716);const o=u(697);const s=u(96);const r=u(154);const isObject=t=>t&&typeof t===\"object\"&&!Array.isArray(t);const picomatch=(t,e,u=false)=>{if(Array.isArray(t)){const n=t.map((t=>picomatch(t,e,u)));const arrayMatcher=t=>{for(const e of n){const u=e(t);if(u)return u}return false};return arrayMatcher}const n=isObject(t)&&t.tokens&&t.input;if(t===\"\"||typeof t!==\"string\"&&!n){throw new TypeError(\"Expected pattern to be a non-empty string\")}const o=e||{};const s=o.windows;const r=n?picomatch.compileRe(t,e):picomatch.makeRe(t,e,false,true);const a=r.state;delete r.state;let isIgnored=()=>false;if(o.ignore){const t={...e,ignore:null,onMatch:null,onResult:null};isIgnored=picomatch(o.ignore,t,u)}const matcher=(u,n=false)=>{const{isMatch:i,match:c,output:p}=picomatch.test(u,r,e,{glob:t,posix:s});const l={glob:t,state:a,regex:r,posix:s,input:u,output:p,match:c,isMatch:i};if(typeof o.onResult===\"function\"){o.onResult(l)}if(i===false){l.isMatch=false;return n?l:false}if(isIgnored(u)){if(typeof o.onIgnore===\"function\"){o.onIgnore(l)}l.isMatch=false;return n?l:false}if(typeof o.onMatch===\"function\"){o.onMatch(l)}return n?l:true};if(u){matcher.state=a}return matcher};picomatch.test=(t,e,u,{glob:n,posix:o}={})=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected input to be a string\")}if(t===\"\"){return{isMatch:false,output:\"\"}}const r=u||{};const a=r.format||(o?s.toPosixSlashes:null);let i=t===n;let c=i&&a?a(t):t;if(i===false){c=a?a(t):t;i=c===n}if(i===false||r.capture===true){if(r.matchBase===true||r.basename===true){i=picomatch.matchBase(t,e,u,o)}else{i=e.exec(c)}}return{isMatch:Boolean(i),match:i,output:c}};picomatch.matchBase=(t,e,u)=>{const n=e instanceof RegExp?e:picomatch.makeRe(e,u);return n.test(s.basename(t))};picomatch.isMatch=(t,e,u)=>picomatch(e,u)(t);picomatch.parse=(t,e)=>{if(Array.isArray(t))return t.map((t=>picomatch.parse(t,e)));return o(t,{...e,fastpaths:false})};picomatch.scan=(t,e)=>n(t,e);picomatch.compileRe=(t,e,u=false,n=false)=>{if(u===true){return t.output}const o=e||{};const s=o.contains?\"\":\"^\";const r=o.contains?\"\":\"$\";let a=`${s}(?:${t.output})${r}`;if(t&&t.negated===true){a=`^(?!${a}).*$`}const i=picomatch.toRegex(a,e);if(n===true){i.state=t}return i};picomatch.makeRe=(t,e={},u=false,n=false)=>{if(!t||typeof t!==\"string\"){throw new TypeError(\"Expected a non-empty string\")}let s={negated:false,fastpaths:true};if(e.fastpaths!==false&&(t[0]===\".\"||t[0]===\"*\")){s.output=o.fastpaths(t,e)}if(!s.output){s=o(t,e)}return picomatch.compileRe(s,e,u,n)};picomatch.toRegex=(t,e)=>{try{const u=e||{};return new RegExp(t,u.flags||(u.nocase?\"i\":\"\"))}catch(t){if(e&&e.debug===true)throw t;return/$^/}};picomatch.constants=r;t.exports=picomatch},716:(t,e,u)=>{const n=u(96);const{CHAR_ASTERISK:o,CHAR_AT:s,CHAR_BACKWARD_SLASH:r,CHAR_COMMA:a,CHAR_DOT:i,CHAR_EXCLAMATION_MARK:c,CHAR_FORWARD_SLASH:p,CHAR_LEFT_CURLY_BRACE:l,CHAR_LEFT_PARENTHESES:f,CHAR_LEFT_SQUARE_BRACKET:A,CHAR_PLUS:_,CHAR_QUESTION_MARK:R,CHAR_RIGHT_CURLY_BRACE:E,CHAR_RIGHT_PARENTHESES:h,CHAR_RIGHT_SQUARE_BRACKET:g}=u(154);const isPathSeparator=t=>t===p||t===r;const depth=t=>{if(t.isPrefix!==true){t.depth=t.isGlobstar?Infinity:1}};const scan=(t,e)=>{const u=e||{};const b=t.length-1;const C=u.parts===true||u.scanToEnd===true;const y=[];const $=[];const x=[];let S=t;let H=-1;let v=0;let d=0;let L=false;let T=false;let O=false;let k=false;let m=false;let w=false;let N=false;let I=false;let B=false;let G=false;let D=0;let M;let P;let K={value:\"\",depth:0,isGlob:false};const eos=()=>H>=b;const peek=()=>S.charCodeAt(H+1);const advance=()=>{M=P;return S.charCodeAt(++H)};while(H<b){P=advance();let t;if(P===r){N=K.backslashes=true;P=advance();if(P===l){w=true}continue}if(w===true||P===l){D++;while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;advance();continue}if(P===l){D++;continue}if(w!==true&&P===i&&(P=advance())===i){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(w!==true&&P===a){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===E){D--;if(D===0){w=false;L=K.isBrace=true;G=true;break}}}if(C===true){continue}break}if(P===p){y.push(H);$.push(K);K={value:\"\",depth:0,isGlob:false};if(G===true)continue;if(M===i&&H===v+1){v+=2;continue}d=H+1;continue}if(u.noext!==true){const t=P===_||P===s||P===o||P===R||P===c;if(t===true&&peek()===f){O=K.isGlob=true;k=K.isExtglob=true;G=true;if(P===c&&H===v){B=true}if(C===true){while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;P=advance();continue}if(P===h){O=K.isGlob=true;G=true;break}}continue}break}}if(P===o){if(M===o)m=K.isGlobstar=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===R){O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===A){while(eos()!==true&&(t=advance())){if(t===r){N=K.backslashes=true;advance();continue}if(t===g){T=K.isBracket=true;O=K.isGlob=true;G=true;break}}if(C===true){continue}break}if(u.nonegate!==true&&P===c&&H===v){I=K.negated=true;v++;continue}if(u.noparen!==true&&P===f){O=K.isGlob=true;if(C===true){while(eos()!==true&&(P=advance())){if(P===f){N=K.backslashes=true;P=advance();continue}if(P===h){G=true;break}}continue}break}if(O===true){G=true;if(C===true){continue}break}}if(u.noext===true){k=false;O=false}let U=S;let X=\"\";let F=\"\";if(v>0){X=S.slice(0,v);S=S.slice(v);d-=v}if(U&&O===true&&d>0){U=S.slice(0,d);F=S.slice(d)}else if(O===true){U=\"\";F=S}else{U=S}if(U&&U!==\"\"&&U!==\"/\"&&U!==S){if(isPathSeparator(U.charCodeAt(U.length-1))){U=U.slice(0,-1)}}if(u.unescape===true){if(F)F=n.removeBackslashes(F);if(U&&N===true){U=n.removeBackslashes(U)}}const Q={prefix:X,input:t,start:v,base:U,glob:F,isBrace:L,isBracket:T,isGlob:O,isExtglob:k,isGlobstar:m,negated:I,negatedExtglob:B};if(u.tokens===true){Q.maxDepth=0;if(!isPathSeparator(P)){$.push(K)}Q.tokens=$}if(u.parts===true||u.tokens===true){let e;for(let n=0;n<y.length;n++){const o=e?e+1:v;const s=y[n];const r=t.slice(o,s);if(u.tokens){if(n===0&&v!==0){$[n].isPrefix=true;$[n].value=X}else{$[n].value=r}depth($[n]);Q.maxDepth+=$[n].depth}if(n!==0||r!==\"\"){x.push(r)}e=s}if(e&&e+1<t.length){const n=t.slice(e+1);x.push(n);if(u.tokens){$[$.length-1].value=n;depth($[$.length-1]);Q.maxDepth+=$[$.length-1].depth}}Q.slashes=y;Q.parts=x}return Q};t.exports=scan},96:(t,e,u)=>{const{REGEX_BACKSLASH:n,REGEX_REMOVE_BACKSLASH:o,REGEX_SPECIAL_CHARS:s,REGEX_SPECIAL_CHARS_GLOBAL:r}=u(154);e.isObject=t=>t!==null&&typeof t===\"object\"&&!Array.isArray(t);e.hasRegexChars=t=>s.test(t);e.isRegexChar=t=>t.length===1&&e.hasRegexChars(t);e.escapeRegex=t=>t.replace(r,\"\\\\$1\");e.toPosixSlashes=t=>t.replace(n,\"/\");e.removeBackslashes=t=>t.replace(o,(t=>t===\"\\\\\"?\"\":t));e.escapeLast=(t,u,n)=>{const o=t.lastIndexOf(u,n);if(o===-1)return t;if(t[o-1]===\"\\\\\")return e.escapeLast(t,u,o-1);return`${t.slice(0,o)}\\\\${t.slice(o)}`};e.removePrefix=(t,e={})=>{let u=t;if(u.startsWith(\"./\")){u=u.slice(2);e.prefix=\"./\"}return u};e.wrapOutput=(t,e={},u={})=>{const n=u.contains?\"\":\"^\";const o=u.contains?\"\":\"$\";let s=`${n}(?:${t})${o}`;if(e.negated===true){s=`(?:^(?!${s}).*$)`}return s};e.basename=(t,{windows:e}={})=>{const u=t.split(e?/[\\\\/]/:\"/\");const n=u[u.length-1];if(n===\"\"){return u[u.length-2]}return n}}};var e={};function __nccwpck_require__(u){var n=e[u];if(n!==undefined){return n.exports}var o=e[u]={exports:{}};var s=true;try{t[u](o,o.exports,__nccwpck_require__);s=false}finally{if(s)delete e[u]}return o.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var u=__nccwpck_require__(170);module.exports=u})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGljb21hdGNoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUEsTUFBTSxhQUFhLE9BQU8sY0FBYyxlQUFlLHFCQUFxQix1REFBdUQseUNBQXlDLGtDQUFrQyxVQUFVLE9BQU8sZ0JBQWdCLE9BQU8sV0FBVyxPQUFPLE9BQU8sb0JBQW9CLGNBQWMsZ0NBQWdDLGlEQUFpRCxHQUFHLDBCQUEwQixnQkFBZ0IsMkJBQTJCLG9CQUFvQixTQUFTLGdCQUFnQixhQUFhLEVBQUUsR0FBRyxjQUFjLGNBQWMsY0FBYyxjQUFjLGdCQUFnQixlQUFlLGNBQWMsRUFBRSxLQUFLLGdCQUFnQixFQUFFLEdBQUcsV0FBVyxHQUFHLElBQUksRUFBRSxFQUFFLEVBQUUsY0FBYyxFQUFFLEdBQUcsY0FBYyxFQUFFLEVBQUUsRUFBRSxHQUFHLGNBQWMsR0FBRyxJQUFJLEVBQUUsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLFdBQVcsRUFBRSxJQUFJLFlBQVksU0FBUyx3TUFBd00sU0FBUyx1QkFBdUIsRUFBRSxtQkFBbUIsRUFBRSxrQkFBa0IsR0FBRyxJQUFJLE1BQU0sRUFBRSxtQkFBbUIsRUFBRSx1QkFBdUIsRUFBRSxJQUFJLEdBQUcsSUFBSSxNQUFNLEVBQUUsMEJBQTBCLEdBQUcsSUFBSSxNQUFNLEVBQUUsMkJBQTJCLEdBQUcsSUFBSSxNQUFNLEVBQUUsMEJBQTBCLEVBQUUseUJBQXlCLEVBQUUsc0JBQXNCLEVBQUUsZ0JBQWdCLFNBQVMseUxBQXlMLGFBQWEsRUFBRSw4RUFBOEUsV0FBVyxzRUFBc0UscURBQXFELHlDQUF5QyxnR0FBZ0csNEVBQTRFLHVDQUF1QyxtM0JBQW0zQixPQUFPLEtBQUssMENBQTBDLE9BQU8sR0FBRyxNQUFNLG1DQUFtQyxNQUFNLGtDQUFrQyxNQUFNLGtDQUFrQyxNQUFNLGlDQUFpQyxjQUFjLHNCQUFzQixlQUFlLGVBQWUs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QUFPLGFBQWEsU0FBUyxPQUFPLG1CQUFtQixRQUFRLFFBQVEsUUFBUSxTQUFTLFNBQVMsUUFBUSxlQUFlLGFBQWEsS0FBSyxxQkFBcUIsZUFBZSxhQUFhLGtCQUFrQixLQUFLLElBQUksS0FBSyxJQUFJLDhCQUE4Qiw4Q0FBOEMsaUJBQWlCLHNCQUFzQiw4QkFBOEIsZ0JBQWdCLDBCQUEwQixTQUFTLDJIQUEySCxvQkFBb0IsYUFBYSx3QkFBd0IsVUFBVSxXQUFXLG9DQUFvQyxNQUFNLFlBQVksV0FBVyxLQUFLLGdCQUFnQixhQUFhLHFCQUFxQixhQUFhLGlCQUFpQixtQkFBbUIsYUFBYSxLQUFLLGFBQWEsWUFBWSx1QkFBdUIsa0JBQWtCLFVBQVUsSUFBSSxvQkFBb0IscUJBQXFCLFVBQVUsYUFBYSxzQkFBc0IscUJBQXFCLGlDQUFpQyxZQUFZLFVBQVUsVUFBVSxlQUFlLGNBQWMsTUFBTSw4RkFBOEYsUUFBUSwrREFBK0QsNkJBQTZCLGtEQUFrRCxxQ0FBcUMscUNBQXFDLHVEQUF1RCx1QkFBdUIsMkJBQTJCLG1CQUFtQiw4Q0FBOEMsU0FBUyxhQUFhLElBQUksV0FBVyxHQUFHLHNCQUFzQixJQUFJLFFBQVEsdUJBQXVCLGFBQWEsY0FBYyxVQUFVLG9CQUFvQixLQUFLLElBQUksMEJBQTBCLDBCQUEwQixTQUFTLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxFQUFFLHFCQUFxQixZQUFZLEVBQUUsT0FBTyxVQUFVLGVBQWUsVUFBVSxHQUFHLElBQUksK0JBQStCLHNCQUFzQixXQUFXLHFCQUFxQixZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGljb21hdGNoL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciB0PXsxNzA6KHQsZSx1KT0+e2NvbnN0IG49dSg1MTApO2NvbnN0IGlzV2luZG93cz0oKT0+e2lmKHR5cGVvZiBuYXZpZ2F0b3IhPT1cInVuZGVmaW5lZFwiJiZuYXZpZ2F0b3IucGxhdGZvcm0pe2NvbnN0IHQ9bmF2aWdhdG9yLnBsYXRmb3JtLnRvTG93ZXJDYXNlKCk7cmV0dXJuIHQ9PT1cIndpbjMyXCJ8fHQ9PT1cIndpbmRvd3NcIn1pZih0eXBlb2YgcHJvY2VzcyE9PVwidW5kZWZpbmVkXCImJnByb2Nlc3MucGxhdGZvcm0pe3JldHVybiBwcm9jZXNzLnBsYXRmb3JtPT09XCJ3aW4zMlwifXJldHVybiBmYWxzZX07ZnVuY3Rpb24gcGljb21hdGNoKHQsZSx1PWZhbHNlKXtpZihlJiYoZS53aW5kb3dzPT09bnVsbHx8ZS53aW5kb3dzPT09dW5kZWZpbmVkKSl7ZT17Li4uZSx3aW5kb3dzOmlzV2luZG93cygpfX1yZXR1cm4gbih0LGUsdSl9T2JqZWN0LmFzc2lnbihwaWNvbWF0Y2gsbik7dC5leHBvcnRzPXBpY29tYXRjaH0sMTU0OnQ9Pntjb25zdCBlPVwiXFxcXFxcXFwvXCI7Y29uc3QgdT1gW14ke2V9XWA7Y29uc3Qgbj1cIlxcXFwuXCI7Y29uc3Qgbz1cIlxcXFwrXCI7Y29uc3Qgcz1cIlxcXFw/XCI7Y29uc3Qgcj1cIlxcXFwvXCI7Y29uc3QgYT1cIig/PS4pXCI7Y29uc3QgaT1cIlteL11cIjtjb25zdCBjPWAoPzoke3J9fCQpYDtjb25zdCBwPWAoPzpefCR7cn0pYDtjb25zdCBsPWAke259ezEsMn0ke2N9YDtjb25zdCBmPWAoPyEke259KWA7Y29uc3QgQT1gKD8hJHtwfSR7bH0pYDtjb25zdCBfPWAoPyEke259ezAsMX0ke2N9KWA7Y29uc3QgUj1gKD8hJHtsfSlgO2NvbnN0IEU9YFteLiR7cn1dYDtjb25zdCBoPWAke2l9Kj9gO2NvbnN0IGc9XCIvXCI7Y29uc3QgYj17RE9UX0xJVEVSQUw6bixQTFVTX0xJVEVSQUw6byxRTUFSS19MSVRFUkFMOnMsU0xBU0hfTElURVJBTDpyLE9ORV9DSEFSOmEsUU1BUks6aSxFTkRfQU5DSE9SOmMsRE9UU19TTEFTSDpsLE5PX0RPVDpmLE5PX0RPVFM6QSxOT19ET1RfU0xBU0g6XyxOT19ET1RTX1NMQVNIOlIsUU1BUktfTk9fRE9UOkUsU1RBUjpoLFNUQVJUX0FOQ0hPUjpwLFNFUDpnfTtjb25zdCBDPXsuLi5iLFNMQVNIX0xJVEVSQUw6YFske2V9XWAsUU1BUks6dSxTVEFSOmAke3V9Kj9gLERPVFNfU0xBU0g6YCR7bn17MSwyfSg/Olske2V9XXwkKWAsTk9fRE9UOmAoPyEke259KWAsTk9fRE9UUzpgKD8hKD86XnxbJHtlfV0pJHtufXsxLDJ9KD86WyR7ZX1dfCQpKWAsTk9fRE9UX1NMQVNIOmAoPyEke259ezAsMX0oPzpbJHtlfV18JCkpYCxOT19ET1RTX1NMQVNIOmAoPyEke259ezEsMn0oPzpbJHtlfV18JCkpYCxRTUFSS19OT19ET1Q6YFteLiR7ZX1dYCxTVEFSVF9BTkNIT1I6YCg/Ol58WyR7ZX1dKWAsRU5EX0FOQ0hPUjpgKD86WyR7ZX1dfCQpYCxTRVA6XCJcXFxcXCJ9O2NvbnN0IHk9e2FsbnVtOlwiYS16QS1aMC05XCIsYWxwaGE6XCJhLXpBLVpcIixhc2NpaTpcIlxcXFx4MDAtXFxcXHg3RlwiLGJsYW5rOlwiIFxcXFx0XCIsY250cmw6XCJcXFxceDAwLVxcXFx4MUZcXFxceDdGXCIsZGlnaXQ6XCIwLTlcIixncmFwaDpcIlxcXFx4MjEtXFxcXHg3RVwiLGxvd2VyOlwiYS16XCIscHJpbnQ6XCJcXFxceDIwLVxcXFx4N0UgXCIscHVuY3Q6XCJcXFxcLSFcXFwiIyQlJicoKVxcXFwqKywuLzo7PD0+P0BbXFxcXF1eX2B7fH1+XCIsc3BhY2U6XCIgXFxcXHRcXFxcclxcXFxuXFxcXHZcXFxcZlwiLHVwcGVyOlwiQS1aXCIsd29yZDpcIkEtWmEtejAtOV9cIix4ZGlnaXQ6XCJBLUZhLWYwLTlcIn07dC5leHBvcnRzPXtNQVhfTEVOR1RIOjEwMjQqNjQsUE9TSVhfUkVHRVhfU09VUkNFOnksUkVHRVhfQkFDS1NMQVNIOi9cXFxcKD8hWyorP14ke30ofClbXFxdXSkvZyxSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzovXlteQCFbXFxdLiwkKis/Xnt9KCl8XFxcXC9dKy8sUkVHRVhfU1BFQ0lBTF9DSEFSUzovWy0qKz8uXiR7fSh8KVtcXF1dLyxSRUdFWF9TUEVDSUFMX0NIQVJTX0JBQ0tSRUY6LyhcXFxcPykoKFxcVykoXFwzKikpL2csUkVHRVhfU1BFQ0lBTF9DSEFSU19HTE9CQUw6LyhbLSorPy5eJHt9KHwpW1xcXV0pL2csUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSDovKD86XFxbLio/W15cXFxcXVxcXXxcXFxcKD89LikpL2csUkVQTEFDRU1FTlRTOntcIioqKlwiOlwiKlwiLFwiKiovKipcIjpcIioqXCIsXCIqKi8qKi8qKlwiOlwiKipcIn0sQ0hBUl8wOjQ4LENIQVJfOTo1NyxDSEFSX1VQUEVSQ0FTRV9BOjY1LENIQVJfTE9XRVJDQVNFX0E6OTcsQ0hBUl9VUFBFUkNBU0VfWjo5MCxDSEFSX0xPV0VSQ0FTRV9aOjEyMixDSEFSX0xFRlRfUEFSRU5USEVTRVM6NDAsQ0hBUl9SSUdIVF9QQVJFTlRIRVNFUzo0MSxDSEFSX0FTVEVSSVNLOjQyLENIQVJfQU1QRVJTQU5EOjM4LENIQVJfQVQ6NjQsQ0hBUl9CQUNLV0FSRF9TTEFTSDo5MixDSEFSX0NBUlJJQUdFX1JFVFVSTjoxMyxDSEFSX0NJUkNVTUZMRVhfQUNDRU5UOjk0LENIQVJfQ09MT046NTgsQ0hBUl9DT01NQTo0NCxDSEFSX0RPVDo0NixDSEFSX0RPVUJMRV9RVU9URTozNCxDSEFSX0VRVUFMOjYxLENIQVJfRVhDTEFNQVRJT05fTUFSSzozMyxDSEFSX0ZPUk1fRkVFRDoxMixDSEFSX0ZPUldBUkRfU0xBU0g6NDcsQ0hBUl9HUkFWRV9BQ0NFTlQ6OTYsQ0hBUl9IQVNIOjM1LENIQVJfSFlQSEVOX01JTlVTOjQ1LENIQVJfTEVGVF9BTkdMRV9CUkFDS0VUOjYwLENIQVJfTEVGVF9DVVJMWV9CUkFDRToxMjMsQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOjkxLENIQVJfTElORV9GRUVEOjEwLENIQVJfTk9fQlJFQUtfU1BBQ0U6MTYwLENIQVJfUEVSQ0VOVDozNyxDSEFSX1BMVVM6NDMsQ0hBUl9RVUVTVElPTl9NQVJLOjYzLENIQVJfUklHSFRfQU5HTEVfQlJBQ0tFVDo2MixDSEFSX1JJR0hUX0NVUkxZX0JSQUNFOjEyNSxDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUOjkzLENIQVJfU0VNSUNPTE9OOjU5LENIQVJfU0lOR0xFX1FVT1RFOjM5LENIQVJfU1BBQ0U6MzIsQ0hBUl9UQUI6OSxDSEFSX1VOREVSU0NPUkU6OTUsQ0hBUl9WRVJUSUNBTF9MSU5FOjEyNCxDSEFSX1pFUk9fV0lEVEhfTk9CUkVBS19TUEFDRTo2NTI3OSxleHRnbG9iQ2hhcnModCl7cmV0dXJue1wiIVwiOnt0eXBlOlwibmVnYXRlXCIsb3BlbjpcIig/Oig/ISg/OlwiLGNsb3NlOmApKSR7dC5TVEFSfSlgfSxcIj9cIjp7dHlwZTpcInFtYXJrXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKT9cIn0sXCIrXCI6e3R5cGU6XCJwbHVzXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKStcIn0sXCIqXCI6e3R5cGU6XCJzdGFyXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKSpcIn0sXCJAXCI6e3R5cGU6XCJhdFwiLG9wZW46XCIoPzpcIixjbG9zZTpcIilcIn19fSxnbG9iQ2hhcnModCl7cmV0dXJuIHQ9PT10cnVlP0M6Yn19fSw2OTc6KHQsZSx1KT0+e2NvbnN0IG49dSgxNTQpO2NvbnN0IG89dSg5Nik7Y29uc3R7TUFYX0xFTkdUSDpzLFBPU0lYX1JFR0VYX1NPVVJDRTpyLFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTOmEsUkVHRVhfU1BFQ0lBTF9DSEFSU19CQUNLUkVGOmksUkVQTEFDRU1FTlRTOmN9PW47Y29uc3QgZXhwYW5kUmFuZ2U9KHQsZSk9PntpZih0eXBlb2YgZS5leHBhbmRSYW5nZT09PVwiZnVuY3Rpb25cIil7cmV0dXJuIGUuZXhwYW5kUmFuZ2UoLi4udCxlKX10LnNvcnQoKTtjb25zdCB1PWBbJHt0LmpvaW4oXCItXCIpfV1gO3RyeXtuZXcgUmVnRXhwKHUpfWNhdGNoKGUpe3JldHVybiB0Lm1hcCgodD0+by5lc2NhcGVSZWdleCh0KSkpLmpvaW4oXCIuLlwiKX1yZXR1cm4gdX07Y29uc3Qgc3ludGF4RXJyb3I9KHQsZSk9PmBNaXNzaW5nICR7dH06IFwiJHtlfVwiIC0gdXNlIFwiXFxcXFxcXFwke2V9XCIgdG8gbWF0Y2ggbGl0ZXJhbCBjaGFyYWN0ZXJzYDtjb25zdCBwYXJzZT0odCxlKT0+e2lmKHR5cGVvZiB0IT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgc3RyaW5nXCIpfXQ9Y1t0XXx8dDtjb25zdCB1PXsuLi5lfTtjb25zdCBwPXR5cGVvZiB1Lm1heExlbmd0aD09PVwibnVtYmVyXCI/TWF0aC5taW4ocyx1Lm1heExlbmd0aCk6cztsZXQgbD10Lmxlbmd0aDtpZihsPnApe3Rocm93IG5ldyBTeW50YXhFcnJvcihgSW5wdXQgbGVuZ3RoOiAke2x9LCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBsZW5ndGg6ICR7cH1gKX1jb25zdCBmPXt0eXBlOlwiYm9zXCIsdmFsdWU6XCJcIixvdXRwdXQ6dS5wcmVwZW5kfHxcIlwifTtjb25zdCBBPVtmXTtjb25zdCBfPXUuY2FwdHVyZT9cIlwiOlwiPzpcIjtjb25zdCBSPW4uZ2xvYkNoYXJzKHUud2luZG93cyk7Y29uc3QgRT1uLmV4dGdsb2JDaGFycyhSKTtjb25zdHtET1RfTElURVJBTDpoLFBMVVNfTElURVJBTDpnLFNMQVNIX0xJVEVSQUw6YixPTkVfQ0hBUjpDLERPVFNfU0xBU0g6eSxOT19ET1Q6JCxOT19ET1RfU0xBU0g6eCxOT19ET1RTX1NMQVNIOlMsUU1BUks6SCxRTUFSS19OT19ET1Q6dixTVEFSOmQsU1RBUlRfQU5DSE9SOkx9PVI7Y29uc3QgZ2xvYnN0YXI9dD0+YCgke199KD86KD8hJHtMfSR7dC5kb3Q/eTpofSkuKSo/KWA7Y29uc3QgVD11LmRvdD9cIlwiOiQ7Y29uc3QgTz11LmRvdD9IOnY7bGV0IGs9dS5iYXNoPT09dHJ1ZT9nbG9ic3Rhcih1KTpkO2lmKHUuY2FwdHVyZSl7az1gKCR7a30pYH1pZih0eXBlb2YgdS5ub2V4dD09PVwiYm9vbGVhblwiKXt1Lm5vZXh0Z2xvYj11Lm5vZXh0fWNvbnN0IG09e2lucHV0OnQsaW5kZXg6LTEsc3RhcnQ6MCxkb3Q6dS5kb3Q9PT10cnVlLGNvbnN1bWVkOlwiXCIsb3V0cHV0OlwiXCIscHJlZml4OlwiXCIsYmFja3RyYWNrOmZhbHNlLG5lZ2F0ZWQ6ZmFsc2UsYnJhY2tldHM6MCxicmFjZXM6MCxwYXJlbnM6MCxxdW90ZXM6MCxnbG9ic3RhcjpmYWxzZSx0b2tlbnM6QX07dD1vLnJlbW92ZVByZWZpeCh0LG0pO2w9dC5sZW5ndGg7Y29uc3Qgdz1bXTtjb25zdCBOPVtdO2NvbnN0IEk9W107bGV0IEI9ZjtsZXQgRztjb25zdCBlb3M9KCk9Pm0uaW5kZXg9PT1sLTE7Y29uc3QgRD1tLnBlZWs9KGU9MSk9PnRbbS5pbmRleCtlXTtjb25zdCBNPW0uYWR2YW5jZT0oKT0+dFsrK20uaW5kZXhdfHxcIlwiO2NvbnN0IHJlbWFpbmluZz0oKT0+dC5zbGljZShtLmluZGV4KzEpO2NvbnN0IGNvbnN1bWU9KHQ9XCJcIixlPTApPT57bS5jb25zdW1lZCs9dDttLmluZGV4Kz1lfTtjb25zdCBhcHBlbmQ9dD0+e20ub3V0cHV0Kz10Lm91dHB1dCE9bnVsbD90Lm91dHB1dDp0LnZhbHVlO2NvbnN1bWUodC52YWx1ZSl9O2NvbnN0IG5lZ2F0ZT0oKT0+e2xldCB0PTE7d2hpbGUoRCgpPT09XCIhXCImJihEKDIpIT09XCIoXCJ8fEQoMyk9PT1cIj9cIikpe00oKTttLnN0YXJ0Kys7dCsrfWlmKHQlMj09PTApe3JldHVybiBmYWxzZX1tLm5lZ2F0ZWQ9dHJ1ZTttLnN0YXJ0Kys7cmV0dXJuIHRydWV9O2NvbnN0IGluY3JlbWVudD10PT57bVt0XSsrO0kucHVzaCh0KX07Y29uc3QgZGVjcmVtZW50PXQ9PnttW3RdLS07SS5wb3AoKX07Y29uc3QgcHVzaD10PT57aWYoQi50eXBlPT09XCJnbG9ic3RhclwiKXtjb25zdCBlPW0uYnJhY2VzPjAmJih0LnR5cGU9PT1cImNvbW1hXCJ8fHQudHlwZT09PVwiYnJhY2VcIik7Y29uc3QgdT10LmV4dGdsb2I9PT10cnVlfHx3Lmxlbmd0aCYmKHQudHlwZT09PVwicGlwZVwifHx0LnR5cGU9PT1cInBhcmVuXCIpO2lmKHQudHlwZSE9PVwic2xhc2hcIiYmdC50eXBlIT09XCJwYXJlblwiJiYhZSYmIXUpe20ub3V0cHV0PW0ub3V0cHV0LnNsaWNlKDAsLUIub3V0cHV0Lmxlbmd0aCk7Qi50eXBlPVwic3RhclwiO0IudmFsdWU9XCIqXCI7Qi5vdXRwdXQ9azttLm91dHB1dCs9Qi5vdXRwdXR9fWlmKHcubGVuZ3RoJiZ0LnR5cGUhPT1cInBhcmVuXCIpe3dbdy5sZW5ndGgtMV0uaW5uZXIrPXQudmFsdWV9aWYodC52YWx1ZXx8dC5vdXRwdXQpYXBwZW5kKHQpO2lmKEImJkIudHlwZT09PVwidGV4dFwiJiZ0LnR5cGU9PT1cInRleHRcIil7Qi5vdXRwdXQ9KEIub3V0cHV0fHxCLnZhbHVlKSt0LnZhbHVlO0IudmFsdWUrPXQudmFsdWU7cmV0dXJufXQucHJldj1CO0EucHVzaCh0KTtCPXR9O2NvbnN0IGV4dGdsb2JPcGVuPSh0LGUpPT57Y29uc3Qgbj17Li4uRVtlXSxjb25kaXRpb25zOjEsaW5uZXI6XCJcIn07bi5wcmV2PUI7bi5wYXJlbnM9bS5wYXJlbnM7bi5vdXRwdXQ9bS5vdXRwdXQ7Y29uc3Qgbz0odS5jYXB0dXJlP1wiKFwiOlwiXCIpK24ub3BlbjtpbmNyZW1lbnQoXCJwYXJlbnNcIik7cHVzaCh7dHlwZTp0LHZhbHVlOmUsb3V0cHV0Om0ub3V0cHV0P1wiXCI6Q30pO3B1c2goe3R5cGU6XCJwYXJlblwiLGV4dGdsb2I6dHJ1ZSx2YWx1ZTpNKCksb3V0cHV0Om99KTt3LnB1c2gobil9O2NvbnN0IGV4dGdsb2JDbG9zZT10PT57bGV0IG49dC5jbG9zZSsodS5jYXB0dXJlP1wiKVwiOlwiXCIpO2xldCBvO2lmKHQudHlwZT09PVwibmVnYXRlXCIpe2xldCBzPWs7aWYodC5pbm5lciYmdC5pbm5lci5sZW5ndGg+MSYmdC5pbm5lci5pbmNsdWRlcyhcIi9cIikpe3M9Z2xvYnN0YXIodSl9aWYocyE9PWt8fGVvcygpfHwvXlxcKSskLy50ZXN0KHJlbWFpbmluZygpKSl7bj10LmNsb3NlPWApJCkpJHtzfWB9aWYodC5pbm5lci5pbmNsdWRlcyhcIipcIikmJihvPXJlbWFpbmluZygpKSYmL15cXC5bXlxcXFwvLl0rJC8udGVzdChvKSl7Y29uc3QgdT1wYXJzZShvLHsuLi5lLGZhc3RwYXRoczpmYWxzZX0pLm91dHB1dDtuPXQuY2xvc2U9YCkke3V9KSR7c30pYH1pZih0LnByZXYudHlwZT09PVwiYm9zXCIpe20ubmVnYXRlZEV4dGdsb2I9dHJ1ZX19cHVzaCh7dHlwZTpcInBhcmVuXCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkcsb3V0cHV0Om59KTtkZWNyZW1lbnQoXCJwYXJlbnNcIil9O2lmKHUuZmFzdHBhdGhzIT09ZmFsc2UmJiEvKF5bKiFdfFsvKClbXFxde31cIl0pLy50ZXN0KHQpKXtsZXQgbj1mYWxzZTtsZXQgcz10LnJlcGxhY2UoaSwoKHQsZSx1LG8scyxyKT0+e2lmKG89PT1cIlxcXFxcIil7bj10cnVlO3JldHVybiB0fWlmKG89PT1cIj9cIil7aWYoZSl7cmV0dXJuIGUrbysocz9ILnJlcGVhdChzLmxlbmd0aCk6XCJcIil9aWYocj09PTApe3JldHVybiBPKyhzP0gucmVwZWF0KHMubGVuZ3RoKTpcIlwiKX1yZXR1cm4gSC5yZXBlYXQodS5sZW5ndGgpfWlmKG89PT1cIi5cIil7cmV0dXJuIGgucmVwZWF0KHUubGVuZ3RoKX1pZihvPT09XCIqXCIpe2lmKGUpe3JldHVybiBlK28rKHM/azpcIlwiKX1yZXR1cm4ga31yZXR1cm4gZT90OmBcXFxcJHt0fWB9KSk7aWYobj09PXRydWUpe2lmKHUudW5lc2NhcGU9PT10cnVlKXtzPXMucmVwbGFjZSgvXFxcXC9nLFwiXCIpfWVsc2V7cz1zLnJlcGxhY2UoL1xcXFwrL2csKHQ9PnQubGVuZ3RoJTI9PT0wP1wiXFxcXFxcXFxcIjp0P1wiXFxcXFwiOlwiXCIpKX19aWYocz09PXQmJnUuY29udGFpbnM9PT10cnVlKXttLm91dHB1dD10O3JldHVybiBtfW0ub3V0cHV0PW8ud3JhcE91dHB1dChzLG0sZSk7cmV0dXJuIG19d2hpbGUoIWVvcygpKXtHPU0oKTtpZihHPT09XCJcXDBcIil7Y29udGludWV9aWYoRz09PVwiXFxcXFwiKXtjb25zdCB0PUQoKTtpZih0PT09XCIvXCImJnUuYmFzaCE9PXRydWUpe2NvbnRpbnVlfWlmKHQ9PT1cIi5cInx8dD09PVwiO1wiKXtjb250aW51ZX1pZighdCl7Rys9XCJcXFxcXCI7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSk7Y29udGludWV9Y29uc3QgZT0vXlxcXFwrLy5leGVjKHJlbWFpbmluZygpKTtsZXQgbj0wO2lmKGUmJmVbMF0ubGVuZ3RoPjIpe249ZVswXS5sZW5ndGg7bS5pbmRleCs9bjtpZihuJTIhPT0wKXtHKz1cIlxcXFxcIn19aWYodS51bmVzY2FwZT09PXRydWUpe0c9TSgpfWVsc2V7Rys9TSgpfWlmKG0uYnJhY2tldHM9PT0wKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX19aWYobS5icmFja2V0cz4wJiYoRyE9PVwiXVwifHxCLnZhbHVlPT09XCJbXCJ8fEIudmFsdWU9PT1cIlteXCIpKXtpZih1LnBvc2l4IT09ZmFsc2UmJkc9PT1cIjpcIil7Y29uc3QgdD1CLnZhbHVlLnNsaWNlKDEpO2lmKHQuaW5jbHVkZXMoXCJbXCIpKXtCLnBvc2l4PXRydWU7aWYodC5pbmNsdWRlcyhcIjpcIikpe2NvbnN0IHQ9Qi52YWx1ZS5sYXN0SW5kZXhPZihcIltcIik7Y29uc3QgZT1CLnZhbHVlLnNsaWNlKDAsdCk7Y29uc3QgdT1CLnZhbHVlLnNsaWNlKHQrMik7Y29uc3Qgbj1yW3VdO2lmKG4pe0IudmFsdWU9ZStuO20uYmFja3RyYWNrPXRydWU7TSgpO2lmKCFmLm91dHB1dCYmQS5pbmRleE9mKEIpPT09MSl7Zi5vdXRwdXQ9Q31jb250aW51ZX19fX1pZihHPT09XCJbXCImJkQoKSE9PVwiOlwifHxHPT09XCItXCImJkQoKT09PVwiXVwiKXtHPWBcXFxcJHtHfWB9aWYoRz09PVwiXVwiJiYoQi52YWx1ZT09PVwiW1wifHxCLnZhbHVlPT09XCJbXlwiKSl7Rz1gXFxcXCR7R31gfWlmKHUucG9zaXg9PT10cnVlJiZHPT09XCIhXCImJkIudmFsdWU9PT1cIltcIil7Rz1cIl5cIn1CLnZhbHVlKz1HO2FwcGVuZCh7dmFsdWU6R30pO2NvbnRpbnVlfWlmKG0ucXVvdGVzPT09MSYmRyE9PSdcIicpe0c9by5lc2NhcGVSZWdleChHKTtCLnZhbHVlKz1HO2FwcGVuZCh7dmFsdWU6R30pO2NvbnRpbnVlfWlmKEc9PT0nXCInKXttLnF1b3Rlcz1tLnF1b3Rlcz09PTE/MDoxO2lmKHUua2VlcFF1b3Rlcz09PXRydWUpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6R30pfWNvbnRpbnVlfWlmKEc9PT1cIihcIil7aW5jcmVtZW50KFwicGFyZW5zXCIpO3B1c2goe3R5cGU6XCJwYXJlblwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09XCIpXCIpe2lmKG0ucGFyZW5zPT09MCYmdS5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcIm9wZW5pbmdcIixcIihcIikpfWNvbnN0IHQ9d1t3Lmxlbmd0aC0xXTtpZih0JiZtLnBhcmVucz09PXQucGFyZW5zKzEpe2V4dGdsb2JDbG9zZSh3LnBvcCgpKTtjb250aW51ZX1wdXNoKHt0eXBlOlwicGFyZW5cIix2YWx1ZTpHLG91dHB1dDptLnBhcmVucz9cIilcIjpcIlxcXFwpXCJ9KTtkZWNyZW1lbnQoXCJwYXJlbnNcIik7Y29udGludWV9aWYoRz09PVwiW1wiKXtpZih1Lm5vYnJhY2tldD09PXRydWV8fCFyZW1haW5pbmcoKS5pbmNsdWRlcyhcIl1cIikpe2lmKHUubm9icmFja2V0IT09dHJ1ZSYmdS5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIl1cIikpfUc9YFxcXFwke0d9YH1lbHNle2luY3JlbWVudChcImJyYWNrZXRzXCIpfXB1c2goe3R5cGU6XCJicmFja2V0XCIsdmFsdWU6R30pO2NvbnRpbnVlfWlmKEc9PT1cIl1cIil7aWYodS5ub2JyYWNrZXQ9PT10cnVlfHxCJiZCLnR5cGU9PT1cImJyYWNrZXRcIiYmQi52YWx1ZS5sZW5ndGg9PT0xKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkcsb3V0cHV0OmBcXFxcJHtHfWB9KTtjb250aW51ZX1pZihtLmJyYWNrZXRzPT09MCl7aWYodS5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcIm9wZW5pbmdcIixcIltcIikpfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6RyxvdXRwdXQ6YFxcXFwke0d9YH0pO2NvbnRpbnVlfWRlY3JlbWVudChcImJyYWNrZXRzXCIpO2NvbnN0IHQ9Qi52YWx1ZS5zbGljZSgxKTtpZihCLnBvc2l4IT09dHJ1ZSYmdFswXT09PVwiXlwiJiYhdC5pbmNsdWRlcyhcIi9cIikpe0c9YC8ke0d9YH1CLnZhbHVlKz1HO2FwcGVuZCh7dmFsdWU6R30pO2lmKHUubGl0ZXJhbEJyYWNrZXRzPT09ZmFsc2V8fG8uaGFzUmVnZXhDaGFycyh0KSl7Y29udGludWV9Y29uc3QgZT1vLmVzY2FwZVJlZ2V4KEIudmFsdWUpO20ub3V0cHV0PW0ub3V0cHV0LnNsaWNlKDAsLUIudmFsdWUubGVuZ3RoKTtpZih1LmxpdGVyYWxCcmFja2V0cz09PXRydWUpe20ub3V0cHV0Kz1lO0IudmFsdWU9ZTtjb250aW51ZX1CLnZhbHVlPWAoJHtffSR7ZX18JHtCLnZhbHVlfSlgO20ub3V0cHV0Kz1CLnZhbHVlO2NvbnRpbnVlfWlmKEc9PT1cIntcIiYmdS5ub2JyYWNlIT09dHJ1ZSl7aW5jcmVtZW50KFwiYnJhY2VzXCIpO2NvbnN0IHQ9e3R5cGU6XCJicmFjZVwiLHZhbHVlOkcsb3V0cHV0OlwiKFwiLG91dHB1dEluZGV4Om0ub3V0cHV0Lmxlbmd0aCx0b2tlbnNJbmRleDptLnRva2Vucy5sZW5ndGh9O04ucHVzaCh0KTtwdXNoKHQpO2NvbnRpbnVlfWlmKEc9PT1cIn1cIil7Y29uc3QgdD1OW04ubGVuZ3RoLTFdO2lmKHUubm9icmFjZT09PXRydWV8fCF0KXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkcsb3V0cHV0Okd9KTtjb250aW51ZX1sZXQgZT1cIilcIjtpZih0LmRvdHM9PT10cnVlKXtjb25zdCB0PUEuc2xpY2UoKTtjb25zdCBuPVtdO2ZvcihsZXQgZT10Lmxlbmd0aC0xO2U+PTA7ZS0tKXtBLnBvcCgpO2lmKHRbZV0udHlwZT09PVwiYnJhY2VcIil7YnJlYWt9aWYodFtlXS50eXBlIT09XCJkb3RzXCIpe24udW5zaGlmdCh0W2VdLnZhbHVlKX19ZT1leHBhbmRSYW5nZShuLHUpO20uYmFja3RyYWNrPXRydWV9aWYodC5jb21tYSE9PXRydWUmJnQuZG90cyE9PXRydWUpe2NvbnN0IHU9bS5vdXRwdXQuc2xpY2UoMCx0Lm91dHB1dEluZGV4KTtjb25zdCBuPW0udG9rZW5zLnNsaWNlKHQudG9rZW5zSW5kZXgpO3QudmFsdWU9dC5vdXRwdXQ9XCJcXFxce1wiO0c9ZT1cIlxcXFx9XCI7bS5vdXRwdXQ9dTtmb3IoY29uc3QgdCBvZiBuKXttLm91dHB1dCs9dC5vdXRwdXR8fHQudmFsdWV9fXB1c2goe3R5cGU6XCJicmFjZVwiLHZhbHVlOkcsb3V0cHV0OmV9KTtkZWNyZW1lbnQoXCJicmFjZXNcIik7Ti5wb3AoKTtjb250aW51ZX1pZihHPT09XCJ8XCIpe2lmKHcubGVuZ3RoPjApe3dbdy5sZW5ndGgtMV0uY29uZGl0aW9ucysrfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6R30pO2NvbnRpbnVlfWlmKEc9PT1cIixcIil7bGV0IHQ9Rztjb25zdCBlPU5bTi5sZW5ndGgtMV07aWYoZSYmSVtJLmxlbmd0aC0xXT09PVwiYnJhY2VzXCIpe2UuY29tbWE9dHJ1ZTt0PVwifFwifXB1c2goe3R5cGU6XCJjb21tYVwiLHZhbHVlOkcsb3V0cHV0OnR9KTtjb250aW51ZX1pZihHPT09XCIvXCIpe2lmKEIudHlwZT09PVwiZG90XCImJm0uaW5kZXg9PT1tLnN0YXJ0KzEpe20uc3RhcnQ9bS5pbmRleCsxO20uY29uc3VtZWQ9XCJcIjttLm91dHB1dD1cIlwiO0EucG9wKCk7Qj1mO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJzbGFzaFwiLHZhbHVlOkcsb3V0cHV0OmJ9KTtjb250aW51ZX1pZihHPT09XCIuXCIpe2lmKG0uYnJhY2VzPjAmJkIudHlwZT09PVwiZG90XCIpe2lmKEIudmFsdWU9PT1cIi5cIilCLm91dHB1dD1oO2NvbnN0IHQ9TltOLmxlbmd0aC0xXTtCLnR5cGU9XCJkb3RzXCI7Qi5vdXRwdXQrPUc7Qi52YWx1ZSs9Rzt0LmRvdHM9dHJ1ZTtjb250aW51ZX1pZihtLmJyYWNlcyttLnBhcmVucz09PTAmJkIudHlwZSE9PVwiYm9zXCImJkIudHlwZSE9PVwic2xhc2hcIil7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDpofSk7Y29udGludWV9cHVzaCh7dHlwZTpcImRvdFwiLHZhbHVlOkcsb3V0cHV0Omh9KTtjb250aW51ZX1pZihHPT09XCI/XCIpe2NvbnN0IHQ9QiYmQi52YWx1ZT09PVwiKFwiO2lmKCF0JiZ1Lm5vZXh0Z2xvYiE9PXRydWUmJkQoKT09PVwiKFwiJiZEKDIpIT09XCI/XCIpe2V4dGdsb2JPcGVuKFwicW1hcmtcIixHKTtjb250aW51ZX1pZihCJiZCLnR5cGU9PT1cInBhcmVuXCIpe2NvbnN0IHQ9RCgpO2xldCBlPUc7aWYoQi52YWx1ZT09PVwiKFwiJiYhL1shPTw6XS8udGVzdCh0KXx8dD09PVwiPFwiJiYhLzwoWyE9XXxcXHcrPikvLnRlc3QocmVtYWluaW5nKCkpKXtlPWBcXFxcJHtHfWB9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDplfSk7Y29udGludWV9aWYodS5kb3QhPT10cnVlJiYoQi50eXBlPT09XCJzbGFzaFwifHxCLnR5cGU9PT1cImJvc1wiKSl7cHVzaCh7dHlwZTpcInFtYXJrXCIsdmFsdWU6RyxvdXRwdXQ6dn0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJxbWFya1wiLHZhbHVlOkcsb3V0cHV0Okh9KTtjb250aW51ZX1pZihHPT09XCIhXCIpe2lmKHUubm9leHRnbG9iIT09dHJ1ZSYmRCgpPT09XCIoXCIpe2lmKEQoMikhPT1cIj9cInx8IS9bIT08Ol0vLnRlc3QoRCgzKSkpe2V4dGdsb2JPcGVuKFwibmVnYXRlXCIsRyk7Y29udGludWV9fWlmKHUubm9uZWdhdGUhPT10cnVlJiZtLmluZGV4PT09MCl7bmVnYXRlKCk7Y29udGludWV9fWlmKEc9PT1cIitcIil7aWYodS5ub2V4dGdsb2IhPT10cnVlJiZEKCk9PT1cIihcIiYmRCgyKSE9PVwiP1wiKXtleHRnbG9iT3BlbihcInBsdXNcIixHKTtjb250aW51ZX1pZihCJiZCLnZhbHVlPT09XCIoXCJ8fHUucmVnZXg9PT1mYWxzZSl7cHVzaCh7dHlwZTpcInBsdXNcIix2YWx1ZTpHLG91dHB1dDpnfSk7Y29udGludWV9aWYoQiYmKEIudHlwZT09PVwiYnJhY2tldFwifHxCLnR5cGU9PT1cInBhcmVuXCJ8fEIudHlwZT09PVwiYnJhY2VcIil8fG0ucGFyZW5zPjApe3B1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6R30pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6Z30pO2NvbnRpbnVlfWlmKEc9PT1cIkBcIil7aWYodS5ub2V4dGdsb2IhPT10cnVlJiZEKCk9PT1cIihcIiYmRCgyKSE9PVwiP1wiKXtwdXNoKHt0eXBlOlwiYXRcIixleHRnbG9iOnRydWUsdmFsdWU6RyxvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6R30pO2NvbnRpbnVlfWlmKEchPT1cIipcIil7aWYoRz09PVwiJFwifHxHPT09XCJeXCIpe0c9YFxcXFwke0d9YH1jb25zdCB0PWEuZXhlYyhyZW1haW5pbmcoKSk7aWYodCl7Rys9dFswXTttLmluZGV4Kz10WzBdLmxlbmd0aH1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihCJiYoQi50eXBlPT09XCJnbG9ic3RhclwifHxCLnN0YXI9PT10cnVlKSl7Qi50eXBlPVwic3RhclwiO0Iuc3Rhcj10cnVlO0IudmFsdWUrPUc7Qi5vdXRwdXQ9azttLmJhY2t0cmFjaz10cnVlO20uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEcpO2NvbnRpbnVlfWxldCBlPXJlbWFpbmluZygpO2lmKHUubm9leHRnbG9iIT09dHJ1ZSYmL15cXChbXj9dLy50ZXN0KGUpKXtleHRnbG9iT3BlbihcInN0YXJcIixHKTtjb250aW51ZX1pZihCLnR5cGU9PT1cInN0YXJcIil7aWYodS5ub2dsb2JzdGFyPT09dHJ1ZSl7Y29uc3VtZShHKTtjb250aW51ZX1jb25zdCBuPUIucHJldjtjb25zdCBvPW4ucHJldjtjb25zdCBzPW4udHlwZT09PVwic2xhc2hcInx8bi50eXBlPT09XCJib3NcIjtjb25zdCByPW8mJihvLnR5cGU9PT1cInN0YXJcInx8by50eXBlPT09XCJnbG9ic3RhclwiKTtpZih1LmJhc2g9PT10cnVlJiYoIXN8fGVbMF0mJmVbMF0hPT1cIi9cIikpe3B1c2goe3R5cGU6XCJzdGFyXCIsdmFsdWU6RyxvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfWNvbnN0IGE9bS5icmFjZXM+MCYmKG4udHlwZT09PVwiY29tbWFcInx8bi50eXBlPT09XCJicmFjZVwiKTtjb25zdCBpPXcubGVuZ3RoJiYobi50eXBlPT09XCJwaXBlXCJ8fG4udHlwZT09PVwicGFyZW5cIik7aWYoIXMmJm4udHlwZSE9PVwicGFyZW5cIiYmIWEmJiFpKXtwdXNoKHt0eXBlOlwic3RhclwiLHZhbHVlOkcsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX13aGlsZShlLnNsaWNlKDAsMyk9PT1cIi8qKlwiKXtjb25zdCB1PXRbbS5pbmRleCs0XTtpZih1JiZ1IT09XCIvXCIpe2JyZWFrfWU9ZS5zbGljZSgzKTtjb25zdW1lKFwiLyoqXCIsMyl9aWYobi50eXBlPT09XCJib3NcIiYmZW9zKCkpe0IudHlwZT1cImdsb2JzdGFyXCI7Qi52YWx1ZSs9RztCLm91dHB1dD1nbG9ic3Rhcih1KTttLm91dHB1dD1CLm91dHB1dDttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHKTtjb250aW51ZX1pZihuLnR5cGU9PT1cInNsYXNoXCImJm4ucHJldi50eXBlIT09XCJib3NcIiYmIXImJmVvcygpKXttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC0obi5vdXRwdXQrQi5vdXRwdXQpLmxlbmd0aCk7bi5vdXRwdXQ9YCg/OiR7bi5vdXRwdXR9YDtCLnR5cGU9XCJnbG9ic3RhclwiO0Iub3V0cHV0PWdsb2JzdGFyKHUpKyh1LnN0cmljdFNsYXNoZXM/XCIpXCI6XCJ8JClcIik7Qi52YWx1ZSs9RzttLmdsb2JzdGFyPXRydWU7bS5vdXRwdXQrPW4ub3V0cHV0K0Iub3V0cHV0O2NvbnN1bWUoRyk7Y29udGludWV9aWYobi50eXBlPT09XCJzbGFzaFwiJiZuLnByZXYudHlwZSE9PVwiYm9zXCImJmVbMF09PT1cIi9cIil7Y29uc3QgdD1lWzFdIT09dm9pZCAwP1wifCRcIjpcIlwiO20ub3V0cHV0PW0ub3V0cHV0LnNsaWNlKDAsLShuLm91dHB1dCtCLm91dHB1dCkubGVuZ3RoKTtuLm91dHB1dD1gKD86JHtuLm91dHB1dH1gO0IudHlwZT1cImdsb2JzdGFyXCI7Qi5vdXRwdXQ9YCR7Z2xvYnN0YXIodSl9JHtifXwke2J9JHt0fSlgO0IudmFsdWUrPUc7bS5vdXRwdXQrPW4ub3V0cHV0K0Iub3V0cHV0O20uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEcrTSgpKTtwdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpcIi9cIixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfWlmKG4udHlwZT09PVwiYm9zXCImJmVbMF09PT1cIi9cIil7Qi50eXBlPVwiZ2xvYnN0YXJcIjtCLnZhbHVlKz1HO0Iub3V0cHV0PWAoPzpefCR7Yn18JHtnbG9ic3Rhcih1KX0ke2J9KWA7bS5vdXRwdXQ9Qi5vdXRwdXQ7bS5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoRytNKCkpO3B1c2goe3R5cGU6XCJzbGFzaFwiLHZhbHVlOlwiL1wiLG91dHB1dDpcIlwifSk7Y29udGludWV9bS5vdXRwdXQ9bS5vdXRwdXQuc2xpY2UoMCwtQi5vdXRwdXQubGVuZ3RoKTtCLnR5cGU9XCJnbG9ic3RhclwiO0Iub3V0cHV0PWdsb2JzdGFyKHUpO0IudmFsdWUrPUc7bS5vdXRwdXQrPUIub3V0cHV0O20uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEcpO2NvbnRpbnVlfWNvbnN0IG49e3R5cGU6XCJzdGFyXCIsdmFsdWU6RyxvdXRwdXQ6a307aWYodS5iYXNoPT09dHJ1ZSl7bi5vdXRwdXQ9XCIuKj9cIjtpZihCLnR5cGU9PT1cImJvc1wifHxCLnR5cGU9PT1cInNsYXNoXCIpe24ub3V0cHV0PVQrbi5vdXRwdXR9cHVzaChuKTtjb250aW51ZX1pZihCJiYoQi50eXBlPT09XCJicmFja2V0XCJ8fEIudHlwZT09PVwicGFyZW5cIikmJnUucmVnZXg9PT10cnVlKXtuLm91dHB1dD1HO3B1c2gobik7Y29udGludWV9aWYobS5pbmRleD09PW0uc3RhcnR8fEIudHlwZT09PVwic2xhc2hcInx8Qi50eXBlPT09XCJkb3RcIil7aWYoQi50eXBlPT09XCJkb3RcIil7bS5vdXRwdXQrPXg7Qi5vdXRwdXQrPXh9ZWxzZSBpZih1LmRvdD09PXRydWUpe20ub3V0cHV0Kz1TO0Iub3V0cHV0Kz1TfWVsc2V7bS5vdXRwdXQrPVQ7Qi5vdXRwdXQrPVR9aWYoRCgpIT09XCIqXCIpe20ub3V0cHV0Kz1DO0Iub3V0cHV0Kz1DfX1wdXNoKG4pfXdoaWxlKG0uYnJhY2tldHM+MCl7aWYodS5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwiXVwiKSk7bS5vdXRwdXQ9by5lc2NhcGVMYXN0KG0ub3V0cHV0LFwiW1wiKTtkZWNyZW1lbnQoXCJicmFja2V0c1wiKX13aGlsZShtLnBhcmVucz4wKXtpZih1LnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCIpXCIpKTttLm91dHB1dD1vLmVzY2FwZUxhc3QobS5vdXRwdXQsXCIoXCIpO2RlY3JlbWVudChcInBhcmVuc1wiKX13aGlsZShtLmJyYWNlcz4wKXtpZih1LnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCJ9XCIpKTttLm91dHB1dD1vLmVzY2FwZUxhc3QobS5vdXRwdXQsXCJ7XCIpO2RlY3JlbWVudChcImJyYWNlc1wiKX1pZih1LnN0cmljdFNsYXNoZXMhPT10cnVlJiYoQi50eXBlPT09XCJzdGFyXCJ8fEIudHlwZT09PVwiYnJhY2tldFwiKSl7cHVzaCh7dHlwZTpcIm1heWJlX3NsYXNoXCIsdmFsdWU6XCJcIixvdXRwdXQ6YCR7Yn0/YH0pfWlmKG0uYmFja3RyYWNrPT09dHJ1ZSl7bS5vdXRwdXQ9XCJcIjtmb3IoY29uc3QgdCBvZiBtLnRva2Vucyl7bS5vdXRwdXQrPXQub3V0cHV0IT1udWxsP3Qub3V0cHV0OnQudmFsdWU7aWYodC5zdWZmaXgpe20ub3V0cHV0Kz10LnN1ZmZpeH19fXJldHVybiBtfTtwYXJzZS5mYXN0cGF0aHM9KHQsZSk9Pntjb25zdCB1PXsuLi5lfTtjb25zdCByPXR5cGVvZiB1Lm1heExlbmd0aD09PVwibnVtYmVyXCI/TWF0aC5taW4ocyx1Lm1heExlbmd0aCk6cztjb25zdCBhPXQubGVuZ3RoO2lmKGE+cil7dGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnB1dCBsZW5ndGg6ICR7YX0sIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIGxlbmd0aDogJHtyfWApfXQ9Y1t0XXx8dDtjb25zdHtET1RfTElURVJBTDppLFNMQVNIX0xJVEVSQUw6cCxPTkVfQ0hBUjpsLERPVFNfU0xBU0g6ZixOT19ET1Q6QSxOT19ET1RTOl8sTk9fRE9UU19TTEFTSDpSLFNUQVI6RSxTVEFSVF9BTkNIT1I6aH09bi5nbG9iQ2hhcnModS53aW5kb3dzKTtjb25zdCBnPXUuZG90P186QTtjb25zdCBiPXUuZG90P1I6QTtjb25zdCBDPXUuY2FwdHVyZT9cIlwiOlwiPzpcIjtjb25zdCB5PXtuZWdhdGVkOmZhbHNlLHByZWZpeDpcIlwifTtsZXQgJD11LmJhc2g9PT10cnVlP1wiLio/XCI6RTtpZih1LmNhcHR1cmUpeyQ9YCgkeyR9KWB9Y29uc3QgZ2xvYnN0YXI9dD0+e2lmKHQubm9nbG9ic3Rhcj09PXRydWUpcmV0dXJuICQ7cmV0dXJuYCgke0N9KD86KD8hJHtofSR7dC5kb3Q/ZjppfSkuKSo/KWB9O2NvbnN0IGNyZWF0ZT10PT57c3dpdGNoKHQpe2Nhc2VcIipcIjpyZXR1cm5gJHtnfSR7bH0keyR9YDtjYXNlXCIuKlwiOnJldHVybmAke2l9JHtsfSR7JH1gO2Nhc2VcIiouKlwiOnJldHVybmAke2d9JHskfSR7aX0ke2x9JHskfWA7Y2FzZVwiKi8qXCI6cmV0dXJuYCR7Z30keyR9JHtwfSR7bH0ke2J9JHskfWA7Y2FzZVwiKipcIjpyZXR1cm4gZytnbG9ic3Rhcih1KTtjYXNlXCIqKi8qXCI6cmV0dXJuYCg/OiR7Z30ke2dsb2JzdGFyKHUpfSR7cH0pPyR7Yn0ke2x9JHskfWA7Y2FzZVwiKiovKi4qXCI6cmV0dXJuYCg/OiR7Z30ke2dsb2JzdGFyKHUpfSR7cH0pPyR7Yn0keyR9JHtpfSR7bH0keyR9YDtjYXNlXCIqKi8uKlwiOnJldHVybmAoPzoke2d9JHtnbG9ic3Rhcih1KX0ke3B9KT8ke2l9JHtsfSR7JH1gO2RlZmF1bHQ6e2NvbnN0IGU9L14oLio/KVxcLihcXHcrKSQvLmV4ZWModCk7aWYoIWUpcmV0dXJuO2NvbnN0IHU9Y3JlYXRlKGVbMV0pO2lmKCF1KXJldHVybjtyZXR1cm4gdStpK2VbMl19fX07Y29uc3QgeD1vLnJlbW92ZVByZWZpeCh0LHkpO2xldCBTPWNyZWF0ZSh4KTtpZihTJiZ1LnN0cmljdFNsYXNoZXMhPT10cnVlKXtTKz1gJHtwfT9gfXJldHVybiBTfTt0LmV4cG9ydHM9cGFyc2V9LDUxMDoodCxlLHUpPT57Y29uc3Qgbj11KDcxNik7Y29uc3Qgbz11KDY5Nyk7Y29uc3Qgcz11KDk2KTtjb25zdCByPXUoMTU0KTtjb25zdCBpc09iamVjdD10PT50JiZ0eXBlb2YgdD09PVwib2JqZWN0XCImJiFBcnJheS5pc0FycmF5KHQpO2NvbnN0IHBpY29tYXRjaD0odCxlLHU9ZmFsc2UpPT57aWYoQXJyYXkuaXNBcnJheSh0KSl7Y29uc3Qgbj10Lm1hcCgodD0+cGljb21hdGNoKHQsZSx1KSkpO2NvbnN0IGFycmF5TWF0Y2hlcj10PT57Zm9yKGNvbnN0IGUgb2Ygbil7Y29uc3QgdT1lKHQpO2lmKHUpcmV0dXJuIHV9cmV0dXJuIGZhbHNlfTtyZXR1cm4gYXJyYXlNYXRjaGVyfWNvbnN0IG49aXNPYmplY3QodCkmJnQudG9rZW5zJiZ0LmlucHV0O2lmKHQ9PT1cIlwifHx0eXBlb2YgdCE9PVwic3RyaW5nXCImJiFuKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgcGF0dGVybiB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIil9Y29uc3Qgbz1lfHx7fTtjb25zdCBzPW8ud2luZG93cztjb25zdCByPW4/cGljb21hdGNoLmNvbXBpbGVSZSh0LGUpOnBpY29tYXRjaC5tYWtlUmUodCxlLGZhbHNlLHRydWUpO2NvbnN0IGE9ci5zdGF0ZTtkZWxldGUgci5zdGF0ZTtsZXQgaXNJZ25vcmVkPSgpPT5mYWxzZTtpZihvLmlnbm9yZSl7Y29uc3QgdD17Li4uZSxpZ25vcmU6bnVsbCxvbk1hdGNoOm51bGwsb25SZXN1bHQ6bnVsbH07aXNJZ25vcmVkPXBpY29tYXRjaChvLmlnbm9yZSx0LHUpfWNvbnN0IG1hdGNoZXI9KHUsbj1mYWxzZSk9Pntjb25zdHtpc01hdGNoOmksbWF0Y2g6YyxvdXRwdXQ6cH09cGljb21hdGNoLnRlc3QodSxyLGUse2dsb2I6dCxwb3NpeDpzfSk7Y29uc3QgbD17Z2xvYjp0LHN0YXRlOmEscmVnZXg6cixwb3NpeDpzLGlucHV0OnUsb3V0cHV0OnAsbWF0Y2g6Yyxpc01hdGNoOml9O2lmKHR5cGVvZiBvLm9uUmVzdWx0PT09XCJmdW5jdGlvblwiKXtvLm9uUmVzdWx0KGwpfWlmKGk9PT1mYWxzZSl7bC5pc01hdGNoPWZhbHNlO3JldHVybiBuP2w6ZmFsc2V9aWYoaXNJZ25vcmVkKHUpKXtpZih0eXBlb2Ygby5vbklnbm9yZT09PVwiZnVuY3Rpb25cIil7by5vbklnbm9yZShsKX1sLmlzTWF0Y2g9ZmFsc2U7cmV0dXJuIG4/bDpmYWxzZX1pZih0eXBlb2Ygby5vbk1hdGNoPT09XCJmdW5jdGlvblwiKXtvLm9uTWF0Y2gobCl9cmV0dXJuIG4/bDp0cnVlfTtpZih1KXttYXRjaGVyLnN0YXRlPWF9cmV0dXJuIG1hdGNoZXJ9O3BpY29tYXRjaC50ZXN0PSh0LGUsdSx7Z2xvYjpuLHBvc2l4Om99PXt9KT0+e2lmKHR5cGVvZiB0IT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGlucHV0IHRvIGJlIGEgc3RyaW5nXCIpfWlmKHQ9PT1cIlwiKXtyZXR1cm57aXNNYXRjaDpmYWxzZSxvdXRwdXQ6XCJcIn19Y29uc3Qgcj11fHx7fTtjb25zdCBhPXIuZm9ybWF0fHwobz9zLnRvUG9zaXhTbGFzaGVzOm51bGwpO2xldCBpPXQ9PT1uO2xldCBjPWkmJmE/YSh0KTp0O2lmKGk9PT1mYWxzZSl7Yz1hP2EodCk6dDtpPWM9PT1ufWlmKGk9PT1mYWxzZXx8ci5jYXB0dXJlPT09dHJ1ZSl7aWYoci5tYXRjaEJhc2U9PT10cnVlfHxyLmJhc2VuYW1lPT09dHJ1ZSl7aT1waWNvbWF0Y2gubWF0Y2hCYXNlKHQsZSx1LG8pfWVsc2V7aT1lLmV4ZWMoYyl9fXJldHVybntpc01hdGNoOkJvb2xlYW4oaSksbWF0Y2g6aSxvdXRwdXQ6Y319O3BpY29tYXRjaC5tYXRjaEJhc2U9KHQsZSx1KT0+e2NvbnN0IG49ZSBpbnN0YW5jZW9mIFJlZ0V4cD9lOnBpY29tYXRjaC5tYWtlUmUoZSx1KTtyZXR1cm4gbi50ZXN0KHMuYmFzZW5hbWUodCkpfTtwaWNvbWF0Y2guaXNNYXRjaD0odCxlLHUpPT5waWNvbWF0Y2goZSx1KSh0KTtwaWNvbWF0Y2gucGFyc2U9KHQsZSk9PntpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiB0Lm1hcCgodD0+cGljb21hdGNoLnBhcnNlKHQsZSkpKTtyZXR1cm4gbyh0LHsuLi5lLGZhc3RwYXRoczpmYWxzZX0pfTtwaWNvbWF0Y2guc2Nhbj0odCxlKT0+bih0LGUpO3BpY29tYXRjaC5jb21waWxlUmU9KHQsZSx1PWZhbHNlLG49ZmFsc2UpPT57aWYodT09PXRydWUpe3JldHVybiB0Lm91dHB1dH1jb25zdCBvPWV8fHt9O2NvbnN0IHM9by5jb250YWlucz9cIlwiOlwiXlwiO2NvbnN0IHI9by5jb250YWlucz9cIlwiOlwiJFwiO2xldCBhPWAke3N9KD86JHt0Lm91dHB1dH0pJHtyfWA7aWYodCYmdC5uZWdhdGVkPT09dHJ1ZSl7YT1gXig/ISR7YX0pLiokYH1jb25zdCBpPXBpY29tYXRjaC50b1JlZ2V4KGEsZSk7aWYobj09PXRydWUpe2kuc3RhdGU9dH1yZXR1cm4gaX07cGljb21hdGNoLm1ha2VSZT0odCxlPXt9LHU9ZmFsc2Usbj1mYWxzZSk9PntpZighdHx8dHlwZW9mIHQhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYSBub24tZW1wdHkgc3RyaW5nXCIpfWxldCBzPXtuZWdhdGVkOmZhbHNlLGZhc3RwYXRoczp0cnVlfTtpZihlLmZhc3RwYXRocyE9PWZhbHNlJiYodFswXT09PVwiLlwifHx0WzBdPT09XCIqXCIpKXtzLm91dHB1dD1vLmZhc3RwYXRocyh0LGUpfWlmKCFzLm91dHB1dCl7cz1vKHQsZSl9cmV0dXJuIHBpY29tYXRjaC5jb21waWxlUmUocyxlLHUsbil9O3BpY29tYXRjaC50b1JlZ2V4PSh0LGUpPT57dHJ5e2NvbnN0IHU9ZXx8e307cmV0dXJuIG5ldyBSZWdFeHAodCx1LmZsYWdzfHwodS5ub2Nhc2U/XCJpXCI6XCJcIikpfWNhdGNoKHQpe2lmKGUmJmUuZGVidWc9PT10cnVlKXRocm93IHQ7cmV0dXJuLyReL319O3BpY29tYXRjaC5jb25zdGFudHM9cjt0LmV4cG9ydHM9cGljb21hdGNofSw3MTY6KHQsZSx1KT0+e2NvbnN0IG49dSg5Nik7Y29uc3R7Q0hBUl9BU1RFUklTSzpvLENIQVJfQVQ6cyxDSEFSX0JBQ0tXQVJEX1NMQVNIOnIsQ0hBUl9DT01NQTphLENIQVJfRE9UOmksQ0hBUl9FWENMQU1BVElPTl9NQVJLOmMsQ0hBUl9GT1JXQVJEX1NMQVNIOnAsQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOmwsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOmYsQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOkEsQ0hBUl9QTFVTOl8sQ0hBUl9RVUVTVElPTl9NQVJLOlIsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRTpFLENIQVJfUklHSFRfUEFSRU5USEVTRVM6aCxDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUOmd9PXUoMTU0KTtjb25zdCBpc1BhdGhTZXBhcmF0b3I9dD0+dD09PXB8fHQ9PT1yO2NvbnN0IGRlcHRoPXQ9PntpZih0LmlzUHJlZml4IT09dHJ1ZSl7dC5kZXB0aD10LmlzR2xvYnN0YXI/SW5maW5pdHk6MX19O2NvbnN0IHNjYW49KHQsZSk9Pntjb25zdCB1PWV8fHt9O2NvbnN0IGI9dC5sZW5ndGgtMTtjb25zdCBDPXUucGFydHM9PT10cnVlfHx1LnNjYW5Ub0VuZD09PXRydWU7Y29uc3QgeT1bXTtjb25zdCAkPVtdO2NvbnN0IHg9W107bGV0IFM9dDtsZXQgSD0tMTtsZXQgdj0wO2xldCBkPTA7bGV0IEw9ZmFsc2U7bGV0IFQ9ZmFsc2U7bGV0IE89ZmFsc2U7bGV0IGs9ZmFsc2U7bGV0IG09ZmFsc2U7bGV0IHc9ZmFsc2U7bGV0IE49ZmFsc2U7bGV0IEk9ZmFsc2U7bGV0IEI9ZmFsc2U7bGV0IEc9ZmFsc2U7bGV0IEQ9MDtsZXQgTTtsZXQgUDtsZXQgSz17dmFsdWU6XCJcIixkZXB0aDowLGlzR2xvYjpmYWxzZX07Y29uc3QgZW9zPSgpPT5IPj1iO2NvbnN0IHBlZWs9KCk9PlMuY2hhckNvZGVBdChIKzEpO2NvbnN0IGFkdmFuY2U9KCk9PntNPVA7cmV0dXJuIFMuY2hhckNvZGVBdCgrK0gpfTt3aGlsZShIPGIpe1A9YWR2YW5jZSgpO2xldCB0O2lmKFA9PT1yKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTtQPWFkdmFuY2UoKTtpZihQPT09bCl7dz10cnVlfWNvbnRpbnVlfWlmKHc9PT10cnVlfHxQPT09bCl7RCsrO3doaWxlKGVvcygpIT09dHJ1ZSYmKFA9YWR2YW5jZSgpKSl7aWYoUD09PXIpe049Sy5iYWNrc2xhc2hlcz10cnVlO2FkdmFuY2UoKTtjb250aW51ZX1pZihQPT09bCl7RCsrO2NvbnRpbnVlfWlmKHchPT10cnVlJiZQPT09aSYmKFA9YWR2YW5jZSgpKT09PWkpe0w9Sy5pc0JyYWNlPXRydWU7Tz1LLmlzR2xvYj10cnVlO0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYodyE9PXRydWUmJlA9PT1hKXtMPUsuaXNCcmFjZT10cnVlO089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKFA9PT1FKXtELS07aWYoRD09PTApe3c9ZmFsc2U7TD1LLmlzQnJhY2U9dHJ1ZTtHPXRydWU7YnJlYWt9fX1pZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoUD09PXApe3kucHVzaChIKTskLnB1c2goSyk7Sz17dmFsdWU6XCJcIixkZXB0aDowLGlzR2xvYjpmYWxzZX07aWYoRz09PXRydWUpY29udGludWU7aWYoTT09PWkmJkg9PT12KzEpe3YrPTI7Y29udGludWV9ZD1IKzE7Y29udGludWV9aWYodS5ub2V4dCE9PXRydWUpe2NvbnN0IHQ9UD09PV98fFA9PT1zfHxQPT09b3x8UD09PVJ8fFA9PT1jO2lmKHQ9PT10cnVlJiZwZWVrKCk9PT1mKXtPPUsuaXNHbG9iPXRydWU7az1LLmlzRXh0Z2xvYj10cnVlO0c9dHJ1ZTtpZihQPT09YyYmSD09PXYpe0I9dHJ1ZX1pZihDPT09dHJ1ZSl7d2hpbGUoZW9zKCkhPT10cnVlJiYoUD1hZHZhbmNlKCkpKXtpZihQPT09cil7Tj1LLmJhY2tzbGFzaGVzPXRydWU7UD1hZHZhbmNlKCk7Y29udGludWV9aWYoUD09PWgpe089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7YnJlYWt9fWNvbnRpbnVlfWJyZWFrfX1pZihQPT09byl7aWYoTT09PW8pbT1LLmlzR2xvYnN0YXI9dHJ1ZTtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2lmKEM9PT10cnVlKXtjb250aW51ZX1icmVha31pZihQPT09Uil7Tz1LLmlzR2xvYj10cnVlO0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoUD09PUEpe3doaWxlKGVvcygpIT09dHJ1ZSYmKHQ9YWR2YW5jZSgpKSl7aWYodD09PXIpe049Sy5iYWNrc2xhc2hlcz10cnVlO2FkdmFuY2UoKTtjb250aW51ZX1pZih0PT09Zyl7VD1LLmlzQnJhY2tldD10cnVlO089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7YnJlYWt9fWlmKEM9PT10cnVlKXtjb250aW51ZX1icmVha31pZih1Lm5vbmVnYXRlIT09dHJ1ZSYmUD09PWMmJkg9PT12KXtJPUsubmVnYXRlZD10cnVlO3YrKztjb250aW51ZX1pZih1Lm5vcGFyZW4hPT10cnVlJiZQPT09Zil7Tz1LLmlzR2xvYj10cnVlO2lmKEM9PT10cnVlKXt3aGlsZShlb3MoKSE9PXRydWUmJihQPWFkdmFuY2UoKSkpe2lmKFA9PT1mKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTtQPWFkdmFuY2UoKTtjb250aW51ZX1pZihQPT09aCl7Rz10cnVlO2JyZWFrfX1jb250aW51ZX1icmVha31pZihPPT09dHJ1ZSl7Rz10cnVlO2lmKEM9PT10cnVlKXtjb250aW51ZX1icmVha319aWYodS5ub2V4dD09PXRydWUpe2s9ZmFsc2U7Tz1mYWxzZX1sZXQgVT1TO2xldCBYPVwiXCI7bGV0IEY9XCJcIjtpZih2PjApe1g9Uy5zbGljZSgwLHYpO1M9Uy5zbGljZSh2KTtkLT12fWlmKFUmJk89PT10cnVlJiZkPjApe1U9Uy5zbGljZSgwLGQpO0Y9Uy5zbGljZShkKX1lbHNlIGlmKE89PT10cnVlKXtVPVwiXCI7Rj1TfWVsc2V7VT1TfWlmKFUmJlUhPT1cIlwiJiZVIT09XCIvXCImJlUhPT1TKXtpZihpc1BhdGhTZXBhcmF0b3IoVS5jaGFyQ29kZUF0KFUubGVuZ3RoLTEpKSl7VT1VLnNsaWNlKDAsLTEpfX1pZih1LnVuZXNjYXBlPT09dHJ1ZSl7aWYoRilGPW4ucmVtb3ZlQmFja3NsYXNoZXMoRik7aWYoVSYmTj09PXRydWUpe1U9bi5yZW1vdmVCYWNrc2xhc2hlcyhVKX19Y29uc3QgUT17cHJlZml4OlgsaW5wdXQ6dCxzdGFydDp2LGJhc2U6VSxnbG9iOkYsaXNCcmFjZTpMLGlzQnJhY2tldDpULGlzR2xvYjpPLGlzRXh0Z2xvYjprLGlzR2xvYnN0YXI6bSxuZWdhdGVkOkksbmVnYXRlZEV4dGdsb2I6Qn07aWYodS50b2tlbnM9PT10cnVlKXtRLm1heERlcHRoPTA7aWYoIWlzUGF0aFNlcGFyYXRvcihQKSl7JC5wdXNoKEspfVEudG9rZW5zPSR9aWYodS5wYXJ0cz09PXRydWV8fHUudG9rZW5zPT09dHJ1ZSl7bGV0IGU7Zm9yKGxldCBuPTA7bjx5Lmxlbmd0aDtuKyspe2NvbnN0IG89ZT9lKzE6djtjb25zdCBzPXlbbl07Y29uc3Qgcj10LnNsaWNlKG8scyk7aWYodS50b2tlbnMpe2lmKG49PT0wJiZ2IT09MCl7JFtuXS5pc1ByZWZpeD10cnVlOyRbbl0udmFsdWU9WH1lbHNleyRbbl0udmFsdWU9cn1kZXB0aCgkW25dKTtRLm1heERlcHRoKz0kW25dLmRlcHRofWlmKG4hPT0wfHxyIT09XCJcIil7eC5wdXNoKHIpfWU9c31pZihlJiZlKzE8dC5sZW5ndGgpe2NvbnN0IG49dC5zbGljZShlKzEpO3gucHVzaChuKTtpZih1LnRva2Vucyl7JFskLmxlbmd0aC0xXS52YWx1ZT1uO2RlcHRoKCRbJC5sZW5ndGgtMV0pO1EubWF4RGVwdGgrPSRbJC5sZW5ndGgtMV0uZGVwdGh9fVEuc2xhc2hlcz15O1EucGFydHM9eH1yZXR1cm4gUX07dC5leHBvcnRzPXNjYW59LDk2Oih0LGUsdSk9Pntjb25zdHtSRUdFWF9CQUNLU0xBU0g6bixSRUdFWF9SRU1PVkVfQkFDS1NMQVNIOm8sUkVHRVhfU1BFQ0lBTF9DSEFSUzpzLFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMOnJ9PXUoMTU0KTtlLmlzT2JqZWN0PXQ9PnQhPT1udWxsJiZ0eXBlb2YgdD09PVwib2JqZWN0XCImJiFBcnJheS5pc0FycmF5KHQpO2UuaGFzUmVnZXhDaGFycz10PT5zLnRlc3QodCk7ZS5pc1JlZ2V4Q2hhcj10PT50Lmxlbmd0aD09PTEmJmUuaGFzUmVnZXhDaGFycyh0KTtlLmVzY2FwZVJlZ2V4PXQ9PnQucmVwbGFjZShyLFwiXFxcXCQxXCIpO2UudG9Qb3NpeFNsYXNoZXM9dD0+dC5yZXBsYWNlKG4sXCIvXCIpO2UucmVtb3ZlQmFja3NsYXNoZXM9dD0+dC5yZXBsYWNlKG8sKHQ9PnQ9PT1cIlxcXFxcIj9cIlwiOnQpKTtlLmVzY2FwZUxhc3Q9KHQsdSxuKT0+e2NvbnN0IG89dC5sYXN0SW5kZXhPZih1LG4pO2lmKG89PT0tMSlyZXR1cm4gdDtpZih0W28tMV09PT1cIlxcXFxcIilyZXR1cm4gZS5lc2NhcGVMYXN0KHQsdSxvLTEpO3JldHVybmAke3Quc2xpY2UoMCxvKX1cXFxcJHt0LnNsaWNlKG8pfWB9O2UucmVtb3ZlUHJlZml4PSh0LGU9e30pPT57bGV0IHU9dDtpZih1LnN0YXJ0c1dpdGgoXCIuL1wiKSl7dT11LnNsaWNlKDIpO2UucHJlZml4PVwiLi9cIn1yZXR1cm4gdX07ZS53cmFwT3V0cHV0PSh0LGU9e30sdT17fSk9Pntjb25zdCBuPXUuY29udGFpbnM/XCJcIjpcIl5cIjtjb25zdCBvPXUuY29udGFpbnM/XCJcIjpcIiRcIjtsZXQgcz1gJHtufSg/OiR7dH0pJHtvfWA7aWYoZS5uZWdhdGVkPT09dHJ1ZSl7cz1gKD86Xig/ISR7c30pLiokKWB9cmV0dXJuIHN9O2UuYmFzZW5hbWU9KHQse3dpbmRvd3M6ZX09e30pPT57Y29uc3QgdT10LnNwbGl0KGU/L1tcXFxcL10vOlwiL1wiKTtjb25zdCBuPXVbdS5sZW5ndGgtMV07aWYobj09PVwiXCIpe3JldHVybiB1W3UubGVuZ3RoLTJdfXJldHVybiBufX19O3ZhciBlPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odSl7dmFyIG49ZVt1XTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBvPWVbdV09e2V4cG9ydHM6e319O3ZhciBzPXRydWU7dHJ5e3RbdV0obyxvLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7cz1mYWxzZX1maW5hbGx5e2lmKHMpZGVsZXRlIGVbdV19cmV0dXJuIG8uZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHU9X19uY2N3cGNrX3JlcXVpcmVfXygxNzApO21vZHVsZS5leHBvcnRzPXV9KSgpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return type.displayName || \"Context\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, props, owner, debugStack, debugTask) {\n      var refProp = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== refProp ? refProp : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        maybeKey,\n        getOwner(),\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      react_stack_bottom_frame: function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (type, config, maybeKey, isStaticChildren) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsc0dBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCLElBQUksY0FBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9BQ1RJVklUWV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkFjdGl2aXR5XCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB0eXBlLnRhZyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIHR5cGUuJCR0eXBlb2YpXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXNrTmFtZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkgcmV0dXJuIFwiPD5cIjtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICByZXR1cm4gbmFtZSA/IFwiPFwiICsgbmFtZSArIFwiPlwiIDogXCI8Li4uPlwiO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPd25lcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIHJldHVybiBudWxsID09PSBkaXNwYXRjaGVyID8gbnVsbCA6IGRpc3BhdGNoZXIuZ2V0T3duZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVW5rbm93bk93bmVyKCkge1xuICAgICAgcmV0dXJuIEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb25maWcua2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uIHdhcm5BYm91dEFjY2Vzc2luZ0tleSgpIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gfHxcbiAgICAgICAgICAoKHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zcGVjaWFsLXByb3BzKVwiLFxuICAgICAgICAgICAgZGlzcGxheU5hbWVcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9ICEwO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCBcImtleVwiLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aGlzLnR5cGUpO1xuICAgICAgZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAoKGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBY2Nlc3NpbmcgZWxlbWVudC5yZWYgd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIHJlZiBpcyBub3cgYSByZWd1bGFyIHByb3AuIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBKU1ggRWxlbWVudCB0eXBlIGluIGEgZnV0dXJlIHJlbGVhc2UuXCJcbiAgICAgICAgKSk7XG4gICAgICBjb21wb25lbnROYW1lID0gdGhpcy5wcm9wcy5yZWY7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb21wb25lbnROYW1lID8gY29tcG9uZW50TmFtZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHByb3BzLCBvd25lciwgZGVidWdTdGFjaywgZGVidWdUYXNrKSB7XG4gICAgICB2YXIgcmVmUHJvcCA9IHByb3BzLnJlZjtcbiAgICAgIHR5cGUgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgIF9vd25lcjogb3duZXJcbiAgICAgIH07XG4gICAgICBudWxsICE9PSAodm9pZCAwICE9PSByZWZQcm9wID8gcmVmUHJvcCA6IG51bGwpXG4gICAgICAgID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgZ2V0OiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgIH0pXG4gICAgICAgIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHsgZW51bWVyYWJsZTogITEsIHZhbHVlOiBudWxsIH0pO1xuICAgICAgdHlwZS5fc3RvcmUgPSB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogMFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdJbmZvXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnU3RhY2tcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogZGVidWdTdGFja1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdUYXNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGRlYnVnVGFza1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKHR5cGUucHJvcHMpLCBPYmplY3QuZnJlZXplKHR5cGUpKTtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBqc3hERVZJbXBsKFxuICAgICAgdHlwZSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1heWJlS2V5LFxuICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgIGRlYnVnU3RhY2ssXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgIGlmICh2b2lkIDAgIT09IGNoaWxkcmVuKVxuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbilcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID0gMDtcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbisrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dKTtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbik7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgcmV0dXJuIFwia2V5XCIgIT09IGs7XG4gICAgICAgIH0pO1xuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID1cbiAgICAgICAgICAwIDwga2V5cy5sZW5ndGhcbiAgICAgICAgICAgID8gXCJ7a2V5OiBzb21lS2V5LCBcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiXG4gICAgICAgICAgICA6IFwie2tleTogc29tZUtleX1cIjtcbiAgICAgICAgZGlkV2FybkFib3V0S2V5U3ByZWFkW2NoaWxkcmVuICsgaXNTdGF0aWNDaGlsZHJlbl0gfHxcbiAgICAgICAgICAoKGtleXMgPVxuICAgICAgICAgICAgMCA8IGtleXMubGVuZ3RoID8gXCJ7XCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIiA6IFwie31cIiksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIHsuLi5wcm9wc30gLz5cXG5SZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIGtleT17c29tZUtleX0gey4uLnByb3BzfSAvPicsXG4gICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBrZXlzLFxuICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSA9ICEwKSk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB2b2lkIDAgIT09IG1heWJlS2V5ICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KSwgKGNoaWxkcmVuID0gXCJcIiArIG1heWJlS2V5KSk7XG4gICAgICBoYXNWYWxpZEtleShjb25maWcpICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgY29uZmlnLmtleSkpO1xuICAgICAgaWYgKFwia2V5XCIgaW4gY29uZmlnKSB7XG4gICAgICAgIG1heWJlS2V5ID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGNvbmZpZylcbiAgICAgICAgICBcImtleVwiICE9PSBwcm9wTmFtZSAmJiAobWF5YmVLZXlbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gICAgICB9IGVsc2UgbWF5YmVLZXkgPSBjb25maWc7XG4gICAgICBjaGlsZHJlbiAmJlxuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihcbiAgICAgICAgICBtYXliZUtleSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlXG4gICAgICAgICAgICA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICA6IHR5cGVcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBSZWFjdEVsZW1lbnQoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBtYXliZUtleSxcbiAgICAgICAgZ2V0T3duZXIoKSxcbiAgICAgICAgZGVidWdTdGFjayxcbiAgICAgICAgZGVidWdUYXNrXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlKSB7XG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJlxuICAgICAgICBudWxsICE9PSBub2RlICYmXG4gICAgICAgIG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSAmJlxuICAgICAgICBub2RlLl9zdG9yZSAmJlxuICAgICAgICAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgfVxuICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIiksXG4gICAgICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICAgICAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgICAgIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksXG4gICAgICBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLFxuICAgICAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gICAgICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuICAgICAgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksXG4gICAgICBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSxcbiAgICAgIFJFQUNUX0FDVElWSVRZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuYWN0aXZpdHlcIiksXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGNyZWF0ZVRhc2sgPSBjb25zb2xlLmNyZWF0ZVRhc2tcbiAgICAgICAgPyBjb25zb2xlLmNyZWF0ZVRhc2tcbiAgICAgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9O1xuICAgIFJlYWN0ID0ge1xuICAgICAgcmVhY3Rfc3RhY2tfYm90dG9tX2ZyYW1lOiBmdW5jdGlvbiAoY2FsbFN0YWNrRm9yRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxTdGFja0ZvckVycm9yKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG4gICAgdmFyIGRpZFdhcm5BYm91dEVsZW1lbnRSZWYgPSB7fTtcbiAgICB2YXIgdW5rbm93bk93bmVyRGVidWdTdGFjayA9IFJlYWN0LnJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZS5iaW5kKFxuICAgICAgUmVhY3QsXG4gICAgICBVbmtub3duT3duZXJcbiAgICApKCk7XG4gICAgdmFyIHVua25vd25Pd25lckRlYnVnVGFzayA9IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUoVW5rbm93bk93bmVyKSk7XG4gICAgdmFyIGRpZFdhcm5BYm91dEtleVNwcmVhZCA9IHt9O1xuICAgIGV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICAgIGV4cG9ydHMuanN4REVWID0gZnVuY3Rpb24gKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgIHZhciB0cmFja0FjdHVhbE93bmVyID1cbiAgICAgICAgMWU0ID4gUmVhY3RTaGFyZWRJbnRlcm5hbHMucmVjZW50bHlDcmVhdGVkT3duZXJTdGFja3MrKztcbiAgICAgIHJldHVybiBqc3hERVZJbXBsKFxuICAgICAgICB0eXBlLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIG1heWJlS2V5LFxuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyXG4gICAgICAgICAgPyBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKVxuICAgICAgICAgIDogdW5rbm93bk93bmVyRGVidWdTdGFjayxcbiAgICAgICAgdHJhY2tBY3R1YWxPd25lciA/IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUodHlwZSkpIDogdW5rbm93bk93bmVyRGVidWdUYXNrXG4gICAgICApO1xuICAgIH07XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"AmpStateContext\", ({\n    enumerable: true,\n    get: function() {\n        return AmpStateContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst AmpStateContext = _react.default.createContext({});\nif (true) {\n    AmpStateContext.displayName = 'AmpStateContext';\n} //# sourceMappingURL=amp-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQUVhQTs7O2VBQUFBOzs7OzRFQUZLO0FBRVgsTUFBTUEsa0JBQXNDQyxPQUFBQSxPQUFLLENBQUNDLGFBQWEsQ0FBQyxDQUFDO0FBRXhFLElBQUlDLElBQW9CLEVBQW1CO0lBQ3pDSCxnQkFBZ0JNLFdBQVcsR0FBRztBQUNoQyIsInNvdXJjZXMiOlsiL1VzZXJzL3NyYy9zaGFyZWQvbGliL2FtcC1jb250ZXh0LnNoYXJlZC1ydW50aW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGNvbnN0IEFtcFN0YXRlQ29udGV4dDogUmVhY3QuQ29udGV4dDxhbnk+ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7fSlcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgQW1wU3RhdGVDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0FtcFN0YXRlQ29udGV4dCdcbn1cbiJdLCJuYW1lcyI6WyJBbXBTdGF0ZUNvbnRleHQiLCJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJkaXNwbGF5TmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-mode.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isInAmpMode\", ({\n    enumerable: true,\n    get: function() {\n        return isInAmpMode;\n    }\n}));\nfunction isInAmpMode(param) {\n    let { ampFirst = false, hybrid = false, hasQuery = false } = param === void 0 ? {} : param;\n    return ampFirst || hybrid && hasQuery;\n} //# sourceMappingURL=amp-mode.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtbW9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7OytDQUFnQkE7OztlQUFBQTs7O0FBQVQsU0FBU0EsWUFBWTtJQUFBLE1BQzFCQyxXQUFXLEtBQUssRUFDaEJDLFNBQVMsS0FBSyxFQUNkQyxXQUFXLEtBQUssRUFDakIsR0FKMkIsbUJBSXhCLENBQUMsSUFKdUI7SUFLMUIsT0FBT0YsWUFBYUMsVUFBVUM7QUFDaEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zcmMvc2hhcmVkL2xpYi9hbXAtbW9kZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gaXNJbkFtcE1vZGUoe1xuICBhbXBGaXJzdCA9IGZhbHNlLFxuICBoeWJyaWQgPSBmYWxzZSxcbiAgaGFzUXVlcnkgPSBmYWxzZSxcbn0gPSB7fSk6IGJvb2xlYW4ge1xuICByZXR1cm4gYW1wRmlyc3QgfHwgKGh5YnJpZCAmJiBoYXNRdWVyeSlcbn1cbiJdLCJuYW1lcyI6WyJpc0luQW1wTW9kZSIsImFtcEZpcnN0IiwiaHlicmlkIiwiaGFzUXVlcnkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/get-img-props.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImgProps\", ({\n    enumerable: true,\n    get: function() {\n        return getImgProps;\n    }\n}));\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _imageblursvg = __webpack_require__(/*! ./image-blur-svg */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js\");\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst VALID_LOADING_VALUES = [\n    'lazy',\n    'eager',\n    undefined\n];\n// Object-fit values that are not valid background-size values\nconst INVALID_BACKGROUND_SIZE_VALUES = [\n    '-moz-initial',\n    'fill',\n    'none',\n    'scale-down',\n    undefined\n];\nfunction isStaticRequire(src) {\n    return src.default !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return !!src && typeof src === 'object' && (isStaticRequire(src) || isStaticImageData(src));\n}\nconst allImgs = new Map();\nlet perfObserver;\nfunction getInt(x) {\n    if (typeof x === 'undefined') {\n        return x;\n    }\n    if (typeof x === 'number') {\n        return Number.isFinite(x) ? x : NaN;\n    }\n    if (typeof x === 'string' && /^[0-9]+$/.test(x)) {\n        return parseInt(x, 10);\n    }\n    return NaN;\n}\nfunction getWidths(param, width, sizes) {\n    let { deviceSizes, allSizes } = param;\n    if (sizes) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        const viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        const percentSizes = [];\n        for(let match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            const smallestRatio = Math.min(...percentSizes) * 0.01;\n            return {\n                widths: allSizes.filter((s)=>s >= deviceSizes[0] * smallestRatio),\n                kind: 'w'\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: 'w'\n        };\n    }\n    if (typeof width !== 'number') {\n        return {\n            widths: deviceSizes,\n            kind: 'w'\n        };\n    }\n    const widths = [\n        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n        // > blue colors. Showing a 3x resolution image in the app vs a 2x\n        // > resolution image will be visually the same, though the 3x image\n        // > takes significantly more data. Even true 3x resolution screens are\n        // > wasteful as the human eye cannot see that level of detail without\n        // > something like a magnifying glass.\n        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n        [\n            width,\n            width * 2 /*, width * 3*/ \n        ].map((w)=>allSizes.find((p)=>p >= w) || allSizes[allSizes.length - 1]))\n    ];\n    return {\n        widths,\n        kind: 'x'\n    };\n}\nfunction generateImgAttrs(param) {\n    let { config, src, unoptimized, width, quality, sizes, loader } = param;\n    if (unoptimized) {\n        return {\n            src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    const { widths, kind } = getWidths(config, width, sizes);\n    const last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === 'w' ? '100vw' : sizes,\n        srcSet: widths.map((w, i)=>loader({\n                config,\n                src,\n                quality,\n                width: w\n            }) + \" \" + (kind === 'w' ? w : i + 1) + kind).join(', '),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config,\n            src,\n            quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getImgProps(param, _state) {\n    let { src, sizes, unoptimized = false, priority = false, loading, className, quality, width, height, fill = false, style, overrideSrc, onLoad, onLoadingComplete, placeholder = 'empty', blurDataURL, fetchPriority, decoding = 'async', layout, objectFit, objectPosition, lazyBoundary, lazyRoot, ...rest } = param;\n    const { imgConf, showAltText, blurComplete, defaultLoader } = _state;\n    let config;\n    let c = imgConf || _imageconfig.imageConfigDefault;\n    if ('allSizes' in c) {\n        config = c;\n    } else {\n        var _c_qualities;\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        const qualities = (_c_qualities = c.qualities) == null ? void 0 : _c_qualities.sort((a, b)=>a - b);\n        config = {\n            ...c,\n            allSizes,\n            deviceSizes,\n            qualities\n        };\n    }\n    if (typeof defaultLoader === 'undefined') {\n        throw Object.defineProperty(new Error('images.loaderFile detected but the file is missing default export.\\nRead more: https://nextjs.org/docs/messages/invalid-images-config'), \"__NEXT_ERROR_CODE\", {\n            value: \"E163\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    let loader = rest.loader || defaultLoader;\n    // Remove property so it's not spread on <img> element\n    delete rest.loader;\n    delete rest.srcSet;\n    // This special value indicates that the user\n    // didn't define a \"loader\" prop or \"loader\" config.\n    const isDefaultLoader = '__next_img_default' in loader;\n    if (isDefaultLoader) {\n        if (config.loader === 'custom') {\n            throw Object.defineProperty(new Error('Image with src \"' + src + '\" is missing \"loader\" prop.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\"), \"__NEXT_ERROR_CODE\", {\n                value: \"E252\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    } else {\n        // The user defined a \"loader\" prop or config.\n        // Since the config object is internal only, we\n        // must not pass it to the user-defined \"loader\".\n        const customImageLoader = loader;\n        loader = (obj)=>{\n            const { config: _, ...opts } = obj;\n            return customImageLoader(opts);\n        };\n    }\n    if (layout) {\n        if (layout === 'fill') {\n            fill = true;\n        }\n        const layoutToStyle = {\n            intrinsic: {\n                maxWidth: '100%',\n                height: 'auto'\n            },\n            responsive: {\n                width: '100%',\n                height: 'auto'\n            }\n        };\n        const layoutToSizes = {\n            responsive: '100vw',\n            fill: '100vw'\n        };\n        const layoutStyle = layoutToStyle[layout];\n        if (layoutStyle) {\n            style = {\n                ...style,\n                ...layoutStyle\n            };\n        }\n        const layoutSizes = layoutToSizes[layout];\n        if (layoutSizes && !sizes) {\n            sizes = layoutSizes;\n        }\n    }\n    let staticSrc = '';\n    let widthInt = getInt(width);\n    let heightInt = getInt(height);\n    let blurWidth;\n    let blurHeight;\n    if (isStaticImport(src)) {\n        const staticImageData = isStaticRequire(src) ? src.default : src;\n        if (!staticImageData.src) {\n            throw Object.defineProperty(new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \" + JSON.stringify(staticImageData)), \"__NEXT_ERROR_CODE\", {\n                value: \"E460\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (!staticImageData.height || !staticImageData.width) {\n            throw Object.defineProperty(new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \" + JSON.stringify(staticImageData)), \"__NEXT_ERROR_CODE\", {\n                value: \"E48\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        blurWidth = staticImageData.blurWidth;\n        blurHeight = staticImageData.blurHeight;\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!fill) {\n            if (!widthInt && !heightInt) {\n                widthInt = staticImageData.width;\n                heightInt = staticImageData.height;\n            } else if (widthInt && !heightInt) {\n                const ratio = widthInt / staticImageData.width;\n                heightInt = Math.round(staticImageData.height * ratio);\n            } else if (!widthInt && heightInt) {\n                const ratio = heightInt / staticImageData.height;\n                widthInt = Math.round(staticImageData.width * ratio);\n            }\n        }\n    }\n    src = typeof src === 'string' ? src : staticSrc;\n    let isLazy = !priority && (loading === 'lazy' || typeof loading === 'undefined');\n    if (!src || src.startsWith('data:') || src.startsWith('blob:')) {\n        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if (config.unoptimized) {\n        unoptimized = true;\n    }\n    if (isDefaultLoader && !config.dangerouslyAllowSVG && src.split('?', 1)[0].endsWith('.svg')) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        unoptimized = true;\n    }\n    const qualityInt = getInt(quality);\n    if (true) {\n        var _config_localPatterns;\n        if (config.output === 'export' && isDefaultLoader && !unoptimized) {\n            throw Object.defineProperty(new Error(\"Image Optimization using the default loader is not compatible with `{ output: 'export' }`.\\n  Possible solutions:\\n    - Remove `{ output: 'export' }` and run \\\"next start\\\" to run server mode including the Image Optimization API.\\n    - Configure `{ images: { unoptimized: true } }` in `next.config.js` to disable the Image Optimization API.\\n  Read more: https://nextjs.org/docs/messages/export-image-api\"), \"__NEXT_ERROR_CODE\", {\n                value: \"E500\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (!src) {\n            // React doesn't show the stack trace and there's\n            // no `src` to help identify which image, so we\n            // instead console.error(ref) during mount.\n            unoptimized = true;\n        } else {\n            if (fill) {\n                if (width) {\n                    throw Object.defineProperty(new Error('Image with src \"' + src + '\" has both \"width\" and \"fill\" properties. Only one should be used.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E96\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                if (height) {\n                    throw Object.defineProperty(new Error('Image with src \"' + src + '\" has both \"height\" and \"fill\" properties. Only one should be used.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E115\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                if ((style == null ? void 0 : style.position) && style.position !== 'absolute') {\n                    throw Object.defineProperty(new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.position\" properties. Images with \"fill\" always use position absolute - it cannot be modified.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E216\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                if ((style == null ? void 0 : style.width) && style.width !== '100%') {\n                    throw Object.defineProperty(new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.width\" properties. Images with \"fill\" always use width 100% - it cannot be modified.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E73\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                if ((style == null ? void 0 : style.height) && style.height !== '100%') {\n                    throw Object.defineProperty(new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.height\" properties. Images with \"fill\" always use height 100% - it cannot be modified.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E404\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            } else {\n                if (typeof widthInt === 'undefined') {\n                    throw Object.defineProperty(new Error('Image with src \"' + src + '\" is missing required \"width\" property.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E451\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                } else if (isNaN(widthInt)) {\n                    throw Object.defineProperty(new Error('Image with src \"' + src + '\" has invalid \"width\" property. Expected a numeric value in pixels but received \"' + width + '\".'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E66\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                if (typeof heightInt === 'undefined') {\n                    throw Object.defineProperty(new Error('Image with src \"' + src + '\" is missing required \"height\" property.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E397\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                } else if (isNaN(heightInt)) {\n                    throw Object.defineProperty(new Error('Image with src \"' + src + '\" has invalid \"height\" property. Expected a numeric value in pixels but received \"' + height + '\".'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E444\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                // eslint-disable-next-line no-control-regex\n                if (/^[\\x00-\\x20]/.test(src)) {\n                    throw Object.defineProperty(new Error('Image with src \"' + src + '\" cannot start with a space or control character. Use src.trimStart() to remove it or encodeURIComponent(src) to keep it.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E176\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                // eslint-disable-next-line no-control-regex\n                if (/[\\x00-\\x20]$/.test(src)) {\n                    throw Object.defineProperty(new Error('Image with src \"' + src + '\" cannot end with a space or control character. Use src.trimEnd() to remove it or encodeURIComponent(src) to keep it.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E21\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n        }\n        if (!VALID_LOADING_VALUES.includes(loading)) {\n            throw Object.defineProperty(new Error('Image with src \"' + src + '\" has invalid \"loading\" property. Provided \"' + loading + '\" should be one of ' + VALID_LOADING_VALUES.map(String).join(',') + \".\"), \"__NEXT_ERROR_CODE\", {\n                value: \"E357\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (priority && loading === 'lazy') {\n            throw Object.defineProperty(new Error('Image with src \"' + src + '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.'), \"__NEXT_ERROR_CODE\", {\n                value: \"E218\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (placeholder !== 'empty' && placeholder !== 'blur' && !placeholder.startsWith('data:image/')) {\n            throw Object.defineProperty(new Error('Image with src \"' + src + '\" has invalid \"placeholder\" property \"' + placeholder + '\".'), \"__NEXT_ERROR_CODE\", {\n                value: \"E431\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (placeholder !== 'empty') {\n            if (widthInt && heightInt && widthInt * heightInt < 1600) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is smaller than 40x40. Consider removing the \"placeholder\" property to improve performance.');\n            }\n        }\n        if (qualityInt && qualityInt !== 75 && !config.qualities) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using quality \"' + qualityInt + '\" which is not configured in images.qualities. This config will be required starting in Next.js 16.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-unconfigured-qualities\");\n        }\n        if (src.startsWith('/') && src.includes('?') && (!(config == null ? void 0 : (_config_localPatterns = config.localPatterns) == null ? void 0 : _config_localPatterns.length) || config.localPatterns.length === 1 && config.localPatterns[0].pathname === '/_next/static/media/**')) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using a query string which is not configured in images.localPatterns. This config will be required starting in Next.js 16.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-unconfigured-localpatterns\");\n        }\n        if (placeholder === 'blur' && !blurDataURL) {\n            const VALID_BLUR_EXT = [\n                'jpeg',\n                'png',\n                'webp',\n                'avif'\n            ] // should match next-image-loader\n            ;\n            throw Object.defineProperty(new Error('Image with src \"' + src + '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n        Possible solutions:\\n          - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n          - Change the \"src\" property to a static import with one of the supported file types: ' + VALID_BLUR_EXT.join(',') + ' (animated images not supported)\\n          - Remove the \"placeholder\" property, effectively no blur effect\\n        Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url'), \"__NEXT_ERROR_CODE\", {\n                value: \"E371\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if ('ref' in rest) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using unsupported \"ref\" property. Consider using the \"onLoad\" property instead.');\n        }\n        if (!unoptimized && !isDefaultLoader) {\n            const urlStr = loader({\n                config,\n                src,\n                width: widthInt || 400,\n                quality: qualityInt || 75\n            });\n            let url;\n            try {\n                url = new URL(urlStr);\n            } catch (err) {}\n            if (urlStr === src || url && url.pathname === src && !url.search) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n            }\n        }\n        if (onLoadingComplete) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using deprecated \"onLoadingComplete\" property. Please use the \"onLoad\" property instead.');\n        }\n        for (const [legacyKey, legacyValue] of Object.entries({\n            layout,\n            objectFit,\n            objectPosition,\n            lazyBoundary,\n            lazyRoot\n        })){\n            if (legacyValue) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has legacy prop \"' + legacyKey + '\". Did you forget to run the codemod?' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13\");\n            }\n        }\n        if ( true && !perfObserver && window.PerformanceObserver) {\n            perfObserver = new PerformanceObserver((entryList)=>{\n                for (const entry of entryList.getEntries()){\n                    var _entry_element;\n                    // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n                    const imgSrc = (entry == null ? void 0 : (_entry_element = entry.element) == null ? void 0 : _entry_element.src) || '';\n                    const lcpImage = allImgs.get(imgSrc);\n                    if (lcpImage && !lcpImage.priority && lcpImage.placeholder === 'empty' && !lcpImage.src.startsWith('data:') && !lcpImage.src.startsWith('blob:')) {\n                        // https://web.dev/lcp/#measure-lcp-in-javascript\n                        (0, _warnonce.warnOnce)('Image with src \"' + lcpImage.src + '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.' + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n                    }\n                }\n            });\n            try {\n                perfObserver.observe({\n                    type: 'largest-contentful-paint',\n                    buffered: true\n                });\n            } catch (err) {\n                // Log error but don't crash the app\n                console.error(err);\n            }\n        }\n    }\n    const imgStyle = Object.assign(fill ? {\n        position: 'absolute',\n        height: '100%',\n        width: '100%',\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        objectFit,\n        objectPosition\n    } : {}, showAltText ? {} : {\n        color: 'transparent'\n    }, style);\n    const backgroundImage = !blurComplete && placeholder !== 'empty' ? placeholder === 'blur' ? 'url(\"data:image/svg+xml;charset=utf-8,' + (0, _imageblursvg.getImageBlurSvg)({\n        widthInt,\n        heightInt,\n        blurWidth,\n        blurHeight,\n        blurDataURL: blurDataURL || '',\n        objectFit: imgStyle.objectFit\n    }) + '\")' : 'url(\"' + placeholder + '\")' // assume `data:image/`\n     : null;\n    const backgroundSize = !INVALID_BACKGROUND_SIZE_VALUES.includes(imgStyle.objectFit) ? imgStyle.objectFit : imgStyle.objectFit === 'fill' ? '100% 100%' // the background-size equivalent of `fill`\n     : 'cover';\n    let placeholderStyle = backgroundImage ? {\n        backgroundSize,\n        backgroundPosition: imgStyle.objectPosition || '50% 50%',\n        backgroundRepeat: 'no-repeat',\n        backgroundImage\n    } : {};\n    if (true) {\n        if (placeholderStyle.backgroundImage && placeholder === 'blur' && (blurDataURL == null ? void 0 : blurDataURL.startsWith('/'))) {\n            // During `next dev`, we don't want to generate blur placeholders with webpack\n            // because it can delay starting the dev server. Instead, `next-image-loader.js`\n            // will inline a special url to lazily generate the blur placeholder at request time.\n            placeholderStyle.backgroundImage = 'url(\"' + blurDataURL + '\")';\n        }\n    }\n    const imgAttributes = generateImgAttrs({\n        config,\n        src,\n        unoptimized,\n        width: widthInt,\n        quality: qualityInt,\n        sizes,\n        loader\n    });\n    if (true) {\n        if (true) {\n            let fullUrl;\n            try {\n                fullUrl = new URL(imgAttributes.src);\n            } catch (e) {\n                fullUrl = new URL(imgAttributes.src, window.location.href);\n            }\n            allImgs.set(fullUrl.href, {\n                src,\n                priority,\n                placeholder\n            });\n        }\n    }\n    const props = {\n        ...rest,\n        loading: isLazy ? 'lazy' : loading,\n        fetchPriority,\n        width: widthInt,\n        height: heightInt,\n        decoding,\n        className,\n        style: {\n            ...imgStyle,\n            ...placeholderStyle\n        },\n        sizes: imgAttributes.sizes,\n        srcSet: imgAttributes.srcSet,\n        src: overrideSrc || imgAttributes.src\n    };\n    const meta = {\n        unoptimized,\n        priority,\n        placeholder,\n        fill\n    };\n    return {\n        props,\n        meta\n    };\n} //# sourceMappingURL=get-img-props.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzLmpzIiwibWFwcGluZ3MiOiI7Ozs7K0NBaVFnQkE7OztlQUFBQTs7O3NDQWpRUzswQ0FDTzt5Q0FDRztBQStFbkMsTUFBTUMsdUJBQXVCO0lBQUM7SUFBUTtJQUFTQztDQUFVO0FBRXpELDhEQUE4RDtBQUM5RCxNQUFNQyxpQ0FBaUM7SUFDckM7SUFDQTtJQUNBO0lBQ0E7SUFDQUQ7Q0FDRDtBQTRCRCxTQUFTRSxnQkFDUEMsR0FBb0M7SUFFcEMsT0FBUUEsSUFBc0JDLE9BQU8sS0FBS0o7QUFDNUM7QUFFQSxTQUFTSyxrQkFDUEYsR0FBb0M7SUFFcEMsT0FBUUEsSUFBd0JBLEdBQUcsS0FBS0g7QUFDMUM7QUFFQSxTQUFTTSxlQUFlSCxHQUEwQjtJQUNoRCxPQUNFLENBQUMsQ0FBQ0EsT0FDRixPQUFPQSxRQUFRLFlBQ2RELENBQUFBLGdCQUFnQkMsUUFDZkUsa0JBQWtCRixJQUFBQSxDQUFtQjtBQUUzQztBQUVBLE1BQU1JLFVBQVUsSUFBSUM7QUFJcEIsSUFBSUM7QUFFSixTQUFTQyxPQUFPQyxDQUFVO0lBQ3hCLElBQUksT0FBT0EsTUFBTSxhQUFhO1FBQzVCLE9BQU9BO0lBQ1Q7SUFDQSxJQUFJLE9BQU9BLE1BQU0sVUFBVTtRQUN6QixPQUFPQyxPQUFPQyxRQUFRLENBQUNGLEtBQUtBLElBQUlHO0lBQ2xDO0lBQ0EsSUFBSSxPQUFPSCxNQUFNLFlBQVksV0FBV0ksSUFBSSxDQUFDSixJQUFJO1FBQy9DLE9BQU9LLFNBQVNMLEdBQUc7SUFDckI7SUFDQSxPQUFPRztBQUNUO0FBRUEsU0FBU0csVUFDUCxLQUFzQyxFQUN0Q0MsS0FBeUIsRUFDekJDLEtBQXlCO0lBRnpCLE1BQUVDLFdBQVcsRUFBRUMsUUFBUSxFQUFlLEdBQXRDO0lBSUEsSUFBSUYsT0FBTztRQUNULHlEQUF5RDtRQUN6RCxNQUFNRyxrQkFBa0I7UUFDeEIsTUFBTUMs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NkIsRUFBRTtZQUNqQyxJQUFJaUQ7WUFDSixJQUFJO2dCQUNGQSxVQUFVLElBQUluQyxJQUFJa0MsY0FBYzFKLEdBQUc7WUFDckMsRUFBRSxPQUFPNEosR0FBRztnQkFDVkQsVUFBVSxJQUFJbkMsSUFBSWtDLGNBQWMxSixHQUFHLEVBQUUrSCxPQUFPOEIsUUFBUSxDQUFDQyxJQUFJO1lBQzNEO1lBQ0ExSixRQUFRMkosR0FBRyxDQUFDSixRQUFRRyxJQUFJLEVBQUU7Z0JBQUU5SjtnQkFBSytDO2dCQUFVUztZQUFZO1FBQ3pEO0lBQ0Y7SUFFQSxNQUFNd0csUUFBa0I7UUFDdEIsR0FBRy9GLElBQUk7UUFDUGpCLFNBQVNvRCxTQUFTLFNBQVNwRDtRQUMzQlU7UUFDQTNDLE9BQU80RTtRQUNQekMsUUFBUTBDO1FBQ1JqQztRQUNBVjtRQUNBRyxPQUFPO1lBQUUsR0FBR3lGLFFBQVE7WUFBRSxHQUFHVSxnQkFBZ0I7UUFBQztRQUMxQ3ZJLE9BQU8wSSxjQUFjMUksS0FBSztRQUMxQjBCLFFBQVFnSCxjQUFjaEgsTUFBTTtRQUM1QjFDLEtBQUtxRCxlQUFlcUcsY0FBYzFKLEdBQUc7SUFDdkM7SUFDQSxNQUFNaUssT0FBTztRQUFFMUg7UUFBYVE7UUFBVVM7UUFBYUw7SUFBSztJQUN4RCxPQUFPO1FBQUU2RztRQUFPQztJQUFLO0FBQ3ZCIiwic291cmNlcyI6WyIvVXNlcnMvc3JjL3NoYXJlZC9saWIvZ2V0LWltZy1wcm9wcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB3YXJuT25jZSB9IGZyb20gJy4vdXRpbHMvd2Fybi1vbmNlJ1xuaW1wb3J0IHsgZ2V0SW1hZ2VCbHVyU3ZnIH0gZnJvbSAnLi9pbWFnZS1ibHVyLXN2ZydcbmltcG9ydCB7IGltYWdlQ29uZmlnRGVmYXVsdCB9IGZyb20gJy4vaW1hZ2UtY29uZmlnJ1xuaW1wb3J0IHR5cGUge1xuICBJbWFnZUNvbmZpZ0NvbXBsZXRlLFxuICBJbWFnZUxvYWRlclByb3BzLFxuICBJbWFnZUxvYWRlclByb3BzV2l0aENvbmZpZyxcbn0gZnJvbSAnLi9pbWFnZS1jb25maWcnXG5cbmltcG9ydCB0eXBlIHsgQ1NTUHJvcGVydGllcywgSlNYIH0gZnJvbSAncmVhY3QnXG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGljSW1hZ2VEYXRhIHtcbiAgc3JjOiBzdHJpbmdcbiAgaGVpZ2h0OiBudW1iZXJcbiAgd2lkdGg6IG51bWJlclxuICBibHVyRGF0YVVSTD86IHN0cmluZ1xuICBibHVyV2lkdGg/OiBudW1iZXJcbiAgYmx1ckhlaWdodD86IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpY1JlcXVpcmUge1xuICBkZWZhdWx0OiBTdGF0aWNJbWFnZURhdGFcbn1cblxuZXhwb3J0IHR5cGUgU3RhdGljSW1wb3J0ID0gU3RhdGljUmVxdWlyZSB8IFN0YXRpY0ltYWdlRGF0YVxuXG5leHBvcnQgdHlwZSBJbWFnZVByb3BzID0gT21pdDxcbiAgSlNYLkludHJpbnNpY0VsZW1lbnRzWydpbWcnXSxcbiAgJ3NyYycgfCAnc3JjU2V0JyB8ICdyZWYnIHwgJ2FsdCcgfCAnd2lkdGgnIHwgJ2hlaWdodCcgfCAnbG9hZGluZydcbj4gJiB7XG4gIHNyYzogc3RyaW5nIHwgU3RhdGljSW1wb3J0XG4gIGFsdDogc3RyaW5nXG4gIHdpZHRoPzogbnVtYmVyIHwgYCR7bnVtYmVyfWBcbiAgaGVpZ2h0PzogbnVtYmVyIHwgYCR7bnVtYmVyfWBcbiAgZmlsbD86IGJvb2xlYW5cbiAgbG9hZGVyPzogSW1hZ2VMb2FkZXJcbiAgcXVhbGl0eT86IG51bWJlciB8IGAke251bWJlcn1gXG4gIHByaW9yaXR5PzogYm9vbGVhblxuICBsb2FkaW5nPzogTG9hZGluZ1ZhbHVlXG4gIHBsYWNlaG9sZGVyPzogUGxhY2Vob2xkZXJWYWx1ZVxuICBibHVyRGF0YVVSTD86IHN0cmluZ1xuICB1bm9wdGltaXplZD86IGJvb2xlYW5cbiAgb3ZlcnJpZGVTcmM/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgb25Mb2FkYCBpbnN0ZWFkLlxuICAgKiBAc2VlIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvaW1hZ2Ujb25sb2FkXG4gICAqL1xuICBvbkxvYWRpbmdDb21wbGV0ZT86IE9uTG9hZGluZ0NvbXBsZXRlXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYGZpbGxgIHByb3AgaW5zdGVhZCBvZiBgbGF5b3V0PVwiZmlsbFwiYCBvciBjaGFuZ2UgaW1wb3J0IHRvIGBuZXh0L2xlZ2FjeS9pbWFnZWAuXG4gICAqIEBzZWUgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2xlZ2FjeS9pbWFnZVxuICAgKi9cbiAgbGF5b3V0Pzogc3RyaW5nXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYHN0eWxlYCBwcm9wIGluc3RlYWQuXG4gICAqL1xuICBvYmplY3RGaXQ/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgc3R5bGVgIHByb3AgaW5zdGVhZC5cbiAgICovXG4gIG9iamVjdFBvc2l0aW9uPzogc3RyaW5nXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBUaGlzIHByb3AgZG9lcyBub3QgZG8gYW55dGhpbmcuXG4gICAqL1xuICBsYXp5Qm91bmRhcnk/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgcHJvcCBkb2VzIG5vdCBkbyBhbnl0aGluZy5cbiAgICovXG4gIGxhenlSb290Pzogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIEltZ1Byb3BzID0gT21pdDxJbWFnZVByb3BzLCAnc3JjJyB8ICdsb2FkZXInPiAmIHtcbiAgbG9hZGluZzogTG9hZGluZ1ZhbHVlXG4gIHdpZHRoOiBudW1iZXIgfCB1bmRlZmluZWRcbiAgaGVpZ2h0OiBudW1iZXIgfCB1bmRlZmluZWRcbiAgc3R5bGU6IE5vbk51bGxhYmxlPEpTWC5JbnRyaW5zaWNFbGVtZW50c1snaW1nJ11bJ3N0eWxlJ10+XG4gIHNpemVzOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgc3JjU2V0OiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgc3JjOiBzdHJpbmdcbn1cblxuY29uc3QgVkFMSURfTE9BRElOR19WQUxVRVMgPSBbJ2xhenknLCAnZWFnZXInLCB1bmRlZmluZWRdIGFzIGNvbnN0XG5cbi8vIE9iamVjdC1maXQgdmFsdWVzIHRoYXQgYXJlIG5vdCB2YWxpZCBiYWNrZ3JvdW5kLXNpemUgdmFsdWVzXG5jb25zdCBJTlZBTElEX0JBQ0tHUk9VTkRfU0laRV9WQUxVRVMgPSBbXG4gICctbW96LWluaXRpYWwnLFxuICAnZmlsbCcsXG4gICdub25lJyxcbiAgJ3NjYWxlLWRvd24nLFxuICB1bmRlZmluZWQsXG5dXG50eXBlIExvYWRpbmdWYWx1ZSA9ICh0eXBlb2YgVkFMSURfTE9BRElOR19WQUxVRVMpW251bWJlcl1cbnR5cGUgSW1hZ2VDb25maWcgPSBJbWFnZUNvbmZpZ0NvbXBsZXRlICYge1xuICBhbGxTaXplczogbnVtYmVyW11cbiAgb3V0cHV0PzogJ3N0YW5kYWxvbmUnIHwgJ2V4cG9ydCdcbn1cblxuZXhwb3J0IHR5cGUgSW1hZ2VMb2FkZXIgPSAocDogSW1hZ2VMb2FkZXJQcm9wcykgPT4gc3RyaW5nXG5cbi8vIERvIG5vdCBleHBvcnQgLSB0aGlzIGlzIGFuIGludGVybmFsIHR5cGUgb25seVxuLy8gYmVjYXVzZSBgbmV4dC5jb25maWcuanNgIGlzIG9ubHkgbWVhbnQgZm9yIHRoZVxuLy8gYnVpbHQtaW4gbG9hZGVycywgbm90IGZvciBhIGN1c3RvbSBsb2FkZXIoKSBwcm9wLlxudHlwZSBJbWFnZUxvYWRlcldpdGhDb25maWcgPSAocDogSW1hZ2VMb2FkZXJQcm9wc1dpdGhDb25maWcpID0+IHN0cmluZ1xuXG5leHBvcnQgdHlwZSBQbGFjZWhvbGRlclZhbHVlID0gJ2JsdXInIHwgJ2VtcHR5JyB8IGBkYXRhOmltYWdlLyR7c3RyaW5nfWBcbmV4cG9ydCB0eXBlIE9uTG9hZCA9IFJlYWN0LlJlYWN0RXZlbnRIYW5kbGVyPEhUTUxJbWFnZUVsZW1lbnQ+IHwgdW5kZWZpbmVkXG5leHBvcnQgdHlwZSBPbkxvYWRpbmdDb21wbGV0ZSA9IChpbWc6IEhUTUxJbWFnZUVsZW1lbnQpID0+IHZvaWRcblxuZXhwb3J0IHR5cGUgUGxhY2Vob2xkZXJTdHlsZSA9IFBhcnRpYWw8XG4gIFBpY2s8XG4gICAgQ1NTUHJvcGVydGllcyxcbiAgICB8ICdiYWNrZ3JvdW5kU2l6ZSdcbiAgICB8ICdiYWNrZ3JvdW5kUG9zaXRpb24nXG4gICAgfCAnYmFja2dyb3VuZFJlcGVhdCdcbiAgICB8ICdiYWNrZ3JvdW5kSW1hZ2UnXG4gID5cbj5cblxuZnVuY3Rpb24gaXNTdGF0aWNSZXF1aXJlKFxuICBzcmM6IFN0YXRpY1JlcXVpcmUgfCBTdGF0aWNJbWFnZURhdGFcbik6IHNyYyBpcyBTdGF0aWNSZXF1aXJlIHtcbiAgcmV0dXJuIChzcmMgYXMgU3RhdGljUmVxdWlyZSkuZGVmYXVsdCAhPT0gdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljSW1hZ2VEYXRhKFxuICBzcmM6IFN0YXRpY1JlcXVpcmUgfCBTdGF0aWNJbWFnZURhdGFcbik6IHNyYyBpcyBTdGF0aWNJbWFnZURhdGEge1xuICByZXR1cm4gKHNyYyBhcyBTdGF0aWNJbWFnZURhdGEpLnNyYyAhPT0gdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljSW1wb3J0KHNyYzogc3RyaW5nIHwgU3RhdGljSW1wb3J0KTogc3JjIGlzIFN0YXRpY0ltcG9ydCB7XG4gIHJldHVybiAoXG4gICAgISFzcmMgJiZcbiAgICB0eXBlb2Ygc3JjID09PSAnb2JqZWN0JyAmJlxuICAgIChpc1N0YXRpY1JlcXVpcmUoc3JjIGFzIFN0YXRpY0ltcG9ydCkgfHxcbiAgICAgIGlzU3RhdGljSW1hZ2VEYXRhKHNyYyBhcyBTdGF0aWNJbXBvcnQpKVxuICApXG59XG5cbmNvbnN0IGFsbEltZ3MgPSBuZXcgTWFwPFxuICBzdHJpbmcsXG4gIHsgc3JjOiBzdHJpbmc7IHByaW9yaXR5OiBib29sZWFuOyBwbGFjZWhvbGRlcjogUGxhY2Vob2xkZXJWYWx1ZSB9XG4+KClcbmxldCBwZXJmT2JzZXJ2ZXI6IFBlcmZvcm1hbmNlT2JzZXJ2ZXIgfCB1bmRlZmluZWRcblxuZnVuY3Rpb24gZ2V0SW50KHg6IHVua25vd24pOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBpZiAodHlwZW9mIHggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHhcbiAgfVxuICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZSh4KSA/IHggOiBOYU5cbiAgfVxuICBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnICYmIC9eWzAtOV0rJC8udGVzdCh4KSkge1xuICAgIHJldHVybiBwYXJzZUludCh4LCAxMClcbiAgfVxuICByZXR1cm4gTmFOXG59XG5cbmZ1bmN0aW9uIGdldFdpZHRocyhcbiAgeyBkZXZpY2VTaXplcywgYWxsU2l6ZXMgfTogSW1hZ2VDb25maWcsXG4gIHdpZHRoOiBudW1iZXIgfCB1bmRlZmluZWQsXG4gIHNpemVzOiBzdHJpbmcgfCB1bmRlZmluZWRcbik6IHsgd2lkdGhzOiBudW1iZXJbXTsga2luZDogJ3cnIHwgJ3gnIH0ge1xuICBpZiAoc2l6ZXMpIHtcbiAgICAvLyBGaW5kIGFsbCB0aGUgXCJ2d1wiIHBlcmNlbnQgc2l6ZXMgdXNlZCBpbiB0aGUgc2l6ZXMgcHJvcFxuICAgIGNvbnN0IHZpZXdwb3J0V2lkdGhSZSA9IC8oXnxcXHMpKDE/XFxkP1xcZCl2dy9nXG4gICAgY29uc3QgcGVyY2VudFNpemVzID0gW11cbiAgICBmb3IgKGxldCBtYXRjaDsgKG1hdGNoID0gdmlld3BvcnRXaWR0aFJlLmV4ZWMoc2l6ZXMpKTsgbWF0Y2gpIHtcbiAgICAgIHBlcmNlbnRTaXplcy5wdXNoKHBhcnNlSW50KG1hdGNoWzJdKSlcbiAgICB9XG4gICAgaWYgKHBlcmNlbnRTaXplcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHNtYWxsZXN0UmF0aW8gPSBNYXRoLm1pbiguLi5wZXJjZW50U2l6ZXMpICogMC4wMVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGhzOiBhbGxTaXplcy5maWx0ZXIoKHMpID0+IHMgPj0gZGV2aWNlU2l6ZXNbMF0gKiBzbWFsbGVzdFJhdGlvKSxcbiAgICAgICAga2luZDogJ3cnLFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB3aWR0aHM6IGFsbFNpemVzLCBraW5kOiAndycgfVxuICB9XG4gIGlmICh0eXBlb2Ygd2lkdGggIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHsgd2lkdGhzOiBkZXZpY2VTaXplcywga2luZDogJ3cnIH1cbiAgfVxuXG4gIGNvbnN0IHdpZHRocyA9IFtcbiAgICAuLi5uZXcgU2V0KFxuICAgICAgLy8gPiBUaGlzIG1lYW5zIHRoYXQgbW9zdCBPTEVEIHNjcmVlbnMgdGhhdCBzYXkgdGhleSBhcmUgM3ggcmVzb2x1dGlvbixcbiAgICAgIC8vID4gYXJlIGFjdHVhbGx5IDN4IGluIHRoZSBncmVlbiBjb2xvciwgYnV0IG9ubHkgMS41eCBpbiB0aGUgcmVkIGFuZFxuICAgICAgLy8gPiBibHVlIGNvbG9ycy4gU2hvd2luZyBhIDN4IHJlc29sdXRpb24gaW1hZ2UgaW4gdGhlIGFwcCB2cyBhIDJ4XG4gICAgICAvLyA+IHJlc29sdXRpb24gaW1hZ2Ugd2lsbCBiZSB2aXN1YWxseSB0aGUgc2FtZSwgdGhvdWdoIHRoZSAzeCBpbWFnZVxuICAgICAgLy8gPiB0YWtlcyBzaWduaWZpY2FudGx5IG1vcmUgZGF0YS4gRXZlbiB0cnVlIDN4IHJlc29sdXRpb24gc2NyZWVucyBhcmVcbiAgICAgIC8vID4gd2FzdGVmdWwgYXMgdGhlIGh1bWFuIGV5ZSBjYW5ub3Qgc2VlIHRoYXQgbGV2ZWwgb2YgZGV0YWlsIHdpdGhvdXRcbiAgICAgIC8vID4gc29tZXRoaW5nIGxpa2UgYSBtYWduaWZ5aW5nIGdsYXNzLlxuICAgICAgLy8gaHR0cHM6Ly9ibG9nLnR3aXR0ZXIuY29tL2VuZ2luZWVyaW5nL2VuX3VzL3RvcGljcy9pbmZyYXN0cnVjdHVyZS8yMDE5L2NhcHBpbmctaW1hZ2UtZmlkZWxpdHktb24tdWx0cmEtaGlnaC1yZXNvbHV0aW9uLWRldmljZXMuaHRtbFxuICAgICAgW3dpZHRoLCB3aWR0aCAqIDIgLyosIHdpZHRoICogMyovXS5tYXAoXG4gICAgICAgICh3KSA9PiBhbGxTaXplcy5maW5kKChwKSA9PiBwID49IHcpIHx8IGFsbFNpemVzW2FsbFNpemVzLmxlbmd0aCAtIDFdXG4gICAgICApXG4gICAgKSxcbiAgXVxuICByZXR1cm4geyB3aWR0aHMsIGtpbmQ6ICd4JyB9XG59XG5cbnR5cGUgR2VuSW1nQXR0cnNEYXRhID0ge1xuICBjb25maWc6IEltYWdlQ29uZmlnXG4gIHNyYzogc3RyaW5nXG4gIHVub3B0aW1pemVkOiBib29sZWFuXG4gIGxvYWRlcjogSW1hZ2VMb2FkZXJXaXRoQ29uZmlnXG4gIHdpZHRoPzogbnVtYmVyXG4gIHF1YWxpdHk/OiBudW1iZXJcbiAgc2l6ZXM/OiBzdHJpbmdcbn1cblxudHlwZSBHZW5JbWdBdHRyc1Jlc3VsdCA9IHtcbiAgc3JjOiBzdHJpbmdcbiAgc3JjU2V0OiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgc2l6ZXM6IHN0cmluZyB8IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUltZ0F0dHJzKHtcbiAgY29uZmlnLFxuICBzcmMsXG4gIHVub3B0aW1pemVkLFxuICB3aWR0aCxcbiAgcXVhbGl0eSxcbiAgc2l6ZXMsXG4gIGxvYWRlcixcbn06IEdlbkltZ0F0dHJzRGF0YSk6IEdlbkltZ0F0dHJzUmVzdWx0IHtcbiAgaWYgKHVub3B0aW1pemVkKSB7XG4gICAgcmV0dXJuIHsgc3JjLCBzcmNTZXQ6IHVuZGVmaW5lZCwgc2l6ZXM6IHVuZGVmaW5lZCB9XG4gIH1cblxuICBjb25zdCB7IHdpZHRocywga2luZCB9ID0gZ2V0V2lkdGhzKGNvbmZpZywgd2lkdGgsIHNpemVzKVxuICBjb25zdCBsYXN0ID0gd2lkdGhzLmxlbmd0aCAtIDFcblxuICByZXR1cm4ge1xuICAgIHNpemVzOiAhc2l6ZXMgJiYga2luZCA9PT0gJ3cnID8gJzEwMHZ3JyA6IHNpemVzLFxuICAgIHNyY1NldDogd2lkdGhzXG4gICAgICAubWFwKFxuICAgICAgICAodywgaSkgPT5cbiAgICAgICAgICBgJHtsb2FkZXIoeyBjb25maWcsIHNyYywgcXVhbGl0eSwgd2lkdGg6IHcgfSl9ICR7XG4gICAgICAgICAgICBraW5kID09PSAndycgPyB3IDogaSArIDFcbiAgICAgICAgICB9JHtraW5kfWBcbiAgICAgIClcbiAgICAgIC5qb2luKCcsICcpLFxuXG4gICAgLy8gSXQncyBpbnRlbmRlZCB0byBrZWVwIGBzcmNgIHRoZSBsYXN0IGF0dHJpYnV0ZSBiZWNhdXNlIFJlYWN0IHVwZGF0ZXNcbiAgICAvLyBhdHRyaWJ1dGVzIGluIG9yZGVyLiBJZiB3ZSBrZWVwIGBzcmNgIHRoZSBmaXJzdCBvbmUsIFNhZmFyaSB3aWxsXG4gICAgLy8gaW1tZWRpYXRlbHkgc3RhcnQgdG8gZmV0Y2ggYHNyY2AsIGJlZm9yZSBgc2l6ZXNgIGFuZCBgc3JjU2V0YCBhcmUgZXZlblxuICAgIC8vIHVwZGF0ZWQgYnkgUmVhY3QuIFRoYXQgY2F1c2VzIG11bHRpcGxlIHVubmVjZXNzYXJ5IHJlcXVlc3RzIGlmIGBzcmNTZXRgXG4gICAgLy8gYW5kIGBzaXplc2AgYXJlIGRlZmluZWQuXG4gICAgLy8gVGhpcyBidWcgY2Fubm90IGJlIHJlcHJvZHVjZWQgaW4gQ2hyb21lIG9yIEZpcmVmb3guXG4gICAgc3JjOiBsb2FkZXIoeyBjb25maWcsIHNyYywgcXVhbGl0eSwgd2lkdGg6IHdpZHRoc1tsYXN0XSB9KSxcbiAgfVxufVxuXG4vKipcbiAqIEEgc2hhcmVkIGZ1bmN0aW9uLCB1c2VkIG9uIGJvdGggY2xpZW50IGFuZCBzZXJ2ZXIsIHRvIGdlbmVyYXRlIHRoZSBwcm9wcyBmb3IgPGltZz4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbWdQcm9wcyhcbiAge1xuICAgIHNyYyxcbiAgICBzaXplcyxcbiAgICB1bm9wdGltaXplZCA9IGZhbHNlLFxuICAgIHByaW9yaXR5ID0gZmFsc2UsXG4gICAgbG9hZGluZyxcbiAgICBjbGFzc05hbWUsXG4gICAgcXVhbGl0eSxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgZmlsbCA9IGZhbHNlLFxuICAgIHN0eWxlLFxuICAgIG92ZXJyaWRlU3JjLFxuICAgIG9uTG9hZCxcbiAgICBvbkxvYWRpbmdDb21wbGV0ZSxcbiAgICBwbGFjZWhvbGRlciA9ICdlbXB0eScsXG4gICAgYmx1ckRhdGFVUkwsXG4gICAgZmV0Y2hQcmlvcml0eSxcbiAgICBkZWNvZGluZyA9ICdhc3luYycsXG4gICAgbGF5b3V0LFxuICAgIG9iamVjdEZpdCxcbiAgICBvYmplY3RQb3NpdGlvbixcbiAgICBsYXp5Qm91bmRhcnksXG4gICAgbGF6eVJvb3QsXG4gICAgLi4ucmVzdFxuICB9OiBJbWFnZVByb3BzLFxuICBfc3RhdGU6IHtcbiAgICBkZWZhdWx0TG9hZGVyOiBJbWFnZUxvYWRlcldpdGhDb25maWdcbiAgICBpbWdDb25mOiBJbWFnZUNvbmZpZ0NvbXBsZXRlXG4gICAgc2hvd0FsdFRleHQ/OiBib29sZWFuXG4gICAgYmx1ckNvbXBsZXRlPzogYm9vbGVhblxuICB9XG4pOiB7XG4gIHByb3BzOiBJbWdQcm9wc1xuICBtZXRhOiB7XG4gICAgdW5vcHRpbWl6ZWQ6IGJvb2xlYW5cbiAgICBwcmlvcml0eTogYm9vbGVhblxuICAgIHBsYWNlaG9sZGVyOiBOb25OdWxsYWJsZTxJbWFnZVByb3BzWydwbGFjZWhvbGRlciddPlxuICAgIGZpbGw6IGJvb2xlYW5cbiAgfVxufSB7XG4gIGNvbnN0IHsgaW1nQ29uZiwgc2hvd0FsdFRleHQsIGJsdXJDb21wbGV0ZSwgZGVmYXVsdExvYWRlciB9ID0gX3N0YXRlXG4gIGxldCBjb25maWc6IEltYWdlQ29uZmlnXG4gIGxldCBjID0gaW1nQ29uZiB8fCBpbWFnZUNvbmZpZ0RlZmF1bHRcbiAgaWYgKCdhbGxTaXplcycgaW4gYykge1xuICAgIGNvbmZpZyA9IGMgYXMgSW1hZ2VDb25maWdcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBhbGxTaXplcyA9IFsuLi5jLmRldmljZVNpemVzLCAuLi5jLmltYWdlU2l6ZXNdLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAgIGNvbnN0IGRldmljZVNpemVzID0gYy5kZXZpY2VTaXplcy5zb3J0KChhLCBiKSA9PiBhIC0gYilcbiAgICBjb25zdCBxdWFsaXRpZXMgPSBjLnF1YWxpdGllcz8uc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gICAgY29uZmlnID0geyAuLi5jLCBhbGxTaXplcywgZGV2aWNlU2l6ZXMsIHF1YWxpdGllcyB9XG4gIH1cblxuICBpZiAodHlwZW9mIGRlZmF1bHRMb2FkZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2ltYWdlcy5sb2FkZXJGaWxlIGRldGVjdGVkIGJ1dCB0aGUgZmlsZSBpcyBtaXNzaW5nIGRlZmF1bHQgZXhwb3J0LlxcblJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW52YWxpZC1pbWFnZXMtY29uZmlnJ1xuICAgIClcbiAgfVxuICBsZXQgbG9hZGVyOiBJbWFnZUxvYWRlcldpdGhDb25maWcgPSByZXN0LmxvYWRlciB8fCBkZWZhdWx0TG9hZGVyXG5cbiAgLy8gUmVtb3ZlIHByb3BlcnR5IHNvIGl0J3Mgbm90IHNwcmVhZCBvbiA8aW1nPiBlbGVtZW50XG4gIGRlbGV0ZSByZXN0LmxvYWRlclxuICBkZWxldGUgKHJlc3QgYXMgYW55KS5zcmNTZXRcblxuICAvLyBUaGlzIHNwZWNpYWwgdmFsdWUgaW5kaWNhdGVzIHRoYXQgdGhlIHVzZXJcbiAgLy8gZGlkbid0IGRlZmluZSBhIFwibG9hZGVyXCIgcHJvcCBvciBcImxvYWRlclwiIGNvbmZpZy5cbiAgY29uc3QgaXNEZWZhdWx0TG9hZGVyID0gJ19fbmV4dF9pbWdfZGVmYXVsdCcgaW4gbG9hZGVyXG5cbiAgaWYgKGlzRGVmYXVsdExvYWRlcikge1xuICAgIGlmIChjb25maWcubG9hZGVyID09PSAnY3VzdG9tJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyBtaXNzaW5nIFwibG9hZGVyXCIgcHJvcC5gICtcbiAgICAgICAgICBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLW1pc3NpbmctbG9hZGVyYFxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGUgdXNlciBkZWZpbmVkIGEgXCJsb2FkZXJcIiBwcm9wIG9yIGNvbmZpZy5cbiAgICAvLyBTaW5jZSB0aGUgY29uZmlnIG9iamVjdCBpcyBpbnRlcm5hbCBvbmx5LCB3ZVxuICAgIC8vIG11c3Qgbm90IHBhc3MgaXQgdG8gdGhlIHVzZXItZGVmaW5lZCBcImxvYWRlclwiLlxuICAgIGNvbnN0IGN1c3RvbUltYWdlTG9hZGVyID0gbG9hZGVyIGFzIEltYWdlTG9hZGVyXG4gICAgbG9hZGVyID0gKG9iaikgPT4ge1xuICAgICAgY29uc3QgeyBjb25maWc6IF8sIC4uLm9wdHMgfSA9IG9ialxuICAgICAgcmV0dXJuIGN1c3RvbUltYWdlTG9hZGVyKG9wdHMpXG4gICAgfVxuICB9XG5cbiAgaWYgKGxheW91dCkge1xuICAgIGlmIChsYXlvdXQgPT09ICdmaWxsJykge1xuICAgICAgZmlsbCA9IHRydWVcbiAgICB9XG4gICAgY29uc3QgbGF5b3V0VG9TdHlsZTogUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IHVuZGVmaW5lZD4gPSB7XG4gICAgICBpbnRyaW5zaWM6IHsgbWF4V2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnYXV0bycgfSxcbiAgICAgIHJlc3BvbnNpdmU6IHsgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnYXV0bycgfSxcbiAgICB9XG4gICAgY29uc3QgbGF5b3V0VG9TaXplczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPiA9IHtcbiAgICAgIHJlc3BvbnNpdmU6ICcxMDB2dycsXG4gICAgICBmaWxsOiAnMTAwdncnLFxuICAgIH1cbiAgICBjb25zdCBsYXlvdXRTdHlsZSA9IGxheW91dFRvU3R5bGVbbGF5b3V0XVxuICAgIGlmIChsYXlvdXRTdHlsZSkge1xuICAgICAgc3R5bGUgPSB7IC4uLnN0eWxlLCAuLi5sYXlvdXRTdHlsZSB9XG4gICAgfVxuICAgIGNvbnN0IGxheW91dFNpemVzID0gbGF5b3V0VG9TaXplc1tsYXlvdXRdXG4gICAgaWYgKGxheW91dFNpemVzICYmICFzaXplcykge1xuICAgICAgc2l6ZXMgPSBsYXlvdXRTaXplc1xuICAgIH1cbiAgfVxuXG4gIGxldCBzdGF0aWNTcmMgPSAnJ1xuICBsZXQgd2lkdGhJbnQgPSBnZXRJbnQod2lkdGgpXG4gIGxldCBoZWlnaHRJbnQgPSBnZXRJbnQoaGVpZ2h0KVxuICBsZXQgYmx1cldpZHRoOiBudW1iZXIgfCB1bmRlZmluZWRcbiAgbGV0IGJsdXJIZWlnaHQ6IG51bWJlciB8IHVuZGVmaW5lZFxuICBpZiAoaXNTdGF0aWNJbXBvcnQoc3JjKSkge1xuICAgIGNvbnN0IHN0YXRpY0ltYWdlRGF0YSA9IGlzU3RhdGljUmVxdWlyZShzcmMpID8gc3JjLmRlZmF1bHQgOiBzcmNcblxuICAgIGlmICghc3RhdGljSW1hZ2VEYXRhLnNyYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQW4gb2JqZWN0IHNob3VsZCBvbmx5IGJlIHBhc3NlZCB0byB0aGUgaW1hZ2UgY29tcG9uZW50IHNyYyBwYXJhbWV0ZXIgaWYgaXQgY29tZXMgZnJvbSBhIHN0YXRpYyBpbWFnZSBpbXBvcnQuIEl0IG11c3QgaW5jbHVkZSBzcmMuIFJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgc3RhdGljSW1hZ2VEYXRhXG4gICAgICAgICl9YFxuICAgICAgKVxuICAgIH1cbiAgICBpZiAoIXN0YXRpY0ltYWdlRGF0YS5oZWlnaHQgfHwgIXN0YXRpY0ltYWdlRGF0YS53aWR0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQW4gb2JqZWN0IHNob3VsZCBvbmx5IGJlIHBhc3NlZCB0byB0aGUgaW1hZ2UgY29tcG9uZW50IHNyYyBwYXJhbWV0ZXIgaWYgaXQgY29tZXMgZnJvbSBhIHN0YXRpYyBpbWFnZSBpbXBvcnQuIEl0IG11c3QgaW5jbHVkZSBoZWlnaHQgYW5kIHdpZHRoLiBSZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHN0YXRpY0ltYWdlRGF0YVxuICAgICAgICApfWBcbiAgICAgIClcbiAgICB9XG5cbiAgICBibHVyV2lkdGggPSBzdGF0aWNJbWFnZURhdGEuYmx1cldpZHRoXG4gICAgYmx1ckhlaWdodCA9IHN0YXRpY0ltYWdlRGF0YS5ibHVySGVpZ2h0XG4gICAgYmx1ckRhdGFVUkwgPSBibHVyRGF0YVVSTCB8fCBzdGF0aWNJbWFnZURhdGEuYmx1ckRhdGFVUkxcbiAgICBzdGF0aWNTcmMgPSBzdGF0aWNJbWFnZURhdGEuc3JjXG5cbiAgICBpZiAoIWZpbGwpIHtcbiAgICAgIGlmICghd2lkdGhJbnQgJiYgIWhlaWdodEludCkge1xuICAgICAgICB3aWR0aEludCA9IHN0YXRpY0ltYWdlRGF0YS53aWR0aFxuICAgICAgICBoZWlnaHRJbnQgPSBzdGF0aWNJbWFnZURhdGEuaGVpZ2h0XG4gICAgICB9IGVsc2UgaWYgKHdpZHRoSW50ICYmICFoZWlnaHRJbnQpIHtcbiAgICAgICAgY29uc3QgcmF0aW8gPSB3aWR0aEludCAvIHN0YXRpY0ltYWdlRGF0YS53aWR0aFxuICAgICAgICBoZWlnaHRJbnQgPSBNYXRoLnJvdW5kKHN0YXRpY0ltYWdlRGF0YS5oZWlnaHQgKiByYXRpbylcbiAgICAgIH0gZWxzZSBpZiAoIXdpZHRoSW50ICYmIGhlaWdodEludCkge1xuICAgICAgICBjb25zdCByYXRpbyA9IGhlaWdodEludCAvIHN0YXRpY0ltYWdlRGF0YS5oZWlnaHRcbiAgICAgICAgd2lkdGhJbnQgPSBNYXRoLnJvdW5kKHN0YXRpY0ltYWdlRGF0YS53aWR0aCAqIHJhdGlvKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzcmMgPSB0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyA/IHNyYyA6IHN0YXRpY1NyY1xuXG4gIGxldCBpc0xhenkgPVxuICAgICFwcmlvcml0eSAmJiAobG9hZGluZyA9PT0gJ2xhenknIHx8IHR5cGVvZiBsb2FkaW5nID09PSAndW5kZWZpbmVkJylcbiAgaWYgKCFzcmMgfHwgc3JjLnN0YXJ0c1dpdGgoJ2RhdGE6JykgfHwgc3JjLnN0YXJ0c1dpdGgoJ2Jsb2I6JykpIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9IVFRQL0Jhc2ljc19vZl9IVFRQL0RhdGFfVVJJc1xuICAgIHVub3B0aW1pemVkID0gdHJ1ZVxuICAgIGlzTGF6eSA9IGZhbHNlXG4gIH1cbiAgaWYgKGNvbmZpZy51bm9wdGltaXplZCkge1xuICAgIHVub3B0aW1pemVkID0gdHJ1ZVxuICB9XG4gIGlmIChcbiAgICBpc0RlZmF1bHRMb2FkZXIgJiZcbiAgICAhY29uZmlnLmRhbmdlcm91c2x5QWxsb3dTVkcgJiZcbiAgICBzcmMuc3BsaXQoJz8nLCAxKVswXS5lbmRzV2l0aCgnLnN2ZycpXG4gICkge1xuICAgIC8vIFNwZWNpYWwgY2FzZSB0byBtYWtlIHN2ZyBzZXJ2ZSBhcy1pcyB0byBhdm9pZCBwcm94eWluZ1xuICAgIC8vIHRocm91Z2ggdGhlIGJ1aWx0LWluIEltYWdlIE9wdGltaXphdGlvbiBBUEkuXG4gICAgdW5vcHRpbWl6ZWQgPSB0cnVlXG4gIH1cblxuICBjb25zdCBxdWFsaXR5SW50ID0gZ2V0SW50KHF1YWxpdHkpXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoY29uZmlnLm91dHB1dCA9PT0gJ2V4cG9ydCcgJiYgaXNEZWZhdWx0TG9hZGVyICYmICF1bm9wdGltaXplZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW1hZ2UgT3B0aW1pemF0aW9uIHVzaW5nIHRoZSBkZWZhdWx0IGxvYWRlciBpcyBub3QgY29tcGF0aWJsZSB3aXRoIFxcYHsgb3V0cHV0OiAnZXhwb3J0JyB9XFxgLlxuICBQb3NzaWJsZSBzb2x1dGlvbnM6XG4gICAgLSBSZW1vdmUgXFxgeyBvdXRwdXQ6ICdleHBvcnQnIH1cXGAgYW5kIHJ1biBcIm5leHQgc3RhcnRcIiB0byBydW4gc2VydmVyIG1vZGUgaW5jbHVkaW5nIHRoZSBJbWFnZSBPcHRpbWl6YXRpb24gQVBJLlxuICAgIC0gQ29uZmlndXJlIFxcYHsgaW1hZ2VzOiB7IHVub3B0aW1pemVkOiB0cnVlIH0gfVxcYCBpbiBcXGBuZXh0LmNvbmZpZy5qc1xcYCB0byBkaXNhYmxlIHRoZSBJbWFnZSBPcHRpbWl6YXRpb24gQVBJLlxuICBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2V4cG9ydC1pbWFnZS1hcGlgXG4gICAgICApXG4gICAgfVxuICAgIGlmICghc3JjKSB7XG4gICAgICAvLyBSZWFjdCBkb2Vzbid0IHNob3cgdGhlIHN0YWNrIHRyYWNlIGFuZCB0aGVyZSdzXG4gICAgICAvLyBubyBgc3JjYCB0byBoZWxwIGlkZW50aWZ5IHdoaWNoIGltYWdlLCBzbyB3ZVxuICAgICAgLy8gaW5zdGVhZCBjb25zb2xlLmVycm9yKHJlZikgZHVyaW5nIG1vdW50LlxuICAgICAgdW5vcHRpbWl6ZWQgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBib3RoIFwid2lkdGhcIiBhbmQgXCJmaWxsXCIgcHJvcGVydGllcy4gT25seSBvbmUgc2hvdWxkIGJlIHVzZWQuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJoZWlnaHRcIiBhbmQgXCJmaWxsXCIgcHJvcGVydGllcy4gT25seSBvbmUgc2hvdWxkIGJlIHVzZWQuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGU/LnBvc2l0aW9uICYmIHN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJmaWxsXCIgYW5kIFwic3R5bGUucG9zaXRpb25cIiBwcm9wZXJ0aWVzLiBJbWFnZXMgd2l0aCBcImZpbGxcIiBhbHdheXMgdXNlIHBvc2l0aW9uIGFic29sdXRlIC0gaXQgY2Fubm90IGJlIG1vZGlmaWVkLmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlPy53aWR0aCAmJiBzdHlsZS53aWR0aCAhPT0gJzEwMCUnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJmaWxsXCIgYW5kIFwic3R5bGUud2lkdGhcIiBwcm9wZXJ0aWVzLiBJbWFnZXMgd2l0aCBcImZpbGxcIiBhbHdheXMgdXNlIHdpZHRoIDEwMCUgLSBpdCBjYW5ub3QgYmUgbW9kaWZpZWQuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGU/LmhlaWdodCAmJiBzdHlsZS5oZWlnaHQgIT09ICcxMDAlJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBib3RoIFwiZmlsbFwiIGFuZCBcInN0eWxlLmhlaWdodFwiIHByb3BlcnRpZXMuIEltYWdlcyB3aXRoIFwiZmlsbFwiIGFsd2F5cyB1c2UgaGVpZ2h0IDEwMCUgLSBpdCBjYW5ub3QgYmUgbW9kaWZpZWQuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aEludCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyBtaXNzaW5nIHJlcXVpcmVkIFwid2lkdGhcIiBwcm9wZXJ0eS5gXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKHdpZHRoSW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBpbnZhbGlkIFwid2lkdGhcIiBwcm9wZXJ0eS4gRXhwZWN0ZWQgYSBudW1lcmljIHZhbHVlIGluIHBpeGVscyBidXQgcmVjZWl2ZWQgXCIke3dpZHRofVwiLmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHRJbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgbWlzc2luZyByZXF1aXJlZCBcImhlaWdodFwiIHByb3BlcnR5LmBcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSBpZiAoaXNOYU4oaGVpZ2h0SW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBpbnZhbGlkIFwiaGVpZ2h0XCIgcHJvcGVydHkuIEV4cGVjdGVkIGEgbnVtZXJpYyB2YWx1ZSBpbiBwaXhlbHMgYnV0IHJlY2VpdmVkIFwiJHtoZWlnaHR9XCIuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgICAgICBpZiAoL15bXFx4MDAtXFx4MjBdLy50ZXN0KHNyYykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBjYW5ub3Qgc3RhcnQgd2l0aCBhIHNwYWNlIG9yIGNvbnRyb2wgY2hhcmFjdGVyLiBVc2Ugc3JjLnRyaW1TdGFydCgpIHRvIHJlbW92ZSBpdCBvciBlbmNvZGVVUklDb21wb25lbnQoc3JjKSB0byBrZWVwIGl0LmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgICAgICAgaWYgKC9bXFx4MDAtXFx4MjBdJC8udGVzdChzcmMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgY2Fubm90IGVuZCB3aXRoIGEgc3BhY2Ugb3IgY29udHJvbCBjaGFyYWN0ZXIuIFVzZSBzcmMudHJpbUVuZCgpIHRvIHJlbW92ZSBpdCBvciBlbmNvZGVVUklDb21wb25lbnQoc3JjKSB0byBrZWVwIGl0LmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFWQUxJRF9MT0FESU5HX1ZBTFVFUy5pbmNsdWRlcyhsb2FkaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgaW52YWxpZCBcImxvYWRpbmdcIiBwcm9wZXJ0eS4gUHJvdmlkZWQgXCIke2xvYWRpbmd9XCIgc2hvdWxkIGJlIG9uZSBvZiAke1ZBTElEX0xPQURJTkdfVkFMVUVTLm1hcChcbiAgICAgICAgICBTdHJpbmdcbiAgICAgICAgKS5qb2luKCcsJyl9LmBcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKHByaW9yaXR5ICYmIGxvYWRpbmcgPT09ICdsYXp5Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgYm90aCBcInByaW9yaXR5XCIgYW5kIFwibG9hZGluZz0nbGF6eSdcIiBwcm9wZXJ0aWVzLiBPbmx5IG9uZSBzaG91bGQgYmUgdXNlZC5gXG4gICAgICApXG4gICAgfVxuICAgIGlmIChcbiAgICAgIHBsYWNlaG9sZGVyICE9PSAnZW1wdHknICYmXG4gICAgICBwbGFjZWhvbGRlciAhPT0gJ2JsdXInICYmXG4gICAgICAhcGxhY2Vob2xkZXIuc3RhcnRzV2l0aCgnZGF0YTppbWFnZS8nKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgaW52YWxpZCBcInBsYWNlaG9sZGVyXCIgcHJvcGVydHkgXCIke3BsYWNlaG9sZGVyfVwiLmBcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKHBsYWNlaG9sZGVyICE9PSAnZW1wdHknKSB7XG4gICAgICBpZiAod2lkdGhJbnQgJiYgaGVpZ2h0SW50ICYmIHdpZHRoSW50ICogaGVpZ2h0SW50IDwgMTYwMCkge1xuICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyBzbWFsbGVyIHRoYW4gNDB4NDAuIENvbnNpZGVyIHJlbW92aW5nIHRoZSBcInBsYWNlaG9sZGVyXCIgcHJvcGVydHkgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS5gXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHF1YWxpdHlJbnQgJiYgcXVhbGl0eUludCAhPT0gNzUgJiYgIWNvbmZpZy5xdWFsaXRpZXMpIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyB1c2luZyBxdWFsaXR5IFwiJHtxdWFsaXR5SW50fVwiIHdoaWNoIGlzIG5vdCBjb25maWd1cmVkIGluIGltYWdlcy5xdWFsaXRpZXMuIFRoaXMgY29uZmlnIHdpbGwgYmUgcmVxdWlyZWQgc3RhcnRpbmcgaW4gTmV4dC5qcyAxNi5gICtcbiAgICAgICAgICBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVuY29uZmlndXJlZC1xdWFsaXRpZXNgXG4gICAgICApXG4gICAgfVxuICAgIGlmIChcbiAgICAgIHNyYy5zdGFydHNXaXRoKCcvJykgJiZcbiAgICAgIHNyYy5pbmNsdWRlcygnPycpICYmXG4gICAgICAoIWNvbmZpZz8ubG9jYWxQYXR0ZXJucz8ubGVuZ3RoIHx8XG4gICAgICAgIChjb25maWcubG9jYWxQYXR0ZXJucy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICBjb25maWcubG9jYWxQYXR0ZXJuc1swXS5wYXRobmFtZSA9PT0gJy9fbmV4dC9zdGF0aWMvbWVkaWEvKionKSlcbiAgICApIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyB1c2luZyBhIHF1ZXJ5IHN0cmluZyB3aGljaCBpcyBub3QgY29uZmlndXJlZCBpbiBpbWFnZXMubG9jYWxQYXR0ZXJucy4gVGhpcyBjb25maWcgd2lsbCBiZSByZXF1aXJlZCBzdGFydGluZyBpbiBOZXh0LmpzIDE2LmAgK1xuICAgICAgICAgIGBcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtdW5jb25maWd1cmVkLWxvY2FscGF0dGVybnNgXG4gICAgICApXG4gICAgfVxuICAgIGlmIChwbGFjZWhvbGRlciA9PT0gJ2JsdXInICYmICFibHVyRGF0YVVSTCkge1xuICAgICAgY29uc3QgVkFMSURfQkxVUl9FWFQgPSBbJ2pwZWcnLCAncG5nJywgJ3dlYnAnLCAnYXZpZiddIC8vIHNob3VsZCBtYXRjaCBuZXh0LWltYWdlLWxvYWRlclxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBcInBsYWNlaG9sZGVyPSdibHVyJ1wiIHByb3BlcnR5IGJ1dCBpcyBtaXNzaW5nIHRoZSBcImJsdXJEYXRhVVJMXCIgcHJvcGVydHkuXG4gICAgICAgIFBvc3NpYmxlIHNvbHV0aW9uczpcbiAgICAgICAgICAtIEFkZCBhIFwiYmx1ckRhdGFVUkxcIiBwcm9wZXJ0eSwgdGhlIGNvbnRlbnRzIHNob3VsZCBiZSBhIHNtYWxsIERhdGEgVVJMIHRvIHJlcHJlc2VudCB0aGUgaW1hZ2VcbiAgICAgICAgICAtIENoYW5nZSB0aGUgXCJzcmNcIiBwcm9wZXJ0eSB0byBhIHN0YXRpYyBpbXBvcnQgd2l0aCBvbmUgb2YgdGhlIHN1cHBvcnRlZCBmaWxlIHR5cGVzOiAke1ZBTElEX0JMVVJfRVhULmpvaW4oXG4gICAgICAgICAgICAnLCdcbiAgICAgICAgICApfSAoYW5pbWF0ZWQgaW1hZ2VzIG5vdCBzdXBwb3J0ZWQpXG4gICAgICAgICAgLSBSZW1vdmUgdGhlIFwicGxhY2Vob2xkZXJcIiBwcm9wZXJ0eSwgZWZmZWN0aXZlbHkgbm8gYmx1ciBlZmZlY3RcbiAgICAgICAgUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9wbGFjZWhvbGRlci1ibHVyLWRhdGEtdXJsYFxuICAgICAgKVxuICAgIH1cbiAgICBpZiAoJ3JlZicgaW4gcmVzdCkge1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIHVzaW5nIHVuc3VwcG9ydGVkIFwicmVmXCIgcHJvcGVydHkuIENvbnNpZGVyIHVzaW5nIHRoZSBcIm9uTG9hZFwiIHByb3BlcnR5IGluc3RlYWQuYFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICghdW5vcHRpbWl6ZWQgJiYgIWlzRGVmYXVsdExvYWRlcikge1xuICAgICAgY29uc3QgdXJsU3RyID0gbG9hZGVyKHtcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBzcmMsXG4gICAgICAgIHdpZHRoOiB3aWR0aEludCB8fCA0MDAsXG4gICAgICAgIHF1YWxpdHk6IHF1YWxpdHlJbnQgfHwgNzUsXG4gICAgICB9KVxuICAgICAgbGV0IHVybDogVVJMIHwgdW5kZWZpbmVkXG4gICAgICB0cnkge1xuICAgICAgICB1cmwgPSBuZXcgVVJMKHVybFN0cilcbiAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgIGlmICh1cmxTdHIgPT09IHNyYyB8fCAodXJsICYmIHVybC5wYXRobmFtZSA9PT0gc3JjICYmICF1cmwuc2VhcmNoKSkge1xuICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgYSBcImxvYWRlclwiIHByb3BlcnR5IHRoYXQgZG9lcyBub3QgaW1wbGVtZW50IHdpZHRoLiBQbGVhc2UgaW1wbGVtZW50IGl0IG9yIHVzZSB0aGUgXCJ1bm9wdGltaXplZFwiIHByb3BlcnR5IGluc3RlYWQuYCArXG4gICAgICAgICAgICBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLW1pc3NpbmctbG9hZGVyLXdpZHRoYFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9uTG9hZGluZ0NvbXBsZXRlKSB7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgdXNpbmcgZGVwcmVjYXRlZCBcIm9uTG9hZGluZ0NvbXBsZXRlXCIgcHJvcGVydHkuIFBsZWFzZSB1c2UgdGhlIFwib25Mb2FkXCIgcHJvcGVydHkgaW5zdGVhZC5gXG4gICAgICApXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBbbGVnYWN5S2V5LCBsZWdhY3lWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoe1xuICAgICAgbGF5b3V0LFxuICAgICAgb2JqZWN0Rml0LFxuICAgICAgb2JqZWN0UG9zaXRpb24sXG4gICAgICBsYXp5Qm91bmRhcnksXG4gICAgICBsYXp5Um9vdCxcbiAgICB9KSkge1xuICAgICAgaWYgKGxlZ2FjeVZhbHVlKSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBsZWdhY3kgcHJvcCBcIiR7bGVnYWN5S2V5fVwiLiBEaWQgeW91IGZvcmdldCB0byBydW4gdGhlIGNvZGVtb2Q/YCArXG4gICAgICAgICAgICBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVwZ3JhZGUtdG8tMTNgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgIXBlcmZPYnNlcnZlciAmJlxuICAgICAgd2luZG93LlBlcmZvcm1hbmNlT2JzZXJ2ZXJcbiAgICApIHtcbiAgICAgIHBlcmZPYnNlcnZlciA9IG5ldyBQZXJmb3JtYW5jZU9ic2VydmVyKChlbnRyeUxpc3QpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyeUxpc3QuZ2V0RW50cmllcygpKSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIG1pc3NpbmcgXCJMYXJnZXN0Q29udGVudGZ1bFBhaW50XCIgY2xhc3Mgd2l0aCBcImVsZW1lbnRcIiBwcm9wXG4gICAgICAgICAgY29uc3QgaW1nU3JjID0gZW50cnk/LmVsZW1lbnQ/LnNyYyB8fCAnJ1xuICAgICAgICAgIGNvbnN0IGxjcEltYWdlID0gYWxsSW1ncy5nZXQoaW1nU3JjKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGxjcEltYWdlICYmXG4gICAgICAgICAgICAhbGNwSW1hZ2UucHJpb3JpdHkgJiZcbiAgICAgICAgICAgIGxjcEltYWdlLnBsYWNlaG9sZGVyID09PSAnZW1wdHknICYmXG4gICAgICAgICAgICAhbGNwSW1hZ2Uuc3JjLnN0YXJ0c1dpdGgoJ2RhdGE6JykgJiZcbiAgICAgICAgICAgICFsY3BJbWFnZS5zcmMuc3RhcnRzV2l0aCgnYmxvYjonKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93ZWIuZGV2L2xjcC8jbWVhc3VyZS1sY3AtaW4tamF2YXNjcmlwdFxuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7bGNwSW1hZ2Uuc3JjfVwiIHdhcyBkZXRlY3RlZCBhcyB0aGUgTGFyZ2VzdCBDb250ZW50ZnVsIFBhaW50IChMQ1ApLiBQbGVhc2UgYWRkIHRoZSBcInByaW9yaXR5XCIgcHJvcGVydHkgaWYgdGhpcyBpbWFnZSBpcyBhYm92ZSB0aGUgZm9sZC5gICtcbiAgICAgICAgICAgICAgICBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2UjcHJpb3JpdHlgXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdHJ5IHtcbiAgICAgICAgcGVyZk9ic2VydmVyLm9ic2VydmUoe1xuICAgICAgICAgIHR5cGU6ICdsYXJnZXN0LWNvbnRlbnRmdWwtcGFpbnQnLFxuICAgICAgICAgIGJ1ZmZlcmVkOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIExvZyBlcnJvciBidXQgZG9uJ3QgY3Jhc2ggdGhlIGFwcFxuICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgaW1nU3R5bGUgPSBPYmplY3QuYXNzaWduKFxuICAgIGZpbGxcbiAgICAgID8ge1xuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgIG9iamVjdEZpdCxcbiAgICAgICAgICBvYmplY3RQb3NpdGlvbixcbiAgICAgICAgfVxuICAgICAgOiB7fSxcbiAgICBzaG93QWx0VGV4dCA/IHt9IDogeyBjb2xvcjogJ3RyYW5zcGFyZW50JyB9LFxuICAgIHN0eWxlXG4gIClcblxuICBjb25zdCBiYWNrZ3JvdW5kSW1hZ2UgPVxuICAgICFibHVyQ29tcGxldGUgJiYgcGxhY2Vob2xkZXIgIT09ICdlbXB0eSdcbiAgICAgID8gcGxhY2Vob2xkZXIgPT09ICdibHVyJ1xuICAgICAgICA/IGB1cmwoXCJkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCwke2dldEltYWdlQmx1clN2Zyh7XG4gICAgICAgICAgICB3aWR0aEludCxcbiAgICAgICAgICAgIGhlaWdodEludCxcbiAgICAgICAgICAgIGJsdXJXaWR0aCxcbiAgICAgICAgICAgIGJsdXJIZWlnaHQsXG4gICAgICAgICAgICBibHVyRGF0YVVSTDogYmx1ckRhdGFVUkwgfHwgJycsIC8vIGFzc3VtZSBub3QgdW5kZWZpbmVkXG4gICAgICAgICAgICBvYmplY3RGaXQ6IGltZ1N0eWxlLm9iamVjdEZpdCxcbiAgICAgICAgICB9KX1cIilgXG4gICAgICAgIDogYHVybChcIiR7cGxhY2Vob2xkZXJ9XCIpYCAvLyBhc3N1bWUgYGRhdGE6aW1hZ2UvYFxuICAgICAgOiBudWxsXG5cbiAgY29uc3QgYmFja2dyb3VuZFNpemUgPSAhSU5WQUxJRF9CQUNLR1JPVU5EX1NJWkVfVkFMVUVTLmluY2x1ZGVzKFxuICAgIGltZ1N0eWxlLm9iamVjdEZpdFxuICApXG4gICAgPyBpbWdTdHlsZS5vYmplY3RGaXRcbiAgICA6IGltZ1N0eWxlLm9iamVjdEZpdCA9PT0gJ2ZpbGwnXG4gICAgICA/ICcxMDAlIDEwMCUnIC8vIHRoZSBiYWNrZ3JvdW5kLXNpemUgZXF1aXZhbGVudCBvZiBgZmlsbGBcbiAgICAgIDogJ2NvdmVyJ1xuXG4gIGxldCBwbGFjZWhvbGRlclN0eWxlOiBQbGFjZWhvbGRlclN0eWxlID0gYmFja2dyb3VuZEltYWdlXG4gICAgPyB7XG4gICAgICAgIGJhY2tncm91bmRTaXplLFxuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IGltZ1N0eWxlLm9iamVjdFBvc2l0aW9uIHx8ICc1MCUgNTAlJyxcbiAgICAgICAgYmFja2dyb3VuZFJlcGVhdDogJ25vLXJlcGVhdCcsXG4gICAgICAgIGJhY2tncm91bmRJbWFnZSxcbiAgICAgIH1cbiAgICA6IHt9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgaWYgKFxuICAgICAgcGxhY2Vob2xkZXJTdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgJiZcbiAgICAgIHBsYWNlaG9sZGVyID09PSAnYmx1cicgJiZcbiAgICAgIGJsdXJEYXRhVVJMPy5zdGFydHNXaXRoKCcvJylcbiAgICApIHtcbiAgICAgIC8vIER1cmluZyBgbmV4dCBkZXZgLCB3ZSBkb24ndCB3YW50IHRvIGdlbmVyYXRlIGJsdXIgcGxhY2Vob2xkZXJzIHdpdGggd2VicGFja1xuICAgICAgLy8gYmVjYXVzZSBpdCBjYW4gZGVsYXkgc3RhcnRpbmcgdGhlIGRldiBzZXJ2ZXIuIEluc3RlYWQsIGBuZXh0LWltYWdlLWxvYWRlci5qc2BcbiAgICAgIC8vIHdpbGwgaW5saW5lIGEgc3BlY2lhbCB1cmwgdG8gbGF6aWx5IGdlbmVyYXRlIHRoZSBibHVyIHBsYWNlaG9sZGVyIGF0IHJlcXVlc3QgdGltZS5cbiAgICAgIHBsYWNlaG9sZGVyU3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybChcIiR7Ymx1ckRhdGFVUkx9XCIpYFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGltZ0F0dHJpYnV0ZXMgPSBnZW5lcmF0ZUltZ0F0dHJzKHtcbiAgICBjb25maWcsXG4gICAgc3JjLFxuICAgIHVub3B0aW1pemVkLFxuICAgIHdpZHRoOiB3aWR0aEludCxcbiAgICBxdWFsaXR5OiBxdWFsaXR5SW50LFxuICAgIHNpemVzLFxuICAgIGxvYWRlcixcbiAgfSlcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbGV0IGZ1bGxVcmw6IFVSTFxuICAgICAgdHJ5IHtcbiAgICAgICAgZnVsbFVybCA9IG5ldyBVUkwoaW1nQXR0cmlidXRlcy5zcmMpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGZ1bGxVcmwgPSBuZXcgVVJMKGltZ0F0dHJpYnV0ZXMuc3JjLCB3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgICAgIH1cbiAgICAgIGFsbEltZ3Muc2V0KGZ1bGxVcmwuaHJlZiwgeyBzcmMsIHByaW9yaXR5LCBwbGFjZWhvbGRlciB9KVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHByb3BzOiBJbWdQcm9wcyA9IHtcbiAgICAuLi5yZXN0LFxuICAgIGxvYWRpbmc6IGlzTGF6eSA/ICdsYXp5JyA6IGxvYWRpbmcsXG4gICAgZmV0Y2hQcmlvcml0eSxcbiAgICB3aWR0aDogd2lkdGhJbnQsXG4gICAgaGVpZ2h0OiBoZWlnaHRJbnQsXG4gICAgZGVjb2RpbmcsXG4gICAgY2xhc3NOYW1lLFxuICAgIHN0eWxlOiB7IC4uLmltZ1N0eWxlLCAuLi5wbGFjZWhvbGRlclN0eWxlIH0sXG4gICAgc2l6ZXM6IGltZ0F0dHJpYnV0ZXMuc2l6ZXMsXG4gICAgc3JjU2V0OiBpbWdBdHRyaWJ1dGVzLnNyY1NldCxcbiAgICBzcmM6IG92ZXJyaWRlU3JjIHx8IGltZ0F0dHJpYnV0ZXMuc3JjLFxuICB9XG4gIGNvbnN0IG1ldGEgPSB7IHVub3B0aW1pemVkLCBwcmlvcml0eSwgcGxhY2Vob2xkZXIsIGZpbGwgfVxuICByZXR1cm4geyBwcm9wcywgbWV0YSB9XG59XG4iXSwibmFtZXMiOlsiZ2V0SW1nUHJvcHMiLCJWQUxJRF9MT0FESU5HX1ZBTFVFUyIsInVuZGVmaW5lZCIsIklOVkFMSURfQkFDS0dST1VORF9TSVpFX1ZBTFVFUyIsImlzU3RhdGljUmVxdWlyZSIsInNyYyIsImRlZmF1bHQiLCJpc1N0YXRpY0ltYWdlRGF0YSIsImlzU3RhdGljSW1wb3J0IiwiYWxsSW1ncyIsIk1hcCIsInBlcmZPYnNlcnZlciIsImdldEludCIsIngiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIk5hTiIsInRlc3QiLCJwYXJzZUludCIsImdldFdpZHRocyIsIndpZHRoIiwic2l6ZXMiLCJkZXZpY2VTaXplcyIsImFsbFNpemVzIiwidmlld3BvcnRXaWR0aFJlIiwicGVyY2VudFNpemVzIiwibWF0Y2giLCJleGVjIiwicHVzaCIsImxlbmd0aCIsInNtYWxsZXN0UmF0aW8iLCJNYXRoIiwibWluIiwid2lkdGhzIiwiZmlsdGVyIiwicyIsImtpbmQiLCJTZXQiLCJtYXAiLCJ3IiwiZmluZCIsInAiLCJnZW5lcmF0ZUltZ0F0dHJzIiwiY29uZmlnIiwidW5vcHRpbWl6ZWQiLCJxdWFsaXR5IiwibG9hZGVyIiwic3JjU2V0IiwibGFzdCIsImkiLCJqb2luIiwiX3N0YXRlIiwicHJpb3JpdHkiLCJsb2FkaW5nIiwiY2xhc3NOYW1lIiwiaGVpZ2h0IiwiZmlsbCIsInN0eWxlIiwib3ZlcnJpZGVTcmMiLCJvbkxvYWQiLCJvbkxvYWRpbmdDb21wbGV0ZSIsInBsYWNlaG9sZGVyIiwiYmx1ckRhdGFVUkwiLCJmZXRjaFByaW9yaXR5IiwiZGVjb2RpbmciLCJsYXlvdXQiLCJvYmplY3RGaXQiLCJvYmplY3RQb3NpdGlvbiIsImxhenlCb3VuZGFyeSIsImxhenlSb290IiwicmVzdCIsImltZ0NvbmYiLCJzaG93QWx0VGV4dCIsImJsdXJDb21wbGV0ZSIsImRlZmF1bHRMb2FkZXIiLCJjIiwiaW1hZ2VDb25maWdEZWZhdWx0IiwiaW1hZ2VTaXplcyIsInNvcnQiLCJhIiwiYiIsInF1YWxpdGllcyIsIkVycm9yIiwiaXNEZWZhdWx0TG9hZGVyIiwiY3VzdG9tSW1hZ2VMb2FkZXIiLCJvYmoiLCJfIiwib3B0cyIsImxheW91dFRvU3R5bGUiLCJpbnRyaW5zaWMiLCJtYXhXaWR0aCIsInJlc3BvbnNpdmUiLCJsYXlvdXRUb1NpemVzIiwibGF5b3V0U3R5bGUiLCJsYXlvdXRTaXplcyIsInN0YXRpY1NyYyIsIndpZHRoSW50IiwiaGVpZ2h0SW50IiwiYmx1cldpZHRoIiwiYmx1ckhlaWdodCIsInN0YXRpY0ltYWdlRGF0YSIsIkpTT04iLCJzdHJpbmdpZnkiLCJyYXRpbyIsInJvdW5kIiwiaXNMYXp5Iiwic3RhcnRzV2l0aCIsImRhbmdlcm91c2x5QWxsb3dTVkciLCJzcGxpdCIsImVuZHNXaXRoIiwicXVhbGl0eUludCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIm91dHB1dCIsInBvc2l0aW9uIiwiaXNOYU4iLCJpbmNsdWRlcyIsIlN0cmluZyIsIndhcm5PbmNlIiwibG9jYWxQYXR0ZXJucyIsInBhdGhuYW1lIiwiVkFMSURfQkxVUl9FWFQiLCJ1cmxTdHIiLCJ1cmwiLCJVUkwiLCJlcnIiLCJzZWFyY2giLCJsZWdhY3lLZXkiLCJsZWdhY3lWYWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJ3aW5kb3ciLCJQZXJmb3JtYW5jZU9ic2VydmVyIiwiZW50cnlMaXN0IiwiZW50cnkiLCJnZXRFbnRyaWVzIiwiaW1nU3JjIiwiZWxlbWVudCIsImxjcEltYWdlIiwiZ2V0Iiwib2JzZXJ2ZSIsInR5cGUiLCJidWZmZXJlZCIsImNvbnNvbGUiLCJlcnJvciIsImltZ1N0eWxlIiwiYXNzaWduIiwibGVmdCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwiY29sb3IiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJnZXRJbWFnZUJsdXJTdmciLCJiYWNrZ3JvdW5kU2l6ZSIsInBsYWNlaG9sZGVyU3R5bGUiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJiYWNrZ3JvdW5kUmVwZWF0IiwiaW1nQXR0cmlidXRlcyIsImZ1bGxVcmwiLCJlIiwibG9jYXRpb24iLCJocmVmIiwic2V0IiwicHJvcHMiLCJtZXRhIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/head.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return _default;\n    },\n    defaultHead: function() {\n        return defaultHead;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _sideeffect = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./side-effect */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js\"));\nconst _ampcontextsharedruntime = __webpack_require__(/*! ./amp-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\");\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ./head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _ampmode = __webpack_require__(/*! ./amp-mode */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\");\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nfunction defaultHead(inAmpMode) {\n    if (inAmpMode === void 0) inAmpMode = false;\n    const head = [\n        /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            charSet: \"utf-8\"\n        }, \"charset\")\n    ];\n    if (!inAmpMode) {\n        head.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            name: \"viewport\",\n            content: \"width=device-width\"\n        }, \"viewport\"));\n    }\n    return head;\n}\nfunction onlyReactElement(list, child) {\n    // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n    if (typeof child === 'string' || typeof child === 'number') {\n        return list;\n    }\n    // Adds support for React.Fragment\n    if (child.type === _react.default.Fragment) {\n        return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild)=>{\n            if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {\n                return fragmentList;\n            }\n            return fragmentList.concat(fragmentChild);\n        }, []));\n    }\n    return list.concat(child);\n}\nconst METATYPES = [\n    'name',\n    'httpEquiv',\n    'charSet',\n    'itemProp'\n];\n/*\n returns a function for filtering head child elements\n which shouldn't be duplicated, like <title/>\n Also adds support for deduplicated `key` properties\n*/ function unique() {\n    const keys = new Set();\n    const tags = new Set();\n    const metaTypes = new Set();\n    const metaCategories = {};\n    return (h)=>{\n        let isUnique = true;\n        let hasKey = false;\n        if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {\n            hasKey = true;\n            const key = h.key.slice(h.key.indexOf('$') + 1);\n            if (keys.has(key)) {\n                isUnique = false;\n            } else {\n                keys.add(key);\n            }\n        }\n        // eslint-disable-next-line default-case\n        switch(h.type){\n            case 'title':\n            case 'base':\n                if (tags.has(h.type)) {\n                    isUnique = false;\n                } else {\n                    tags.add(h.type);\n                }\n                break;\n            case 'meta':\n                for(let i = 0, len = METATYPES.length; i < len; i++){\n                    const metatype = METATYPES[i];\n                    if (!h.props.hasOwnProperty(metatype)) continue;\n                    if (metatype === 'charSet') {\n                        if (metaTypes.has(metatype)) {\n                            isUnique = false;\n                        } else {\n                            metaTypes.add(metatype);\n                        }\n                    } else {\n                        const category = h.props[metatype];\n                        const categories = metaCategories[metatype] || new Set();\n                        if ((metatype !== 'name' || !hasKey) && categories.has(category)) {\n                            isUnique = false;\n                        } else {\n                            categories.add(category);\n                            metaCategories[metatype] = categories;\n                        }\n                    }\n                }\n                break;\n        }\n        return isUnique;\n    };\n}\n/**\n *\n * @param headChildrenElements List of children of <Head>\n */ function reduceComponents(headChildrenElements, props) {\n    const { inAmpMode } = props;\n    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map((c, i)=>{\n        const key = c.key || i;\n        if (true) {\n            // omit JSON-LD structured data snippets from the warning\n            if (c.type === 'script' && c.props['type'] !== 'application/ld+json') {\n                const srcMessage = c.props['src'] ? '<script> tag with src=\"' + c.props['src'] + '\"' : \"inline <script>\";\n                (0, _warnonce.warnOnce)(\"Do not add <script> tags using next/head (see \" + srcMessage + \"). Use next/script instead. \\nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component\");\n            } else if (c.type === 'link' && c.props['rel'] === 'stylesheet') {\n                (0, _warnonce.warnOnce)('Do not add stylesheets using next/head (see <link rel=\"stylesheet\"> tag with href=\"' + c.props['href'] + '\"). Use Document instead. \\nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component');\n            }\n        }\n        return /*#__PURE__*/ _react.default.cloneElement(c, {\n            key\n        });\n    });\n}\n/**\n * This component injects elements to `<head>` of your page.\n * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n */ function Head(param) {\n    let { children } = param;\n    const ampState = (0, _react.useContext)(_ampcontextsharedruntime.AmpStateContext);\n    const headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect.default, {\n        reduceComponentsToState: reduceComponents,\n        headManager: headManager,\n        inAmpMode: (0, _ampmode.isInAmpMode)(ampState),\n        children: children\n    });\n}\n_c = Head;\nconst _default = Head;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=head.js.map\nvar _c;\n$RefreshReg$(_c, \"Head\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9oZWFkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQWdMQSxPQUFtQjtlQUFuQjs7SUFuS2dCQSxXQUFXO2VBQVhBOzs7Ozs7NkVBWDRCO2lGQUN6QjtxREFDYTs2REFDRztxQ0FDUDtzQ0FDSDtBQU1sQixTQUFTQSxZQUFZQyxTQUFpQjtJQUFqQkEsSUFBQUEsY0FBQUEsS0FBQUEsR0FBQUEsWUFBWTtJQUN0QyxNQUFNQyxPQUFPO3NCQUFDLHFCQUFDQyxRQUFBQTtZQUFLQyxTQUFRO1dBQVk7S0FBYTtJQUNyRCxJQUFJLENBQUNILFdBQVc7UUFDZEMsS0FBS0csSUFBSSxlQUNQLHFCQUFDRixRQUFBQTtZQUFLRyxNQUFLO1lBQVdDLFNBQVE7V0FBeUI7SUFFM0Q7SUFDQSxPQUFPTDtBQUNUO0FBRUEsU0FBU00saUJBQ1BDLElBQW9DLEVBQ3BDQyxLQUEyQztJQUUzQyw4RkFBOEY7SUFDOUYsSUFBSSxPQUFPQSxVQUFVLFlBQVksT0FBT0EsVUFBVSxVQUFVO1FBQzFELE9BQU9EO0lBQ1Q7SUFDQSxrQ0FBa0M7SUFDbEMsSUFBSUMsTUFBTUMsSUFBSSxLQUFLQyxPQUFBQSxPQUFLLENBQUNDLFFBQVEsRUFBRTtRQUNqQyxPQUFPSixLQUFLSyxNQUFNLENBQ2hCLE9BQ0FGLE9BQUssQ0FBQ0csUUFBUSxDQUFDQyxPQUFPLENBQUNOLE1BQU1PLEtBQUssQ0FBQ0MsUUFBUSxFQUFFQyxNQUFNLENBQ2pELENBRUVDLGNBQ0FDO1lBRUEsSUFDRSxPQUFPQSxrQkFBa0IsWUFDekIsT0FBT0Esa0JBQWtCLFVBQ3pCO2dCQUNBLE9BQU9EO1lBQ1Q7WUFDQSxPQUFPQSxhQUFhTixNQUFNLENBQUNPO1FBQzdCLEdBQ0EsRUFBRTtJQUdSO0lBQ0EsT0FBT1osS0FBS0ssTUFBTSxDQUFDSjtBQUNyQjtBQUVBLE1BQU1ZLFlBQVk7SUFBQztJQUFRO0lBQWE7SUFBVztDQUFXO0FBRTlEOzs7O0FBSUEsR0FDQSxTQUFTQztJQUNQLE1BQU1DLE9BQU8sSUFBSUM7SUFDakIsTUFBTUMsT0FBTyxJQUFJRDtJQUNqQixNQUFNRSxZQUFZLElBQUlGO0lBQ3RCLE1BQU1HLGlCQUFzRCxDQUFDO0lBRTdELE9BQU8sQ0FBQ0M7UUFDTixJQUFJQyxXQUFXO1FBQ2YsSUFBSUMsU0FBUztRQUViLElBQUlGLEVBQUVHLEdBQUcsSUFBSSxPQUFPSCxFQUFFRyxHQUFHLEtBQUssWUFBWUgsRUFBRUcsR0FBRyxDQUFDQyxPQUFPLENBQUMsT0FBTyxHQUFHO1lBQ2hFRixTQUFTO1lBQ1QsTUFBTUMsTUFBTUgsRUFBRUcsR0FBRyxDQUFDRSxLQUFLLENBQUNMLEVBQUVHLEdBQUcsQ0FBQ0MsT0FBTyxDQUFDLE9BQU87WUFDN0MsSUFBSVQsS0FBS1csR0FBRyxDQUFDSCxNQUFNO2dCQUNqQkYsV0FBVztZQUNiLE9BQU87Z0JBQ0xOLEtBQUtZLEdBQUcsQ0FBQ0o7WUFDWDtRQUNGO1FBRUEsd0NBQXdDO1FBQ3hDLE9BQVFILEVBQUVsQixJQUFJO1lBQ1osS0FBSztZQUNMLEtBQUs7Z0JBQ0gsSUFBSWUsS0FBS1MsR0FBRyxDQUFDTixFQUFFbEIsSUFBSSxHQUFHO29CQUNwQm1CLFdBQVc7Z0JBQ2IsT0FBTztvQkFDTEosS0FBS1UsR0FBRyxDQUFDUCxFQUFFbEIsSUFBSTtnQkFDakI7Z0JBQ0E7WUFDRixLQUFLO2dCQUNILElBQUssSUFBSTBCLElBQUksR0FBR0MsTUFBTWhCLFVBQVVpQixNQUFNLEVBQUVGLElBQUlDLEtBQUtELElBQUs7b0JBQ3BELE1BQU1HLFdBQVdsQixTQUFTLENBQUNlLEVBQUU7b0JBQzdCLElBQUksQ0FBQ1IsRUFBRVosS0FBSyxDQUFDd0IsY0FBYyxDQUFDRCxXQUFXO29CQUV2QyxJQUFJQSxhQUFhLFdBQVc7d0JBQzFCLElBQUliLFVBQVVRLEdBQUcsQ0FBQ0ssV0FBVzs0QkFDM0JWLFdBQVc7d0JBQ2IsT0FBTzs0QkFDTEgsVUFBVVMsR0FBRyxDQUFDSTt3QkFDaEI7b0JBQ0YsT0FBTzt3QkFDTCxNQUFNRSxXQUFXYixFQUFFWixLQUFLLENBQUN1QixTQUFTO3dCQUNsQyxNQUFNRyxhQUFhZixjQUFjLENBQUNZLFNBQVMsSUFBSSxJQUFJZjt3QkFDbkQsSUFBS2UsQ0FBQUEsYUFBYSxVQUFVLENBQUNULE1BQUFBLENBQUssSUFBTVksV0FBV1IsR0FBRyxDQUFDTyxXQUFXOzRCQUNoRVosV0FBVzt3QkFDYixPQUFPOzRCQUNMYSxXQUFXUCxHQUFHLENBQUNNOzRCQUNmZCxjQUFjLENBQUNZLFNBQVMsR0FBR0c7d0JBQzdCO29CQUNGO2dCQUNGO2dCQUNBO1FBQ0o7UUFFQSxPQUFPYjtJQUNUO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxTQUFTYyxpQkFDUEMsb0JBQW9ELEVBQ3BENUIsS0FBUTtJQUVSLE1BQU0sRUFBRWhCLFNBQVMsRUFBRSxHQUFHZ0I7SUFDdEIsT0FBTzRCLHFCQUNKMUIsTUFBTSxDQUFDWCxrQkFBa0IsRUFBRSxFQUMzQnNDLE9BQU8sR0FDUGhDLE1BQU0sQ0FBQ2QsWUFBWUMsV0FBVzZDLE9BQU8sSUFDckNDLE1BQU0sQ0FBQ3hCLFVBQ1B1QixPQUFPLEdBQ1BFLEdBQUcsQ0FBQyxDQUFDQyxHQUE0Qlo7UUFDaEMsTUFBTUwsTUFBTWlCLEVBQUVqQixHQUFHLElBQUlLO1FBQ3JCLElBQUlhLElBQW9CLEVBQW9CO1lBQzFDLHlEQUF5RDtZQUN6RCxJQUFJRCxFQUFFdEMsSUFBSSxLQUFLLFlBQVlzQyxFQUFFaEMsS0FBSyxDQUFDLE9BQU8sS0FBSyx1QkFBdUI7Z0JBQ3BFLE1BQU1vQyxhQUFhSixFQUFFaEMsS0FBSyxDQUFDLE1BQU0sR0FDNUIsNEJBQXlCZ0MsRUFBRWhDLEtBQUssQ0FBQyxNQUFNLEdBQUMsTUFDeEM7Z0JBQ0xxQyxDQUFBQSxHQUFBQSxVQUFBQSxRQUFBQSxFQUNHLG1EQUFnREQsYUFBVztZQUVoRSxPQUFPLElBQUlKLEVBQUV0QyxJQUFJLEtBQUssVUFBVXNDLEVBQUVoQyxLQUFLLENBQUMsTUFBTSxLQUFLLGNBQWM7Z0JBQy9EcUMsQ0FBQUEsR0FBQUEsVUFBQUEsUUFBQUEsRUFDRyx3RkFBcUZMLEVBQUVoQyxLQUFLLENBQUMsT0FBTyxHQUFDO1lBRTFHO1FBQ0Y7UUFDQSxxQkFBT0wsT0FBQUEsT0FBSyxDQUFDMkMsWUFBWSxDQUFDTixHQUFHO1lBQUVqQjtRQUFJO0lBQ3JDO0FBQ0o7QUFFQTs7O0NBR0MsR0FDRCxjQUFjLEtBQTJDO0lBQTNDLE1BQUVkLFFBQVEsRUFBaUMsR0FBM0M7SUFDWixNQUFNdUMsV0FBV0MsQ0FBQUEsR0FBQUEsT0FBQUEsVUFBQUEsRUFBV0MseUJBQUFBLGVBQWU7SUFDM0MsTUFBTUMsY0FBY0YsQ0FBQUEsR0FBQUEsT0FBQUEsVUFBQUEsRUFBV0csaUNBQUFBLGtCQUFrQjtJQUNqRCxxQkFDRSxxQkFBQ0MsWUFBQUEsT0FBTTtRQUNMQyx5QkFBeUJuQjtRQUN6QmdCLGFBQWFBO1FBQ2IzRCxXQUFXK0QsQ0FBQUEsR0FBQUEsU0FBQUEsV0FBQUEsRUFBWVA7a0JBRXRCdkM7O0FBR1A7S0FaU3NDO01BY1QsV0FBZUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zcmMvc2hhcmVkL2xpYi9oZWFkLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQsIHR5cGUgSlNYIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgRWZmZWN0IGZyb20gJy4vc2lkZS1lZmZlY3QnXG5pbXBvcnQgeyBBbXBTdGF0ZUNvbnRleHQgfSBmcm9tICcuL2FtcC1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgSGVhZE1hbmFnZXJDb250ZXh0IH0gZnJvbSAnLi9oZWFkLW1hbmFnZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGlzSW5BbXBNb2RlIH0gZnJvbSAnLi9hbXAtbW9kZSdcbmltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSAnLi91dGlscy93YXJuLW9uY2UnXG5cbnR5cGUgV2l0aEluQW1wTW9kZSA9IHtcbiAgaW5BbXBNb2RlPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdEhlYWQoaW5BbXBNb2RlID0gZmFsc2UpOiBKU1guRWxlbWVudFtdIHtcbiAgY29uc3QgaGVhZCA9IFs8bWV0YSBjaGFyU2V0PVwidXRmLThcIiBrZXk9XCJjaGFyc2V0XCIgLz5dXG4gIGlmICghaW5BbXBNb2RlKSB7XG4gICAgaGVhZC5wdXNoKFxuICAgICAgPG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aFwiIGtleT1cInZpZXdwb3J0XCIgLz5cbiAgICApXG4gIH1cbiAgcmV0dXJuIGhlYWRcbn1cblxuZnVuY3Rpb24gb25seVJlYWN0RWxlbWVudChcbiAgbGlzdDogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICBjaGlsZDogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVtYmVyIHwgc3RyaW5nXG4pOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4ge1xuICAvLyBSZWFjdCBjaGlsZHJlbiBjYW4gYmUgXCJzdHJpbmdcIiBvciBcIm51bWJlclwiIGluIHRoaXMgY2FzZSB3ZSBpZ25vcmUgdGhlbSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGxpc3RcbiAgfVxuICAvLyBBZGRzIHN1cHBvcnQgZm9yIFJlYWN0LkZyYWdtZW50XG4gIGlmIChjaGlsZC50eXBlID09PSBSZWFjdC5GcmFnbWVudCkge1xuICAgIHJldHVybiBsaXN0LmNvbmNhdChcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgQHR5cGVzL3JlYWN0IGRvZXMgbm90IHJlbW92ZSBmcmFnbWVudHMgYnV0IHRoaXMgY291bGQgYWxzbyByZXR1cm4gUmVhY3RQb3J0YWxbXVxuICAgICAgUmVhY3QuQ2hpbGRyZW4udG9BcnJheShjaGlsZC5wcm9wcy5jaGlsZHJlbikucmVkdWNlKFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEB0eXBlcy9yZWFjdCBkb2VzIG5vdCByZW1vdmUgZnJhZ21lbnRzIGJ1dCB0aGlzIGNvdWxkIGFsc28gcmV0dXJuIFJlYWN0UG9ydGFsW11cbiAgICAgICAgKFxuICAgICAgICAgIGZyYWdtZW50TGlzdDogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICAgICAgICAgIGZyYWdtZW50Q2hpbGQ6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bWJlciB8IHN0cmluZ1xuICAgICAgICApOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4gPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBmcmFnbWVudENoaWxkID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgdHlwZW9mIGZyYWdtZW50Q2hpbGQgPT09ICdudW1iZXInXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRMaXN0XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmcmFnbWVudExpc3QuY29uY2F0KGZyYWdtZW50Q2hpbGQpXG4gICAgICAgIH0sXG4gICAgICAgIFtdXG4gICAgICApXG4gICAgKVxuICB9XG4gIHJldHVybiBsaXN0LmNvbmNhdChjaGlsZClcbn1cblxuY29uc3QgTUVUQVRZUEVTID0gWyduYW1lJywgJ2h0dHBFcXVpdicsICdjaGFyU2V0JywgJ2l0ZW1Qcm9wJ11cblxuLypcbiByZXR1cm5zIGEgZnVuY3Rpb24gZm9yIGZpbHRlcmluZyBoZWFkIGNoaWxkIGVsZW1lbnRzXG4gd2hpY2ggc2hvdWxkbid0IGJlIGR1cGxpY2F0ZWQsIGxpa2UgPHRpdGxlLz5cbiBBbHNvIGFkZHMgc3VwcG9ydCBmb3IgZGVkdXBsaWNhdGVkIGBrZXlgIHByb3BlcnRpZXNcbiovXG5mdW5jdGlvbiB1bmlxdWUoKSB7XG4gIGNvbnN0IGtleXMgPSBuZXcgU2V0KClcbiAgY29uc3QgdGFncyA9IG5ldyBTZXQoKVxuICBjb25zdCBtZXRhVHlwZXMgPSBuZXcgU2V0KClcbiAgY29uc3QgbWV0YUNhdGVnb3JpZXM6IHsgW21ldGF0eXBlOiBzdHJpbmddOiBTZXQ8c3RyaW5nPiB9ID0ge31cblxuICByZXR1cm4gKGg6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+KSA9PiB7XG4gICAgbGV0IGlzVW5pcXVlID0gdHJ1ZVxuICAgIGxldCBoYXNLZXkgPSBmYWxzZVxuXG4gICAgaWYgKGgua2V5ICYmIHR5cGVvZiBoLmtleSAhPT0gJ251bWJlcicgJiYgaC5rZXkuaW5kZXhPZignJCcpID4gMCkge1xuICAgICAgaGFzS2V5ID0gdHJ1ZVxuICAgICAgY29uc3Qga2V5ID0gaC5rZXkuc2xpY2UoaC5rZXkuaW5kZXhPZignJCcpICsgMSlcbiAgICAgIGlmIChrZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMuYWRkKGtleSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXG4gICAgc3dpdGNoIChoLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3RpdGxlJzpcbiAgICAgIGNhc2UgJ2Jhc2UnOlxuICAgICAgICBpZiAodGFncy5oYXMoaC50eXBlKSkge1xuICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YWdzLmFkZChoLnR5cGUpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ21ldGEnOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gTUVUQVRZUEVTLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbWV0YXR5cGUgPSBNRVRBVFlQRVNbaV1cbiAgICAgICAgICBpZiAoIWgucHJvcHMuaGFzT3duUHJvcGVydHkobWV0YXR5cGUpKSBjb250aW51ZVxuXG4gICAgICAgICAgaWYgKG1ldGF0eXBlID09PSAnY2hhclNldCcpIHtcbiAgICAgICAgICAgIGlmIChtZXRhVHlwZXMuaGFzKG1ldGF0eXBlKSkge1xuICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtZXRhVHlwZXMuYWRkKG1ldGF0eXBlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yeSA9IGgucHJvcHNbbWV0YXR5cGVdXG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdIHx8IG5ldyBTZXQoKVxuICAgICAgICAgICAgaWYgKChtZXRhdHlwZSAhPT0gJ25hbWUnIHx8ICFoYXNLZXkpICYmIGNhdGVnb3JpZXMuaGFzKGNhdGVnb3J5KSkge1xuICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYXRlZ29yaWVzLmFkZChjYXRlZ29yeSlcbiAgICAgICAgICAgICAgbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdID0gY2F0ZWdvcmllc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIHJldHVybiBpc1VuaXF1ZVxuICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBoZWFkQ2hpbGRyZW5FbGVtZW50cyBMaXN0IG9mIGNoaWxkcmVuIG9mIDxIZWFkPlxuICovXG5mdW5jdGlvbiByZWR1Y2VDb21wb25lbnRzPFQgZXh0ZW5kcyB7fSAmIFdpdGhJbkFtcE1vZGU+KFxuICBoZWFkQ2hpbGRyZW5FbGVtZW50czogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICBwcm9wczogVFxuKSB7XG4gIGNvbnN0IHsgaW5BbXBNb2RlIH0gPSBwcm9wc1xuICByZXR1cm4gaGVhZENoaWxkcmVuRWxlbWVudHNcbiAgICAucmVkdWNlKG9ubHlSZWFjdEVsZW1lbnQsIFtdKVxuICAgIC5yZXZlcnNlKClcbiAgICAuY29uY2F0KGRlZmF1bHRIZWFkKGluQW1wTW9kZSkucmV2ZXJzZSgpKVxuICAgIC5maWx0ZXIodW5pcXVlKCkpXG4gICAgLnJldmVyc2UoKVxuICAgIC5tYXAoKGM6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+LCBpOiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IGMua2V5IHx8IGlcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAvLyBvbWl0IEpTT04tTEQgc3RydWN0dXJlZCBkYXRhIHNuaXBwZXRzIGZyb20gdGhlIHdhcm5pbmdcbiAgICAgICAgaWYgKGMudHlwZSA9PT0gJ3NjcmlwdCcgJiYgYy5wcm9wc1sndHlwZSddICE9PSAnYXBwbGljYXRpb24vbGQranNvbicpIHtcbiAgICAgICAgICBjb25zdCBzcmNNZXNzYWdlID0gYy5wcm9wc1snc3JjJ11cbiAgICAgICAgICAgID8gYDxzY3JpcHQ+IHRhZyB3aXRoIHNyYz1cIiR7Yy5wcm9wc1snc3JjJ119XCJgXG4gICAgICAgICAgICA6IGBpbmxpbmUgPHNjcmlwdD5gXG4gICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICBgRG8gbm90IGFkZCA8c2NyaXB0PiB0YWdzIHVzaW5nIG5leHQvaGVhZCAoc2VlICR7c3JjTWVzc2FnZX0pLiBVc2UgbmV4dC9zY3JpcHQgaW5zdGVhZC4gXFxuU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uby1zY3JpcHQtdGFncy1pbi1oZWFkLWNvbXBvbmVudGBcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSBpZiAoYy50eXBlID09PSAnbGluaycgJiYgYy5wcm9wc1sncmVsJ10gPT09ICdzdHlsZXNoZWV0Jykge1xuICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgYERvIG5vdCBhZGQgc3R5bGVzaGVldHMgdXNpbmcgbmV4dC9oZWFkIChzZWUgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiPiB0YWcgd2l0aCBocmVmPVwiJHtjLnByb3BzWydocmVmJ119XCIpLiBVc2UgRG9jdW1lbnQgaW5zdGVhZC4gXFxuU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uby1zdHlsZXNoZWV0cy1pbi1oZWFkLWNvbXBvbmVudGBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoYywgeyBrZXkgfSlcbiAgICB9KVxufVxuXG4vKipcbiAqIFRoaXMgY29tcG9uZW50IGluamVjdHMgZWxlbWVudHMgdG8gYDxoZWFkPmAgb2YgeW91ciBwYWdlLlxuICogVG8gYXZvaWQgZHVwbGljYXRlZCBgdGFnc2AgaW4gYDxoZWFkPmAgeW91IGNhbiB1c2UgdGhlIGBrZXlgIHByb3BlcnR5LCB3aGljaCB3aWxsIG1ha2Ugc3VyZSBldmVyeSB0YWcgaXMgb25seSByZW5kZXJlZCBvbmNlLlxuICovXG5mdW5jdGlvbiBIZWFkKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0pIHtcbiAgY29uc3QgYW1wU3RhdGUgPSB1c2VDb250ZXh0KEFtcFN0YXRlQ29udGV4dClcbiAgY29uc3QgaGVhZE1hbmFnZXIgPSB1c2VDb250ZXh0KEhlYWRNYW5hZ2VyQ29udGV4dClcbiAgcmV0dXJuIChcbiAgICA8RWZmZWN0XG4gICAgICByZWR1Y2VDb21wb25lbnRzVG9TdGF0ZT17cmVkdWNlQ29tcG9uZW50c31cbiAgICAgIGhlYWRNYW5hZ2VyPXtoZWFkTWFuYWdlcn1cbiAgICAgIGluQW1wTW9kZT17aXNJbkFtcE1vZGUoYW1wU3RhdGUpfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0VmZmVjdD5cbiAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBIZWFkXG4iXSwibmFtZXMiOlsiZGVmYXVsdEhlYWQiLCJpbkFtcE1vZGUiLCJoZWFkIiwibWV0YSIsImNoYXJTZXQiLCJwdXNoIiwibmFtZSIsImNvbnRlbnQiLCJvbmx5UmVhY3RFbGVtZW50IiwibGlzdCIsImNoaWxkIiwidHlwZSIsIlJlYWN0IiwiRnJhZ21lbnQiLCJjb25jYXQiLCJDaGlsZHJlbiIsInRvQXJyYXkiLCJwcm9wcyIsImNoaWxkcmVuIiwicmVkdWNlIiwiZnJhZ21lbnRMaXN0IiwiZnJhZ21lbnRDaGlsZCIsIk1FVEFUWVBFUyIsInVuaXF1ZSIsImtleXMiLCJTZXQiLCJ0YWdzIiwibWV0YVR5cGVzIiwibWV0YUNhdGVnb3JpZXMiLCJoIiwiaXNVbmlxdWUiLCJoYXNLZXkiLCJrZXkiLCJpbmRleE9mIiwic2xpY2UiLCJoYXMiLCJhZGQiLCJpIiwibGVuIiwibGVuZ3RoIiwibWV0YXR5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhdGVnb3J5IiwiY2F0ZWdvcmllcyIsInJlZHVjZUNvbXBvbmVudHMiLCJoZWFkQ2hpbGRyZW5FbGVtZW50cyIsInJldmVyc2UiLCJmaWx0ZXIiLCJtYXAiLCJjIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwic3JjTWVzc2FnZSIsIndhcm5PbmNlIiwiY2xvbmVFbGVtZW50IiwiSGVhZCIsImFtcFN0YXRlIiwidXNlQ29udGV4dCIsIkFtcFN0YXRlQ29udGV4dCIsImhlYWRNYW5hZ2VyIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiRWZmZWN0IiwicmVkdWNlQ29tcG9uZW50c1RvU3RhdGUiLCJpc0luQW1wTW9kZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-blur-svg.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * A shared function, used on both client and server, to generate a SVG blur placeholder.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImageBlurSvg\", ({\n    enumerable: true,\n    get: function() {\n        return getImageBlurSvg;\n    }\n}));\nfunction getImageBlurSvg(param) {\n    let { widthInt, heightInt, blurWidth, blurHeight, blurDataURL, objectFit } = param;\n    const std = 20;\n    const svgWidth = blurWidth ? blurWidth * 40 : widthInt;\n    const svgHeight = blurHeight ? blurHeight * 40 : heightInt;\n    const viewBox = svgWidth && svgHeight ? \"viewBox='0 0 \" + svgWidth + \" \" + svgHeight + \"'\" : '';\n    const preserveAspectRatio = viewBox ? 'none' : objectFit === 'contain' ? 'xMidYMid' : objectFit === 'cover' ? 'xMidYMid slice' : 'none';\n    return \"%3Csvg xmlns='http://www.w3.org/2000/svg' \" + viewBox + \"%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='\" + preserveAspectRatio + \"' style='filter: url(%23b);' href='\" + blurDataURL + \"'/%3E%3C/svg%3E\";\n} //# sourceMappingURL=image-blur-svg.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1ibHVyLXN2Zy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQzs7OzttREFDZUE7OztlQUFBQTs7O0FBQVQsU0FBU0EsZ0JBQWdCLEtBYy9CO0lBZCtCLE1BQzlCQyxRQUFRLEVBQ1JDLFNBQVMsRUFDVEMsU0FBUyxFQUNUQyxVQUFVLEVBQ1ZDLFdBQVcsRUFDWEMsU0FBUyxFQVFWLEdBZCtCO0lBZTlCLE1BQU1DLE1BQU07SUFDWixNQUFNQyxXQUFXTCxZQUFZQSxZQUFZLEtBQUtGO0lBQzlDLE1BQU1RLFlBQVlMLGFBQWFBLGFBQWEsS0FBS0Y7SUFFakQsTUFBTVEsVUFDSkYsWUFBWUMsWUFBYSxrQkFBZUQsV0FBUyxNQUFHQyxZQUFVLE1BQUs7SUFDckUsTUFBTUUsc0JBQXNCRCxVQUN4QixTQUNBSixjQUFjLFlBQ1osYUFDQUEsY0FBYyxVQUNaLG1CQUNBO0lBRVIsT0FBUSwrQ0FBNENJLFVBQVEsOEZBQTJGSCxNQUFJLG9RQUFpUUEsTUFBSSxnR0FBNkZJLHNCQUFvQix3Q0FBcUNOLGNBQVk7QUFDcGtCIiwic291cmNlcyI6WyIvVXNlcnMvc3JjL3NoYXJlZC9saWIvaW1hZ2UtYmx1ci1zdmcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIHNoYXJlZCBmdW5jdGlvbiwgdXNlZCBvbiBib3RoIGNsaWVudCBhbmQgc2VydmVyLCB0byBnZW5lcmF0ZSBhIFNWRyBibHVyIHBsYWNlaG9sZGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW1hZ2VCbHVyU3ZnKHtcbiAgd2lkdGhJbnQsXG4gIGhlaWdodEludCxcbiAgYmx1cldpZHRoLFxuICBibHVySGVpZ2h0LFxuICBibHVyRGF0YVVSTCxcbiAgb2JqZWN0Rml0LFxufToge1xuICB3aWR0aEludD86IG51bWJlclxuICBoZWlnaHRJbnQ/OiBudW1iZXJcbiAgYmx1cldpZHRoPzogbnVtYmVyXG4gIGJsdXJIZWlnaHQ/OiBudW1iZXJcbiAgYmx1ckRhdGFVUkw6IHN0cmluZ1xuICBvYmplY3RGaXQ/OiBzdHJpbmdcbn0pOiBzdHJpbmcge1xuICBjb25zdCBzdGQgPSAyMFxuICBjb25zdCBzdmdXaWR0aCA9IGJsdXJXaWR0aCA/IGJsdXJXaWR0aCAqIDQwIDogd2lkdGhJbnRcbiAgY29uc3Qgc3ZnSGVpZ2h0ID0gYmx1ckhlaWdodCA/IGJsdXJIZWlnaHQgKiA0MCA6IGhlaWdodEludFxuXG4gIGNvbnN0IHZpZXdCb3ggPVxuICAgIHN2Z1dpZHRoICYmIHN2Z0hlaWdodCA/IGB2aWV3Qm94PScwIDAgJHtzdmdXaWR0aH0gJHtzdmdIZWlnaHR9J2AgOiAnJ1xuICBjb25zdCBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gdmlld0JveFxuICAgID8gJ25vbmUnXG4gICAgOiBvYmplY3RGaXQgPT09ICdjb250YWluJ1xuICAgICAgPyAneE1pZFlNaWQnXG4gICAgICA6IG9iamVjdEZpdCA9PT0gJ2NvdmVyJ1xuICAgICAgICA/ICd4TWlkWU1pZCBzbGljZSdcbiAgICAgICAgOiAnbm9uZSdcblxuICByZXR1cm4gYCUzQ3N2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnICR7dmlld0JveH0lM0UlM0NmaWx0ZXIgaWQ9J2InIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0nc1JHQiclM0UlM0NmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249JyR7c3RkfScvJTNFJTNDZmVDb2xvck1hdHJpeCB2YWx1ZXM9JzEgMCAwIDAgMCAwIDEgMCAwIDAgMCAwIDEgMCAwIDAgMCAwIDEwMCAtMScgcmVzdWx0PSdzJy8lM0UlM0NmZUZsb29kIHg9JzAnIHk9JzAnIHdpZHRoPScxMDAlMjUnIGhlaWdodD0nMTAwJTI1Jy8lM0UlM0NmZUNvbXBvc2l0ZSBvcGVyYXRvcj0nb3V0JyBpbj0ncycvJTNFJTNDZmVDb21wb3NpdGUgaW4yPSdTb3VyY2VHcmFwaGljJy8lM0UlM0NmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249JyR7c3RkfScvJTNFJTNDL2ZpbHRlciUzRSUzQ2ltYWdlIHdpZHRoPScxMDAlMjUnIGhlaWdodD0nMTAwJTI1JyB4PScwJyB5PScwJyBwcmVzZXJ2ZUFzcGVjdFJhdGlvPScke3ByZXNlcnZlQXNwZWN0UmF0aW99JyBzdHlsZT0nZmlsdGVyOiB1cmwoJTIzYik7JyBocmVmPScke2JsdXJEYXRhVVJMfScvJTNFJTNDL3N2ZyUzRWBcbn1cbiJdLCJuYW1lcyI6WyJnZXRJbWFnZUJsdXJTdmciLCJ3aWR0aEludCIsImhlaWdodEludCIsImJsdXJXaWR0aCIsImJsdXJIZWlnaHQiLCJibHVyRGF0YVVSTCIsIm9iamVjdEZpdCIsInN0ZCIsInN2Z1dpZHRoIiwic3ZnSGVpZ2h0Iiwidmlld0JveCIsInByZXNlcnZlQXNwZWN0UmF0aW8iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ImageConfigContext\", ({\n    enumerable: true,\n    get: function() {\n        return ImageConfigContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst ImageConfigContext = _react.default.createContext(_imageconfig.imageConfigDefault);\nif (true) {\n    ImageConfigContext.displayName = 'ImageConfigContext';\n} //# sourceMappingURL=image-config-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O3NEQUlhQTs7O2VBQUFBOzs7OzRFQUpLO3lDQUVpQjtBQUU1QixNQUFNQSxxQkFDWEMsT0FBQUEsT0FBSyxDQUFDQyxhQUFhLENBQXNCQyxhQUFBQSxrQkFBa0I7QUFFN0QsSUFGUUQsSUFFZ0IsRUFBbUI7SUFDekNGLG1CQUFtQk8sV0FBVyxHQUFHO0FBQ25DIiwic291cmNlcyI6WyIvVXNlcnMvc3JjL3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHR5cGUgeyBJbWFnZUNvbmZpZ0NvbXBsZXRlIH0gZnJvbSAnLi9pbWFnZS1jb25maWcnXG5pbXBvcnQgeyBpbWFnZUNvbmZpZ0RlZmF1bHQgfSBmcm9tICcuL2ltYWdlLWNvbmZpZydcblxuZXhwb3J0IGNvbnN0IEltYWdlQ29uZmlnQ29udGV4dCA9XG4gIFJlYWN0LmNyZWF0ZUNvbnRleHQ8SW1hZ2VDb25maWdDb21wbGV0ZT4oaW1hZ2VDb25maWdEZWZhdWx0KVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBJbWFnZUNvbmZpZ0NvbnRleHQuZGlzcGxheU5hbWUgPSAnSW1hZ2VDb25maWdDb250ZXh0J1xufVxuIl0sIm5hbWVzIjpbIkltYWdlQ29uZmlnQ29udGV4dCIsIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsImltYWdlQ29uZmlnRGVmYXVsdCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImRpc3BsYXlOYW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    VALID_LOADERS: function() {\n        return VALID_LOADERS;\n    },\n    imageConfigDefault: function() {\n        return imageConfigDefault;\n    }\n});\nconst VALID_LOADERS = [\n    'default',\n    'imgix',\n    'cloudinary',\n    'akamai',\n    'custom'\n];\nconst imageConfigDefault = {\n    deviceSizes: [\n        640,\n        750,\n        828,\n        1080,\n        1200,\n        1920,\n        2048,\n        3840\n    ],\n    imageSizes: [\n        16,\n        32,\n        48,\n        64,\n        96,\n        128,\n        256,\n        384\n    ],\n    path: '/_next/image',\n    loader: 'default',\n    loaderFile: '',\n    domains: [],\n    disableStaticImages: false,\n    minimumCacheTTL: 60,\n    formats: [\n        'image/webp'\n    ],\n    dangerouslyAllowSVG: false,\n    contentSecurityPolicy: \"script-src 'none'; frame-src 'none'; sandbox;\",\n    contentDispositionType: 'attachment',\n    localPatterns: undefined,\n    remotePatterns: [],\n    qualities: undefined,\n    unoptimized: false\n}; //# sourceMappingURL=image-config.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBQWFBLGFBQWE7ZUFBYkE7O0lBaUlBQyxrQkFBa0I7ZUFBbEJBOzs7QUFqSU4sTUFBTUQsZ0JBQWdCO0lBQzNCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQTJITSxNQUFNQyxxQkFBMEM7SUFDckRDLGFBQWE7UUFBQztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO0tBQUs7SUFDMURDLFlBQVk7UUFBQztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSztRQUFLO0tBQUk7SUFDL0NDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxZQUFZO0lBQ1pDLFNBQVMsRUFBRTtJQUNYQyxxQkFBcUI7SUFDckJDLGlCQUFpQjtJQUNqQkMsU0FBUztRQUFDO0tBQWE7SUFDdkJDLHFCQUFxQjtJQUNyQkMsdUJBQXdCO0lBQ3hCQyx3QkFBd0I7SUFDeEJDLGVBQWVDO0lBQ2ZDLGdCQUFnQixFQUFFO0lBQ2xCQyxXQUFXRjtJQUNYRyxhQUFhO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zcmMvc2hhcmVkL2xpYi9pbWFnZS1jb25maWcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IFZBTElEX0xPQURFUlMgPSBbXG4gICdkZWZhdWx0JyxcbiAgJ2ltZ2l4JyxcbiAgJ2Nsb3VkaW5hcnknLFxuICAnYWthbWFpJyxcbiAgJ2N1c3RvbScsXG5dIGFzIGNvbnN0XG5cbmV4cG9ydCB0eXBlIExvYWRlclZhbHVlID0gKHR5cGVvZiBWQUxJRF9MT0FERVJTKVtudW1iZXJdXG5cbmV4cG9ydCB0eXBlIEltYWdlTG9hZGVyUHJvcHMgPSB7XG4gIHNyYzogc3RyaW5nXG4gIHdpZHRoOiBudW1iZXJcbiAgcXVhbGl0eT86IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBJbWFnZUxvYWRlclByb3BzV2l0aENvbmZpZyA9IEltYWdlTG9hZGVyUHJvcHMgJiB7XG4gIGNvbmZpZzogUmVhZG9ubHk8SW1hZ2VDb25maWc+XG59XG5cbmV4cG9ydCB0eXBlIExvY2FsUGF0dGVybiA9IHtcbiAgLyoqXG4gICAqIENhbiBiZSBsaXRlcmFsIG9yIHdpbGRjYXJkLlxuICAgKiBTaW5nbGUgYCpgIG1hdGNoZXMgYSBzaW5nbGUgcGF0aCBzZWdtZW50LlxuICAgKiBEb3VibGUgYCoqYCBtYXRjaGVzIGFueSBudW1iZXIgb2YgcGF0aCBzZWdtZW50cy5cbiAgICovXG4gIHBhdGhuYW1lPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIENhbiBiZSBsaXRlcmFsIHF1ZXJ5IHN0cmluZyBzdWNoIGFzIGA/dj0xYCBvclxuICAgKiBlbXB0eSBzdHJpbmcgbWVhbmluZyBubyBxdWVyeSBzdHJpbmcuXG4gICAqL1xuICBzZWFyY2g/OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgUmVtb3RlUGF0dGVybiA9IHtcbiAgLyoqXG4gICAqIE11c3QgYmUgYGh0dHBgIG9yIGBodHRwc2AuXG4gICAqL1xuICBwcm90b2NvbD86ICdodHRwJyB8ICdodHRwcydcblxuICAvKipcbiAgICogQ2FuIGJlIGxpdGVyYWwgb3Igd2lsZGNhcmQuXG4gICAqIFNpbmdsZSBgKmAgbWF0Y2hlcyBhIHNpbmdsZSBzdWJkb21haW4uXG4gICAqIERvdWJsZSBgKipgIG1hdGNoZXMgYW55IG51bWJlciBvZiBzdWJkb21haW5zLlxuICAgKi9cbiAgaG9zdG5hbWU6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBDYW4gYmUgbGl0ZXJhbCBwb3J0IHN1Y2ggYXMgYDgwODBgIG9yIGVtcHR5IHN0cmluZ1xuICAgKiBtZWFuaW5nIG5vIHBvcnQuXG4gICAqL1xuICBwb3J0Pzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIENhbiBiZSBsaXRlcmFsIG9yIHdpbGRjYXJkLlxuICAgKiBTaW5nbGUgYCpgIG1hdGNoZXMgYSBzaW5nbGUgcGF0aCBzZWdtZW50LlxuICAgKiBEb3VibGUgYCoqYCBtYXRjaGVzIGFueSBudW1iZXIgb2YgcGF0aCBzZWdtZW50cy5cbiAgICovXG4gIHBhdGhuYW1lPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIENhbiBiZSBsaXRlcmFsIHF1ZXJ5IHN0cmluZyBzdWNoIGFzIGA/dj0xYCBvclxuICAgKiBlbXB0eSBzdHJpbmcgbWVhbmluZyBubyBxdWVyeSBzdHJpbmcuXG4gICAqL1xuICBzZWFyY2g/OiBzdHJpbmdcbn1cblxudHlwZSBJbWFnZUZvcm1hdCA9ICdpbWFnZS9hdmlmJyB8ICdpbWFnZS93ZWJwJ1xuXG4vKipcbiAqIEltYWdlIGNvbmZpZ3VyYXRpb25zXG4gKlxuICogQHNlZSBbSW1hZ2UgY29uZmlndXJhdGlvbiBvcHRpb25zXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2UjY29uZmlndXJhdGlvbi1vcHRpb25zKVxuICovXG5leHBvcnQgdHlwZSBJbWFnZUNvbmZpZ0NvbXBsZXRlID0ge1xuICAvKiogQHNlZSBbRGV2aWNlIHNpemVzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNkZXZpY2Utc2l6ZXMpICovXG4gIGRldmljZVNpemVzOiBudW1iZXJbXVxuXG4gIC8qKiBAc2VlIFtJbWFnZSBzaXppbmcgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vb3B0aW1pemluZy9pbWFnZXMjaW1hZ2Utc2l6aW5nKSAqL1xuICBpbWFnZVNpemVzOiBudW1iZXJbXVxuXG4gIC8qKiBAc2VlIFtJbWFnZSBsb2FkZXJzIGNvbmZpZ3VyYXRpb25dKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9sZWdhY3kvaW1hZ2UjbG9hZGVyKSAqL1xuICBsb2FkZXI6IExvYWRlclZhbHVlXG5cbiAgLyoqIEBzZWUgW0ltYWdlIGxvYWRlciBjb25maWd1cmF0aW9uXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2ltYWdlI3BhdGgpICovXG4gIHBhdGg6IHN0cmluZ1xuXG4gIC8qKiBAc2VlIFtJbWFnZSBsb2FkZXIgY29uZmlndXJhdGlvbl0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI2xvYWRlci1jb25maWd1cmF0aW9uKSAqL1xuICBsb2FkZXJGaWxlOiBzdHJpbmdcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGByZW1vdGVQYXR0ZXJuc2AgaW5zdGVhZC5cbiAgICovXG4gIGRvbWFpbnM6IHN0cmluZ1tdXG5cbiAgLyoqIEBzZWUgW0Rpc2FibGUgc3RhdGljIGltYWdlIGltcG9ydCBjb25maWd1cmF0aW9uXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2UjZGlzYWJsZS1zdGF0aWMtaW1wb3J0cykgKi9cbiAgZGlzYWJsZVN0YXRpY0ltYWdlczogYm9vbGVhblxuXG4gIC8qKiBAc2VlIFtDYWNoZSBiZWhhdmlvcl0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI2NhY2hpbmctYmVoYXZpb3IpICovXG4gIG1pbmltdW1DYWNoZVRUTDogbnVtYmVyXG5cbiAgLyoqIEBzZWUgW0FjY2VwdGFibGUgZm9ybWF0c10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI2FjY2VwdGFibGUtZm9ybWF0cykgKi9cbiAgZm9ybWF0czogSW1hZ2VGb3JtYXRbXVxuXG4gIC8qKiBAc2VlIFtEYW5nZXJvdXNseSBBbGxvdyBTVkddKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNkYW5nZXJvdXNseS1hbGxvdy1zdmcpICovXG4gIGRhbmdlcm91c2x5QWxsb3dTVkc6IGJvb2xlYW5cblxuICAvKiogQHNlZSBbQ29udGVudCBTZWN1cml0eSBQb2xpY3ldKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNjb250ZW50c2VjdXJpdHlwb2xpY3kpICovXG4gIGNvbnRlbnRTZWN1cml0eVBvbGljeTogc3RyaW5nXG5cbiAgLyoqIEBzZWUgW0NvbnRlbnQgRGlzcG9zaXRpb24gVHlwZV0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI2NvbnRlbnRkaXNwb3NpdGlvbnR5cGUpICovXG4gIGNvbnRlbnREaXNwb3NpdGlvblR5cGU6ICdpbmxpbmUnIHwgJ2F0dGFjaG1lbnQnXG5cbiAgLyoqIEBzZWUgW1JlbW90ZSBQYXR0ZXJuc10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI3JlbW90ZXBhdHRlcm5zKSAqL1xuICByZW1vdGVQYXR0ZXJuczogQXJyYXk8VVJMIHwgUmVtb3RlUGF0dGVybj5cblxuICAvKiogQHNlZSBbTG9jYWwgUGF0dGVybnNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNsb2NhbFBhdHRlcm5zKSAqL1xuICBsb2NhbFBhdHRlcm5zOiBMb2NhbFBhdHRlcm5bXSB8IHVuZGVmaW5lZFxuXG4gIC8qKiBAc2VlIFtRdWFsaXRpZXNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNxdWFsaXRpZXMpICovXG4gIHF1YWxpdGllczogbnVtYmVyW10gfCB1bmRlZmluZWRcblxuICAvKiogQHNlZSBbVW5vcHRpbWl6ZWRdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSN1bm9wdGltaXplZCkgKi9cbiAgdW5vcHRpbWl6ZWQ6IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgSW1hZ2VDb25maWcgPSBQYXJ0aWFsPEltYWdlQ29uZmlnQ29tcGxldGU+XG5cbmV4cG9ydCBjb25zdCBpbWFnZUNvbmZpZ0RlZmF1bHQ6IEltYWdlQ29uZmlnQ29tcGxldGUgPSB7XG4gIGRldmljZVNpemVzOiBbNjQwLCA3NTAsIDgyOCwgMTA4MCwgMTIwMCwgMTkyMCwgMjA0OCwgMzg0MF0sXG4gIGltYWdlU2l6ZXM6IFsxNiwgMzIsIDQ4LCA2NCwgOTYsIDEyOCwgMjU2LCAzODRdLFxuICBwYXRoOiAnL19uZXh0L2ltYWdlJyxcbiAgbG9hZGVyOiAnZGVmYXVsdCcsXG4gIGxvYWRlckZpbGU6ICcnLFxuICBkb21haW5zOiBbXSxcbiAgZGlzYWJsZVN0YXRpY0ltYWdlczogZmFsc2UsXG4gIG1pbmltdW1DYWNoZVRUTDogNjAsXG4gIGZvcm1hdHM6IFsnaW1hZ2Uvd2VicCddLFxuICBkYW5nZXJvdXNseUFsbG93U1ZHOiBmYWxzZSxcbiAgY29udGVudFNlY3VyaXR5UG9saWN5OiBgc2NyaXB0LXNyYyAnbm9uZSc7IGZyYW1lLXNyYyAnbm9uZSc7IHNhbmRib3g7YCxcbiAgY29udGVudERpc3Bvc2l0aW9uVHlwZTogJ2F0dGFjaG1lbnQnLFxuICBsb2NhbFBhdHRlcm5zOiB1bmRlZmluZWQsIC8vIGRlZmF1bHQ6IGFsbG93IGFsbCBsb2NhbCBpbWFnZXNcbiAgcmVtb3RlUGF0dGVybnM6IFtdLCAvLyBkZWZhdWx0OiBhbGxvdyBubyByZW1vdGUgaW1hZ2VzXG4gIHF1YWxpdGllczogdW5kZWZpbmVkLCAvLyBkZWZhdWx0OiBhbGxvdyBhbGwgcXVhbGl0aWVzXG4gIHVub3B0aW1pemVkOiBmYWxzZSxcbn1cbiJdLCJuYW1lcyI6WyJWQUxJRF9MT0FERVJTIiwiaW1hZ2VDb25maWdEZWZhdWx0IiwiZGV2aWNlU2l6ZXMiLCJpbWFnZVNpemVzIiwicGF0aCIsImxvYWRlciIsImxvYWRlckZpbGUiLCJkb21haW5zIiwiZGlzYWJsZVN0YXRpY0ltYWdlcyIsIm1pbmltdW1DYWNoZVRUTCIsImZvcm1hdHMiLCJkYW5nZXJvdXNseUFsbG93U1ZHIiwiY29udGVudFNlY3VyaXR5UG9saWN5IiwiY29udGVudERpc3Bvc2l0aW9uVHlwZSIsImxvY2FsUGF0dGVybnMiLCJ1bmRlZmluZWQiLCJyZW1vdGVQYXR0ZXJucyIsInF1YWxpdGllcyIsInVub3B0aW1pemVkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-external.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return _default;\n    },\n    getImageProps: function() {\n        return getImageProps;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _getimgprops = __webpack_require__(/*! ./get-img-props */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imagecomponent = __webpack_require__(/*! ../../client/image-component */ \"(app-pages-browser)/./node_modules/next/dist/client/image-component.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\"));\nfunction getImageProps(imgProps) {\n    const { props } = (0, _getimgprops.getImgProps)(imgProps, {\n        defaultLoader: _imageloader.default,\n        // This is replaced by webpack define plugin\n        imgConf: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]}\n    });\n    // Normally we don't care about undefined props because we pass to JSX,\n    // but this exported function could be used by the end user for anything\n    // so we delete undefined props to clean it up a little.\n    for (const [key, value] of Object.entries(props)){\n        if (value === undefined) {\n            delete props[key];\n        }\n    }\n    return {\n        props\n    };\n}\nconst _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFpQ0EsT0FBb0I7ZUFBcEI7O0lBakJnQkEsYUFBYTtlQUFiQTs7Ozt5Q0FiWTs0Q0FDTjtrRkFHSTtBQVNuQixTQUFTQSxjQUFjQyxRQUFvQjtJQUNoRCxNQUFNLEVBQUVDLEtBQUssRUFBRSxHQUFHQyxDQUFBQSxHQUFBQSxhQUFBQSxXQUFBQSxFQUFZRixVQUFVO1FBQ3RDRyxlQUFBQSxhQUFBQSxPQUFhO1FBQ2IsNENBQTRDO1FBQzVDQyxTQUFTQywwTkFBNkI7SUFDeEM7SUFDQSx1RUFBdUU7SUFDdkUsd0VBQXdFO0lBQ3hFLHdEQUF3RDtJQUN4RCxLQUFLLE1BQU0sQ0FBQ0csS0FBS0MsTUFBTSxJQUFJQyxPQUFPQyxPQUFPLENBQUNWLE9BQVE7UUFDaEQsSUFBSVEsVUFBVUcsV0FBVztZQUN2QixPQUFPWCxLQUFLLENBQUNPLElBQTBCO1FBQ3pDO0lBQ0Y7SUFDQSxPQUFPO1FBQUVQO0lBQU07QUFDakI7TUFFQSxXQUFlWSxnQkFBQUEsS0FBSyIsInNvdXJjZXMiOlsiL1VzZXJzL3NyYy9zaGFyZWQvbGliL2ltYWdlLWV4dGVybmFsLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEltYWdlQ29uZmlnQ29tcGxldGUsIEltYWdlTG9hZGVyUHJvcHMgfSBmcm9tICcuL2ltYWdlLWNvbmZpZydcbmltcG9ydCB0eXBlIHsgSW1hZ2VQcm9wcywgSW1hZ2VMb2FkZXIsIFN0YXRpY0ltYWdlRGF0YSB9IGZyb20gJy4vZ2V0LWltZy1wcm9wcydcblxuaW1wb3J0IHsgZ2V0SW1nUHJvcHMgfSBmcm9tICcuL2dldC1pbWctcHJvcHMnXG5pbXBvcnQgeyBJbWFnZSB9IGZyb20gJy4uLy4uL2NsaWVudC9pbWFnZS1jb21wb25lbnQnXG5cbi8vIFRoaXMgaXMgcmVwbGFjZWQgYnkgd2VicGFjayBhbGlhc1xuaW1wb3J0IGRlZmF1bHRMb2FkZXIgZnJvbSAnbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtbG9hZGVyJ1xuXG4vKipcbiAqIEZvciBtb3JlIGFkdmFuY2VkIHVzZSBjYXNlcywgeW91IGNhbiBjYWxsIGBnZXRJbWFnZVByb3BzKClgXG4gKiB0byBnZXQgdGhlIHByb3BzIHRoYXQgd291bGQgYmUgcGFzc2VkIHRvIHRoZSB1bmRlcmx5aW5nIGA8aW1nPmAgZWxlbWVudCxcbiAqIGFuZCBpbnN0ZWFkIHBhc3MgdG8gdGhlbSB0byBhbm90aGVyIGNvbXBvbmVudCwgc3R5bGUsIGNhbnZhcywgZXRjLlxuICpcbiAqIFJlYWQgbW9yZTogW05leHQuanMgZG9jczogYGdldEltYWdlUHJvcHNgXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2ltYWdlI2dldGltYWdlcHJvcHMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbWFnZVByb3BzKGltZ1Byb3BzOiBJbWFnZVByb3BzKSB7XG4gIGNvbnN0IHsgcHJvcHMgfSA9IGdldEltZ1Byb3BzKGltZ1Byb3BzLCB7XG4gICAgZGVmYXVsdExvYWRlcixcbiAgICAvLyBUaGlzIGlzIHJlcGxhY2VkIGJ5IHdlYnBhY2sgZGVmaW5lIHBsdWdpblxuICAgIGltZ0NvbmY6IHByb2Nlc3MuZW52Ll9fTkVYVF9JTUFHRV9PUFRTIGFzIGFueSBhcyBJbWFnZUNvbmZpZ0NvbXBsZXRlLFxuICB9KVxuICAvLyBOb3JtYWxseSB3ZSBkb24ndCBjYXJlIGFib3V0IHVuZGVmaW5lZCBwcm9wcyBiZWNhdXNlIHdlIHBhc3MgdG8gSlNYLFxuICAvLyBidXQgdGhpcyBleHBvcnRlZCBmdW5jdGlvbiBjb3VsZCBiZSB1c2VkIGJ5IHRoZSBlbmQgdXNlciBmb3IgYW55dGhpbmdcbiAgLy8gc28gd2UgZGVsZXRlIHVuZGVmaW5lZCBwcm9wcyB0byBjbGVhbiBpdCB1cCBhIGxpdHRsZS5cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlbGV0ZSBwcm9wc1trZXkgYXMga2V5b2YgdHlwZW9mIHByb3BzXVxuICAgIH1cbiAgfVxuICByZXR1cm4geyBwcm9wcyB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEltYWdlXG5cbmV4cG9ydCB0eXBlIHsgSW1hZ2VQcm9wcywgSW1hZ2VMb2FkZXJQcm9wcywgSW1hZ2VMb2FkZXIsIFN0YXRpY0ltYWdlRGF0YSB9XG4iXSwibmFtZXMiOlsiZ2V0SW1hZ2VQcm9wcyIsImltZ1Byb3BzIiwicHJvcHMiLCJnZXRJbWdQcm9wcyIsImRlZmF1bHRMb2FkZXIiLCJpbWdDb25mIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JTUFHRV9PUFRTIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwidW5kZWZpbmVkIiwiSW1hZ2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-loader.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nconst DEFAULT_Q = 75;\nfunction defaultLoader(param) {\n    let { config, src, width, quality } = param;\n    var _config_qualities;\n    if (true) {\n        const missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push('src');\n        if (!width) missingValues.push('width');\n        if (missingValues.length > 0) {\n            throw Object.defineProperty(new Error(\"Next Image Optimization requires \" + missingValues.join(', ') + \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \" + JSON.stringify({\n                src,\n                width,\n                quality\n            })), \"__NEXT_ERROR_CODE\", {\n                value: \"E188\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (src.startsWith('//')) {\n            throw Object.defineProperty(new Error('Failed to parse src \"' + src + '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)'), \"__NEXT_ERROR_CODE\", {\n                value: \"E360\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (src.startsWith('/') && config.localPatterns) {\n            if (true) {\n                // We use dynamic require because this should only error in development\n                const { hasLocalMatch } = __webpack_require__(/*! ./match-local-pattern */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/match-local-pattern.js\");\n                if (!hasLocalMatch(config.localPatterns, src)) {\n                    throw Object.defineProperty(new Error(\"Invalid src prop (\" + src + \") on `next/image` does not match `images.localPatterns` configured in your `next.config.js`\\n\" + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-localpatterns\"), \"__NEXT_ERROR_CODE\", {\n                        value: \"E426\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n        }\n        if (!src.startsWith('/') && (config.domains || config.remotePatterns)) {\n            let parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw Object.defineProperty(new Error('Failed to parse src \"' + src + '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E63\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (true) {\n                // We use dynamic require because this should only error in development\n                const { hasRemoteMatch } = __webpack_require__(/*! ./match-remote-pattern */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\");\n                if (!hasRemoteMatch(config.domains, config.remotePatterns, parsedSrc)) {\n                    throw Object.defineProperty(new Error(\"Invalid src prop (\" + src + ') on `next/image`, hostname \"' + parsedSrc.hostname + '\" is not configured under images in your `next.config.js`\\n' + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\"), \"__NEXT_ERROR_CODE\", {\n                        value: \"E231\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n        }\n        if (quality && config.qualities && !config.qualities.includes(quality)) {\n            throw Object.defineProperty(new Error(\"Invalid quality prop (\" + quality + \") on `next/image` does not match `images.qualities` configured in your `next.config.js`\\n\" + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-qualities\"), \"__NEXT_ERROR_CODE\", {\n                value: \"E623\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    const q = quality || ((_config_qualities = config.qualities) == null ? void 0 : _config_qualities.reduce((prev, cur)=>Math.abs(cur - DEFAULT_Q) < Math.abs(prev - DEFAULT_Q) ? cur : prev)) || DEFAULT_Q;\n    return config.path + \"?url=\" + encodeURIComponent(src) + \"&w=\" + width + \"&q=\" + q + (src.startsWith('/_next/static/media/') && false ? 0 : '');\n}\n// We use this to determine if the import is the default loader\n// or a custom loader defined by the user in next.config.js\ndefaultLoader.__next_img_default = true;\nconst _default = defaultLoader; //# sourceMappingURL=image-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7OzsyQ0EyR0E7OztlQUFBOzs7QUF6R0EsTUFBTUEsWUFBWTtBQUVsQixTQUFTQyxjQUFjLEtBS007SUFMTixNQUNyQkMsTUFBTSxFQUNOQyxHQUFHLEVBQ0hDLEtBQUssRUFDTEMsT0FBTyxFQUNvQixHQUxOO1FBdUZuQkg7SUFqRkYsSUFBSUksSUFBb0IsRUFBbUI7UUFDekMsTUFBTUcsZ0JBQWdCLEVBQUU7UUFFeEI7UUFDQSxJQUFJLENBQUNOLEtBQUtNLGNBQWNDLElBQUksQ0FBQztRQUM3QixJQUFJLENBQUNOLE9BQU9LLGNBQWNDLElBQUksQ0FBQztRQUUvQixJQUFJRCxjQUFjRSxNQUFNLEdBQUcsR0FBRztZQUM1QixNQUFNLHFCQU1MLENBTkssSUFBSUMsTUFDUCxzQ0FBbUNILGNBQWNJLElBQUksQ0FDcEQsUUFDQSxnR0FBK0ZDLEtBQUtDLFNBQVMsQ0FDN0c7Z0JBQUVaO2dCQUFLQztnQkFBT0M7WUFBUSxLQUpwQjt1QkFBQTs0QkFBQTs4QkFBQTtZQU1OO1FBQ0Y7UUFFQSxJQUFJRixJQUFJYSxVQUFVLENBQUMsT0FBTztZQUN4QixNQUFNLHFCQUVMLENBRkssSUFBSUosTUFDUCwwQkFBdUJULE1BQUksMkdBRHhCO3VCQUFBOzRCQUFBOzhCQUFBO1lBRU47UUFDRjtRQUVBLElBQUlBLElBQUlhLFVBQVUsQ0FBQyxRQUFRZCxPQUFPZSxhQUFhLEVBQUU7WUFDL0MsSUFDRVgsSUFFbUMsRUFDbkM7Z0JBQ0EsdUVBQXVFO2dCQUN2RSxNQUFNLEVBQUVhLGFBQWEsRUFBRSxHQUNyQkMsbUJBQU9BLENBQUMsNkdBQXVCO2dCQUNqQyxJQUFJLENBQUNELGNBQWNqQixPQUFPZSxhQUFhLEVBQUVkLE1BQU07b0JBQzdDLE1BQU0scUJBR0wsQ0FISyxJQUFJUyxNQUNQLHVCQUFvQlQsTUFBSSxrR0FDdEIsMEZBRkM7K0JBQUE7b0NBQUE7c0NBQUE7b0JBR047Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsSUFBSSxDQUFDQSxJQUFJYSxVQUFVLENBQUMsUUFBU2QsQ0FBQUEsT0FBT21CLE9BQU8sSUFBSW5CLE9BQU9vQixjQUFBQSxHQUFpQjtZQUNyRSxJQUFJQztZQUNKLElBQUk7Z0JBQ0ZBLFlBQVksSUFBSUMsSUFBSXJCO1lBQ3RCLEVBQUUsT0FBT3NCLEtBQUs7Z0JBQ1pDLFFBQVFDLEtBQUssQ0FBQ0Y7Z0JBQ2QsTUFBTSxxQkFFTCxDQUZLLElBQUliLE1BQ1AsMEJBQXVCVCxNQUFJLGtJQUR4QjsyQkFBQTtnQ0FBQTtrQ0FBQTtnQkFFTjtZQUNGO1lBRUEsSUFDRUcsSUFFbUMsRUFDbkM7Z0JBQ0EsdUVBQXVFO2dCQUN2RSxNQUFNLEVBQUVzQixjQUFjLEVBQUUsR0FDdEJSLG1CQUFPQSxDQUFDLCtHQUF3QjtnQkFDbEMsSUFDRSxDQUFDUSxlQUFlMUIsT0FBT21CLE9BQU8sRUFBR25CLE9BQU9vQixjQUFjLEVBQUdDLFlBQ3pEO29CQUNBLE1BQU0scUJBR0wsQ0FISyxJQUFJWCxNQUNQLHVCQUFvQlQsTUFBSSxrQ0FBaUNvQixVQUFVTSxRQUFRLEdBQUMsZ0VBQzFFLGlGQUZDOytCQUFBO29DQUFBO3NDQUFBO29CQUdOO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLElBQUl4QixXQUFXSCxPQUFPNEIsU0FBUyxJQUFJLENBQUM1QixPQUFPNEIsU0FBUyxDQUFDQyxRQUFRLENBQUMxQixVQUFVO1lBQ3RFLE1BQU0scUJBR0wsQ0FISyxJQUFJTyxNQUNQLDJCQUF3QlAsVUFBUSw4RkFDOUIsc0ZBRkM7dUJBQUE7NEJBQUE7OEJBQUE7WUFHTjtRQUNGO0lBQ0Y7SUFFQSxNQUFNMkIsSUFDSjNCLFdBQUFBLENBQUFBLENBQ0FILG9CQUFBQSxPQUFPNEIsU0FBQUEsS0FBUyxnQkFBaEI1QixrQkFBa0IrQixNQUFNLENBQUMsQ0FBQ0MsTUFBTUMsTUFDOUJDLEtBQUtDLEdBQUcsQ0FBQ0YsTUFBTW5DLGFBQWFvQyxLQUFLQyxHQUFHLENBQUNILE9BQU9sQyxhQUFhbUMsTUFBTUQsS0FBQUEsS0FFakVsQztJQUVGLE9BQVVFLE9BQU9vQyxJQUFJLEdBQUMsVUFBT0MsbUJBQW1CcEMsT0FBSyxRQUFLQyxRQUFNLFFBQUs0QixJQUNuRTdCLENBQUFBLElBQUlhLFVBQVUsQ0FBQywyQkFBMkJWLEtBQThCLEdBQ25FLENBQXFDLEdBQ3RDLEdBQUM7QUFFVDtBQUVBLCtEQUErRDtBQUMvRCwyREFBMkQ7QUFDM0RMLGNBQWN3QyxrQkFBa0IsR0FBRztNQUVuQyxXQUFleEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zcmMvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBJbWFnZUxvYWRlclByb3BzV2l0aENvbmZpZyB9IGZyb20gJy4vaW1hZ2UtY29uZmlnJ1xuXG5jb25zdCBERUZBVUxUX1EgPSA3NVxuXG5mdW5jdGlvbiBkZWZhdWx0TG9hZGVyKHtcbiAgY29uZmlnLFxuICBzcmMsXG4gIHdpZHRoLFxuICBxdWFsaXR5LFxufTogSW1hZ2VMb2FkZXJQcm9wc1dpdGhDb25maWcpOiBzdHJpbmcge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IG1pc3NpbmdWYWx1ZXMgPSBbXVxuXG4gICAgLy8gdGhlc2Ugc2hvdWxkIGFsd2F5cyBiZSBwcm92aWRlZCBidXQgbWFrZSBzdXJlIHRoZXkgYXJlXG4gICAgaWYgKCFzcmMpIG1pc3NpbmdWYWx1ZXMucHVzaCgnc3JjJylcbiAgICBpZiAoIXdpZHRoKSBtaXNzaW5nVmFsdWVzLnB1c2goJ3dpZHRoJylcblxuICAgIGlmIChtaXNzaW5nVmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYE5leHQgSW1hZ2UgT3B0aW1pemF0aW9uIHJlcXVpcmVzICR7bWlzc2luZ1ZhbHVlcy5qb2luKFxuICAgICAgICAgICcsICdcbiAgICAgICAgKX0gdG8gYmUgcHJvdmlkZWQuIE1ha2Ugc3VyZSB5b3UgcGFzcyB0aGVtIGFzIHByb3BzIHRvIHRoZSBcXGBuZXh0L2ltYWdlXFxgIGNvbXBvbmVudC4gUmVjZWl2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgeyBzcmMsIHdpZHRoLCBxdWFsaXR5IH1cbiAgICAgICAgKX1gXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHNyYy5zdGFydHNXaXRoKCcvLycpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gcGFyc2Ugc3JjIFwiJHtzcmN9XCIgb24gXFxgbmV4dC9pbWFnZVxcYCwgcHJvdG9jb2wtcmVsYXRpdmUgVVJMICgvLykgbXVzdCBiZSBjaGFuZ2VkIHRvIGFuIGFic29sdXRlIFVSTCAoaHR0cDovLyBvciBodHRwczovLylgXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHNyYy5zdGFydHNXaXRoKCcvJykgJiYgY29uZmlnLmxvY2FsUGF0dGVybnMpIHtcbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgICAvLyBtaWNyb21hdGNoIGlzbid0IGNvbXBhdGlibGUgd2l0aCBlZGdlIHJ1bnRpbWVcbiAgICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FICE9PSAnZWRnZSdcbiAgICAgICkge1xuICAgICAgICAvLyBXZSB1c2UgZHluYW1pYyByZXF1aXJlIGJlY2F1c2UgdGhpcyBzaG91bGQgb25seSBlcnJvciBpbiBkZXZlbG9wbWVudFxuICAgICAgICBjb25zdCB7IGhhc0xvY2FsTWF0Y2ggfSA9XG4gICAgICAgICAgcmVxdWlyZSgnLi9tYXRjaC1sb2NhbC1wYXR0ZXJuJykgYXMgdHlwZW9mIGltcG9ydCgnLi9tYXRjaC1sb2NhbC1wYXR0ZXJuJylcbiAgICAgICAgaWYgKCFoYXNMb2NhbE1hdGNoKGNvbmZpZy5sb2NhbFBhdHRlcm5zLCBzcmMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEludmFsaWQgc3JjIHByb3AgKCR7c3JjfSkgb24gXFxgbmV4dC9pbWFnZVxcYCBkb2VzIG5vdCBtYXRjaCBcXGBpbWFnZXMubG9jYWxQYXR0ZXJuc1xcYCBjb25maWd1cmVkIGluIHlvdXIgXFxgbmV4dC5jb25maWcuanNcXGBcXG5gICtcbiAgICAgICAgICAgICAgYFNlZSBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtdW5jb25maWd1cmVkLWxvY2FscGF0dGVybnNgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzcmMuc3RhcnRzV2l0aCgnLycpICYmIChjb25maWcuZG9tYWlucyB8fCBjb25maWcucmVtb3RlUGF0dGVybnMpKSB7XG4gICAgICBsZXQgcGFyc2VkU3JjOiBVUkxcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZFNyYyA9IG5ldyBVUkwoc3JjKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZhaWxlZCB0byBwYXJzZSBzcmMgXCIke3NyY31cIiBvbiBcXGBuZXh0L2ltYWdlXFxgLCBpZiB1c2luZyByZWxhdGl2ZSBpbWFnZSBpdCBtdXN0IHN0YXJ0IHdpdGggYSBsZWFkaW5nIHNsYXNoIFwiL1wiIG9yIGJlIGFuIGFic29sdXRlIFVSTCAoaHR0cDovLyBvciBodHRwczovLylgXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmXG4gICAgICAgIC8vIG1pY3JvbWF0Y2ggaXNuJ3QgY29tcGF0aWJsZSB3aXRoIGVkZ2UgcnVudGltZVxuICAgICAgICBwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgIT09ICdlZGdlJ1xuICAgICAgKSB7XG4gICAgICAgIC8vIFdlIHVzZSBkeW5hbWljIHJlcXVpcmUgYmVjYXVzZSB0aGlzIHNob3VsZCBvbmx5IGVycm9yIGluIGRldmVsb3BtZW50XG4gICAgICAgIGNvbnN0IHsgaGFzUmVtb3RlTWF0Y2ggfSA9XG4gICAgICAgICAgcmVxdWlyZSgnLi9tYXRjaC1yZW1vdGUtcGF0dGVybicpIGFzIHR5cGVvZiBpbXBvcnQoJy4vbWF0Y2gtcmVtb3RlLXBhdHRlcm4nKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWhhc1JlbW90ZU1hdGNoKGNvbmZpZy5kb21haW5zISwgY29uZmlnLnJlbW90ZVBhdHRlcm5zISwgcGFyc2VkU3JjKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW52YWxpZCBzcmMgcHJvcCAoJHtzcmN9KSBvbiBcXGBuZXh0L2ltYWdlXFxgLCBob3N0bmFtZSBcIiR7cGFyc2VkU3JjLmhvc3RuYW1lfVwiIGlzIG5vdCBjb25maWd1cmVkIHVuZGVyIGltYWdlcyBpbiB5b3VyIFxcYG5leHQuY29uZmlnLmpzXFxgXFxuYCArXG4gICAgICAgICAgICAgIGBTZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVuY29uZmlndXJlZC1ob3N0YFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChxdWFsaXR5ICYmIGNvbmZpZy5xdWFsaXRpZXMgJiYgIWNvbmZpZy5xdWFsaXRpZXMuaW5jbHVkZXMocXVhbGl0eSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgcXVhbGl0eSBwcm9wICgke3F1YWxpdHl9KSBvbiBcXGBuZXh0L2ltYWdlXFxgIGRvZXMgbm90IG1hdGNoIFxcYGltYWdlcy5xdWFsaXRpZXNcXGAgY29uZmlndXJlZCBpbiB5b3VyIFxcYG5leHQuY29uZmlnLmpzXFxgXFxuYCArXG4gICAgICAgICAgYFNlZSBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtdW5jb25maWd1cmVkLXF1YWxpdGllc2BcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBjb25zdCBxID1cbiAgICBxdWFsaXR5IHx8XG4gICAgY29uZmlnLnF1YWxpdGllcz8ucmVkdWNlKChwcmV2LCBjdXIpID0+XG4gICAgICBNYXRoLmFicyhjdXIgLSBERUZBVUxUX1EpIDwgTWF0aC5hYnMocHJldiAtIERFRkFVTFRfUSkgPyBjdXIgOiBwcmV2XG4gICAgKSB8fFxuICAgIERFRkFVTFRfUVxuXG4gIHJldHVybiBgJHtjb25maWcucGF0aH0/dXJsPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHNyYyl9Jnc9JHt3aWR0aH0mcT0ke3F9JHtcbiAgICBzcmMuc3RhcnRzV2l0aCgnL19uZXh0L3N0YXRpYy9tZWRpYS8nKSAmJiBwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSURcbiAgICAgID8gYCZkcGw9JHtwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSUR9YFxuICAgICAgOiAnJ1xuICB9YFxufVxuXG4vLyBXZSB1c2UgdGhpcyB0byBkZXRlcm1pbmUgaWYgdGhlIGltcG9ydCBpcyB0aGUgZGVmYXVsdCBsb2FkZXJcbi8vIG9yIGEgY3VzdG9tIGxvYWRlciBkZWZpbmVkIGJ5IHRoZSB1c2VyIGluIG5leHQuY29uZmlnLmpzXG5kZWZhdWx0TG9hZGVyLl9fbmV4dF9pbWdfZGVmYXVsdCA9IHRydWVcblxuZXhwb3J0IGRlZmF1bHQgZGVmYXVsdExvYWRlclxuIl0sIm5hbWVzIjpbIkRFRkFVTFRfUSIsImRlZmF1bHRMb2FkZXIiLCJjb25maWciLCJzcmMiLCJ3aWR0aCIsInF1YWxpdHkiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJtaXNzaW5nVmFsdWVzIiwicHVzaCIsImxlbmd0aCIsIkVycm9yIiwiam9pbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdGFydHNXaXRoIiwibG9jYWxQYXR0ZXJucyIsIk5FWFRfUlVOVElNRSIsImhhc0xvY2FsTWF0Y2giLCJyZXF1aXJlIiwiZG9tYWlucyIsInJlbW90ZVBhdHRlcm5zIiwicGFyc2VkU3JjIiwiVVJMIiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwiaGFzUmVtb3RlTWF0Y2giLCJob3N0bmFtZSIsInF1YWxpdGllcyIsImluY2x1ZGVzIiwicSIsInJlZHVjZSIsInByZXYiLCJjdXIiLCJNYXRoIiwiYWJzIiwicGF0aCIsImVuY29kZVVSSUNvbXBvbmVudCIsIk5FWFRfREVQTE9ZTUVOVF9JRCIsIl9fbmV4dF9pbWdfZGVmYXVsdCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/match-local-pattern.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-local-pattern.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    hasLocalMatch: function() {\n        return hasLocalMatch;\n    },\n    matchLocalPattern: function() {\n        return matchLocalPattern;\n    }\n});\nconst _picomatch = __webpack_require__(/*! next/dist/compiled/picomatch */ \"(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js\");\nfunction matchLocalPattern(pattern, url) {\n    if (pattern.search !== undefined) {\n        if (pattern.search !== url.search) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : '**', {\n        dot: true\n    }).test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasLocalMatch(localPatterns, urlPathAndQuery) {\n    if (!localPatterns) {\n        // if the user didn't define \"localPatterns\", we allow all local images\n        return true;\n    }\n    const url = new URL(urlPathAndQuery, 'http://n');\n    return localPatterns.some((p)=>matchLocalPattern(p, url));\n} //# sourceMappingURL=match-local-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9tYXRjaC1sb2NhbC1wYXR0ZXJuLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQWtCZ0JBLGFBQWE7ZUFBYkE7O0lBZEFDLGlCQUFpQjtlQUFqQkE7Ozt1Q0FITztBQUdoQixTQUFTQSxrQkFBa0JDLE9BQXFCLEVBQUVDLEdBQVE7SUFDL0QsSUFBSUQsUUFBUUUsTUFBTSxLQUFLQyxXQUFXO1FBQ2hDLElBQUlILFFBQVFFLE1BQU0sS0FBS0QsSUFBSUMsTUFBTSxFQUFFO1lBQ2pDLE9BQU87UUFDVDtJQUNGO1FBRVlGO0lBQVosSUFBSSxDQUFDSSxDQUFBQSxHQUFBQSxXQUFBQSxNQUFBQSxFQUFPSixDQUFBQSxvQkFBQUEsUUFBUUssUUFBQUEsS0FBUSxPQUFoQkwsb0JBQW9CLE1BQU07UUFBRU0sS0FBSztJQUFLLEdBQUdDLElBQUksQ0FBQ04sSUFBSUksUUFBUSxHQUFHO1FBQ3ZFLE9BQU87SUFDVDtJQUVBLE9BQU87QUFDVDtBQUVPLFNBQVNQLGNBQ2RVLGFBQXlDLEVBQ3pDQyxlQUF1QjtJQUV2QixJQUFJLENBQUNELGVBQWU7UUFDbEIsdUVBQXVFO1FBQ3ZFLE9BQU87SUFDVDtJQUNBLE1BQU1QLE1BQU0sSUFBSVMsSUFBSUQsaUJBQWlCO0lBQ3JDLE9BQU9ELGNBQWNHLElBQUksQ0FBQyxDQUFDQyxJQUFNYixrQkFBa0JhLEdBQUdYO0FBQ3hEIiwic291cmNlcyI6WyIvVXNlcnMvc3JjL3NoYXJlZC9saWIvbWF0Y2gtbG9jYWwtcGF0dGVybi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IExvY2FsUGF0dGVybiB9IGZyb20gJy4vaW1hZ2UtY29uZmlnJ1xuaW1wb3J0IHsgbWFrZVJlIH0gZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL3BpY29tYXRjaCdcblxuLy8gTW9kaWZ5aW5nIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGFsc28gbW9kaWZ5IHdyaXRlSW1hZ2VzTWFuaWZlc3QoKVxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoTG9jYWxQYXR0ZXJuKHBhdHRlcm46IExvY2FsUGF0dGVybiwgdXJsOiBVUkwpOiBib29sZWFuIHtcbiAgaWYgKHBhdHRlcm4uc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAocGF0dGVybi5zZWFyY2ggIT09IHVybC5zZWFyY2gpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGlmICghbWFrZVJlKHBhdHRlcm4ucGF0aG5hbWUgPz8gJyoqJywgeyBkb3Q6IHRydWUgfSkudGVzdCh1cmwucGF0aG5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzTG9jYWxNYXRjaChcbiAgbG9jYWxQYXR0ZXJuczogTG9jYWxQYXR0ZXJuW10gfCB1bmRlZmluZWQsXG4gIHVybFBhdGhBbmRRdWVyeTogc3RyaW5nXG4pOiBib29sZWFuIHtcbiAgaWYgKCFsb2NhbFBhdHRlcm5zKSB7XG4gICAgLy8gaWYgdGhlIHVzZXIgZGlkbid0IGRlZmluZSBcImxvY2FsUGF0dGVybnNcIiwgd2UgYWxsb3cgYWxsIGxvY2FsIGltYWdlc1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgY29uc3QgdXJsID0gbmV3IFVSTCh1cmxQYXRoQW5kUXVlcnksICdodHRwOi8vbicpXG4gIHJldHVybiBsb2NhbFBhdHRlcm5zLnNvbWUoKHApID0+IG1hdGNoTG9jYWxQYXR0ZXJuKHAsIHVybCkpXG59XG4iXSwibmFtZXMiOlsiaGFzTG9jYWxNYXRjaCIsIm1hdGNoTG9jYWxQYXR0ZXJuIiwicGF0dGVybiIsInVybCIsInNlYXJjaCIsInVuZGVmaW5lZCIsIm1ha2VSZSIsInBhdGhuYW1lIiwiZG90IiwidGVzdCIsImxvY2FsUGF0dGVybnMiLCJ1cmxQYXRoQW5kUXVlcnkiLCJVUkwiLCJzb21lIiwicCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/match-local-pattern.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-remote-pattern.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    hasRemoteMatch: function() {\n        return hasRemoteMatch;\n    },\n    matchRemotePattern: function() {\n        return matchRemotePattern;\n    }\n});\nconst _picomatch = __webpack_require__(/*! next/dist/compiled/picomatch */ \"(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js\");\nfunction matchRemotePattern(pattern, url) {\n    if (pattern.protocol !== undefined) {\n        if (pattern.protocol.replace(/:$/, '') !== url.protocol.replace(/:$/, '')) {\n            return false;\n        }\n    }\n    if (pattern.port !== undefined) {\n        if (pattern.port !== url.port) {\n            return false;\n        }\n    }\n    if (pattern.hostname === undefined) {\n        throw Object.defineProperty(new Error(\"Pattern should define hostname but found\\n\" + JSON.stringify(pattern)), \"__NEXT_ERROR_CODE\", {\n            value: \"E410\",\n            enumerable: false,\n            configurable: true\n        });\n    } else {\n        if (!(0, _picomatch.makeRe)(pattern.hostname).test(url.hostname)) {\n            return false;\n        }\n    }\n    if (pattern.search !== undefined) {\n        if (pattern.search !== url.search) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    // Should be the same as writeImagesManifest()\n    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : '**', {\n        dot: true\n    }).test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasRemoteMatch(domains, remotePatterns, url) {\n    return domains.some((domain)=>url.hostname === domain) || remotePatterns.some((p)=>matchRemotePattern(p, url));\n} //# sourceMappingURL=match-remote-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9tYXRjaC1yZW1vdGUtcGF0dGVybi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUEyQ2dCQSxjQUFjO2VBQWRBOztJQXZDQUMsa0JBQWtCO2VBQWxCQTs7O3VDQUhPO0FBR2hCLFNBQVNBLG1CQUNkQyxPQUE0QixFQUM1QkMsR0FBUTtJQUVSLElBQUlELFFBQVFFLFFBQVEsS0FBS0MsV0FBVztRQUNsQyxJQUFJSCxRQUFRRSxRQUFRLENBQUNFLE9BQU8sQ0FBQyxNQUFNLFFBQVFILElBQUlDLFFBQVEsQ0FBQ0UsT0FBTyxDQUFDLE1BQU0sS0FBSztZQUN6RSxPQUFPO1FBQ1Q7SUFDRjtJQUNBLElBQUlKLFFBQVFLLElBQUksS0FBS0YsV0FBVztRQUM5QixJQUFJSCxRQUFRSyxJQUFJLEtBQUtKLElBQUlJLElBQUksRUFBRTtZQUM3QixPQUFPO1FBQ1Q7SUFDRjtJQUVBLElBQUlMLFFBQVFNLFFBQVEsS0FBS0gsV0FBVztRQUNsQyxNQUFNLHFCQUVMLENBRkssSUFBSUksTUFDUCwrQ0FBNENDLEtBQUtDLFNBQVMsQ0FBQ1QsV0FEeEQ7bUJBQUE7d0JBQUE7MEJBQUE7UUFFTjtJQUNGLE9BQU87UUFDTCxJQUFJLENBQUNVLENBQUFBLEdBQUFBLFdBQUFBLE1BQUFBLEVBQU9WLFFBQVFNLFFBQVEsRUFBRUssSUFBSSxDQUFDVixJQUFJSyxRQUFRLEdBQUc7WUFDaEQsT0FBTztRQUNUO0lBQ0Y7SUFFQSxJQUFJTixRQUFRWSxNQUFNLEtBQUtULFdBQVc7UUFDaEMsSUFBSUgsUUFBUVksTUFBTSxLQUFLWCxJQUFJVyxNQUFNLEVBQUU7WUFDakMsT0FBTztRQUNUO0lBQ0Y7UUFHWVo7SUFEWiw4Q0FBOEM7SUFDOUMsSUFBSSxDQUFDVSxDQUFBQSxHQUFBQSxXQUFBQSxNQUFBQSxFQUFPVixDQUFBQSxvQkFBQUEsUUFBUWEsUUFBQUEsS0FBUSxPQUFoQmIsb0JBQW9CLE1BQU07UUFBRWMsS0FBSztJQUFLLEdBQUdILElBQUksQ0FBQ1YsSUFBSVksUUFBUSxHQUFHO1FBQ3ZFLE9BQU87SUFDVDtJQUVBLE9BQU87QUFDVDtBQUVPLFNBQVNmLGVBQ2RpQixPQUFpQixFQUNqQkMsY0FBMEMsRUFDMUNmLEdBQVE7SUFFUixPQUNFYyxRQUFRRSxJQUFJLENBQUMsQ0FBQ0MsU0FBV2pCLElBQUlLLFFBQVEsS0FBS1ksV0FDMUNGLGVBQWVDLElBQUksQ0FBQyxDQUFDRSxJQUFNcEIsbUJBQW1Cb0IsR0FBR2xCO0FBRXJEIiwic291cmNlcyI6WyIvVXNlcnMvc3JjL3NoYXJlZC9saWIvbWF0Y2gtcmVtb3RlLXBhdHRlcm4udHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBSZW1vdGVQYXR0ZXJuIH0gZnJvbSAnLi9pbWFnZS1jb25maWcnXG5pbXBvcnQgeyBtYWtlUmUgfSBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvcGljb21hdGNoJ1xuXG4vLyBNb2RpZnlpbmcgdGhpcyBmdW5jdGlvbiBzaG91bGQgYWxzbyBtb2RpZnkgd3JpdGVJbWFnZXNNYW5pZmVzdCgpXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hSZW1vdGVQYXR0ZXJuKFxuICBwYXR0ZXJuOiBSZW1vdGVQYXR0ZXJuIHwgVVJMLFxuICB1cmw6IFVSTFxuKTogYm9vbGVhbiB7XG4gIGlmIChwYXR0ZXJuLnByb3RvY29sICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAocGF0dGVybi5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSAhPT0gdXJsLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgaWYgKHBhdHRlcm4ucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHBhdHRlcm4ucG9ydCAhPT0gdXJsLnBvcnQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGlmIChwYXR0ZXJuLmhvc3RuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgUGF0dGVybiBzaG91bGQgZGVmaW5lIGhvc3RuYW1lIGJ1dCBmb3VuZFxcbiR7SlNPTi5zdHJpbmdpZnkocGF0dGVybil9YFxuICAgIClcbiAgfSBlbHNlIHtcbiAgICBpZiAoIW1ha2VSZShwYXR0ZXJuLmhvc3RuYW1lKS50ZXN0KHVybC5ob3N0bmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGlmIChwYXR0ZXJuLnNlYXJjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHBhdHRlcm4uc2VhcmNoICE9PSB1cmwuc2VhcmNoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyBTaG91bGQgYmUgdGhlIHNhbWUgYXMgd3JpdGVJbWFnZXNNYW5pZmVzdCgpXG4gIGlmICghbWFrZVJlKHBhdHRlcm4ucGF0aG5hbWUgPz8gJyoqJywgeyBkb3Q6IHRydWUgfSkudGVzdCh1cmwucGF0aG5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzUmVtb3RlTWF0Y2goXG4gIGRvbWFpbnM6IHN0cmluZ1tdLFxuICByZW1vdGVQYXR0ZXJuczogQXJyYXk8UmVtb3RlUGF0dGVybiB8IFVSTD4sXG4gIHVybDogVVJMXG4pOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBkb21haW5zLnNvbWUoKGRvbWFpbikgPT4gdXJsLmhvc3RuYW1lID09PSBkb21haW4pIHx8XG4gICAgcmVtb3RlUGF0dGVybnMuc29tZSgocCkgPT4gbWF0Y2hSZW1vdGVQYXR0ZXJuKHAsIHVybCkpXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJoYXNSZW1vdGVNYXRjaCIsIm1hdGNoUmVtb3RlUGF0dGVybiIsInBhdHRlcm4iLCJ1cmwiLCJwcm90b2NvbCIsInVuZGVmaW5lZCIsInJlcGxhY2UiLCJwb3J0IiwiaG9zdG5hbWUiLCJFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJtYWtlUmUiLCJ0ZXN0Iiwic2VhcmNoIiwicGF0aG5hbWUiLCJkb3QiLCJkb21haW5zIiwicmVtb3RlUGF0dGVybnMiLCJzb21lIiwiZG9tYWluIiwicCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router-context.shared-runtime.js ***!
  \****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouterContext\", ({\n    enumerable: true,\n    get: function() {\n        return RouterContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst RouterContext = _react.default.createContext(null);\nif (true) {\n    RouterContext.displayName = 'RouterContext';\n} //# sourceMappingURL=router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O2lEQUdhQTs7O2VBQUFBOzs7OzRFQUhLO0FBR1gsTUFBTUEsZ0JBQWdCQyxPQUFBQSxPQUFLLENBQUNDLGFBQWEsQ0FBb0I7QUFFcEUsSUFBSUMsSUFBb0IsRUFBbUI7SUFDekNILGNBQWNNLFdBQVcsR0FBRztBQUM5QiIsInNvdXJjZXMiOlsiL1VzZXJzL3NyYy9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB0eXBlIHsgTmV4dFJvdXRlciB9IGZyb20gJy4vcm91dGVyL3JvdXRlcidcblxuZXhwb3J0IGNvbnN0IFJvdXRlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PE5leHRSb3V0ZXIgfCBudWxsPihudWxsKVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSb3V0ZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gJ1JvdXRlckNvbnRleHQnXG59XG4iXSwibmFtZXMiOlsiUm91dGVyQ29udGV4dCIsIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImRpc3BsYXlOYW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/format-url.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatUrl: function() {\n        return formatUrl;\n    },\n    formatWithValidation: function() {\n        return formatWithValidation;\n    },\n    urlObjectKeys: function() {\n        return urlObjectKeys;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _querystring = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ./querystring */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\"));\nconst slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    let { auth, hostname } = urlObj;\n    let protocol = urlObj.protocol || '';\n    let pathname = urlObj.pathname || '';\n    let hash = urlObj.hash || '';\n    let query = urlObj.query || '';\n    let host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(':') ? \"[\" + hostname + \"]\" : hostname);\n        if (urlObj.port) {\n            host += ':' + urlObj.port;\n        }\n    }\n    if (query && typeof query === 'object') {\n        query = String(_querystring.urlQueryToSearchParams(query));\n    }\n    let search = urlObj.search || query && \"?\" + query || '';\n    if (protocol && !protocol.endsWith(':')) protocol += ':';\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = '//' + (host || '');\n        if (pathname && pathname[0] !== '/') pathname = '/' + pathname;\n    } else if (!host) {\n        host = '';\n    }\n    if (hash && hash[0] !== '#') hash = '#' + hash;\n    if (search && search[0] !== '?') search = '?' + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace('#', '%23');\n    return \"\" + protocol + host + pathname + search + hash;\n}\nconst urlObjectKeys = [\n    'auth',\n    'hash',\n    'host',\n    'hostname',\n    'href',\n    'path',\n    'pathname',\n    'port',\n    'protocol',\n    'query',\n    'search',\n    'slashes'\n];\nfunction formatWithValidation(url) {\n    if (true) {\n        if (url !== null && typeof url === 'object') {\n            Object.keys(url).forEach((key)=>{\n                if (!urlObjectKeys.includes(key)) {\n                    console.warn(\"Unknown key passed via urlObject into url.format: \" + key);\n                }\n            });\n        }\n    }\n    return formatUrl(url);\n} //# sourceMappingURL=format-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx1Q0FBdUM7QUFDdkMsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5Qzs7Ozs7Ozs7Ozs7OztJQVF6QkEsU0FBUztlQUFUQTs7SUE2REFDLG9CQUFvQjtlQUFwQkE7O0lBZkhDLGFBQWE7ZUFBYkE7Ozs7bUZBbERnQjtBQUU3QixNQUFNQyxtQkFBbUI7QUFFbEIsU0FBU0gsVUFBVUksTUFBaUI7SUFDekMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLFFBQVEsRUFBRSxHQUFHRjtJQUN6QixJQUFJRyxXQUFXSCxPQUFPRyxRQUFRLElBQUk7SUFDbEMsSUFBSUMsV0FBV0osT0FBT0ksUUFBUSxJQUFJO0lBQ2xDLElBQUlDLE9BQU9MLE9BQU9LLElBQUksSUFBSTtJQUMxQixJQUFJQyxRQUFRTixPQUFPTSxLQUFLLElBQUk7SUFDNUIsSUFBSUMsT0FBdUI7SUFFM0JOLE9BQU9BLE9BQU9PLG1CQUFtQlAsTUFBTVEsT0FBTyxDQUFDLFFBQVEsT0FBTyxNQUFNO0lBRXBFLElBQUlULE9BQU9PLElBQUksRUFBRTtRQUNmQSxPQUFPTixPQUFPRCxPQUFPTyxJQUFJO0lBQzNCLE9BQU8sSUFBSUwsVUFBVTtRQUNuQkssT0FBT04sT0FBUSxFQUFDQyxTQUFTUSxPQUFPLENBQUMsT0FBUSxNQUFHUixXQUFTLE1BQUtBLFFBQUFBLENBQU87UUFDakUsSUFBSUYsT0FBT1csSUFBSSxFQUFFO1lBQ2ZKLFFBQVEsTUFBTVAsT0FBT1csSUFBSTtRQUMzQjtJQUNGO0lBRUEsSUFBSUwsU0FBUyxPQUFPQSxVQUFVLFVBQVU7UUFDdENBLFFBQVFNLE9BQU9DLGFBQVlDLHNCQUFzQixDQUFDUjtJQUNwRDtJQUVBLElBQUlTLFNBQVNmLE9BQU9lLE1BQU0sSUFBS1QsU0FBVSxNQUFHQSxTQUFZO0lBRXhELElBQUlILFlBQVksQ0FBQ0EsU0FBU2EsUUFBUSxDQUFDLE1BQU1iLFlBQVk7SUFFckQsSUFDRUgsT0FBT2lCLE9BQU8sSUFDWixFQUFDZCxZQUFZSixpQkFBaUJtQixJQUFJLENBQUNmLFNBQUFBLENBQVEsSUFBTUksU0FBUyxPQUM1RDtRQUNBQSxPQUFPLE9BQVFBLENBQUFBLFFBQVEsR0FBQztRQUN4QixJQUFJSCxZQUFZQSxRQUFRLENBQUMsRUFBRSxLQUFLLEtBQUtBLFdBQVcsTUFBTUE7SUFDeEQsT0FBTyxJQUFJLENBQUNHLE1BQU07UUFDaEJBLE9BQU87SUFDVDtJQUVBLElBQUlGLFFBQVFBLElBQUksQ0FBQyxFQUFFLEtBQUssS0FBS0EsT0FBTyxNQUFNQTtJQUMxQyxJQUFJVSxVQUFVQSxNQUFNLENBQUMsRUFBRSxLQUFLLEtBQUtBLFNBQVMsTUFBTUE7SUFFaERYLFdBQVdBLFNBQVNLLE9BQU8sQ0FBQyxTQUFTRDtJQUNyQ08sU0FBU0EsT0FBT04sT0FBTyxDQUFDLEtBQUs7SUFFN0IsT0FBUSxLQUFFTixXQUFXSSxPQUFPSCxXQUFXVyxTQUFTVjtBQUNsRDtBQUVPLE1BQU1QLGdCQUFnQjtJQUMzQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUVNLFNBQVNELHFCQUFxQnNCLEdBQWM7SUFDakQsSUFBSUMsSUFBb0IsRUFBb0I7UUFDMUMsSUFBSUQsUUFBUSxRQUFRLE9BQU9BLFFBQVEsVUFBVTtZQUMzQ0ksT0FBT0MsSUFBSSxDQUFDTCxLQUFLTSxPQUFPLENBQUMsQ0FBQ0M7Z0JBQ3hCLElBQUksQ0FBQzVCLGNBQWM2QixRQUFRLENBQUNELE1BQU07b0JBQ2hDRSxRQUFRQyxJQUFJLENBQ1QsdURBQW9ESDtnQkFFekQ7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxPQUFPOUIsVUFBVXVCO0FBQ25CIiwic291cmNlcyI6WyIvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRm9ybWF0IGZ1bmN0aW9uIG1vZGlmaWVkIGZyb20gbm9kZWpzXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHR5cGUgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQgdHlwZSB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgKiBhcyBxdWVyeXN0cmluZyBmcm9tICcuL3F1ZXJ5c3RyaW5nJ1xuXG5jb25zdCBzbGFzaGVkUHJvdG9jb2xzID0gL2h0dHBzP3xmdHB8Z29waGVyfGZpbGUvXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVcmwodXJsT2JqOiBVcmxPYmplY3QpIHtcbiAgbGV0IHsgYXV0aCwgaG9zdG5hbWUgfSA9IHVybE9ialxuICBsZXQgcHJvdG9jb2wgPSB1cmxPYmoucHJvdG9jb2wgfHwgJydcbiAgbGV0IHBhdGhuYW1lID0gdXJsT2JqLnBhdGhuYW1lIHx8ICcnXG4gIGxldCBoYXNoID0gdXJsT2JqLmhhc2ggfHwgJydcbiAgbGV0IHF1ZXJ5ID0gdXJsT2JqLnF1ZXJ5IHx8ICcnXG4gIGxldCBob3N0OiBzdHJpbmcgfCBmYWxzZSA9IGZhbHNlXG5cbiAgYXV0aCA9IGF1dGggPyBlbmNvZGVVUklDb21wb25lbnQoYXV0aCkucmVwbGFjZSgvJTNBL2ksICc6JykgKyAnQCcgOiAnJ1xuXG4gIGlmICh1cmxPYmouaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdXJsT2JqLmhvc3RcbiAgfSBlbHNlIGlmIChob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKH5ob3N0bmFtZS5pbmRleE9mKCc6JykgPyBgWyR7aG9zdG5hbWV9XWAgOiBob3N0bmFtZSlcbiAgICBpZiAodXJsT2JqLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdXJsT2JqLnBvcnRcbiAgICB9XG4gIH1cblxuICBpZiAocXVlcnkgJiYgdHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgIHF1ZXJ5ID0gU3RyaW5nKHF1ZXJ5c3RyaW5nLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnkgYXMgUGFyc2VkVXJsUXVlcnkpKVxuICB9XG5cbiAgbGV0IHNlYXJjaCA9IHVybE9iai5zZWFyY2ggfHwgKHF1ZXJ5ICYmIGA/JHtxdWVyeX1gKSB8fCAnJ1xuXG4gIGlmIChwcm90b2NvbCAmJiAhcHJvdG9jb2wuZW5kc1dpdGgoJzonKSkgcHJvdG9jb2wgKz0gJzonXG5cbiAgaWYgKFxuICAgIHVybE9iai5zbGFzaGVzIHx8XG4gICAgKCghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29scy50ZXN0KHByb3RvY29sKSkgJiYgaG9zdCAhPT0gZmFsc2UpXG4gICkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpXG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lWzBdICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWVcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJ1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaFswXSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaFxuICBpZiAoc2VhcmNoICYmIHNlYXJjaFswXSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2hcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZW5jb2RlVVJJQ29tcG9uZW50KVxuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKVxuXG4gIHJldHVybiBgJHtwcm90b2NvbH0ke2hvc3R9JHtwYXRobmFtZX0ke3NlYXJjaH0ke2hhc2h9YFxufVxuXG5leHBvcnQgY29uc3QgdXJsT2JqZWN0S2V5cyA9IFtcbiAgJ2F1dGgnLFxuICAnaGFzaCcsXG4gICdob3N0JyxcbiAgJ2hvc3RuYW1lJyxcbiAgJ2hyZWYnLFxuICAncGF0aCcsXG4gICdwYXRobmFtZScsXG4gICdwb3J0JyxcbiAgJ3Byb3RvY29sJyxcbiAgJ3F1ZXJ5JyxcbiAgJ3NlYXJjaCcsXG4gICdzbGFzaGVzJyxcbl1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHVybDogVXJsT2JqZWN0KTogc3RyaW5nIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgaWYgKHVybCAhPT0gbnVsbCAmJiB0eXBlb2YgdXJsID09PSAnb2JqZWN0Jykge1xuICAgICAgT2JqZWN0LmtleXModXJsKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKCF1cmxPYmplY3RLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgVW5rbm93biBrZXkgcGFzc2VkIHZpYSB1cmxPYmplY3QgaW50byB1cmwuZm9ybWF0OiAke2tleX1gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmb3JtYXRVcmwodXJsKVxufVxuIl0sIm5hbWVzIjpbImZvcm1hdFVybCIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwidXJsT2JqZWN0S2V5cyIsInNsYXNoZWRQcm90b2NvbHMiLCJ1cmxPYmoiLCJhdXRoIiwiaG9zdG5hbWUiLCJwcm90b2NvbCIsInBhdGhuYW1lIiwiaGFzaCIsInF1ZXJ5IiwiaG9zdCIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlcGxhY2UiLCJpbmRleE9mIiwicG9ydCIsIlN0cmluZyIsInF1ZXJ5c3RyaW5nIiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsInNlYXJjaCIsImVuZHNXaXRoIiwic2xhc2hlcyIsInRlc3QiLCJ1cmwiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwiY29uc29sZSIsIndhcm4iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/is-local-url.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isLocalURL\", ({\n    enumerable: true,\n    get: function() {\n        return isLocalURL;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../../client/has-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/has-base-path.js\");\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (!(0, _utils.isAbsoluteUrl)(url)) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils.getLocationOrigin)();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n} //# sourceMappingURL=is-local-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7OENBTWdCQTs7O2VBQUFBOzs7bUNBTmlDO3lDQUNyQjtBQUtyQixTQUFTQSxXQUFXQyxHQUFXO0lBQ3BDLGdFQUFnRTtJQUNoRSxJQUFJLENBQUNDLENBQUFBLEdBQUFBLE9BQUFBLGFBQUFBLEVBQWNELE1BQU0sT0FBTztJQUNoQyxJQUFJO1FBQ0YsNERBQTREO1FBQzVELE1BQU1FLGlCQUFpQkMsQ0FBQUEsR0FBQUEsT0FBQUEsaUJBQUFBO1FBQ3ZCLE1BQU1DLFdBQVcsSUFBSUMsSUFBSUwsS0FBS0U7UUFDOUIsT0FBT0UsU0FBU0UsTUFBTSxLQUFLSixrQkFBa0JLLENBQUFBLEdBQUFBLGFBQUFBLFdBQUFBLEVBQVlILFNBQVNJLFFBQVE7SUFDNUUsRUFBRSxPQUFPQyxHQUFHO1FBQ1YsT0FBTztJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzQWJzb2x1dGVVcmwsIGdldExvY2F0aW9uT3JpZ2luIH0gZnJvbSAnLi4vLi4vdXRpbHMnXG5pbXBvcnQgeyBoYXNCYXNlUGF0aCB9IGZyb20gJy4uLy4uLy4uLy4uL2NsaWVudC9oYXMtYmFzZS1wYXRoJ1xuXG4vKipcbiAqIERldGVjdHMgd2hldGhlciBhIGdpdmVuIHVybCBpcyByb3V0YWJsZSBieSB0aGUgTmV4dC5qcyByb3V0ZXIgKGJyb3dzZXIgb25seSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0xvY2FsVVJMKHVybDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIHByZXZlbnQgYSBoeWRyYXRpb24gbWlzbWF0Y2ggb24gaHJlZiBmb3IgdXJsIHdpdGggYW5jaG9yIHJlZnNcbiAgaWYgKCFpc0Fic29sdXRlVXJsKHVybCkpIHJldHVybiB0cnVlXG4gIHRyeSB7XG4gICAgLy8gYWJzb2x1dGUgdXJscyBjYW4gYmUgbG9jYWwgaWYgdGhleSBhcmUgb24gdGhlIHNhbWUgb3JpZ2luXG4gICAgY29uc3QgbG9jYXRpb25PcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpXG4gICAgY29uc3QgcmVzb2x2ZWQgPSBuZXcgVVJMKHVybCwgbG9jYXRpb25PcmlnaW4pXG4gICAgcmV0dXJuIHJlc29sdmVkLm9yaWdpbiA9PT0gbG9jYXRpb25PcmlnaW4gJiYgaGFzQmFzZVBhdGgocmVzb2x2ZWQucGF0aG5hbWUpXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIl0sIm5hbWVzIjpbImlzTG9jYWxVUkwiLCJ1cmwiLCJpc0Fic29sdXRlVXJsIiwibG9jYXRpb25PcmlnaW4iLCJnZXRMb2NhdGlvbk9yaWdpbiIsInJlc29sdmVkIiwiVVJMIiwib3JpZ2luIiwiaGFzQmFzZVBhdGgiLCJwYXRobmFtZSIsIl8iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/querystring.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    assign: function() {\n        return assign;\n    },\n    searchParamsToUrlQuery: function() {\n        return searchParamsToUrlQuery;\n    },\n    urlQueryToSearchParams: function() {\n        return urlQueryToSearchParams;\n    }\n});\nfunction searchParamsToUrlQuery(searchParams) {\n    const query = {};\n    for (const [key, value] of searchParams.entries()){\n        const existing = query[key];\n        if (typeof existing === 'undefined') {\n            query[key] = value;\n        } else if (Array.isArray(existing)) {\n            existing.push(value);\n        } else {\n            query[key] = [\n                existing,\n                value\n            ];\n        }\n    }\n    return query;\n}\nfunction stringifyUrlQueryParam(param) {\n    if (typeof param === 'string') {\n        return param;\n    }\n    if (typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {\n        return String(param);\n    } else {\n        return '';\n    }\n}\nfunction urlQueryToSearchParams(query) {\n    const searchParams = new URLSearchParams();\n    for (const [key, value] of Object.entries(query)){\n        if (Array.isArray(value)) {\n            for (const item of value){\n                searchParams.append(key, stringifyUrlQueryParam(item));\n            }\n        } else {\n            searchParams.set(key, stringifyUrlQueryParam(value));\n        }\n    }\n    return searchParams;\n}\nfunction assign(target) {\n    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        searchParamsList[_key - 1] = arguments[_key];\n    }\n    for (const searchParams of searchParamsList){\n        for (const key of searchParams.keys()){\n            target.delete(key);\n        }\n        for (const [key, value] of searchParams.entries()){\n            target.append(key, value);\n        }\n    }\n    return target;\n} //# sourceMappingURL=querystring.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBZ0RnQkEsTUFBTTtlQUFOQTs7SUE5Q0FDLHNCQUFzQjtlQUF0QkE7O0lBZ0NBQyxzQkFBc0I7ZUFBdEJBOzs7QUFoQ1QsU0FBU0QsdUJBQ2RFLFlBQTZCO0lBRTdCLE1BQU1DLFFBQXdCLENBQUM7SUFDL0IsS0FBSyxNQUFNLENBQUNDLEtBQUtDLE1BQU0sSUFBSUgsYUFBYUksT0FBTyxHQUFJO1FBQ2pELE1BQU1DLFdBQVdKLEtBQUssQ0FBQ0MsSUFBSTtRQUMzQixJQUFJLE9BQU9HLGFBQWEsYUFBYTtZQUNuQ0osS0FBSyxDQUFDQyxJQUFJLEdBQUdDO1FBQ2YsT0FBTyxJQUFJRyxNQUFNQyxPQUFPLENBQUNGLFdBQVc7WUFDbENBLFNBQVNHLElBQUksQ0FBQ0w7UUFDaEIsT0FBTztZQUNMRixLQUFLLENBQUNDLElBQUksR0FBRztnQkFBQ0c7Z0JBQVVGO2FBQU07UUFDaEM7SUFDRjtJQUNBLE9BQU9GO0FBQ1Q7QUFFQSxTQUFTUSx1QkFBdUJDLEtBQWM7SUFDNUMsSUFBSSxPQUFPQSxVQUFVLFVBQVU7UUFDN0IsT0FBT0E7SUFDVDtJQUVBLElBQ0csT0FBT0EsVUFBVSxZQUFZLENBQUNDLE1BQU1ELFVBQ3JDLE9BQU9BLFVBQVUsV0FDakI7UUFDQSxPQUFPRSxPQUFPRjtJQUNoQixPQUFPO1FBQ0wsT0FBTztJQUNUO0FBQ0Y7QUFFTyxTQUFTWCx1QkFBdUJFLEtBQXFCO0lBQzFELE1BQU1ELGVBQWUsSUFBSWE7SUFDekIsS0FBSyxNQUFNLENBQUNYLEtBQUtDLE1BQU0sSUFBSVcsT0FBT1YsT0FBTyxDQUFDSCxPQUFRO1FBQ2hELElBQUlLLE1BQU1DLE9BQU8sQ0FBQ0osUUFBUTtZQUN4QixLQUFLLE1BQU1ZLFFBQVFaLE1BQU87Z0JBQ3hCSCxhQUFhZ0IsTUFBTSxDQUFDZCxLQUFLTyx1QkFBdUJNO1lBQ2xEO1FBQ0YsT0FBTztZQUNMZixhQUFhaUIsR0FBRyxDQUFDZixLQUFLTyx1QkFBdUJOO1FBQy9DO0lBQ0Y7SUFDQSxPQUFPSDtBQUNUO0FBRU8sU0FBU0gsT0FDZHFCLE1BQXVCO0lBQ3ZCLGlDQUFHQyxtQkFBSDtRQUFHQSxnQkFBQUEsQ0FBSCwyQkFBc0M7O0lBRXRDLEtBQUssTUFBTW5CLGdCQUFnQm1CLGlCQUFrQjtRQUMzQyxLQUFLLE1BQU1qQixPQUFPRixhQUFhb0IsSUFBSSxHQUFJO1lBQ3JDRixPQUFPRyxNQUFNLENBQUNuQjtRQUNoQjtRQUVBLEtBQUssTUFBTSxDQUFDQSxLQUFLQyxNQUFNLElBQUlILGFBQWFJLE9BQU8sR0FBSTtZQUNqRGMsT0FBT0YsTUFBTSxDQUFDZCxLQUFLQztRQUNyQjtJQUNGO0lBRUEsT0FBT2U7QUFDVCIsInNvdXJjZXMiOlsiL3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5cbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KFxuICBzZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtc1xuKTogUGFyc2VkVXJsUXVlcnkge1xuICBjb25zdCBxdWVyeTogUGFyc2VkVXJsUXVlcnkgPSB7fVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzZWFyY2hQYXJhbXMuZW50cmllcygpKSB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSBxdWVyeVtrZXldXG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHF1ZXJ5W2tleV0gPSB2YWx1ZVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShleGlzdGluZykpIHtcbiAgICAgIGV4aXN0aW5nLnB1c2godmFsdWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5W2tleV0gPSBbZXhpc3RpbmcsIHZhbHVlXVxuICAgIH1cbiAgfVxuICByZXR1cm4gcXVlcnlcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5VXJsUXVlcnlQYXJhbShwYXJhbTogdW5rbm93bik6IHN0cmluZyB7XG4gIGlmICh0eXBlb2YgcGFyYW0gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcmFtXG4gIH1cblxuICBpZiAoXG4gICAgKHR5cGVvZiBwYXJhbSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHBhcmFtKSkgfHxcbiAgICB0eXBlb2YgcGFyYW0gPT09ICdib29sZWFuJ1xuICApIHtcbiAgICByZXR1cm4gU3RyaW5nKHBhcmFtKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAnJ1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cmxRdWVyeVRvU2VhcmNoUGFyYW1zKHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSk6IFVSTFNlYXJjaFBhcmFtcyB7XG4gIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhxdWVyeSkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgc3RyaW5naWZ5VXJsUXVlcnlQYXJhbShpdGVtKSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VhcmNoUGFyYW1zLnNldChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0odmFsdWUpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gc2VhcmNoUGFyYW1zXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24oXG4gIHRhcmdldDogVVJMU2VhcmNoUGFyYW1zLFxuICAuLi5zZWFyY2hQYXJhbXNMaXN0OiBVUkxTZWFyY2hQYXJhbXNbXVxuKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgZm9yIChjb25zdCBzZWFyY2hQYXJhbXMgb2Ygc2VhcmNoUGFyYW1zTGlzdCkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHNlYXJjaFBhcmFtcy5rZXlzKCkpIHtcbiAgICAgIHRhcmdldC5kZWxldGUoa2V5KVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHNlYXJjaFBhcmFtcy5lbnRyaWVzKCkpIHtcbiAgICAgIHRhcmdldC5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0XG59XG4iXSwibmFtZXMiOlsiYXNzaWduIiwic2VhcmNoUGFyYW1zVG9VcmxRdWVyeSIsInVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMiLCJzZWFyY2hQYXJhbXMiLCJxdWVyeSIsImtleSIsInZhbHVlIiwiZW50cmllcyIsImV4aXN0aW5nIiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsInN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0iLCJwYXJhbSIsImlzTmFOIiwiU3RyaW5nIiwiVVJMU2VhcmNoUGFyYW1zIiwiT2JqZWN0IiwiaXRlbSIsImFwcGVuZCIsInNldCIsInRhcmdldCIsInNlYXJjaFBhcmFtc0xpc3QiLCJrZXlzIiwiZGVsZXRlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/side-effect.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return SideEffect;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst isServer = \"object\" === 'undefined';\nconst useClientOnlyLayoutEffect = isServer ? ()=>{} : _react.useLayoutEffect;\nconst useClientOnlyEffect = isServer ? ()=>{} : _react.useEffect;\nfunction SideEffect(props) {\n    _s();\n    const { headManager, reduceComponentsToState } = props;\n    function emitChange() {\n        if (headManager && headManager.mountedInstances) {\n            const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));\n            headManager.updateHead(reduceComponentsToState(headElements, props));\n        }\n    }\n    if (isServer) {\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        emitChange();\n    }\n    useClientOnlyLayoutEffect({\n        \"SideEffect.useClientOnlyLayoutEffect\": ()=>{\n            var _headManager_mountedInstances;\n            headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n            return ({\n                \"SideEffect.useClientOnlyLayoutEffect\": ()=>{\n                    var _headManager_mountedInstances;\n                    headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.delete(props.children);\n                }\n            })[\"SideEffect.useClientOnlyLayoutEffect\"];\n        }\n    }[\"SideEffect.useClientOnlyLayoutEffect\"]);\n    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n    // being rendered, we only trigger the method from the last one.\n    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n    // singleton in the layout effect pass, and actually trigger it in the effect pass.\n    useClientOnlyLayoutEffect({\n        \"SideEffect.useClientOnlyLayoutEffect\": ()=>{\n            if (headManager) {\n                headManager._pendingUpdate = emitChange;\n            }\n            return ({\n                \"SideEffect.useClientOnlyLayoutEffect\": ()=>{\n                    if (headManager) {\n                        headManager._pendingUpdate = emitChange;\n                    }\n                }\n            })[\"SideEffect.useClientOnlyLayoutEffect\"];\n        }\n    }[\"SideEffect.useClientOnlyLayoutEffect\"]);\n    useClientOnlyEffect({\n        \"SideEffect.useClientOnlyEffect\": ()=>{\n            if (headManager && headManager._pendingUpdate) {\n                headManager._pendingUpdate();\n                headManager._pendingUpdate = null;\n            }\n            return ({\n                \"SideEffect.useClientOnlyEffect\": ()=>{\n                    if (headManager && headManager._pendingUpdate) {\n                        headManager._pendingUpdate();\n                        headManager._pendingUpdate = null;\n                    }\n                }\n            })[\"SideEffect.useClientOnlyEffect\"];\n        }\n    }[\"SideEffect.useClientOnlyEffect\"]);\n    return null;\n} //# sourceMappingURL=side-effect.js.map\n_s(SideEffect, \"gHVkikNHNxjVdD11eJBzaqkCiPY=\", false, function() {\n    return [\n        useClientOnlyLayoutEffect,\n        useClientOnlyLayoutEffect,\n        useClientOnlyEffect\n    ];\n});\n_c = SideEffect;\nvar _c;\n$RefreshReg$(_c, \"SideEffect\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9zaWRlLWVmZmVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7MkNBb0JBOzs7ZUFBd0JBOzs7bUNBbkJ1QztBQWUvRCxNQUFNQyxXQUFXLE9BQU9DLE1BQVc7QUFDbkMsTUFBTUMsNEJBQTRCRixXQUFXLEtBQU8sSUFBSUcsT0FBQUEsZUFBZTtBQUN2RSxNQUFNQyxzQkFBc0JKLFdBQVcsS0FBTyxJQUFJSyxPQUFBQSxTQUFTO0FBRTVDLG9CQUFvQkMsS0FBc0I7O0lBQ3ZELE1BQU0sRUFBRUMsV0FBVyxFQUFFQyx1QkFBdUIsRUFBRSxHQUFHRjtJQUVqRCxTQUFTRztRQUNQLElBQUlGLGVBQWVBLFlBQVlHLGdCQUFnQixFQUFFO1lBQy9DLE1BQU1DLGVBQWVDLE9BQUFBLFFBQVEsQ0FBQ0MsT0FBTyxDQUNuQ0MsTUFBTUMsSUFBSSxDQUFDUixZQUFZRyxnQkFBZ0IsRUFBMEJNLE1BQU0sQ0FDckVDO1lBR0pWLFlBQVlXLFVBQVUsQ0FBQ1Ysd0JBQXdCRyxjQUFjTDtRQUMvRDtJQUNGO0lBRUEsSUFBSU4sVUFBVTtZQUNaTztRQUFBQSxlQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSxnQ0FBQUEsWUFBYUcsZ0JBQUFBLEtBQWdCLGdCQUE3QkgsOEJBQStCWSxHQUFHLENBQUNiLE1BQU1jLFFBQVE7UUFDakRYO0lBQ0Y7O2dEQUUwQjtnQkFDeEJGO1lBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBQUEsS0FBZ0IsZ0JBQTdCSCw4QkFBK0JZLEdBQUcsQ0FBQ2IsTUFBTWMsUUFBUTtZQUNqRDt3REFBTzt3QkFDTGI7b0JBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBQUEsS0FBZ0IsZ0JBQTdCSCw4QkFBK0JjLE1BQU0sQ0FBQ2YsTUFBTWMsUUFBUTtnQkFDdEQ7O1FBQ0Y7O0lBRUEsa0ZBQWtGO0lBQ2xGLG9GQUFvRjtJQUNwRixnRUFBZ0U7SUFDaEUscUZBQXFGO0lBQ3JGLG1GQUFtRjs7Z0RBQ3pEO1lBQ3hCLElBQUliLGFBQWE7Z0JBQ2ZBLFlBQVllLGNBQWMsR0FBR2I7WUFDL0I7WUFDQTt3REFBTztvQkFDTCxJQUFJRixhQUFhO3dCQUNmQSxZQUFZZSxjQUFjLEdBQUdiO29CQUMvQjtnQkFDRjs7UUFDRjs7OzBDQUVvQjtZQUNsQixJQUFJRixlQUFlQSxZQUFZZSxjQUFjLEVBQUU7Z0JBQzdDZixZQUFZZSxjQUFjO2dCQUMxQmYsWUFBWWUsY0FBYyxHQUFHO1lBQy9CO1lBQ0E7a0RBQU87b0JBQ0wsSUFBSWYsZUFBZUEsWUFBWWUsY0FBYyxFQUFFO3dCQUM3Q2YsWUFBWWUsY0FBYzt3QkFDMUJmLFlBQVllLGNBQWMsR0FBRztvQkFDL0I7Z0JBQ0Y7O1FBQ0Y7O0lBRUEsT0FBTztBQUNUOzs7UUFyQ0VwQjtRQVlBQTtRQVdBRTs7O0tBMUNzQkwiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zcmMvc2hhcmVkL2xpYi9zaWRlLWVmZmVjdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBDaGlsZHJlbiwgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHR5cGUgSlNYIH0gZnJvbSAncmVhY3QnXG5cbnR5cGUgU3RhdGUgPSBKU1guRWxlbWVudFtdIHwgdW5kZWZpbmVkXG5cbmV4cG9ydCB0eXBlIFNpZGVFZmZlY3RQcm9wcyA9IHtcbiAgcmVkdWNlQ29tcG9uZW50c1RvU3RhdGU6IDxUIGV4dGVuZHMge30+KFxuICAgIGNvbXBvbmVudHM6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PixcbiAgICBwcm9wczogVFxuICApID0+IFN0YXRlXG4gIGhhbmRsZVN0YXRlQ2hhbmdlPzogKHN0YXRlOiBTdGF0ZSkgPT4gdm9pZFxuICBoZWFkTWFuYWdlcjogYW55XG4gIGluQW1wTW9kZT86IGJvb2xlYW5cbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxufVxuXG5jb25zdCBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnXG5jb25zdCB1c2VDbGllbnRPbmx5TGF5b3V0RWZmZWN0ID0gaXNTZXJ2ZXIgPyAoKSA9PiB7fSA6IHVzZUxheW91dEVmZmVjdFxuY29uc3QgdXNlQ2xpZW50T25seUVmZmVjdCA9IGlzU2VydmVyID8gKCkgPT4ge30gOiB1c2VFZmZlY3RcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2lkZUVmZmVjdChwcm9wczogU2lkZUVmZmVjdFByb3BzKSB7XG4gIGNvbnN0IHsgaGVhZE1hbmFnZXIsIHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlIH0gPSBwcm9wc1xuXG4gIGZ1bmN0aW9uIGVtaXRDaGFuZ2UoKSB7XG4gICAgaWYgKGhlYWRNYW5hZ2VyICYmIGhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMpIHtcbiAgICAgIGNvbnN0IGhlYWRFbGVtZW50cyA9IENoaWxkcmVuLnRvQXJyYXkoXG4gICAgICAgIEFycmF5LmZyb20oaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcyBhcyBTZXQ8UmVhY3QuUmVhY3ROb2RlPikuZmlsdGVyKFxuICAgICAgICAgIEJvb2xlYW5cbiAgICAgICAgKVxuICAgICAgKSBhcyBSZWFjdC5SZWFjdEVsZW1lbnRbXVxuICAgICAgaGVhZE1hbmFnZXIudXBkYXRlSGVhZChyZWR1Y2VDb21wb25lbnRzVG9TdGF0ZShoZWFkRWxlbWVudHMsIHByb3BzKSlcbiAgICB9XG4gIH1cblxuICBpZiAoaXNTZXJ2ZXIpIHtcbiAgICBoZWFkTWFuYWdlcj8ubW91bnRlZEluc3RhbmNlcz8uYWRkKHByb3BzLmNoaWxkcmVuKVxuICAgIGVtaXRDaGFuZ2UoKVxuICB9XG5cbiAgdXNlQ2xpZW50T25seUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaGVhZE1hbmFnZXI/Lm1vdW50ZWRJbnN0YW5jZXM/LmFkZChwcm9wcy5jaGlsZHJlbilcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaGVhZE1hbmFnZXI/Lm1vdW50ZWRJbnN0YW5jZXM/LmRlbGV0ZShwcm9wcy5jaGlsZHJlbilcbiAgICB9XG4gIH0pXG5cbiAgLy8gV2UgbmVlZCB0byBjYWxsIGB1cGRhdGVIZWFkYCBtZXRob2Qgd2hlbmV2ZXIgdGhlIGBTaWRlRWZmZWN0YCBpcyB0cmlnZ2VyIGluIGFsbFxuICAvLyBsaWZlLWN5Y2xlczogbW91bnQsIHVwZGF0ZSwgdW5tb3VudC4gSG93ZXZlciwgaWYgdGhlcmUgYXJlIG11bHRpcGxlIGBTaWRlRWZmZWN0YHNcbiAgLy8gYmVpbmcgcmVuZGVyZWQsIHdlIG9ubHkgdHJpZ2dlciB0aGUgbWV0aG9kIGZyb20gdGhlIGxhc3Qgb25lLlxuICAvLyBUaGlzIGlzIGVuc3VyZWQgYnkga2VlcGluZyB0aGUgbGFzdCB1bmZsdXNoZWQgYHVwZGF0ZUhlYWRgIGluIHRoZSBgX3BlbmRpbmdVcGRhdGVgXG4gIC8vIHNpbmdsZXRvbiBpbiB0aGUgbGF5b3V0IGVmZmVjdCBwYXNzLCBhbmQgYWN0dWFsbHkgdHJpZ2dlciBpdCBpbiB0aGUgZWZmZWN0IHBhc3MuXG4gIHVzZUNsaWVudE9ubHlMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChoZWFkTWFuYWdlcikge1xuICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBlbWl0Q2hhbmdlXG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoaGVhZE1hbmFnZXIpIHtcbiAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBlbWl0Q2hhbmdlXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIHVzZUNsaWVudE9ubHlFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChoZWFkTWFuYWdlciAmJiBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSkge1xuICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUoKVxuICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBudWxsXG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoaGVhZE1hbmFnZXIgJiYgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUpIHtcbiAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUoKVxuICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIG51bGxcbn1cbiJdLCJuYW1lcyI6WyJTaWRlRWZmZWN0IiwiaXNTZXJ2ZXIiLCJ3aW5kb3ciLCJ1c2VDbGllbnRPbmx5TGF5b3V0RWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlQ2xpZW50T25seUVmZmVjdCIsInVzZUVmZmVjdCIsInByb3BzIiwiaGVhZE1hbmFnZXIiLCJyZWR1Y2VDb21wb25lbnRzVG9TdGF0ZSIsImVtaXRDaGFuZ2UiLCJtb3VudGVkSW5zdGFuY2VzIiwiaGVhZEVsZW1lbnRzIiwiQ2hpbGRyZW4iLCJ0b0FycmF5IiwiQXJyYXkiLCJmcm9tIiwiZmlsdGVyIiwiQm9vbGVhbiIsInVwZGF0ZUhlYWQiLCJhZGQiLCJjaGlsZHJlbiIsImRlbGV0ZSIsIl9wZW5kaW5nVXBkYXRlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DecodeError: function() {\n        return DecodeError;\n    },\n    MiddlewareNotFoundError: function() {\n        return MiddlewareNotFoundError;\n    },\n    MissingStaticPage: function() {\n        return MissingStaticPage;\n    },\n    NormalizeError: function() {\n        return NormalizeError;\n    },\n    PageNotFoundError: function() {\n        return PageNotFoundError;\n    },\n    SP: function() {\n        return SP;\n    },\n    ST: function() {\n        return ST;\n    },\n    WEB_VITALS: function() {\n        return WEB_VITALS;\n    },\n    execOnce: function() {\n        return execOnce;\n    },\n    getDisplayName: function() {\n        return getDisplayName;\n    },\n    getLocationOrigin: function() {\n        return getLocationOrigin;\n    },\n    getURL: function() {\n        return getURL;\n    },\n    isAbsoluteUrl: function() {\n        return isAbsoluteUrl;\n    },\n    isResSent: function() {\n        return isResSent;\n    },\n    loadGetInitialProps: function() {\n        return loadGetInitialProps;\n    },\n    normalizeRepeatedSlashes: function() {\n        return normalizeRepeatedSlashes;\n    },\n    stringifyError: function() {\n        return stringifyError;\n    }\n});\nconst WEB_VITALS = [\n    'CLS',\n    'FCP',\n    'FID',\n    'INP',\n    'LCP',\n    'TTFB'\n];\nfunction execOnce(fn) {\n    let used = false;\n    let result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn(...args);\n        }\n        return result;\n    };\n}\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nconst isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);\nfunction getLocationOrigin() {\n    const { protocol, hostname, port } = window.location;\n    return protocol + \"//\" + hostname + (port ? ':' + port : '');\n}\nfunction getURL() {\n    const { href } = window.location;\n    const origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    const urlParts = url.split('?');\n    const urlNoQuery = urlParts[0];\n    return urlNoQuery // first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, '/').replace(/\\/\\/+/g, '/') + (urlParts[1] ? \"?\" + urlParts.slice(1).join('?') : '');\n}\nasync function loadGetInitialProps(App, ctx) {\n    if (true) {\n        var _App_prototype;\n        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {\n            const message = '\"' + getDisplayName(App) + '.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';\n            throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    // when called from _app `ctx` is nested in `ctx`\n    const res = ctx.res || ctx.ctx && ctx.ctx.res;\n    if (!App.getInitialProps) {\n        if (ctx.ctx && ctx.Component) {\n            // @ts-ignore pageProps default\n            return {\n                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)\n            };\n        }\n        return {};\n    }\n    const props = await App.getInitialProps(ctx);\n    if (res && isResSent(res)) {\n        return props;\n    }\n    if (!props) {\n        const message = '\"' + getDisplayName(App) + '.getInitialProps()\" should resolve to an object. But found \"' + props + '\" instead.';\n        throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (true) {\n        if (Object.keys(props).length === 0 && !ctx.ctx) {\n            console.warn(\"\" + getDisplayName(App) + \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\");\n        }\n    }\n    return props;\n}\nconst SP = typeof performance !== 'undefined';\nconst ST = SP && [\n    'mark',\n    'measure',\n    'getEntriesByName'\n].every((method)=>typeof performance[method] === 'function');\nclass DecodeError extends Error {\n}\nclass NormalizeError extends Error {\n}\nclass PageNotFoundError extends Error {\n    constructor(page){\n        super();\n        this.code = 'ENOENT';\n        this.name = 'PageNotFoundError';\n        this.message = \"Cannot find module for page: \" + page;\n    }\n}\nclass MissingStaticPage extends Error {\n    constructor(page, message){\n        super();\n        this.message = \"Failed to load static file for page: \" + page + \" \" + message;\n    }\n}\nclass MiddlewareNotFoundError extends Error {\n    constructor(){\n        super();\n        this.code = 'ENOENT';\n        this.message = \"Cannot find the middleware module\";\n    }\n}\nfunction stringifyError(error) {\n    return JSON.stringify({\n        message: error.message,\n        stack: error.stack\n    });\n} //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFvYWFBLFdBQVc7ZUFBWEE7O0lBb0JBQyx1QkFBdUI7ZUFBdkJBOztJQVBBQyxpQkFBaUI7ZUFBakJBOztJQVpBQyxjQUFjO2VBQWRBOztJQUNBQyxpQkFBaUI7ZUFBakJBOztJQVRBQyxFQUFFO2VBQUZBOztJQUNBQyxFQUFFO2VBQUZBOztJQWxYQUMsVUFBVTtlQUFWQTs7SUFzUUdDLFFBQVE7ZUFBUkE7O0lBK0JBQyxjQUFjO2VBQWRBOztJQVhBQyxpQkFBaUI7ZUFBakJBOztJQUtBQyxNQUFNO2VBQU5BOztJQVBIQyxhQUFhO2VBQWJBOztJQW1CR0MsU0FBUztlQUFUQTs7SUFrQk1DLG1CQUFtQjtlQUFuQkE7O0lBZE5DLHdCQUF3QjtlQUF4QkE7O0lBK0dBQyxjQUFjO2VBQWRBOzs7QUE5WlQsTUFBTVQsYUFBYTtJQUFDO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztDQUFPO0FBc1E5RCxTQUFTQyxTQUNkUyxFQUFLO0lBRUwsSUFBSUMsT0FBTztJQUNYLElBQUlDO0lBRUosT0FBUTt5Q0FBSUMsT0FBQUEsSUFBQUEsTUFBQUEsT0FBQUEsT0FBQUEsR0FBQUEsT0FBQUEsTUFBQUEsT0FBQUE7WUFBQUEsSUFBQUEsQ0FBQUEsS0FBQUEsR0FBQUEsU0FBQUEsQ0FBQUEsS0FBQUE7O1FBQ1YsSUFBSSxDQUFDRixNQUFNO1lBQ1RBLE9BQU87WUFDUEMsU0FBU0YsTUFBTUc7UUFDakI7UUFDQSxPQUFPRDtJQUNUO0FBQ0Y7QUFFQSwwREFBMEQ7QUFDMUQsZ0VBQWdFO0FBQ2hFLE1BQU1FLHFCQUFxQjtBQUNwQixNQUFNVCxnQkFBZ0IsQ0FBQ1UsTUFBZ0JELG1CQUFtQkUsSUFBSSxDQUFDRDtBQUUvRCxTQUFTWjtJQUNkLE1BQU0sRUFBRWMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLElBQUksRUFBRSxH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QUksR0FBRztRQUNaLElBQUksQ0FBQzlCLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ2lCLE9BQU8sR0FBSSxrQ0FBK0JZO0lBQ2pEO0FBQ0Y7QUFFTyxNQUFNOUQsMEJBQTBCbUQ7SUFDckNVLFlBQVlDLElBQVksRUFBRVosT0FBZSxDQUFFO1FBQ3pDLEtBQUs7UUFDTCxJQUFJLENBQUNBLE9BQU8sR0FBSSwwQ0FBdUNZLE9BQUssTUFBR1o7SUFDakU7QUFDRjtBQUVPLE1BQU1uRCxnQ0FBZ0NvRDtJQUUzQ1UsYUFBYztRQUNaLEtBQUs7UUFDTCxJQUFJLENBQUNFLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ2IsT0FBTyxHQUFJO0lBQ2xCO0FBQ0Y7QUFXTyxTQUFTcEMsZUFBZWtELEtBQVk7SUFDekMsT0FBT0MsS0FBS0MsU0FBUyxDQUFDO1FBQUVoQixTQUFTYyxNQUFNZCxPQUFPO1FBQUVpQixPQUFPSCxNQUFNRyxLQUFLO0lBQUM7QUFDckUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zcmMvc2hhcmVkL2xpYi91dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEh0bWxQcm9wcyB9IGZyb20gJy4vaHRtbC1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHR5cGUgeyBDb21wb25lbnRUeXBlLCBKU1ggfSBmcm9tICdyZWFjdCdcbmltcG9ydCB0eXBlIHsgRG9tYWluTG9jYWxlIH0gZnJvbSAnLi4vLi4vc2VydmVyL2NvbmZpZydcbmltcG9ydCB0eXBlIHsgRW52IH0gZnJvbSAnQG5leHQvZW52J1xuaW1wb3J0IHR5cGUgeyBJbmNvbWluZ01lc3NhZ2UsIFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnaHR0cCdcbmltcG9ydCB0eXBlIHsgTmV4dFJvdXRlciB9IGZyb20gJy4vcm91dGVyL3JvdXRlcidcbmltcG9ydCB0eXBlIHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB0eXBlIHsgUHJldmlld0RhdGEgfSBmcm9tICcuLi8uLi90eXBlcydcbmltcG9ydCB0eXBlIHsgQ09NUElMRVJfTkFNRVMgfSBmcm9tICcuL2NvbnN0YW50cydcbmltcG9ydCB0eXBlIGZzIGZyb20gJ2ZzJ1xuXG5leHBvcnQgdHlwZSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgQ29udGV4dCBleHRlbmRzIEJhc2VDb250ZXh0ID0gTmV4dFBhZ2VDb250ZXh0LFxuICBJbml0aWFsUHJvcHMgPSB7fSxcbiAgUHJvcHMgPSB7fSxcbj4gPSBDb21wb25lbnRUeXBlPFByb3BzPiAmIHtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGluaXRpYWwgcGFnZSBsb2FkIGRhdGEgcG9wdWxhdGlvbi4gRGF0YSByZXR1cm5lZCBmcm9tIGBnZXRJbml0aWFsUHJvcHNgIGlzIHNlcmlhbGl6ZWQgd2hlbiBzZXJ2ZXIgcmVuZGVyZWQuXG4gICAqIE1ha2Ugc3VyZSB0byByZXR1cm4gcGxhaW4gYE9iamVjdGAgd2l0aG91dCB1c2luZyBgRGF0ZWAsIGBNYXBgLCBgU2V0YC5cbiAgICogQHBhcmFtIGNvbnRleHQgQ29udGV4dCBvZiBgcGFnZWBcbiAgICovXG4gIGdldEluaXRpYWxQcm9wcz8oY29udGV4dDogQ29udGV4dCk6IEluaXRpYWxQcm9wcyB8IFByb21pc2U8SW5pdGlhbFByb3BzPlxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFR5cGUgPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgRG9jdW1lbnRDb250ZXh0LFxuICBEb2N1bWVudEluaXRpYWxQcm9wcyxcbiAgRG9jdW1lbnRQcm9wc1xuPlxuXG5leHBvcnQgdHlwZSBBcHBUeXBlPFAgPSB7fT4gPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgQXBwQ29udGV4dFR5cGUsXG4gIFAsXG4gIEFwcFByb3BzVHlwZTxhbnksIFA+XG4+XG5cbmV4cG9ydCB0eXBlIEFwcFRyZWVUeXBlID0gQ29tcG9uZW50VHlwZTxcbiAgQXBwSW5pdGlhbFByb3BzICYgeyBbbmFtZTogc3RyaW5nXTogYW55IH1cbj5cblxuLyoqXG4gKiBXZWIgdml0YWxzIHByb3ZpZGVkIHRvIF9hcHAucmVwb3J0V2ViVml0YWxzIGJ5IENvcmUgV2ViIFZpdGFscyBwbHVnaW4gZGV2ZWxvcGVkIGJ5IEdvb2dsZSBDaHJvbWUgdGVhbS5cbiAqIGh0dHBzOi8vbmV4dGpzLm9yZy9ibG9nL25leHQtOS00I2ludGVncmF0ZWQtd2ViLXZpdGFscy1yZXBvcnRpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IFdFQl9WSVRBTFMgPSBbJ0NMUycsICdGQ1AnLCAnRklEJywgJ0lOUCcsICdMQ1AnLCAnVFRGQiddIGFzIGNvbnN0XG5leHBvcnQgdHlwZSBOZXh0V2ViVml0YWxzTWV0cmljID0ge1xuICBpZDogc3RyaW5nXG4gIHN0YXJ0VGltZTogbnVtYmVyXG4gIHZhbHVlOiBudW1iZXJcbiAgYXR0cmlidXRpb24/OiB7IFtrZXk6IHN0cmluZ106IHVua25vd24gfVxufSAmIChcbiAgfCB7XG4gICAgICBsYWJlbDogJ3dlYi12aXRhbCdcbiAgICAgIG5hbWU6ICh0eXBlb2YgV0VCX1ZJVEFMUylbbnVtYmVyXVxuICAgIH1cbiAgfCB7XG4gICAgICBsYWJlbDogJ2N1c3RvbSdcbiAgICAgIG5hbWU6XG4gICAgICAgIHwgJ05leHQuanMtaHlkcmF0aW9uJ1xuICAgICAgICB8ICdOZXh0LmpzLXJvdXRlLWNoYW5nZS10by1yZW5kZXInXG4gICAgICAgIHwgJ05leHQuanMtcmVuZGVyJ1xuICAgIH1cbilcblxuZXhwb3J0IHR5cGUgRW5oYW5jZXI8Qz4gPSAoQ29tcG9uZW50OiBDKSA9PiBDXG5cbmV4cG9ydCB0eXBlIENvbXBvbmVudHNFbmhhbmNlciA9XG4gIHwge1xuICAgICAgZW5oYW5jZUFwcD86IEVuaGFuY2VyPEFwcFR5cGU+XG4gICAgICBlbmhhbmNlQ29tcG9uZW50PzogRW5oYW5jZXI8TmV4dENvbXBvbmVudFR5cGU+XG4gICAgfVxuICB8IEVuaGFuY2VyPE5leHRDb21wb25lbnRUeXBlPlxuXG5leHBvcnQgdHlwZSBSZW5kZXJQYWdlUmVzdWx0ID0ge1xuICBodG1sOiBzdHJpbmdcbiAgaGVhZD86IEFycmF5PEpTWC5FbGVtZW50IHwgbnVsbD5cbn1cblxuZXhwb3J0IHR5cGUgUmVuZGVyUGFnZSA9IChcbiAgb3B0aW9ucz86IENvbXBvbmVudHNFbmhhbmNlclxuKSA9PiBEb2N1bWVudEluaXRpYWxQcm9wcyB8IFByb21pc2U8RG9jdW1lbnRJbml0aWFsUHJvcHM+XG5cbmV4cG9ydCB0eXBlIEJhc2VDb250ZXh0ID0ge1xuICByZXM/OiBTZXJ2ZXJSZXNwb25zZVxuICBbazogc3RyaW5nXTogYW55XG59XG5cbmV4cG9ydCB0eXBlIE5FWFRfREFUQSA9IHtcbiAgcHJvcHM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgcGFnZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBidWlsZElkOiBzdHJpbmdcbiAgYXNzZXRQcmVmaXg/OiBzdHJpbmdcbiAgcnVudGltZUNvbmZpZz86IHsgW2tleTogc3RyaW5nXTogYW55IH1cbiAgbmV4dEV4cG9ydD86IGJvb2xlYW5cbiAgYXV0b0V4cG9ydD86IGJvb2xlYW5cbiAgaXNGYWxsYmFjaz86IGJvb2xlYW5cbiAgaXNFeHBlcmltZW50YWxDb21waWxlPzogYm9vbGVhblxuICBkeW5hbWljSWRzPzogKHN0cmluZyB8IG51bWJlcilbXVxuICBlcnI/OiBFcnJvciAmIHtcbiAgICBzdGF0dXNDb2RlPzogbnVtYmVyXG4gICAgc291cmNlPzogdHlwZW9mIENPTVBJTEVSX05BTUVTLnNlcnZlciB8IHR5cGVvZiBDT01QSUxFUl9OQU1FUy5lZGdlU2VydmVyXG4gIH1cbiAgZ3NwPzogYm9vbGVhblxuICBnc3NwPzogYm9vbGVhblxuICBjdXN0b21TZXJ2ZXI/OiBib29sZWFuXG4gIGdpcD86IGJvb2xlYW5cbiAgYXBwR2lwPzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmdcbiAgbG9jYWxlcz86IHJlYWRvbmx5IHN0cmluZ1tdXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgZG9tYWluTG9jYWxlcz86IHJlYWRvbmx5IERvbWFpbkxvY2FsZVtdXG4gIHNjcmlwdExvYWRlcj86IGFueVtdXG4gIGlzUHJldmlldz86IGJvb2xlYW5cbiAgbm90Rm91bmRTcmNQYWdlPzogc3RyaW5nXG59XG5cbi8qKlxuICogYE5leHRgIGNvbnRleHRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh0UGFnZUNvbnRleHQge1xuICAvKipcbiAgICogRXJyb3Igb2JqZWN0IGlmIGVuY291bnRlcmVkIGR1cmluZyByZW5kZXJpbmdcbiAgICovXG4gIGVycj86IChFcnJvciAmIHsgc3RhdHVzQ29kZT86IG51bWJlciB9KSB8IG51bGxcbiAgLyoqXG4gICAqIGBIVFRQYCByZXF1ZXN0IG9iamVjdC5cbiAgICovXG4gIHJlcT86IEluY29taW5nTWVzc2FnZVxuICAvKipcbiAgICogYEhUVFBgIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIHJlcz86IFNlcnZlclJlc3BvbnNlXG4gIC8qKlxuICAgKiBQYXRoIHNlY3Rpb24gb2YgYFVSTGAuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nXG4gIC8qKlxuICAgKiBRdWVyeSBzdHJpbmcgc2VjdGlvbiBvZiBgVVJMYCBwYXJzZWQgYXMgYW4gb2JqZWN0LlxuICAgKi9cbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIC8qKlxuICAgKiBgU3RyaW5nYCBvZiB0aGUgYWN0dWFsIHBhdGggaW5jbHVkaW5nIHF1ZXJ5LlxuICAgKi9cbiAgYXNQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBsb2NhbGVcbiAgICovXG4gIGxvY2FsZT86IHN0cmluZ1xuICAvKipcbiAgICogQWxsIGNvbmZpZ3VyZWQgbG9jYWxlc1xuICAgKi9cbiAgbG9jYWxlcz86IHJlYWRvbmx5IHN0cmluZ1tdXG4gIC8qKlxuICAgKiBUaGUgY29uZmlndXJlZCBkZWZhdWx0IGxvY2FsZVxuICAgKi9cbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICAvKipcbiAgICogYENvbXBvbmVudGAgdGhlIHRyZWUgb2YgdGhlIEFwcCB0byB1c2UgaWYgbmVlZGluZyB0byByZW5kZXIgc2VwYXJhdGVseVxuICAgKi9cbiAgQXBwVHJlZTogQXBwVHJlZVR5cGVcbn1cblxuZXhwb3J0IHR5cGUgQXBwQ29udGV4dFR5cGU8Um91dGVyIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXI+ID0ge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dD5cbiAgQXBwVHJlZTogQXBwVHJlZVR5cGVcbiAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgcm91dGVyOiBSb3V0ZXJcbn1cblxuZXhwb3J0IHR5cGUgQXBwSW5pdGlhbFByb3BzPFBhZ2VQcm9wcyA9IGFueT4gPSB7XG4gIHBhZ2VQcm9wczogUGFnZVByb3BzXG59XG5cbmV4cG9ydCB0eXBlIEFwcFByb3BzVHlwZTxcbiAgUm91dGVyIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXIsXG4gIFBhZ2VQcm9wcyA9IHt9LFxuPiA9IEFwcEluaXRpYWxQcm9wczxQYWdlUHJvcHM+ICYge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dCwgYW55LCBhbnk+XG4gIHJvdXRlcjogUm91dGVyXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50Q29udGV4dCA9IE5leHRQYWdlQ29udGV4dCAmIHtcbiAgcmVuZGVyUGFnZTogUmVuZGVyUGFnZVxuICBkZWZhdWx0R2V0SW5pdGlhbFByb3BzKFxuICAgIGN0eDogRG9jdW1lbnRDb250ZXh0LFxuICAgIG9wdGlvbnM/OiB7IG5vbmNlPzogc3RyaW5nIH1cbiAgKTogUHJvbWlzZTxEb2N1bWVudEluaXRpYWxQcm9wcz5cbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRJbml0aWFsUHJvcHMgPSBSZW5kZXJQYWdlUmVzdWx0ICYge1xuICBzdHlsZXM/OiBSZWFjdC5SZWFjdEVsZW1lbnRbXSB8IEl0ZXJhYmxlPFJlYWN0LlJlYWN0Tm9kZT4gfCBKU1guRWxlbWVudFxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFByb3BzID0gRG9jdW1lbnRJbml0aWFsUHJvcHMgJiBIdG1sUHJvcHNcblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIHJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh0QXBpUmVxdWVzdCBleHRlbmRzIEluY29taW5nTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBPYmplY3Qgb2YgYHF1ZXJ5YCB2YWx1ZXMgZnJvbSB1cmxcbiAgICovXG4gIHF1ZXJ5OiBQYXJ0aWFsPHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBzdHJpbmdbXVxuICB9PlxuICAvKipcbiAgICogT2JqZWN0IG9mIGBjb29raWVzYCBmcm9tIGhlYWRlclxuICAgKi9cbiAgY29va2llczogUGFydGlhbDx7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nXG4gIH0+XG5cbiAgYm9keTogYW55XG5cbiAgZW52OiBFbnZcblxuICBkcmFmdE1vZGU/OiBib29sZWFuXG5cbiAgcHJldmlldz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFByZXZpZXcgZGF0YSBzZXQgb24gdGhlIHJlcXVlc3QsIGlmIGFueVxuICAgKiAqL1xuICBwcmV2aWV3RGF0YT86IFByZXZpZXdEYXRhXG59XG5cbi8qKlxuICogU2VuZCBib2R5IG9mIHJlc3BvbnNlXG4gKi9cbnR5cGUgU2VuZDxUPiA9IChib2R5OiBUKSA9PiB2b2lkXG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSByZXNwb25zZVxuICovXG5leHBvcnQgdHlwZSBOZXh0QXBpUmVzcG9uc2U8RGF0YSA9IGFueT4gPSBTZXJ2ZXJSZXNwb25zZSAmIHtcbiAgLyoqXG4gICAqIFNlbmQgZGF0YSBgYW55YCBkYXRhIGluIHJlc3BvbnNlXG4gICAqL1xuICBzZW5kOiBTZW5kPERhdGE+XG4gIC8qKlxuICAgKiBTZW5kIGRhdGEgYGpzb25gIGRhdGEgaW4gcmVzcG9uc2VcbiAgICovXG4gIGpzb246IFNlbmQ8RGF0YT5cbiAgc3RhdHVzOiAoc3RhdHVzQ29kZTogbnVtYmVyKSA9PiBOZXh0QXBpUmVzcG9uc2U8RGF0YT5cbiAgcmVkaXJlY3QodXJsOiBzdHJpbmcpOiBOZXh0QXBpUmVzcG9uc2U8RGF0YT5cbiAgcmVkaXJlY3Qoc3RhdHVzOiBudW1iZXIsIHVybDogc3RyaW5nKTogTmV4dEFwaVJlc3BvbnNlPERhdGE+XG5cbiAgLyoqXG4gICAqIFNldCBkcmFmdCBtb2RlXG4gICAqL1xuICBzZXREcmFmdE1vZGU6IChvcHRpb25zOiB7IGVuYWJsZTogYm9vbGVhbiB9KSA9PiBOZXh0QXBpUmVzcG9uc2U8RGF0YT5cblxuICAvKipcbiAgICogU2V0IHByZXZpZXcgZGF0YSBmb3IgTmV4dC5qcycgcHJlcmVuZGVyIG1vZGVcbiAgICovXG4gIHNldFByZXZpZXdEYXRhOiAoXG4gICAgZGF0YTogb2JqZWN0IHwgc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICAvKipcbiAgICAgICAqIFNwZWNpZmllcyB0aGUgbnVtYmVyIChpbiBzZWNvbmRzKSBmb3IgdGhlIHByZXZpZXcgc2Vzc2lvbiB0byBsYXN0IGZvci5cbiAgICAgICAqIFRoZSBnaXZlbiBudW1iZXIgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlciBieSByb3VuZGluZyBkb3duLlxuICAgICAgICogQnkgZGVmYXVsdCwgbm8gbWF4aW11bSBhZ2UgaXMgc2V0IGFuZCB0aGUgcHJldmlldyBzZXNzaW9uIGZpbmlzaGVzXG4gICAgICAgKiB3aGVuIHRoZSBjbGllbnQgc2h1dHMgZG93biAoYnJvd3NlciBpcyBjbG9zZWQpLlxuICAgICAgICovXG4gICAgICBtYXhBZ2U/OiBudW1iZXJcbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lmaWVzIHRoZSBwYXRoIGZvciB0aGUgcHJldmlldyBzZXNzaW9uIHRvIHdvcmsgdW5kZXIuIEJ5IGRlZmF1bHQsXG4gICAgICAgKiB0aGUgcGF0aCBpcyBjb25zaWRlcmVkIHRoZSBcImRlZmF1bHQgcGF0aFwiLCBpLmUuLCBhbnkgcGFnZXMgdW5kZXIgXCIvXCIuXG4gICAgICAgKi9cbiAgICAgIHBhdGg/OiBzdHJpbmdcbiAgICB9XG4gICkgPT4gTmV4dEFwaVJlc3BvbnNlPERhdGE+XG5cbiAgLyoqXG4gICAqIENsZWFyIHByZXZpZXcgZGF0YSBmb3IgTmV4dC5qcycgcHJlcmVuZGVyIG1vZGVcbiAgICovXG4gIGNsZWFyUHJldmlld0RhdGE6IChvcHRpb25zPzogeyBwYXRoPzogc3RyaW5nIH0pID0+IE5leHRBcGlSZXNwb25zZTxEYXRhPlxuXG4gIC8qKlxuICAgKiBSZXZhbGlkYXRlIGEgc3BlY2lmaWMgcGFnZSBhbmQgcmVnZW5lcmF0ZSBpdCB1c2luZyBPbi1EZW1hbmQgSW5jcmVtZW50YWxcbiAgICogU3RhdGljIFJlZ2VuZXJhdGlvbi5cbiAgICogVGhlIHBhdGggc2hvdWxkIGJlIGFuIGFjdHVhbCBwYXRoLCBub3QgYSByZXdyaXR0ZW4gcGF0aC4gRS5nLiBmb3JcbiAgICogXCIvYmxvZy9bc2x1Z11cIiB0aGlzIHNob3VsZCBiZSBcIi9ibG9nL3Bvc3QtMVwiLlxuICAgKiBAbGluayBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9kYXRhLWZldGNoaW5nL2luY3JlbWVudGFsLXN0YXRpYy1yZWdlbmVyYXRpb24jb24tZGVtYW5kLXJldmFsaWRhdGlvbi13aXRoLXJldmFsaWRhdGVwYXRoXG4gICAqL1xuICByZXZhbGlkYXRlOiAoXG4gICAgdXJsUGF0aDogc3RyaW5nLFxuICAgIG9wdHM/OiB7XG4gICAgICB1bnN0YWJsZV9vbmx5R2VuZXJhdGVkPzogYm9vbGVhblxuICAgIH1cbiAgKSA9PiBQcm9taXNlPHZvaWQ+XG59XG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSBoYW5kbGVyXG4gKi9cbmV4cG9ydCB0eXBlIE5leHRBcGlIYW5kbGVyPFQgPSBhbnk+ID0gKFxuICByZXE6IE5leHRBcGlSZXF1ZXN0LFxuICByZXM6IE5leHRBcGlSZXNwb25zZTxUPlxuKSA9PiB1bmtub3duIHwgUHJvbWlzZTx1bmtub3duPlxuXG4vKipcbiAqIFV0aWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjT25jZTxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBSZXR1cm5UeXBlPFQ+PihcbiAgZm46IFRcbik6IFQge1xuICBsZXQgdXNlZCA9IGZhbHNlXG4gIGxldCByZXN1bHQ6IFJldHVyblR5cGU8VD5cblxuICByZXR1cm4gKCguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgIGlmICghdXNlZCkge1xuICAgICAgdXNlZCA9IHRydWVcbiAgICAgIHJlc3VsdCA9IGZuKC4uLmFyZ3MpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSkgYXMgVFxufVxuXG4vLyBTY2hlbWU6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4xXG4vLyBBYnNvbHV0ZSBVUkw6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNC4zXG5jb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo/Oi9cbmV4cG9ydCBjb25zdCBpc0Fic29sdXRlVXJsID0gKHVybDogc3RyaW5nKSA9PiBBQlNPTFVURV9VUkxfUkVHRVgudGVzdCh1cmwpXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2NhdGlvbk9yaWdpbigpIHtcbiAgY29uc3QgeyBwcm90b2NvbCwgaG9zdG5hbWUsIHBvcnQgfSA9IHdpbmRvdy5sb2NhdGlvblxuICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3RuYW1lfSR7cG9ydCA/ICc6JyArIHBvcnQgOiAnJ31gXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVUkwoKSB7XG4gIGNvbnN0IHsgaHJlZiB9ID0gd2luZG93LmxvY2F0aW9uXG4gIGNvbnN0IG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcbiAgcmV0dXJuIGhyZWYuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXNwbGF5TmFtZTxQPihDb21wb25lbnQ6IENvbXBvbmVudFR5cGU8UD4pIHtcbiAgcmV0dXJuIHR5cGVvZiBDb21wb25lbnQgPT09ICdzdHJpbmcnXG4gICAgPyBDb21wb25lbnRcbiAgICA6IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnVW5rbm93bidcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVzU2VudChyZXM6IFNlcnZlclJlc3BvbnNlKSB7XG4gIHJldHVybiByZXMuZmluaXNoZWQgfHwgcmVzLmhlYWRlcnNTZW50XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVSZXBlYXRlZFNsYXNoZXModXJsOiBzdHJpbmcpIHtcbiAgY29uc3QgdXJsUGFydHMgPSB1cmwuc3BsaXQoJz8nKVxuICBjb25zdCB1cmxOb1F1ZXJ5ID0gdXJsUGFydHNbMF1cblxuICByZXR1cm4gKFxuICAgIHVybE5vUXVlcnlcbiAgICAgIC8vIGZpcnN0IHdlIHJlcGxhY2UgYW55IG5vbi1lbmNvZGVkIGJhY2tzbGFzaGVzIHdpdGggZm9yd2FyZFxuICAgICAgLy8gdGhlbiBub3JtYWxpemUgcmVwZWF0ZWQgZm9yd2FyZCBzbGFzaGVzXG4gICAgICAucmVwbGFjZSgvXFxcXC9nLCAnLycpXG4gICAgICAucmVwbGFjZSgvXFwvXFwvKy9nLCAnLycpICtcbiAgICAodXJsUGFydHNbMV0gPyBgPyR7dXJsUGFydHMuc2xpY2UoMSkuam9pbignPycpfWAgOiAnJylcbiAgKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZEdldEluaXRpYWxQcm9wczxcbiAgQyBleHRlbmRzIEJhc2VDb250ZXh0LFxuICBJUCA9IHt9LFxuICBQID0ge30sXG4+KEFwcDogTmV4dENvbXBvbmVudFR5cGU8QywgSVAsIFA+LCBjdHg6IEMpOiBQcm9taXNlPElQPiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKEFwcC5wcm90b3R5cGU/LmdldEluaXRpYWxQcm9wcykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICAgIEFwcFxuICAgICAgKX0uZ2V0SW5pdGlhbFByb3BzKClcIiBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAtIHZpc2l0IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2dldC1pbml0aWFsLXByb3BzLWFzLWFuLWluc3RhbmNlLW1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICB9XG4gIH1cbiAgLy8gd2hlbiBjYWxsZWQgZnJvbSBfYXBwIGBjdHhgIGlzIG5lc3RlZCBpbiBgY3R4YFxuICBjb25zdCByZXMgPSBjdHgucmVzIHx8IChjdHguY3R4ICYmIGN0eC5jdHgucmVzKVxuXG4gIGlmICghQXBwLmdldEluaXRpYWxQcm9wcykge1xuICAgIGlmIChjdHguY3R4ICYmIGN0eC5Db21wb25lbnQpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgcGFnZVByb3BzIGRlZmF1bHRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2VQcm9wczogYXdhaXQgbG9hZEdldEluaXRpYWxQcm9wcyhjdHguQ29tcG9uZW50LCBjdHguY3R4KSxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHt9IGFzIElQXG4gIH1cblxuICBjb25zdCBwcm9wcyA9IGF3YWl0IEFwcC5nZXRJbml0aWFsUHJvcHMoY3R4KVxuXG4gIGlmIChyZXMgJiYgaXNSZXNTZW50KHJlcykpIHtcbiAgICByZXR1cm4gcHJvcHNcbiAgfVxuXG4gIGlmICghcHJvcHMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShcbiAgICAgIEFwcFxuICAgICl9LmdldEluaXRpYWxQcm9wcygpXCIgc2hvdWxkIHJlc29sdmUgdG8gYW4gb2JqZWN0LiBCdXQgZm91bmQgXCIke3Byb3BzfVwiIGluc3RlYWQuYFxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA9PT0gMCAmJiAhY3R4LmN0eCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgJHtnZXREaXNwbGF5TmFtZShcbiAgICAgICAgICBBcHBcbiAgICAgICAgKX0gcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0IGZyb20gXFxgZ2V0SW5pdGlhbFByb3BzXFxgLiBUaGlzIGRlLW9wdGltaXplcyBhbmQgcHJldmVudHMgYXV0b21hdGljIHN0YXRpYyBvcHRpbWl6YXRpb24uIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2VtcHR5LW9iamVjdC1nZXRJbml0aWFsUHJvcHNgXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb3BzXG59XG5cbmV4cG9ydCBjb25zdCBTUCA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCdcbmV4cG9ydCBjb25zdCBTVCA9XG4gIFNQICYmXG4gIChbJ21hcmsnLCAnbWVhc3VyZScsICdnZXRFbnRyaWVzQnlOYW1lJ10gYXMgY29uc3QpLmV2ZXJ5KFxuICAgIChtZXRob2QpID0+IHR5cGVvZiBwZXJmb3JtYW5jZVttZXRob2RdID09PSAnZnVuY3Rpb24nXG4gIClcblxuZXhwb3J0IGNsYXNzIERlY29kZUVycm9yIGV4dGVuZHMgRXJyb3Ige31cbmV4cG9ydCBjbGFzcyBOb3JtYWxpemVFcnJvciBleHRlbmRzIEVycm9yIHt9XG5leHBvcnQgY2xhc3MgUGFnZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvZGU6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKHBhZ2U6IHN0cmluZykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmNvZGUgPSAnRU5PRU5UJ1xuICAgIHRoaXMubmFtZSA9ICdQYWdlTm90Rm91bmRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBgQ2Fubm90IGZpbmQgbW9kdWxlIGZvciBwYWdlOiAke3BhZ2V9YFxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNaXNzaW5nU3RhdGljUGFnZSBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocGFnZTogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5tZXNzYWdlID0gYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBmaWxlIGZvciBwYWdlOiAke3BhZ2V9ICR7bWVzc2FnZX1gXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1pZGRsZXdhcmVOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb2RlOiBzdHJpbmdcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuY29kZSA9ICdFTk9FTlQnXG4gICAgdGhpcy5tZXNzYWdlID0gYENhbm5vdCBmaW5kIHRoZSBtaWRkbGV3YXJlIG1vZHVsZWBcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlRnMge1xuICBleGlzdHNTeW5jOiB0eXBlb2YgZnMuZXhpc3RzU3luY1xuICByZWFkRmlsZTogdHlwZW9mIGZzLnByb21pc2VzLnJlYWRGaWxlXG4gIHJlYWRGaWxlU3luYzogdHlwZW9mIGZzLnJlYWRGaWxlU3luY1xuICB3cml0ZUZpbGUoZjogc3RyaW5nLCBkOiBhbnkpOiBQcm9taXNlPHZvaWQ+XG4gIG1rZGlyKGRpcjogc3RyaW5nKTogUHJvbWlzZTx2b2lkIHwgc3RyaW5nPlxuICBzdGF0KGY6IHN0cmluZyk6IFByb21pc2U8eyBtdGltZTogRGF0ZSB9PlxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5RXJyb3IoZXJyb3I6IEVycm9yKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh7IG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsIHN0YWNrOiBlcnJvci5zdGFjayB9KVxufVxuIl0sIm5hbWVzIjpbIkRlY29kZUVycm9yIiwiTWlkZGxld2FyZU5vdEZvdW5kRXJyb3IiLCJNaXNzaW5nU3RhdGljUGFnZSIsIk5vcm1hbGl6ZUVycm9yIiwiUGFnZU5vdEZvdW5kRXJyb3IiLCJTUCIsIlNUIiwiV0VCX1ZJVEFMUyIsImV4ZWNPbmNlIiwiZ2V0RGlzcGxheU5hbWUiLCJnZXRMb2NhdGlvbk9yaWdpbiIsImdldFVSTCIsImlzQWJzb2x1dGVVcmwiLCJpc1Jlc1NlbnQiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwibm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzIiwic3RyaW5naWZ5RXJyb3IiLCJmbiIsInVzZWQiLCJyZXN1bHQiLCJhcmdzIiwiQUJTT0xVVEVfVVJMX1JFR0VYIiwidXJsIiwidGVzdCIsInByb3RvY29sIiwiaG9zdG5hbWUiLCJwb3J0Iiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwib3JpZ2luIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwiQ29tcG9uZW50IiwiZGlzcGxheU5hbWUiLCJuYW1lIiwicmVzIiwiZmluaXNoZWQiLCJoZWFkZXJzU2VudCIsInVybFBhcnRzIiwic3BsaXQiLCJ1cmxOb1F1ZXJ5IiwicmVwbGFjZSIsInNsaWNlIiwiam9pbiIsIkFwcCIsImN0eCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInByb3RvdHlwZSIsImdldEluaXRpYWxQcm9wcyIsIm1lc3NhZ2UiLCJFcnJvciIsInBhZ2VQcm9wcyIsInByb3BzIiwiT2JqZWN0Iiwia2V5cyIsImNvbnNvbGUiLCJ3YXJuIiwicGVyZm9ybWFuY2UiLCJldmVyeSIsIm1ldGhvZCIsImNvbnN0cnVjdG9yIiwicGFnZSIsImNvZGUiLCJlcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdGFjayJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/error-once.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils/error-once.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"errorOnce\", ({\n    enumerable: true,\n    get: function() {\n        return errorOnce;\n    }\n}));\nlet errorOnce = (_)=>{};\nif (true) {\n    const errors = new Set();\n    errorOnce = (msg)=>{\n        if (!errors.has(msg)) {\n            console.error(msg);\n        }\n        errors.add(msg);\n    };\n} //# sourceMappingURL=error-once.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy9lcnJvci1vbmNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7NkNBV1NBOzs7ZUFBQUE7OztBQVhULElBQUlBLFlBQVksQ0FBQ0MsS0FBZTtBQUNoQyxJQUFJQyxJQUFvQixFQUFtQjtJQUN6QyxNQUFNRyxTQUFTLElBQUlDO0lBQ25CTixZQUFZLENBQUNPO1FBQ1gsSUFBSSxDQUFDRixPQUFPRyxHQUFHLENBQUNELE1BQU07WUFDcEJFLFFBQVFDLEtBQUssQ0FBQ0g7UUFDaEI7UUFDQUYsT0FBT00sR0FBRyxDQUFDSjtJQUNiO0FBQ0YiLCJzb3VyY2VzIjpbIi9zcmMvc2hhcmVkL2xpYi91dGlscy9lcnJvci1vbmNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImxldCBlcnJvck9uY2UgPSAoXzogc3RyaW5nKSA9PiB7fVxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgY29uc3QgZXJyb3JzID0gbmV3IFNldDxzdHJpbmc+KClcbiAgZXJyb3JPbmNlID0gKG1zZzogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFlcnJvcnMuaGFzKG1zZykpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobXNnKVxuICAgIH1cbiAgICBlcnJvcnMuYWRkKG1zZylcbiAgfVxufVxuXG5leHBvcnQgeyBlcnJvck9uY2UgfVxuIl0sIm5hbWVzIjpbImVycm9yT25jZSIsIl8iLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJlcnJvcnMiLCJTZXQiLCJtc2ciLCJoYXMiLCJjb25zb2xlIiwiZXJyb3IiLCJhZGQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/error-once.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/swr/dist/_internal/config-context-client-BoS53ST9.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/swr/dist/_internal/config-context-client-BoS53ST9.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ noop),\n/* harmony export */   B: () => (/* binding */ isPromiseLike),\n/* harmony export */   I: () => (/* binding */ IS_REACT_LEGACY),\n/* harmony export */   O: () => (/* binding */ OBJECT),\n/* harmony export */   S: () => (/* binding */ SWRConfigContext),\n/* harmony export */   U: () => (/* binding */ UNDEFINED),\n/* harmony export */   a: () => (/* binding */ isFunction),\n/* harmony export */   b: () => (/* binding */ SWRGlobalState),\n/* harmony export */   c: () => (/* binding */ cache),\n/* harmony export */   d: () => (/* binding */ defaultConfig),\n/* harmony export */   e: () => (/* binding */ isUndefined),\n/* harmony export */   f: () => (/* binding */ mergeConfigs),\n/* harmony export */   g: () => (/* binding */ SWRConfig),\n/* harmony export */   h: () => (/* binding */ initCache),\n/* harmony export */   i: () => (/* binding */ isWindowDefined),\n/* harmony export */   j: () => (/* binding */ mutate),\n/* harmony export */   k: () => (/* binding */ compare),\n/* harmony export */   l: () => (/* binding */ stableHash),\n/* harmony export */   m: () => (/* binding */ mergeObjects),\n/* harmony export */   n: () => (/* binding */ internalMutate),\n/* harmony export */   o: () => (/* binding */ getTimestamp),\n/* harmony export */   p: () => (/* binding */ preset),\n/* harmony export */   q: () => (/* binding */ defaultConfigOptions),\n/* harmony export */   r: () => (/* binding */ IS_SERVER),\n/* harmony export */   s: () => (/* binding */ serialize),\n/* harmony export */   t: () => (/* binding */ rAF),\n/* harmony export */   u: () => (/* binding */ useIsomorphicLayoutEffect),\n/* harmony export */   v: () => (/* binding */ slowConnection),\n/* harmony export */   w: () => (/* binding */ isDocumentDefined),\n/* harmony export */   x: () => (/* binding */ isLegacyDeno),\n/* harmony export */   y: () => (/* binding */ hasRequestAnimationFrame),\n/* harmony export */   z: () => (/* binding */ createCacheHelper)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _events_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events.mjs */ \"(app-pages-browser)/./node_modules/swr/dist/_internal/events.mjs\");\n/* harmony import */ var dequal_lite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dequal/lite */ \"(app-pages-browser)/./node_modules/dequal/lite/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ A,B,I,O,S,U,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z auto */ var _s = $RefreshSig$();\n\n\n\n// Global state used to deduplicate requests and store listeners\nconst SWRGlobalState = new WeakMap();\n// Shared state between server components and client components\nconst noop = ()=>{};\n// Using noop() as the undefined value as undefined can be replaced\n// by something else. Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nconst UNDEFINED = /*#__NOINLINE__*/ noop();\nconst OBJECT = Object;\nconst isUndefined = (v)=>v === UNDEFINED;\nconst isFunction = (v)=>typeof v == 'function';\nconst mergeObjects = (a, b)=>({\n        ...a,\n        ...b\n    });\nconst isPromiseLike = (x)=>isFunction(x.then);\nconst EMPTY_CACHE = {};\nconst INITIAL_CACHE = {};\nconst STR_UNDEFINED = 'undefined';\n// NOTE: Use the function to guarantee it's re-evaluated between jsdom and node runtime for tests.\nconst isWindowDefined = typeof window != STR_UNDEFINED;\nconst isDocumentDefined = typeof document != STR_UNDEFINED;\nconst isLegacyDeno = isWindowDefined && 'Deno' in window;\nconst hasRequestAnimationFrame = ()=>isWindowDefined && typeof window['requestAnimationFrame'] != STR_UNDEFINED;\nconst createCacheHelper = (cache, key)=>{\n    const state = SWRGlobalState.get(cache);\n    return [\n        // Getter\n        ()=>!isUndefined(key) && cache.get(key) || EMPTY_CACHE,\n        // Setter\n        (info)=>{\n            if (!isUndefined(key)) {\n                const prev = cache.get(key);\n                // Before writing to the store, we keep the value in the initial cache\n                // if it's not there yet.\n                if (!(key in INITIAL_CACHE)) {\n                    INITIAL_CACHE[key] = prev;\n                }\n                state[5](key, mergeObjects(prev, info), prev || EMPTY_CACHE);\n            }\n        },\n        // Subscriber\n        state[6],\n        // Get server cache snapshot\n        ()=>{\n            if (!isUndefined(key)) {\n                // If the cache was updated on the client, we return the stored initial value.\n                if (key in INITIAL_CACHE) return INITIAL_CACHE[key];\n            }\n            // If we haven't done any client-side updates, we return the current value.\n            return !isUndefined(key) && cache.get(key) || EMPTY_CACHE;\n        }\n    ];\n} // export { UNDEFINED, OBJECT, isUndefined, isFunction, mergeObjects, isPromiseLike }\n;\n/**\n * Due to the bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,\n * it's not reliable to detect if the browser is currently online or offline\n * based on `navigator.onLine`.\n * As a workaround, we always assume it's online on the first load, and change\n * the status upon `online` or `offline` events.\n */ let online = true;\nconst isOnline = ()=>online;\n// For node and React Native, `add/removeEventListener` doesn't exist on window.\nconst [onWindowEvent, offWindowEvent] = isWindowDefined && window.addEventListener ? [\n    window.addEventListener.bind(window),\n    window.removeEventListener.bind(window)\n] : [\n    noop,\n    noop\n];\nconst isVisible = ()=>{\n    const visibilityState = isDocumentDefined && document.visibilityState;\n    return isUndefined(visibilityState) || visibilityState !== 'hidden';\n};\nconst initFocus = (callback)=>{\n    // focus revalidate\n    if (isDocumentDefined) {\n        document.addEventListener('visibilitychange', callback);\n    }\n    onWindowEvent('focus', callback);\n    return ()=>{\n        if (isDocumentDefined) {\n            document.removeEventListener('visibilitychange', callback);\n        }\n        offWindowEvent('focus', callback);\n    };\n};\nconst initReconnect = (callback)=>{\n    // revalidate on reconnected\n    const onOnline = ()=>{\n        online = true;\n        callback();\n    };\n    // nothing to revalidate, just update the status\n    const onOffline = ()=>{\n        online = false;\n    };\n    onWindowEvent('online', onOnline);\n    onWindowEvent('offline', onOffline);\n    return ()=>{\n        offWindowEvent('online', onOnline);\n        offWindowEvent('offline', onOffline);\n    };\n};\nconst preset = {\n    isOnline,\n    isVisible\n};\nconst defaultConfigOptions = {\n    initFocus,\n    initReconnect\n};\nconst IS_REACT_LEGACY = !react__WEBPACK_IMPORTED_MODULE_0__.useId;\nconst IS_SERVER = !isWindowDefined || isLegacyDeno;\n// Polyfill requestAnimationFrame\nconst rAF = (f)=>hasRequestAnimationFrame() ? window['requestAnimationFrame'](f) : setTimeout(f, 1);\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nconst useIsomorphicLayoutEffect = IS_SERVER ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\n// This assignment is to extend the Navigator type to use effectiveType.\nconst navigatorConnection = typeof navigator !== 'undefined' && navigator.connection;\n// Adjust the config based on slow connection status (<= 70Kbps).\nconst slowConnection = !IS_SERVER && navigatorConnection && ([\n    'slow-2g',\n    '2g'\n].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nconst table = new WeakMap();\nconst getTypeName = (value)=>OBJECT.prototype.toString.call(value);\nconst isObjectTypeName = (typeName, type)=>typeName === \"[object \".concat(type, \"]\");\n// counter of the key\nlet counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsable.\nconst stableHash = (arg)=>{\n    const type = typeof arg;\n    const typeName = getTypeName(arg);\n    const isDate = isObjectTypeName(typeName, 'Date');\n    const isRegex = isObjectTypeName(typeName, 'RegExp');\n    const isPlainObject = isObjectTypeName(typeName, 'Object');\n    let result;\n    let index;\n    if (OBJECT(arg) === arg && !isDate && !isRegex) {\n        // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n        // If it's already hashed, directly return the result.\n        result = table.get(arg);\n        if (result) return result;\n        // Store the hash first for circular reference detection before entering the\n        // recursive `stableHash` calls.\n        // For other objects like set and map, we use this id directly as the hash.\n        result = ++counter + '~';\n        table.set(arg, result);\n        if (Array.isArray(arg)) {\n            // Array.\n            result = '@';\n            for(index = 0; index < arg.length; index++){\n                result += stableHash(arg[index]) + ',';\n            }\n            table.set(arg, result);\n        }\n        if (isPlainObject) {\n            // Object, sort keys.\n            result = '#';\n            const keys = OBJECT.keys(arg).sort();\n            while(!isUndefined(index = keys.pop())){\n                if (!isUndefined(arg[index])) {\n                    result += index + ':' + stableHash(arg[index]) + ',';\n                }\n            }\n            table.set(arg, result);\n        }\n    } else {\n        result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;\n    }\n    return result;\n};\nconst serialize = (key)=>{\n    if (isFunction(key)) {\n        try {\n            key = key();\n        } catch (err) {\n            // dependencies not ready\n            key = '';\n        }\n    }\n    // Use the original key as the argument of fetcher. This can be a string or an\n    // array of values.\n    const args = key;\n    // If key is not falsy, or not an empty array, hash it.\n    key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';\n    return [\n        key,\n        args\n    ];\n};\n// Global timestamp.\nlet __timestamp = 0;\nconst getTimestamp = ()=>++__timestamp;\nasync function internalMutate() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    const [cache, _key1, _data, _opts] = args;\n    // When passing as a boolean, it's explicitly used to disable/enable\n    // revalidation.\n    const options = mergeObjects({\n        populateCache: true,\n        throwOnError: true\n    }, typeof _opts === 'boolean' ? {\n        revalidate: _opts\n    } : _opts || {});\n    let populateCache = options.populateCache;\n    const rollbackOnErrorOption = options.rollbackOnError;\n    let optimisticData = options.optimisticData;\n    const rollbackOnError = (error)=>{\n        return typeof rollbackOnErrorOption === 'function' ? rollbackOnErrorOption(error) : rollbackOnErrorOption !== false;\n    };\n    const throwOnError = options.throwOnError;\n    // If the second argument is a key filter, return the mutation results for all\n    // filtered keys.\n    if (isFunction(_key1)) {\n        const keyFilter = _key1;\n        const matchedKeys = [];\n        const it = cache.keys();\n        for (const key of it){\n            if (!/^\\$(inf|sub)\\$/.test(key) && keyFilter(cache.get(key)._k)) {\n                matchedKeys.push(key);\n            }\n        }\n        return Promise.all(matchedKeys.map(mutateByKey));\n    }\n    return mutateByKey(_key1);\n    async function mutateByKey(_k) {\n        // Serialize key\n        const [key] = serialize(_k);\n        if (!key) return;\n        const [get, set] = createCacheHelper(cache, key);\n        const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = SWRGlobalState.get(cache);\n        const startRevalidate = ()=>{\n            const revalidators = EVENT_REVALIDATORS[key];\n            const revalidate = isFunction(options.revalidate) ? options.revalidate(get().data, _k) : options.revalidate !== false;\n            if (revalidate) {\n                // Invalidate the key by deleting the concurrent request markers so new\n                // requests will not be deduped.\n                delete FETCH[key];\n                delete PRELOAD[key];\n                if (revalidators && revalidators[0]) {\n                    return revalidators[0](_events_mjs__WEBPACK_IMPORTED_MODULE_2__.MUTATE_EVENT).then(()=>get().data);\n                }\n            }\n            return get().data;\n        };\n        // If there is no new data provided, revalidate the key with current state.\n        if (args.length < 3) {\n            // Revalidate and broadcast state.\n            return startRevalidate();\n        }\n        let data = _data;\n        let error;\n        let isError = false;\n        // Update global timestamps.\n        const beforeMutationTs = getTimestamp();\n        MUTATION[key] = [\n            beforeMutationTs,\n            0\n        ];\n        const hasOptimisticData = !isUndefined(optimisticData);\n        const state = get();\n        // `displayedData` is the current value on screen. It could be the optimistic value\n        // that is going to be overridden by a `committedData`, or get reverted back.\n        // `committedData` is the validated value that comes from a fetch or mutation.\n        const displayedData = state.data;\n        const currentData = state._c;\n        const committedData = isUndefined(currentData) ? displayedData : currentData;\n        // Do optimistic data update.\n        if (hasOptimisticData) {\n            optimisticData = isFunction(optimisticData) ? optimisticData(committedData, displayedData) : optimisticData;\n            // When we set optimistic data, backup the current committedData data in `_c`.\n            set({\n                data: optimisticData,\n                _c: committedData\n            });\n        }\n        if (isFunction(data)) {\n            // `data` is a function, call it passing current cache value.\n            try {\n                data = data(committedData);\n            } catch (err) {\n                // If it throws an error synchronously, we shouldn't update the cache.\n                error = err;\n                isError = true;\n            }\n        }\n        // `data` is a promise/thenable, resolve the final data first.\n        if (data && isPromiseLike(data)) {\n            // This means that the mutation is async, we need to check timestamps to\n            // avoid race conditions.\n            data = await data.catch((err)=>{\n                error = err;\n                isError = true;\n            });\n            // Check if other mutations have occurred since we've started this mutation.\n            // If there's a race we don't update cache or broadcast the change,\n            // just return the data.\n            if (beforeMutationTs !== MUTATION[key][0]) {\n                if (isError) throw error;\n                return data;\n            } else if (isError && hasOptimisticData && rollbackOnError(error)) {\n                // Rollback. Always populate the cache in this case but without\n                // transforming the data.\n                populateCache = true;\n                // Reset data to be the latest committed data, and clear the `_c` value.\n                set({\n                    data: committedData,\n                    _c: UNDEFINED\n                });\n            }\n        }\n        // If we should write back the cache after request.\n        if (populateCache) {\n            if (!isError) {\n                // Transform the result into data.\n                if (isFunction(populateCache)) {\n                    const populateCachedData = populateCache(data, committedData);\n                    set({\n                        data: populateCachedData,\n                        error: UNDEFINED,\n                        _c: UNDEFINED\n                    });\n                } else {\n                    // Only update cached data and reset the error if there's no error. Data can be `undefined` here.\n                    set({\n                        data,\n                        error: UNDEFINED,\n                        _c: UNDEFINED\n                    });\n                }\n            }\n        }\n        // Reset the timestamp to mark the mutation has ended.\n        MUTATION[key][1] = getTimestamp();\n        // Update existing SWR Hooks' internal states:\n        Promise.resolve(startRevalidate()).then(()=>{\n            // The mutation and revalidation are ended, we can clear it since the data is\n            // not an optimistic value anymore.\n            set({\n                _c: UNDEFINED\n            });\n        });\n        // Throw error or return data\n        if (isError) {\n            if (throwOnError) throw error;\n            return;\n        }\n        return data;\n    }\n}\nconst revalidateAllKeys = (revalidators, type)=>{\n    for(const key in revalidators){\n        if (revalidators[key][0]) revalidators[key][0](type);\n    }\n};\nconst initCache = (provider, options)=>{\n    // The global state for a specific provider will be used to deduplicate\n    // requests and store listeners. As well as a mutate function that is bound to\n    // the cache.\n    // The provider's global state might be already initialized. Let's try to get the\n    // global state associated with the provider first.\n    if (!SWRGlobalState.has(provider)) {\n        const opts = mergeObjects(defaultConfigOptions, options);\n        // If there's no global state bound to the provider, create a new one with the\n        // new mutate function.\n        const EVENT_REVALIDATORS = Object.create(null);\n        const mutate = internalMutate.bind(UNDEFINED, provider);\n        let unmount = noop;\n        const subscriptions = Object.create(null);\n        const subscribe = (key, callback)=>{\n            const subs = subscriptions[key] || [];\n            subscriptions[key] = subs;\n            subs.push(callback);\n            return ()=>subs.splice(subs.indexOf(callback), 1);\n        };\n        const setter = (key, value, prev)=>{\n            provider.set(key, value);\n            const subs = subscriptions[key];\n            if (subs) {\n                for (const fn of subs){\n                    fn(value, prev);\n                }\n            }\n        };\n        const initProvider = ()=>{\n            if (!SWRGlobalState.has(provider)) {\n                // Update the state if it's new, or if the provider has been extended.\n                SWRGlobalState.set(provider, [\n                    EVENT_REVALIDATORS,\n                    Object.create(null),\n                    Object.create(null),\n                    Object.create(null),\n                    mutate,\n                    setter,\n                    subscribe\n                ]);\n                if (!IS_SERVER) {\n                    // When listening to the native events for auto revalidations,\n                    // we intentionally put a delay (setTimeout) here to make sure they are\n                    // fired after immediate JavaScript executions, which can be\n                    // React's state updates.\n                    // This avoids some unnecessary revalidations such as\n                    // https://github.com/vercel/swr/issues/1680.\n                    const releaseFocus = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, _events_mjs__WEBPACK_IMPORTED_MODULE_2__.FOCUS_EVENT)));\n                    const releaseReconnect = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, _events_mjs__WEBPACK_IMPORTED_MODULE_2__.RECONNECT_EVENT)));\n                    unmount = ()=>{\n                        releaseFocus && releaseFocus();\n                        releaseReconnect && releaseReconnect();\n                        // When un-mounting, we need to remove the cache provider from the state\n                        // storage too because it's a side-effect. Otherwise, when re-mounting we\n                        // will not re-register those event listeners.\n                        SWRGlobalState.delete(provider);\n                    };\n                }\n            }\n        };\n        initProvider();\n        // This is a new provider, we need to initialize it and setup DOM events\n        // listeners for `focus` and `reconnect` actions.\n        // We might want to inject an extra layer on top of `provider` in the future,\n        // such as key serialization, auto GC, etc.\n        // For now, it's just a `Map` interface without any modifications.\n        return [\n            provider,\n            mutate,\n            initProvider,\n            unmount\n        ];\n    }\n    return [\n        provider,\n        SWRGlobalState.get(provider)[4]\n    ];\n};\n// error retry\nconst onErrorRetry = (_, __, config, revalidate, opts)=>{\n    const maxRetryCount = config.errorRetryCount;\n    const currentRetryCount = opts.retryCount;\n    // Exponential backoff\n    const timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;\n    if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {\n        return;\n    }\n    setTimeout(revalidate, timeout, opts);\n};\nconst compare = dequal_lite__WEBPACK_IMPORTED_MODULE_1__.dequal;\n// Default cache provider\nconst [cache, mutate] = initCache(new Map());\n// Default config\nconst defaultConfig = mergeObjects({\n    // events\n    onLoadingSlow: noop,\n    onSuccess: noop,\n    onError: noop,\n    onErrorRetry,\n    onDiscarded: noop,\n    // switches\n    revalidateOnFocus: true,\n    revalidateOnReconnect: true,\n    revalidateIfStale: true,\n    shouldRetryOnError: true,\n    // timeouts\n    errorRetryInterval: slowConnection ? 10000 : 5000,\n    focusThrottleInterval: 5 * 1000,\n    dedupingInterval: 2 * 1000,\n    loadingTimeout: slowConnection ? 5000 : 3000,\n    // providers\n    compare,\n    isPaused: ()=>false,\n    cache,\n    mutate,\n    fallback: {}\n}, preset);\nconst mergeConfigs = (a, b)=>{\n    // Need to create a new object to avoid mutating the original here.\n    const v = mergeObjects(a, b);\n    // If two configs are provided, merge their `use` and `fallback` options.\n    if (b) {\n        const { use: u1, fallback: f1 } = a;\n        const { use: u2, fallback: f2 } = b;\n        if (u1 && u2) {\n            v.use = u1.concat(u2);\n        }\n        if (f1 && f2) {\n            v.fallback = mergeObjects(f1, f2);\n        }\n    }\n    return v;\n};\nconst SWRConfigContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nconst SWRConfig = (props)=>{\n    _s();\n    const { value } = props;\n    const parentConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext);\n    const isFunctionalConfig = isFunction(value);\n    const config = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"SWRConfig.useMemo[config]\": ()=>isFunctionalConfig ? value(parentConfig) : value\n    }[\"SWRConfig.useMemo[config]\"], [\n        isFunctionalConfig,\n        parentConfig,\n        value\n    ]);\n    // Extend parent context values and middleware.\n    const extendedConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"SWRConfig.useMemo[extendedConfig]\": ()=>isFunctionalConfig ? config : mergeConfigs(parentConfig, config)\n    }[\"SWRConfig.useMemo[extendedConfig]\"], [\n        isFunctionalConfig,\n        parentConfig,\n        config\n    ]);\n    // Should not use the inherited provider.\n    const provider = config && config.provider;\n    // initialize the cache only on first access.\n    const cacheContextRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(UNDEFINED);\n    if (provider && !cacheContextRef.current) {\n        cacheContextRef.current = initCache(provider(extendedConfig.cache || cache), config);\n    }\n    const cacheContext = cacheContextRef.current;\n    // Override the cache if a new provider is given.\n    if (cacheContext) {\n        extendedConfig.cache = cacheContext[0];\n        extendedConfig.mutate = cacheContext[1];\n    }\n    // Unsubscribe events.\n    useIsomorphicLayoutEffect({\n        \"SWRConfig.useIsomorphicLayoutEffect\": ()=>{\n            if (cacheContext) {\n                cacheContext[2] && cacheContext[2]();\n                return cacheContext[3];\n            }\n        }\n    }[\"SWRConfig.useIsomorphicLayoutEffect\"], []);\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(SWRConfigContext.Provider, mergeObjects(props, {\n        value: extendedConfig\n    }));\n};\n_s(SWRConfig, \"A6qnBUlOKXkyZ5NVwzVYJI6vl14=\", false, function() {\n    return [\n        useIsomorphicLayoutEffect\n    ];\n});\n_c = SWRConfig;\n\nvar _c;\n$RefreshReg$(_c, \"SWRConfig\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zd3IvZGlzdC9faW50ZXJuYWwvY29uZmlnLWNvbnRleHQtY2xpZW50LUJvUzUzU1Q5Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDcUg7QUFDcEU7QUFDWjtBQUVyQyxnRUFBZ0U7QUFDaEUsTUFBTVUsaUJBQWlCLElBQUlDO0FBRTNCLCtEQUErRDtBQUMvRCxNQUFNQyxPQUFPLEtBQUs7QUFDbEIsbUVBQW1FO0FBQ25FLDhFQUE4RTtBQUM5RSw4REFBOEQ7QUFDOUQsa0JBQWtCO0FBQ2xCLE1BQU1DLFlBQVksZUFBZSxHQUFHRDtBQUNwQyxNQUFNRSxTQUFTQztBQUNmLE1BQU1DLGNBQWMsQ0FBQ0MsSUFBSUEsTUFBTUo7QUFDL0IsTUFBTUssYUFBYSxDQUFDRCxJQUFJLE9BQU9BLEtBQUs7QUFDcEMsTUFBTUUsZUFBZSxDQUFDQyxHQUFHQyxJQUFLO1FBQ3RCLEdBQUdELENBQUM7UUFDSixHQUFHQyxDQUFDO0lBQ1I7QUFDSixNQUFNQyxnQkFBZ0IsQ0FBQ0MsSUFBSUwsV0FBV0ssRUFBRUMsSUFBSTtBQUU1QyxNQUFNQyxjQUFjLENBQUM7QUFDckIsTUFBTUMsZ0JBQWdCLENBQUM7QUFDdkIsTUFBTUMsZ0JBQWdCO0FBQ3RCLGtHQUFrRztBQUNsRyxNQUFNQyxrQkFBa0IsT0FBT0MsVUFBVUY7QUFDekMsTUFBTUcsb0JBQW9CLE9BQU9DLFlBQVlKO0FBQzdDLE1BQU1LLGVBQWVKLG1CQUFtQixVQUFVQztBQUNsRCxNQUFNSSwyQkFBMkIsSUFBSUwsbUJBQW1CLE9BQU9DLE1BQU0sQ0FBQyx3QkFBd0IsSUFBSUY7QUFDbEcsTUFBTU8sb0JBQW9CLENBQUNDLE9BQU9DO0lBQzlCLE1BQU1DLFFBQVEzQixlQUFlNEIsR0FBRyxDQUFDSDtJQUNqQyxPQUFPO1FBQ0gsU0FBUztRQUNULElBQUksQ0FBQ25CLFlBQVlvQixRQUFRRCxNQUFNRyxH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T0FBT3RCLFFBQVE7SUFDMUMsNkNBQTZDO0lBQzdDLE1BQU00RCxrQkFBa0J2TSw2Q0FBTUEsQ0FBQ087SUFDL0IsSUFBSW9JLFlBQVksQ0FBQzRELGdCQUFnQkMsT0FBTyxFQUFFO1FBQ3RDRCxnQkFBZ0JDLE9BQU8sR0FBRzlELFVBQVVDLFNBQVMyRCxlQUFlekssS0FBSyxJQUFJQSxRQUFRb0k7SUFDakY7SUFDQSxNQUFNd0MsZUFBZUYsZ0JBQWdCQyxPQUFPO0lBQzVDLGlEQUFpRDtJQUNqRCxJQUFJQyxjQUFjO1FBQ2RILGVBQWV6SyxLQUFLLEdBQUc0SyxZQUFZLENBQUMsRUFBRTtRQUN0Q0gsZUFBZXZELE1BQU0sR0FBRzBELFlBQVksQ0FBQyxFQUFFO0lBQzNDO0lBQ0Esc0JBQXNCO0lBQ3RCaEo7K0NBQTBCO1lBQ3RCLElBQUlnSixjQUFjO2dCQUNkQSxZQUFZLENBQUMsRUFBRSxJQUFJQSxZQUFZLENBQUMsRUFBRTtnQkFDbEMsT0FBT0EsWUFBWSxDQUFDLEVBQUU7WUFDMUI7UUFDSjs4Q0FBRyxFQUFFO0lBQ0wscUJBQU94TSxvREFBYUEsQ0FBQ2dNLGlCQUFpQlMsUUFBUSxFQUFFN0wsYUFBYXNMLE9BQU87UUFDaEVoSSxPQUFPbUk7SUFDWDtBQUNKO0dBdENNSjs7UUE2QkZ6STs7O0tBN0JFeUk7QUF3QzhsQiIsInNvdXJjZXMiOlsiL1VzZXJzL2lzaGFxYmVsbG8vV2Vic2l0ZS9oYXZlbnJpZGVfZnVsbF9hcHAvbm9kZV9tb2R1bGVzL3N3ci9kaXN0L19pbnRlcm5hbC9jb25maWctY29udGV4dC1jbGllbnQtQm9TNTNTVDkubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlTWVtbywgdXNlUmVmLCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgcmV2YWxpZGF0ZUV2ZW50cyBmcm9tICcuL2V2ZW50cy5tanMnO1xuaW1wb3J0IHsgZGVxdWFsIH0gZnJvbSAnZGVxdWFsL2xpdGUnO1xuXG4vLyBHbG9iYWwgc3RhdGUgdXNlZCB0byBkZWR1cGxpY2F0ZSByZXF1ZXN0cyBhbmQgc3RvcmUgbGlzdGVuZXJzXG5jb25zdCBTV1JHbG9iYWxTdGF0ZSA9IG5ldyBXZWFrTWFwKCk7XG5cbi8vIFNoYXJlZCBzdGF0ZSBiZXR3ZWVuIHNlcnZlciBjb21wb25lbnRzIGFuZCBjbGllbnQgY29tcG9uZW50c1xuY29uc3Qgbm9vcCA9ICgpPT57fTtcbi8vIFVzaW5nIG5vb3AoKSBhcyB0aGUgdW5kZWZpbmVkIHZhbHVlIGFzIHVuZGVmaW5lZCBjYW4gYmUgcmVwbGFjZWRcbi8vIGJ5IHNvbWV0aGluZyBlbHNlLiBQcmV0dGllciBpZ25vcmUgYW5kIGV4dHJhIHBhcmVudGhlc2VzIGFyZSBuZWNlc3NhcnkgaGVyZVxuLy8gdG8gZW5zdXJlIHRoYXQgdHNjIGRvZXNuJ3QgcmVtb3ZlIHRoZSBfX05PSU5MSU5FX18gY29tbWVudC5cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgVU5ERUZJTkVEID0gLyojX19OT0lOTElORV9fKi8gbm9vcCgpO1xuY29uc3QgT0JKRUNUID0gT2JqZWN0O1xuY29uc3QgaXNVbmRlZmluZWQgPSAodik9PnYgPT09IFVOREVGSU5FRDtcbmNvbnN0IGlzRnVuY3Rpb24gPSAodik9PnR5cGVvZiB2ID09ICdmdW5jdGlvbic7XG5jb25zdCBtZXJnZU9iamVjdHMgPSAoYSwgYik9Pih7XG4gICAgICAgIC4uLmEsXG4gICAgICAgIC4uLmJcbiAgICB9KTtcbmNvbnN0IGlzUHJvbWlzZUxpa2UgPSAoeCk9PmlzRnVuY3Rpb24oeC50aGVuKTtcblxuY29uc3QgRU1QVFlfQ0FDSEUgPSB7fTtcbmNvbnN0IElOSVRJQUxfQ0FDSEUgPSB7fTtcbmNvbnN0IFNUUl9VTkRFRklORUQgPSAndW5kZWZpbmVkJztcbi8vIE5PVEU6IFVzZSB0aGUgZnVuY3Rpb24gdG8gZ3VhcmFudGVlIGl0J3MgcmUtZXZhbHVhdGVkIGJldHdlZW4ganNkb20gYW5kIG5vZGUgcnVudGltZSBmb3IgdGVzdHMuXG5jb25zdCBpc1dpbmRvd0RlZmluZWQgPSB0eXBlb2Ygd2luZG93ICE9IFNUUl9VTkRFRklORUQ7XG5jb25zdCBpc0RvY3VtZW50RGVmaW5lZCA9IHR5cGVvZiBkb2N1bWVudCAhPSBTVFJfVU5ERUZJTkVEO1xuY29uc3QgaXNMZWdhY3lEZW5vID0gaXNXaW5kb3dEZWZpbmVkICYmICdEZW5vJyBpbiB3aW5kb3c7XG5jb25zdCBoYXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSAoKT0+aXNXaW5kb3dEZWZpbmVkICYmIHR5cGVvZiB3aW5kb3dbJ3JlcXVlc3RBbmltYXRpb25GcmFtZSddICE9IFNUUl9VTkRFRklORUQ7XG5jb25zdCBjcmVhdGVDYWNoZUhlbHBlciA9IChjYWNoZSwga2V5KT0+e1xuICAgIGNvbnN0IHN0YXRlID0gU1dSR2xvYmFsU3RhdGUuZ2V0KGNhY2hlKTtcbiAgICByZXR1cm4gW1xuICAgICAgICAvLyBHZXR0ZXJcbiAgICAgICAgKCk9PiFpc1VuZGVmaW5lZChrZXkpICYmIGNhY2hlLmdldChrZXkpIHx8IEVNUFRZX0NBQ0hFLFxuICAgICAgICAvLyBTZXR0ZXJcbiAgICAgICAgKGluZm8pPT57XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgLy8gQmVmb3JlIHdyaXRpbmcgdG8gdGhlIHN0b3JlLCB3ZSBrZWVwIHRoZSB2YWx1ZSBpbiB0aGUgaW5pdGlhbCBjYWNoZVxuICAgICAgICAgICAgICAgIC8vIGlmIGl0J3Mgbm90IHRoZXJlIHlldC5cbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gSU5JVElBTF9DQUNIRSkpIHtcbiAgICAgICAgICAgICAgICAgICAgSU5JVElBTF9DQUNIRVtrZXldID0gcHJldjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGVbNV0oa2V5LCBtZXJnZU9iamVjdHMocHJldiwgaW5mbyksIHByZXYgfHwgRU1QVFlfQ0FDSEUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBTdWJzY3JpYmVyXG4gICAgICAgIHN0YXRlWzZdLFxuICAgICAgICAvLyBHZXQgc2VydmVyIGNhY2hlIHNuYXBzaG90XG4gICAgICAgICgpPT57XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY2FjaGUgd2FzIHVwZGF0ZWQgb24gdGhlIGNsaWVudCwgd2UgcmV0dXJuIHRoZSBzdG9yZWQgaW5pdGlhbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluIElOSVRJQUxfQ0FDSEUpIHJldHVybiBJTklUSUFMX0NBQ0hFW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlbid0IGRvbmUgYW55IGNsaWVudC1zaWRlIHVwZGF0ZXMsIHdlIHJldHVybiB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgICAgICAgIHJldHVybiAhaXNVbmRlZmluZWQoa2V5KSAmJiBjYWNoZS5nZXQoa2V5KSB8fCBFTVBUWV9DQUNIRTtcbiAgICAgICAgfVxuICAgIF07XG59IC8vIGV4cG9ydCB7IFVOREVGSU5FRCwgT0JKRUNULCBpc1VuZGVmaW5lZCwgaXNGdW5jdGlvbiwgbWVyZ2VPYmplY3RzLCBpc1Byb21pc2VMaWtlIH1cbjtcblxuLyoqXG4gKiBEdWUgdG8gdGhlIGJ1ZyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02NzgwNzUsXG4gKiBpdCdzIG5vdCByZWxpYWJsZSB0byBkZXRlY3QgaWYgdGhlIGJyb3dzZXIgaXMgY3VycmVudGx5IG9ubGluZSBvciBvZmZsaW5lXG4gKiBiYXNlZCBvbiBgbmF2aWdhdG9yLm9uTGluZWAuXG4gKiBBcyBhIHdvcmthcm91bmQsIHdlIGFsd2F5cyBhc3N1bWUgaXQncyBvbmxpbmUgb24gdGhlIGZpcnN0IGxvYWQsIGFuZCBjaGFuZ2VcbiAqIHRoZSBzdGF0dXMgdXBvbiBgb25saW5lYCBvciBgb2ZmbGluZWAgZXZlbnRzLlxuICovIGxldCBvbmxpbmUgPSB0cnVlO1xuY29uc3QgaXNPbmxpbmUgPSAoKT0+b25saW5lO1xuLy8gRm9yIG5vZGUgYW5kIFJlYWN0IE5hdGl2ZSwgYGFkZC9yZW1vdmVFdmVudExpc3RlbmVyYCBkb2Vzbid0IGV4aXN0IG9uIHdpbmRvdy5cbmNvbnN0IFtvbldpbmRvd0V2ZW50LCBvZmZXaW5kb3dFdmVudF0gPSBpc1dpbmRvd0RlZmluZWQgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPyBbXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIuYmluZCh3aW5kb3cpLFxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyLmJpbmQod2luZG93KVxuXSA6IFtcbiAgICBub29wLFxuICAgIG5vb3Bcbl07XG5jb25zdCBpc1Zpc2libGUgPSAoKT0+e1xuICAgIGNvbnN0IHZpc2liaWxpdHlTdGF0ZSA9IGlzRG9jdW1lbnREZWZpbmVkICYmIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZTtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQodmlzaWJpbGl0eVN0YXRlKSB8fCB2aXNpYmlsaXR5U3RhdGUgIT09ICdoaWRkZW4nO1xufTtcbmNvbnN0IGluaXRGb2N1cyA9IChjYWxsYmFjayk9PntcbiAgICAvLyBmb2N1cyByZXZhbGlkYXRlXG4gICAgaWYgKGlzRG9jdW1lbnREZWZpbmVkKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIG9uV2luZG93RXZlbnQoJ2ZvY3VzJywgY2FsbGJhY2spO1xuICAgIHJldHVybiAoKT0+e1xuICAgICAgICBpZiAoaXNEb2N1bWVudERlZmluZWQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgb2ZmV2luZG93RXZlbnQoJ2ZvY3VzJywgY2FsbGJhY2spO1xuICAgIH07XG59O1xuY29uc3QgaW5pdFJlY29ubmVjdCA9IChjYWxsYmFjayk9PntcbiAgICAvLyByZXZhbGlkYXRlIG9uIHJlY29ubmVjdGVkXG4gICAgY29uc3Qgb25PbmxpbmUgPSAoKT0+e1xuICAgICAgICBvbmxpbmUgPSB0cnVlO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH07XG4gICAgLy8gbm90aGluZyB0byByZXZhbGlkYXRlLCBqdXN0IHVwZGF0ZSB0aGUgc3RhdHVzXG4gICAgY29uc3Qgb25PZmZsaW5lID0gKCk9PntcbiAgICAgICAgb25saW5lID0gZmFsc2U7XG4gICAgfTtcbiAgICBvbldpbmRvd0V2ZW50KCdvbmxpbmUnLCBvbk9ubGluZSk7XG4gICAgb25XaW5kb3dFdmVudCgnb2ZmbGluZScsIG9uT2ZmbGluZSk7XG4gICAgcmV0dXJuICgpPT57XG4gICAgICAgIG9mZldpbmRvd0V2ZW50KCdvbmxpbmUnLCBvbk9ubGluZSk7XG4gICAgICAgIG9mZldpbmRvd0V2ZW50KCdvZmZsaW5lJywgb25PZmZsaW5lKTtcbiAgICB9O1xufTtcbmNvbnN0IHByZXNldCA9IHtcbiAgICBpc09ubGluZSxcbiAgICBpc1Zpc2libGVcbn07XG5jb25zdCBkZWZhdWx0Q29uZmlnT3B0aW9ucyA9IHtcbiAgICBpbml0Rm9jdXMsXG4gICAgaW5pdFJlY29ubmVjdFxufTtcblxuY29uc3QgSVNfUkVBQ1RfTEVHQUNZID0gIVJlYWN0LnVzZUlkO1xuY29uc3QgSVNfU0VSVkVSID0gIWlzV2luZG93RGVmaW5lZCB8fCBpc0xlZ2FjeURlbm87XG4vLyBQb2x5ZmlsbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbmNvbnN0IHJBRiA9IChmKT0+aGFzUmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkgPyB3aW5kb3dbJ3JlcXVlc3RBbmltYXRpb25GcmFtZSddKGYpIDogc2V0VGltZW91dChmLCAxKTtcbi8vIFJlYWN0IGN1cnJlbnRseSB0aHJvd3MgYSB3YXJuaW5nIHdoZW4gdXNpbmcgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBzZXJ2ZXIuXG4vLyBUbyBnZXQgYXJvdW5kIGl0LCB3ZSBjYW4gY29uZGl0aW9uYWxseSB1c2VFZmZlY3Qgb24gdGhlIHNlcnZlciAobm8tb3ApIGFuZFxuLy8gdXNlTGF5b3V0RWZmZWN0IGluIHRoZSBicm93c2VyLlxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IElTX1NFUlZFUiA/IHVzZUVmZmVjdCA6IHVzZUxheW91dEVmZmVjdDtcbi8vIFRoaXMgYXNzaWdubWVudCBpcyB0byBleHRlbmQgdGhlIE5hdmlnYXRvciB0eXBlIHRvIHVzZSBlZmZlY3RpdmVUeXBlLlxuY29uc3QgbmF2aWdhdG9yQ29ubmVjdGlvbiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5jb25uZWN0aW9uO1xuLy8gQWRqdXN0IHRoZSBjb25maWcgYmFzZWQgb24gc2xvdyBjb25uZWN0aW9uIHN0YXR1cyAoPD0gNzBLYnBzKS5cbmNvbnN0IHNsb3dDb25uZWN0aW9uID0gIUlTX1NFUlZFUiAmJiBuYXZpZ2F0b3JDb25uZWN0aW9uICYmIChbXG4gICAgJ3Nsb3ctMmcnLFxuICAgICcyZydcbl0uaW5jbHVkZXMobmF2aWdhdG9yQ29ubmVjdGlvbi5lZmZlY3RpdmVUeXBlKSB8fCBuYXZpZ2F0b3JDb25uZWN0aW9uLnNhdmVEYXRhKTtcblxuLy8gdXNlIFdlYWtNYXAgdG8gc3RvcmUgdGhlIG9iamVjdC0+a2V5IG1hcHBpbmdcbi8vIHNvIHRoZSBvYmplY3RzIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbi8vIFdlYWtNYXAgdXNlcyBhIGhhc2h0YWJsZSB1bmRlciB0aGUgaG9vZCwgc28gdGhlIGxvb2t1cFxuLy8gY29tcGxleGl0eSBpcyBhbG1vc3QgTygxKS5cbmNvbnN0IHRhYmxlID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGdldFR5cGVOYW1lID0gKHZhbHVlKT0+T0JKRUNULnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbmNvbnN0IGlzT2JqZWN0VHlwZU5hbWUgPSAodHlwZU5hbWUsIHR5cGUpPT50eXBlTmFtZSA9PT0gYFtvYmplY3QgJHt0eXBlfV1gO1xuLy8gY291bnRlciBvZiB0aGUga2V5XG5sZXQgY291bnRlciA9IDA7XG4vLyBBIHN0YWJsZSBoYXNoIGltcGxlbWVudGF0aW9uIHRoYXQgc3VwcG9ydHM6XG4vLyAtIEZhc3QgYW5kIGVuc3VyZXMgdW5pcXVlIGhhc2ggcHJvcGVydGllc1xuLy8gLSBIYW5kbGVzIHVuc2VyaWFsaXphYmxlIHZhbHVlc1xuLy8gLSBIYW5kbGVzIG9iamVjdCBrZXkgb3JkZXJpbmdcbi8vIC0gR2VuZXJhdGVzIHNob3J0IHJlc3VsdHNcbi8vXG4vLyBUaGlzIGlzIG5vdCBhIHNlcmlhbGl6YXRpb24gZnVuY3Rpb24sIGFuZCB0aGUgcmVzdWx0IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlXG4vLyBwYXJzYWJsZS5cbmNvbnN0IHN0YWJsZUhhc2ggPSAoYXJnKT0+e1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgYXJnO1xuICAgIGNvbnN0IHR5cGVOYW1lID0gZ2V0VHlwZU5hbWUoYXJnKTtcbiAgICBjb25zdCBpc0RhdGUgPSBpc09iamVjdFR5cGVOYW1lKHR5cGVOYW1lLCAnRGF0ZScpO1xuICAgIGNvbnN0IGlzUmVnZXggPSBpc09iamVjdFR5cGVOYW1lKHR5cGVOYW1lLCAnUmVnRXhwJyk7XG4gICAgY29uc3QgaXNQbGFpbk9iamVjdCA9IGlzT2JqZWN0VHlwZU5hbWUodHlwZU5hbWUsICdPYmplY3QnKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBpbmRleDtcbiAgICBpZiAoT0JKRUNUKGFyZykgPT09IGFyZyAmJiAhaXNEYXRlICYmICFpc1JlZ2V4KSB7XG4gICAgICAgIC8vIE9iamVjdC9mdW5jdGlvbiwgbm90IG51bGwvZGF0ZS9yZWdleHAuIFVzZSBXZWFrTWFwIHRvIHN0b3JlIHRoZSBpZCBmaXJzdC5cbiAgICAgICAgLy8gSWYgaXQncyBhbHJlYWR5IGhhc2hlZCwgZGlyZWN0bHkgcmV0dXJuIHRoZSByZXN1bHQuXG4gICAgICAgIHJlc3VsdCA9IHRhYmxlLmdldChhcmcpO1xuICAgICAgICBpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAvLyBTdG9yZSB0aGUgaGFzaCBmaXJzdCBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGlvbiBiZWZvcmUgZW50ZXJpbmcgdGhlXG4gICAgICAgIC8vIHJlY3Vyc2l2ZSBgc3RhYmxlSGFzaGAgY2FsbHMuXG4gICAgICAgIC8vIEZvciBvdGhlciBvYmplY3RzIGxpa2Ugc2V0IGFuZCBtYXAsIHdlIHVzZSB0aGlzIGlkIGRpcmVjdGx5IGFzIHRoZSBoYXNoLlxuICAgICAgICByZXN1bHQgPSArK2NvdW50ZXIgKyAnfic7XG4gICAgICAgIHRhYmxlLnNldChhcmcsIHJlc3VsdCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgIC8vIEFycmF5LlxuICAgICAgICAgICAgcmVzdWx0ID0gJ0AnO1xuICAgICAgICAgICAgZm9yKGluZGV4ID0gMDsgaW5kZXggPCBhcmcubGVuZ3RoOyBpbmRleCsrKXtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RhYmxlSGFzaChhcmdbaW5kZXhdKSArICcsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYmxlLnNldChhcmcsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QpIHtcbiAgICAgICAgICAgIC8vIE9iamVjdCwgc29ydCBrZXlzLlxuICAgICAgICAgICAgcmVzdWx0ID0gJyMnO1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9CSkVDVC5rZXlzKGFyZykuc29ydCgpO1xuICAgICAgICAgICAgd2hpbGUoIWlzVW5kZWZpbmVkKGluZGV4ID0ga2V5cy5wb3AoKSkpe1xuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoYXJnW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGluZGV4ICsgJzonICsgc3RhYmxlSGFzaChhcmdbaW5kZXhdKSArICcsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWJsZS5zZXQoYXJnLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gaXNEYXRlID8gYXJnLnRvSlNPTigpIDogdHlwZSA9PSAnc3ltYm9sJyA/IGFyZy50b1N0cmluZygpIDogdHlwZSA9PSAnc3RyaW5nJyA/IEpTT04uc3RyaW5naWZ5KGFyZykgOiAnJyArIGFyZztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHNlcmlhbGl6ZSA9IChrZXkpPT57XG4gICAgaWYgKGlzRnVuY3Rpb24oa2V5KSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAga2V5ID0ga2V5KCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gZGVwZW5kZW5jaWVzIG5vdCByZWFkeVxuICAgICAgICAgICAga2V5ID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXNlIHRoZSBvcmlnaW5hbCBrZXkgYXMgdGhlIGFyZ3VtZW50IG9mIGZldGNoZXIuIFRoaXMgY2FuIGJlIGEgc3RyaW5nIG9yIGFuXG4gICAgLy8gYXJyYXkgb2YgdmFsdWVzLlxuICAgIGNvbnN0IGFyZ3MgPSBrZXk7XG4gICAgLy8gSWYga2V5IGlzIG5vdCBmYWxzeSwgb3Igbm90IGFuIGVtcHR5IGFycmF5LCBoYXNoIGl0LlxuICAgIGtleSA9IHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyBrZXkgOiAoQXJyYXkuaXNBcnJheShrZXkpID8ga2V5Lmxlbmd0aCA6IGtleSkgPyBzdGFibGVIYXNoKGtleSkgOiAnJztcbiAgICByZXR1cm4gW1xuICAgICAgICBrZXksXG4gICAgICAgIGFyZ3NcbiAgICBdO1xufTtcblxuLy8gR2xvYmFsIHRpbWVzdGFtcC5cbmxldCBfX3RpbWVzdGFtcCA9IDA7XG5jb25zdCBnZXRUaW1lc3RhbXAgPSAoKT0+KytfX3RpbWVzdGFtcDtcblxuYXN5bmMgZnVuY3Rpb24gaW50ZXJuYWxNdXRhdGUoLi4uYXJncykge1xuICAgIGNvbnN0IFtjYWNoZSwgX2tleSwgX2RhdGEsIF9vcHRzXSA9IGFyZ3M7XG4gICAgLy8gV2hlbiBwYXNzaW5nIGFzIGEgYm9vbGVhbiwgaXQncyBleHBsaWNpdGx5IHVzZWQgdG8gZGlzYWJsZS9lbmFibGVcbiAgICAvLyByZXZhbGlkYXRpb24uXG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlT2JqZWN0cyh7XG4gICAgICAgIHBvcHVsYXRlQ2FjaGU6IHRydWUsXG4gICAgICAgIHRocm93T25FcnJvcjogdHJ1ZVxuICAgIH0sIHR5cGVvZiBfb3B0cyA9PT0gJ2Jvb2xlYW4nID8ge1xuICAgICAgICByZXZhbGlkYXRlOiBfb3B0c1xuICAgIH0gOiBfb3B0cyB8fCB7fSk7XG4gICAgbGV0IHBvcHVsYXRlQ2FjaGUgPSBvcHRpb25zLnBvcHVsYXRlQ2FjaGU7XG4gICAgY29uc3Qgcm9sbGJhY2tPbkVycm9yT3B0aW9uID0gb3B0aW9ucy5yb2xsYmFja09uRXJyb3I7XG4gICAgbGV0IG9wdGltaXN0aWNEYXRhID0gb3B0aW9ucy5vcHRpbWlzdGljRGF0YTtcbiAgICBjb25zdCByb2xsYmFja09uRXJyb3IgPSAoZXJyb3IpPT57XG4gICAgICAgIHJldHVybiB0eXBlb2Ygcm9sbGJhY2tPbkVycm9yT3B0aW9uID09PSAnZnVuY3Rpb24nID8gcm9sbGJhY2tPbkVycm9yT3B0aW9uKGVycm9yKSA6IHJvbGxiYWNrT25FcnJvck9wdGlvbiAhPT0gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCB0aHJvd09uRXJyb3IgPSBvcHRpb25zLnRocm93T25FcnJvcjtcbiAgICAvLyBJZiB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIGEga2V5IGZpbHRlciwgcmV0dXJuIHRoZSBtdXRhdGlvbiByZXN1bHRzIGZvciBhbGxcbiAgICAvLyBmaWx0ZXJlZCBrZXlzLlxuICAgIGlmIChpc0Z1bmN0aW9uKF9rZXkpKSB7XG4gICAgICAgIGNvbnN0IGtleUZpbHRlciA9IF9rZXk7XG4gICAgICAgIGNvbnN0IG1hdGNoZWRLZXlzID0gW107XG4gICAgICAgIGNvbnN0IGl0ID0gY2FjaGUua2V5cygpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBpdCl7XG4gICAgICAgICAgICBpZiAoLy8gU2tpcCB0aGUgc3BlY2lhbCB1c2VTV1JJbmZpbml0ZSBhbmQgdXNlU1dSU3Vic2NyaXB0aW9uIGtleXMuXG4gICAgICAgICAgICAhL15cXCQoaW5mfHN1YilcXCQvLnRlc3Qoa2V5KSAmJiBrZXlGaWx0ZXIoY2FjaGUuZ2V0KGtleSkuX2spKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZEtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChtYXRjaGVkS2V5cy5tYXAobXV0YXRlQnlLZXkpKTtcbiAgICB9XG4gICAgcmV0dXJuIG11dGF0ZUJ5S2V5KF9rZXkpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIG11dGF0ZUJ5S2V5KF9rKSB7XG4gICAgICAgIC8vIFNlcmlhbGl6ZSBrZXlcbiAgICAgICAgY29uc3QgW2tleV0gPSBzZXJpYWxpemUoX2spO1xuICAgICAgICBpZiAoIWtleSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBbZ2V0LCBzZXRdID0gY3JlYXRlQ2FjaGVIZWxwZXIoY2FjaGUsIGtleSk7XG4gICAgICAgIGNvbnN0IFtFVkVOVF9SRVZBTElEQVRPUlMsIE1VVEFUSU9OLCBGRVRDSCwgUFJFTE9BRF0gPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpO1xuICAgICAgICBjb25zdCBzdGFydFJldmFsaWRhdGUgPSAoKT0+e1xuICAgICAgICAgICAgY29uc3QgcmV2YWxpZGF0b3JzID0gRVZFTlRfUkVWQUxJREFUT1JTW2tleV07XG4gICAgICAgICAgICBjb25zdCByZXZhbGlkYXRlID0gaXNGdW5jdGlvbihvcHRpb25zLnJldmFsaWRhdGUpID8gb3B0aW9ucy5yZXZhbGlkYXRlKGdldCgpLmRhdGEsIF9rKSA6IG9wdGlvbnMucmV2YWxpZGF0ZSAhPT0gZmFsc2U7XG4gICAgICAgICAgICBpZiAocmV2YWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIEludmFsaWRhdGUgdGhlIGtleSBieSBkZWxldGluZyB0aGUgY29uY3VycmVudCByZXF1ZXN0IG1hcmtlcnMgc28gbmV3XG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdHMgd2lsbCBub3QgYmUgZGVkdXBlZC5cbiAgICAgICAgICAgICAgICBkZWxldGUgRkVUQ0hba2V5XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgUFJFTE9BRFtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChyZXZhbGlkYXRvcnMgJiYgcmV2YWxpZGF0b3JzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXZhbGlkYXRvcnNbMF0ocmV2YWxpZGF0ZUV2ZW50cy5NVVRBVEVfRVZFTlQpLnRoZW4oKCk9PmdldCgpLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXQoKS5kYXRhO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBuZXcgZGF0YSBwcm92aWRlZCwgcmV2YWxpZGF0ZSB0aGUga2V5IHdpdGggY3VycmVudCBzdGF0ZS5cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgLy8gUmV2YWxpZGF0ZSBhbmQgYnJvYWRjYXN0IHN0YXRlLlxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0UmV2YWxpZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhID0gX2RhdGE7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgbGV0IGlzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgLy8gVXBkYXRlIGdsb2JhbCB0aW1lc3RhbXBzLlxuICAgICAgICBjb25zdCBiZWZvcmVNdXRhdGlvblRzID0gZ2V0VGltZXN0YW1wKCk7XG4gICAgICAgIE1VVEFUSU9OW2tleV0gPSBbXG4gICAgICAgICAgICBiZWZvcmVNdXRhdGlvblRzLFxuICAgICAgICAgICAgMFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBoYXNPcHRpbWlzdGljRGF0YSA9ICFpc1VuZGVmaW5lZChvcHRpbWlzdGljRGF0YSk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgIC8vIGBkaXNwbGF5ZWREYXRhYCBpcyB0aGUgY3VycmVudCB2YWx1ZSBvbiBzY3JlZW4uIEl0IGNvdWxkIGJlIHRoZSBvcHRpbWlzdGljIHZhbHVlXG4gICAgICAgIC8vIHRoYXQgaXMgZ29pbmcgdG8gYmUgb3ZlcnJpZGRlbiBieSBhIGBjb21taXR0ZWREYXRhYCwgb3IgZ2V0IHJldmVydGVkIGJhY2suXG4gICAgICAgIC8vIGBjb21taXR0ZWREYXRhYCBpcyB0aGUgdmFsaWRhdGVkIHZhbHVlIHRoYXQgY29tZXMgZnJvbSBhIGZldGNoIG9yIG11dGF0aW9uLlxuICAgICAgICBjb25zdCBkaXNwbGF5ZWREYXRhID0gc3RhdGUuZGF0YTtcbiAgICAgICAgY29uc3QgY3VycmVudERhdGEgPSBzdGF0ZS5fYztcbiAgICAgICAgY29uc3QgY29tbWl0dGVkRGF0YSA9IGlzVW5kZWZpbmVkKGN1cnJlbnREYXRhKSA/IGRpc3BsYXllZERhdGEgOiBjdXJyZW50RGF0YTtcbiAgICAgICAgLy8gRG8gb3B0aW1pc3RpYyBkYXRhIHVwZGF0ZS5cbiAgICAgICAgaWYgKGhhc09wdGltaXN0aWNEYXRhKSB7XG4gICAgICAgICAgICBvcHRpbWlzdGljRGF0YSA9IGlzRnVuY3Rpb24ob3B0aW1pc3RpY0RhdGEpID8gb3B0aW1pc3RpY0RhdGEoY29tbWl0dGVkRGF0YSwgZGlzcGxheWVkRGF0YSkgOiBvcHRpbWlzdGljRGF0YTtcbiAgICAgICAgICAgIC8vIFdoZW4gd2Ugc2V0IG9wdGltaXN0aWMgZGF0YSwgYmFja3VwIHRoZSBjdXJyZW50IGNvbW1pdHRlZERhdGEgZGF0YSBpbiBgX2NgLlxuICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgICBkYXRhOiBvcHRpbWlzdGljRGF0YSxcbiAgICAgICAgICAgICAgICBfYzogY29tbWl0dGVkRGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZGF0YSkpIHtcbiAgICAgICAgICAgIC8vIGBkYXRhYCBpcyBhIGZ1bmN0aW9uLCBjYWxsIGl0IHBhc3NpbmcgY3VycmVudCBjYWNoZSB2YWx1ZS5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEoY29tbWl0dGVkRGF0YSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCB0aHJvd3MgYW4gZXJyb3Igc3luY2hyb25vdXNseSwgd2Ugc2hvdWxkbid0IHVwZGF0ZSB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgaXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYGRhdGFgIGlzIGEgcHJvbWlzZS90aGVuYWJsZSwgcmVzb2x2ZSB0aGUgZmluYWwgZGF0YSBmaXJzdC5cbiAgICAgICAgaWYgKGRhdGEgJiYgaXNQcm9taXNlTGlrZShkYXRhKSkge1xuICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IHRoZSBtdXRhdGlvbiBpcyBhc3luYywgd2UgbmVlZCB0byBjaGVjayB0aW1lc3RhbXBzIHRvXG4gICAgICAgICAgICAvLyBhdm9pZCByYWNlIGNvbmRpdGlvbnMuXG4gICAgICAgICAgICBkYXRhID0gYXdhaXQgZGF0YS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIGlzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBvdGhlciBtdXRhdGlvbnMgaGF2ZSBvY2N1cnJlZCBzaW5jZSB3ZSd2ZSBzdGFydGVkIHRoaXMgbXV0YXRpb24uXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgcmFjZSB3ZSBkb24ndCB1cGRhdGUgY2FjaGUgb3IgYnJvYWRjYXN0IHRoZSBjaGFuZ2UsXG4gICAgICAgICAgICAvLyBqdXN0IHJldHVybiB0aGUgZGF0YS5cbiAgICAgICAgICAgIGlmIChiZWZvcmVNdXRhdGlvblRzICE9PSBNVVRBVElPTltrZXldWzBdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IpIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0Vycm9yICYmIGhhc09wdGltaXN0aWNEYXRhICYmIHJvbGxiYWNrT25FcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAvLyBSb2xsYmFjay4gQWx3YXlzIHBvcHVsYXRlIHRoZSBjYWNoZSBpbiB0aGlzIGNhc2UgYnV0IHdpdGhvdXRcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm1pbmcgdGhlIGRhdGEuXG4gICAgICAgICAgICAgICAgcG9wdWxhdGVDYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSB0byBiZSB0aGUgbGF0ZXN0IGNvbW1pdHRlZCBkYXRhLCBhbmQgY2xlYXIgdGhlIGBfY2AgdmFsdWUuXG4gICAgICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY29tbWl0dGVkRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgX2M6IFVOREVGSU5FRFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIHNob3VsZCB3cml0ZSBiYWNrIHRoZSBjYWNoZSBhZnRlciByZXF1ZXN0LlxuICAgICAgICBpZiAocG9wdWxhdGVDYWNoZSkge1xuICAgICAgICAgICAgaWYgKCFpc0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHRoZSByZXN1bHQgaW50byBkYXRhLlxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHBvcHVsYXRlQ2FjaGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvcHVsYXRlQ2FjaGVkRGF0YSA9IHBvcHVsYXRlQ2FjaGUoZGF0YSwgY29tbWl0dGVkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwb3B1bGF0ZUNhY2hlZERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogVU5ERUZJTkVELFxuICAgICAgICAgICAgICAgICAgICAgICAgX2M6IFVOREVGSU5FRFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSBjYWNoZWQgZGF0YSBhbmQgcmVzZXQgdGhlIGVycm9yIGlmIHRoZXJlJ3Mgbm8gZXJyb3IuIERhdGEgY2FuIGJlIGB1bmRlZmluZWRgIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IFVOREVGSU5FRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jOiBVTkRFRklORURcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2V0IHRoZSB0aW1lc3RhbXAgdG8gbWFyayB0aGUgbXV0YXRpb24gaGFzIGVuZGVkLlxuICAgICAgICBNVVRBVElPTltrZXldWzFdID0gZ2V0VGltZXN0YW1wKCk7XG4gICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBTV1IgSG9va3MnIGludGVybmFsIHN0YXRlczpcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHN0YXJ0UmV2YWxpZGF0ZSgpKS50aGVuKCgpPT57XG4gICAgICAgICAgICAvLyBUaGUgbXV0YXRpb24gYW5kIHJldmFsaWRhdGlvbiBhcmUgZW5kZWQsIHdlIGNhbiBjbGVhciBpdCBzaW5jZSB0aGUgZGF0YSBpc1xuICAgICAgICAgICAgLy8gbm90IGFuIG9wdGltaXN0aWMgdmFsdWUgYW55bW9yZS5cbiAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgX2M6IFVOREVGSU5FRFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaHJvdyBlcnJvciBvciByZXR1cm4gZGF0YVxuICAgICAgICBpZiAoaXNFcnJvcikge1xuICAgICAgICAgICAgaWYgKHRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufVxuXG5jb25zdCByZXZhbGlkYXRlQWxsS2V5cyA9IChyZXZhbGlkYXRvcnMsIHR5cGUpPT57XG4gICAgZm9yKGNvbnN0IGtleSBpbiByZXZhbGlkYXRvcnMpe1xuICAgICAgICBpZiAocmV2YWxpZGF0b3JzW2tleV1bMF0pIHJldmFsaWRhdG9yc1trZXldWzBdKHR5cGUpO1xuICAgIH1cbn07XG5jb25zdCBpbml0Q2FjaGUgPSAocHJvdmlkZXIsIG9wdGlvbnMpPT57XG4gICAgLy8gVGhlIGdsb2JhbCBzdGF0ZSBmb3IgYSBzcGVjaWZpYyBwcm92aWRlciB3aWxsIGJlIHVzZWQgdG8gZGVkdXBsaWNhdGVcbiAgICAvLyByZXF1ZXN0cyBhbmQgc3RvcmUgbGlzdGVuZXJzLiBBcyB3ZWxsIGFzIGEgbXV0YXRlIGZ1bmN0aW9uIHRoYXQgaXMgYm91bmQgdG9cbiAgICAvLyB0aGUgY2FjaGUuXG4gICAgLy8gVGhlIHByb3ZpZGVyJ3MgZ2xvYmFsIHN0YXRlIG1pZ2h0IGJlIGFscmVhZHkgaW5pdGlhbGl6ZWQuIExldCdzIHRyeSB0byBnZXQgdGhlXG4gICAgLy8gZ2xvYmFsIHN0YXRlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZXIgZmlyc3QuXG4gICAgaWYgKCFTV1JHbG9iYWxTdGF0ZS5oYXMocHJvdmlkZXIpKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBtZXJnZU9iamVjdHMoZGVmYXVsdENvbmZpZ09wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGdsb2JhbCBzdGF0ZSBib3VuZCB0byB0aGUgcHJvdmlkZXIsIGNyZWF0ZSBhIG5ldyBvbmUgd2l0aCB0aGVcbiAgICAgICAgLy8gbmV3IG11dGF0ZSBmdW5jdGlvbi5cbiAgICAgICAgY29uc3QgRVZFTlRfUkVWQUxJREFUT1JTID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgY29uc3QgbXV0YXRlID0gaW50ZXJuYWxNdXRhdGUuYmluZChVTkRFRklORUQsIHByb3ZpZGVyKTtcbiAgICAgICAgbGV0IHVubW91bnQgPSBub29wO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlID0gKGtleSwgY2FsbGJhY2spPT57XG4gICAgICAgICAgICBjb25zdCBzdWJzID0gc3Vic2NyaXB0aW9uc1trZXldIHx8IFtdO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uc1trZXldID0gc3VicztcbiAgICAgICAgICAgIHN1YnMucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gKCk9PnN1YnMuc3BsaWNlKHN1YnMuaW5kZXhPZihjYWxsYmFjayksIDEpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzZXR0ZXIgPSAoa2V5LCB2YWx1ZSwgcHJldik9PntcbiAgICAgICAgICAgIHByb3ZpZGVyLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IHN1YnMgPSBzdWJzY3JpcHRpb25zW2tleV07XG4gICAgICAgICAgICBpZiAoc3Vicykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZm4gb2Ygc3Vicyl7XG4gICAgICAgICAgICAgICAgICAgIGZuKHZhbHVlLCBwcmV2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGluaXRQcm92aWRlciA9ICgpPT57XG4gICAgICAgICAgICBpZiAoIVNXUkdsb2JhbFN0YXRlLmhhcyhwcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHN0YXRlIGlmIGl0J3MgbmV3LCBvciBpZiB0aGUgcHJvdmlkZXIgaGFzIGJlZW4gZXh0ZW5kZWQuXG4gICAgICAgICAgICAgICAgU1dSR2xvYmFsU3RhdGUuc2V0KHByb3ZpZGVyLCBbXG4gICAgICAgICAgICAgICAgICAgIEVWRU5UX1JFVkFMSURBVE9SUyxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRlLFxuICAgICAgICAgICAgICAgICAgICBzZXR0ZXIsXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGlmICghSVNfU0VSVkVSKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gbGlzdGVuaW5nIHRvIHRoZSBuYXRpdmUgZXZlbnRzIGZvciBhdXRvIHJldmFsaWRhdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGludGVudGlvbmFsbHkgcHV0IGEgZGVsYXkgKHNldFRpbWVvdXQpIGhlcmUgdG8gbWFrZSBzdXJlIHRoZXkgYXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpcmVkIGFmdGVyIGltbWVkaWF0ZSBKYXZhU2NyaXB0IGV4ZWN1dGlvbnMsIHdoaWNoIGNhbiBiZVxuICAgICAgICAgICAgICAgICAgICAvLyBSZWFjdCdzIHN0YXRlIHVwZGF0ZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgYXZvaWRzIHNvbWUgdW5uZWNlc3NhcnkgcmV2YWxpZGF0aW9ucyBzdWNoIGFzXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvc3dyL2lzc3Vlcy8xNjgwLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWxlYXNlRm9jdXMgPSBvcHRzLmluaXRGb2N1cyhzZXRUaW1lb3V0LmJpbmQoVU5ERUZJTkVELCByZXZhbGlkYXRlQWxsS2V5cy5iaW5kKFVOREVGSU5FRCwgRVZFTlRfUkVWQUxJREFUT1JTLCByZXZhbGlkYXRlRXZlbnRzLkZPQ1VTX0VWRU5UKSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWxlYXNlUmVjb25uZWN0ID0gb3B0cy5pbml0UmVjb25uZWN0KHNldFRpbWVvdXQuYmluZChVTkRFRklORUQsIHJldmFsaWRhdGVBbGxLZXlzLmJpbmQoVU5ERUZJTkVELCBFVkVOVF9SRVZBTElEQVRPUlMsIHJldmFsaWRhdGVFdmVudHMuUkVDT05ORUNUX0VWRU5UKSkpO1xuICAgICAgICAgICAgICAgICAgICB1bm1vdW50ID0gKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2VGb2N1cyAmJiByZWxlYXNlRm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2VSZWNvbm5lY3QgJiYgcmVsZWFzZVJlY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB1bi1tb3VudGluZywgd2UgbmVlZCB0byByZW1vdmUgdGhlIGNhY2hlIHByb3ZpZGVyIGZyb20gdGhlIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yYWdlIHRvbyBiZWNhdXNlIGl0J3MgYSBzaWRlLWVmZmVjdC4gT3RoZXJ3aXNlLCB3aGVuIHJlLW1vdW50aW5nIHdlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIG5vdCByZS1yZWdpc3RlciB0aG9zZSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICBTV1JHbG9iYWxTdGF0ZS5kZWxldGUocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaW5pdFByb3ZpZGVyKCk7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgcHJvdmlkZXIsIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZSBpdCBhbmQgc2V0dXAgRE9NIGV2ZW50c1xuICAgICAgICAvLyBsaXN0ZW5lcnMgZm9yIGBmb2N1c2AgYW5kIGByZWNvbm5lY3RgIGFjdGlvbnMuXG4gICAgICAgIC8vIFdlIG1pZ2h0IHdhbnQgdG8gaW5qZWN0IGFuIGV4dHJhIGxheWVyIG9uIHRvcCBvZiBgcHJvdmlkZXJgIGluIHRoZSBmdXR1cmUsXG4gICAgICAgIC8vIHN1Y2ggYXMga2V5IHNlcmlhbGl6YXRpb24sIGF1dG8gR0MsIGV0Yy5cbiAgICAgICAgLy8gRm9yIG5vdywgaXQncyBqdXN0IGEgYE1hcGAgaW50ZXJmYWNlIHdpdGhvdXQgYW55IG1vZGlmaWNhdGlvbnMuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgIG11dGF0ZSxcbiAgICAgICAgICAgIGluaXRQcm92aWRlcixcbiAgICAgICAgICAgIHVubW91bnRcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgIFNXUkdsb2JhbFN0YXRlLmdldChwcm92aWRlcilbNF1cbiAgICBdO1xufTtcblxuLy8gZXJyb3IgcmV0cnlcbmNvbnN0IG9uRXJyb3JSZXRyeSA9IChfLCBfXywgY29uZmlnLCByZXZhbGlkYXRlLCBvcHRzKT0+e1xuICAgIGNvbnN0IG1heFJldHJ5Q291bnQgPSBjb25maWcuZXJyb3JSZXRyeUNvdW50O1xuICAgIGNvbnN0IGN1cnJlbnRSZXRyeUNvdW50ID0gb3B0cy5yZXRyeUNvdW50O1xuICAgIC8vIEV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICBjb25zdCB0aW1lb3V0ID0gfn4oKE1hdGgucmFuZG9tKCkgKyAwLjUpICogKDEgPDwgKGN1cnJlbnRSZXRyeUNvdW50IDwgOCA/IGN1cnJlbnRSZXRyeUNvdW50IDogOCkpKSAqIGNvbmZpZy5lcnJvclJldHJ5SW50ZXJ2YWw7XG4gICAgaWYgKCFpc1VuZGVmaW5lZChtYXhSZXRyeUNvdW50KSAmJiBjdXJyZW50UmV0cnlDb3VudCA+IG1heFJldHJ5Q291bnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KHJldmFsaWRhdGUsIHRpbWVvdXQsIG9wdHMpO1xufTtcbmNvbnN0IGNvbXBhcmUgPSBkZXF1YWw7XG4vLyBEZWZhdWx0IGNhY2hlIHByb3ZpZGVyXG5jb25zdCBbY2FjaGUsIG11dGF0ZV0gPSBpbml0Q2FjaGUobmV3IE1hcCgpKTtcbi8vIERlZmF1bHQgY29uZmlnXG5jb25zdCBkZWZhdWx0Q29uZmlnID0gbWVyZ2VPYmplY3RzKHtcbiAgICAvLyBldmVudHNcbiAgICBvbkxvYWRpbmdTbG93OiBub29wLFxuICAgIG9uU3VjY2Vzczogbm9vcCxcbiAgICBvbkVycm9yOiBub29wLFxuICAgIG9uRXJyb3JSZXRyeSxcbiAgICBvbkRpc2NhcmRlZDogbm9vcCxcbiAgICAvLyBzd2l0Y2hlc1xuICAgIHJldmFsaWRhdGVPbkZvY3VzOiB0cnVlLFxuICAgIHJldmFsaWRhdGVPblJlY29ubmVjdDogdHJ1ZSxcbiAgICByZXZhbGlkYXRlSWZTdGFsZTogdHJ1ZSxcbiAgICBzaG91bGRSZXRyeU9uRXJyb3I6IHRydWUsXG4gICAgLy8gdGltZW91dHNcbiAgICBlcnJvclJldHJ5SW50ZXJ2YWw6IHNsb3dDb25uZWN0aW9uID8gMTAwMDAgOiA1MDAwLFxuICAgIGZvY3VzVGhyb3R0bGVJbnRlcnZhbDogNSAqIDEwMDAsXG4gICAgZGVkdXBpbmdJbnRlcnZhbDogMiAqIDEwMDAsXG4gICAgbG9hZGluZ1RpbWVvdXQ6IHNsb3dDb25uZWN0aW9uID8gNTAwMCA6IDMwMDAsXG4gICAgLy8gcHJvdmlkZXJzXG4gICAgY29tcGFyZSxcbiAgICBpc1BhdXNlZDogKCk9PmZhbHNlLFxuICAgIGNhY2hlLFxuICAgIG11dGF0ZSxcbiAgICBmYWxsYmFjazoge31cbn0sIC8vIHVzZSB3ZWIgcHJlc2V0IGJ5IGRlZmF1bHRcbnByZXNldCk7XG5cbmNvbnN0IG1lcmdlQ29uZmlncyA9IChhLCBiKT0+e1xuICAgIC8vIE5lZWQgdG8gY3JlYXRlIGEgbmV3IG9iamVjdCB0byBhdm9pZCBtdXRhdGluZyB0aGUgb3JpZ2luYWwgaGVyZS5cbiAgICBjb25zdCB2ID0gbWVyZ2VPYmplY3RzKGEsIGIpO1xuICAgIC8vIElmIHR3byBjb25maWdzIGFyZSBwcm92aWRlZCwgbWVyZ2UgdGhlaXIgYHVzZWAgYW5kIGBmYWxsYmFja2Agb3B0aW9ucy5cbiAgICBpZiAoYikge1xuICAgICAgICBjb25zdCB7IHVzZTogdTEsIGZhbGxiYWNrOiBmMSB9ID0gYTtcbiAgICAgICAgY29uc3QgeyB1c2U6IHUyLCBmYWxsYmFjazogZjIgfSA9IGI7XG4gICAgICAgIGlmICh1MSAmJiB1Mikge1xuICAgICAgICAgICAgdi51c2UgPSB1MS5jb25jYXQodTIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmMSAmJiBmMikge1xuICAgICAgICAgICAgdi5mYWxsYmFjayA9IG1lcmdlT2JqZWN0cyhmMSwgZjIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2O1xufTtcblxuY29uc3QgU1dSQ29uZmlnQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pO1xuY29uc3QgU1dSQ29uZmlnID0gKHByb3BzKT0+e1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IHByb3BzO1xuICAgIGNvbnN0IHBhcmVudENvbmZpZyA9IHVzZUNvbnRleHQoU1dSQ29uZmlnQ29udGV4dCk7XG4gICAgY29uc3QgaXNGdW5jdGlvbmFsQ29uZmlnID0gaXNGdW5jdGlvbih2YWx1ZSk7XG4gICAgY29uc3QgY29uZmlnID0gdXNlTWVtbygoKT0+aXNGdW5jdGlvbmFsQ29uZmlnID8gdmFsdWUocGFyZW50Q29uZmlnKSA6IHZhbHVlLCBbXG4gICAgICAgIGlzRnVuY3Rpb25hbENvbmZpZyxcbiAgICAgICAgcGFyZW50Q29uZmlnLFxuICAgICAgICB2YWx1ZVxuICAgIF0pO1xuICAgIC8vIEV4dGVuZCBwYXJlbnQgY29udGV4dCB2YWx1ZXMgYW5kIG1pZGRsZXdhcmUuXG4gICAgY29uc3QgZXh0ZW5kZWRDb25maWcgPSB1c2VNZW1vKCgpPT5pc0Z1bmN0aW9uYWxDb25maWcgPyBjb25maWcgOiBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpLCBbXG4gICAgICAgIGlzRnVuY3Rpb25hbENvbmZpZyxcbiAgICAgICAgcGFyZW50Q29uZmlnLFxuICAgICAgICBjb25maWdcbiAgICBdKTtcbiAgICAvLyBTaG91bGQgbm90IHVzZSB0aGUgaW5oZXJpdGVkIHByb3ZpZGVyLlxuICAgIGNvbnN0IHByb3ZpZGVyID0gY29uZmlnICYmIGNvbmZpZy5wcm92aWRlcjtcbiAgICAvLyBpbml0aWFsaXplIHRoZSBjYWNoZSBvbmx5IG9uIGZpcnN0IGFjY2Vzcy5cbiAgICBjb25zdCBjYWNoZUNvbnRleHRSZWYgPSB1c2VSZWYoVU5ERUZJTkVEKTtcbiAgICBpZiAocHJvdmlkZXIgJiYgIWNhY2hlQ29udGV4dFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNhY2hlQ29udGV4dFJlZi5jdXJyZW50ID0gaW5pdENhY2hlKHByb3ZpZGVyKGV4dGVuZGVkQ29uZmlnLmNhY2hlIHx8IGNhY2hlKSwgY29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVDb250ZXh0ID0gY2FjaGVDb250ZXh0UmVmLmN1cnJlbnQ7XG4gICAgLy8gT3ZlcnJpZGUgdGhlIGNhY2hlIGlmIGEgbmV3IHByb3ZpZGVyIGlzIGdpdmVuLlxuICAgIGlmIChjYWNoZUNvbnRleHQpIHtcbiAgICAgICAgZXh0ZW5kZWRDb25maWcuY2FjaGUgPSBjYWNoZUNvbnRleHRbMF07XG4gICAgICAgIGV4dGVuZGVkQ29uZmlnLm11dGF0ZSA9IGNhY2hlQ29udGV4dFsxXTtcbiAgICB9XG4gICAgLy8gVW5zdWJzY3JpYmUgZXZlbnRzLlxuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKGNhY2hlQ29udGV4dCkge1xuICAgICAgICAgICAgY2FjaGVDb250ZXh0WzJdICYmIGNhY2hlQ29udGV4dFsyXSgpO1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlQ29udGV4dFszXTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChTV1JDb25maWdDb250ZXh0LlByb3ZpZGVyLCBtZXJnZU9iamVjdHMocHJvcHMsIHtcbiAgICAgICAgdmFsdWU6IGV4dGVuZGVkQ29uZmlnXG4gICAgfSkpO1xufTtcblxuZXhwb3J0IHsgbm9vcCBhcyBBLCBpc1Byb21pc2VMaWtlIGFzIEIsIElTX1JFQUNUX0xFR0FDWSBhcyBJLCBPQkpFQ1QgYXMgTywgU1dSQ29uZmlnQ29udGV4dCBhcyBTLCBVTkRFRklORUQgYXMgVSwgaXNGdW5jdGlvbiBhcyBhLCBTV1JHbG9iYWxTdGF0ZSBhcyBiLCBjYWNoZSBhcyBjLCBkZWZhdWx0Q29uZmlnIGFzIGQsIGlzVW5kZWZpbmVkIGFzIGUsIG1lcmdlQ29uZmlncyBhcyBmLCBTV1JDb25maWcgYXMgZywgaW5pdENhY2hlIGFzIGgsIGlzV2luZG93RGVmaW5lZCBhcyBpLCBtdXRhdGUgYXMgaiwgY29tcGFyZSBhcyBrLCBzdGFibGVIYXNoIGFzIGwsIG1lcmdlT2JqZWN0cyBhcyBtLCBpbnRlcm5hbE11dGF0ZSBhcyBuLCBnZXRUaW1lc3RhbXAgYXMgbywgcHJlc2V0IGFzIHAsIGRlZmF1bHRDb25maWdPcHRpb25zIGFzIHEsIElTX1NFUlZFUiBhcyByLCBzZXJpYWxpemUgYXMgcywgckFGIGFzIHQsIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgYXMgdSwgc2xvd0Nvbm5lY3Rpb24gYXMgdiwgaXNEb2N1bWVudERlZmluZWQgYXMgdywgaXNMZWdhY3lEZW5vIGFzIHgsIGhhc1JlcXVlc3RBbmltYXRpb25GcmFtZSBhcyB5LCBjcmVhdGVDYWNoZUhlbHBlciBhcyB6IH07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZU1lbW8iLCJ1c2VSZWYiLCJjcmVhdGVFbGVtZW50IiwicmV2YWxpZGF0ZUV2ZW50cyIsImRlcXVhbCIsIlNXUkdsb2JhbFN0YXRlIiwiV2Vha01hcCIsIm5vb3AiLCJVTkRFRklORUQiLCJPQkpFQ1QiLCJPYmplY3QiLCJpc1VuZGVmaW5lZCIsInYiLCJpc0Z1bmN0aW9uIiwibWVyZ2VPYmplY3RzIiwiYSIsImIiLCJpc1Byb21pc2VMaWtlIiwieCIsInRoZW4iLCJFTVBUWV9DQUNIRSIsIklOSVRJQUxfQ0FDSEUiLCJTVFJfVU5ERUZJTkVEIiwiaXNXaW5kb3dEZWZpbmVkIiwid2luZG93IiwiaXNEb2N1bWVudERlZmluZWQiLCJkb2N1bWVudCIsImlzTGVnYWN5RGVubyIsImhhc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsImNyZWF0ZUNhY2hlSGVscGVyIiwiY2FjaGUiLCJrZXkiLCJzdGF0ZSIsImdldCIsImluZm8iLCJwcmV2Iiwib25saW5lIiwiaXNPbmxpbmUiLCJvbldpbmRvd0V2ZW50Iiwib2ZmV2luZG93RXZlbnQiLCJhZGRFdmVudExpc3RlbmVyIiwiYmluZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJpc1Zpc2libGUiLCJ2aXNpYmlsaXR5U3RhdGUiLCJpbml0Rm9jdXMiLCJjYWxsYmFjayIsImluaXRSZWNvbm5lY3QiLCJvbk9ubGluZSIsIm9uT2ZmbGluZSIsInByZXNldCIsImRlZmF1bHRDb25maWdPcHRpb25zIiwiSVNfUkVBQ1RfTEVHQUNZIiwidXNlSWQiLCJJU19TRVJWRVIiLCJyQUYiLCJmIiwic2V0VGltZW91dCIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJuYXZpZ2F0b3JDb25uZWN0aW9uIiwibmF2aWdhdG9yIiwiY29ubmVjdGlvbiIsInNsb3dDb25uZWN0aW9uIiwiaW5jbHVkZXMiLCJlZmZlY3RpdmVUeXBlIiwic2F2ZURhdGEiLCJ0YWJsZSIsImdldFR5cGVOYW1lIiwidmFsdWUiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpc09iamVjdFR5cGVOYW1lIiwidHlwZU5hbWUiLCJ0eXBlIiwiY291bnRlciIsInN0YWJsZUhhc2giLCJhcmciLCJpc0RhdGUiLCJpc1JlZ2V4IiwiaXNQbGFpbk9iamVjdCIsInJlc3VsdCIsImluZGV4Iiwic2V0IiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwia2V5cyIsInNvcnQiLCJwb3AiLCJ0b0pTT04iLCJKU09OIiwic3RyaW5naWZ5Iiwic2VyaWFsaXplIiwiZXJyIiwiYXJncyIsIl9fdGltZXN0YW1wIiwiZ2V0VGltZXN0YW1wIiwiaW50ZXJuYWxNdXRhdGUiLCJfa2V5IiwiX2RhdGEiLCJfb3B0cyIsIm9wdGlvbnMiLCJwb3B1bGF0ZUNhY2hlIiwidGhyb3dPbkVycm9yIiwicmV2YWxpZGF0ZSIsInJvbGxiYWNrT25FcnJvck9wdGlvbiIsInJvbGxiYWNrT25FcnJvciIsIm9wdGltaXN0aWNEYXRhIiwiZXJyb3IiLCJrZXlGaWx0ZXIiLCJtYXRjaGVkS2V5cyIsIml0IiwidGVzdCIsIl9rIiwicHVzaCIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJtdXRhdGVCeUtleSIsIkVWRU5UX1JFVkFMSURBVE9SUyIsIk1VVEFUSU9OIiwiRkVUQ0giLCJQUkVMT0FEIiwic3RhcnRSZXZhbGlkYXRlIiwicmV2YWxpZGF0b3JzIiwiZGF0YSIsIk1VVEFURV9FVkVOVCIsImlzRXJyb3IiLCJiZWZvcmVNdXRhdGlvblRzIiwiaGFzT3B0aW1pc3RpY0RhdGEiLCJkaXNwbGF5ZWREYXRhIiwiY3VycmVudERhdGEiLCJfYyIsImNvbW1pdHRlZERhdGEiLCJjYXRjaCIsInBvcHVsYXRlQ2FjaGVkRGF0YSIsInJlc29sdmUiLCJyZXZhbGlkYXRlQWxsS2V5cyIsImluaXRDYWNoZSIsInByb3ZpZGVyIiwiaGFzIiwib3B0cyIsImNyZWF0ZSIsIm11dGF0ZSIsInVubW91bnQiLCJzdWJzY3JpcHRpb25zIiwic3Vic2NyaWJlIiwic3VicyIsInNwbGljZSIsImluZGV4T2YiLCJzZXR0ZXIiLCJmbiIsImluaXRQcm92aWRlciIsInJlbGVhc2VGb2N1cyIsIkZPQ1VTX0VWRU5UIiwicmVsZWFzZVJlY29ubmVjdCIsIlJFQ09OTkVDVF9FVkVOVCIsImRlbGV0ZSIsIm9uRXJyb3JSZXRyeSIsIl8iLCJfXyIsImNvbmZpZyIsIm1heFJldHJ5Q291bnQiLCJlcnJvclJldHJ5Q291bnQiLCJjdXJyZW50UmV0cnlDb3VudCIsInJldHJ5Q291bnQiLCJ0aW1lb3V0IiwiTWF0aCIsInJhbmRvbSIsImVycm9yUmV0cnlJbnRlcnZhbCIsImNvbXBhcmUiLCJNYXAiLCJkZWZhdWx0Q29uZmlnIiwib25Mb2FkaW5nU2xvdyIsIm9uU3VjY2VzcyIsIm9uRXJyb3IiLCJvbkRpc2NhcmRlZCIsInJldmFsaWRhdGVPbkZvY3VzIiwicmV2YWxpZGF0ZU9uUmVjb25uZWN0IiwicmV2YWxpZGF0ZUlmU3RhbGUiLCJzaG91bGRSZXRyeU9uRXJyb3IiLCJmb2N1c1Rocm90dGxlSW50ZXJ2YWwiLCJkZWR1cGluZ0ludGVydmFsIiwibG9hZGluZ1RpbWVvdXQiLCJpc1BhdXNlZCIsImZhbGxiYWNrIiwibWVyZ2VDb25maWdzIiwidXNlIiwidTEiLCJmMSIsInUyIiwiZjIiLCJjb25jYXQiLCJTV1JDb25maWdDb250ZXh0IiwiU1dSQ29uZmlnIiwicHJvcHMiLCJwYXJlbnRDb25maWciLCJpc0Z1bmN0aW9uYWxDb25maWciLCJleHRlbmRlZENvbmZpZyIsImNhY2hlQ29udGV4dFJlZiIsImN1cnJlbnQiLCJjYWNoZUNvbnRleHQiLCJQcm92aWRlciIsIkEiLCJCIiwiSSIsIk8iLCJTIiwiVSIsImMiLCJkIiwiZSIsImciLCJoIiwiaSIsImoiLCJrIiwibCIsIm0iLCJuIiwibyIsInAiLCJxIiwiciIsInMiLCJ0IiwidSIsInciLCJ5IiwieiJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/swr/dist/_internal/config-context-client-BoS53ST9.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/swr/dist/_internal/constants.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/swr/dist/_internal/constants.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   INFINITE_PREFIX: () => (/* binding */ INFINITE_PREFIX)\n/* harmony export */ });\nconst INFINITE_PREFIX = '$inf$';\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zd3IvZGlzdC9faW50ZXJuYWwvY29uc3RhbnRzLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0FBRTJCIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvc3dyL2Rpc3QvX2ludGVybmFsL2NvbnN0YW50cy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgSU5GSU5JVEVfUFJFRklYID0gJyRpbmYkJztcblxuZXhwb3J0IHsgSU5GSU5JVEVfUFJFRklYIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/swr/dist/_internal/constants.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/swr/dist/_internal/events.mjs":
/*!****************************************************!*\
  !*** ./node_modules/swr/dist/_internal/events.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ERROR_REVALIDATE_EVENT: () => (/* binding */ ERROR_REVALIDATE_EVENT),\n/* harmony export */   FOCUS_EVENT: () => (/* binding */ FOCUS_EVENT),\n/* harmony export */   MUTATE_EVENT: () => (/* binding */ MUTATE_EVENT),\n/* harmony export */   RECONNECT_EVENT: () => (/* binding */ RECONNECT_EVENT)\n/* harmony export */ });\nconst FOCUS_EVENT = 0;\nconst RECONNECT_EVENT = 1;\nconst MUTATE_EVENT = 2;\nconst ERROR_REVALIDATE_EVENT = 3;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zd3IvZGlzdC9faW50ZXJuYWwvZXZlbnRzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRThFIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvc3dyL2Rpc3QvX2ludGVybmFsL2V2ZW50cy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgRk9DVVNfRVZFTlQgPSAwO1xuY29uc3QgUkVDT05ORUNUX0VWRU5UID0gMTtcbmNvbnN0IE1VVEFURV9FVkVOVCA9IDI7XG5jb25zdCBFUlJPUl9SRVZBTElEQVRFX0VWRU5UID0gMztcblxuZXhwb3J0IHsgRVJST1JfUkVWQUxJREFURV9FVkVOVCwgRk9DVVNfRVZFTlQsIE1VVEFURV9FVkVOVCwgUkVDT05ORUNUX0VWRU5UIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/swr/dist/_internal/events.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/swr/dist/_internal/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/swr/dist/_internal/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   INFINITE_PREFIX: () => (/* reexport safe */ _constants_mjs__WEBPACK_IMPORTED_MODULE_2__.INFINITE_PREFIX),\n/* harmony export */   IS_REACT_LEGACY: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.I),\n/* harmony export */   IS_SERVER: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   OBJECT: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.O),\n/* harmony export */   SWRConfig: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   SWRGlobalState: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   UNDEFINED: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.U),\n/* harmony export */   cache: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   compare: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   createCacheHelper: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   defaultConfig: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   defaultConfigOptions: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   getTimestamp: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   hasRequestAnimationFrame: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   initCache: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   internalMutate: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   isDocumentDefined: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   isFunction: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.a),\n/* harmony export */   isLegacyDeno: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   isPromiseLike: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.B),\n/* harmony export */   isUndefined: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   isWindowDefined: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.i),\n/* harmony export */   mergeConfigs: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   mergeObjects: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   mutate: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   noop: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.A),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   preload: () => (/* binding */ preload),\n/* harmony export */   preset: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   rAF: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   revalidateEvents: () => (/* reexport module object */ _events_mjs__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   serialize: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   slowConnection: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   stableHash: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   subscribeCallback: () => (/* binding */ subscribeCallback),\n/* harmony export */   useIsomorphicLayoutEffect: () => (/* reexport safe */ _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.u),\n/* harmony export */   useSWRConfig: () => (/* binding */ useSWRConfig),\n/* harmony export */   withArgs: () => (/* binding */ withArgs),\n/* harmony export */   withMiddleware: () => (/* binding */ withMiddleware)\n/* harmony export */ });\n/* harmony import */ var _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config-context-client-BoS53ST9.mjs */ \"(app-pages-browser)/./node_modules/swr/dist/_internal/config-context-client-BoS53ST9.mjs\");\n/* harmony import */ var _events_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events.mjs */ \"(app-pages-browser)/./node_modules/swr/dist/_internal/events.mjs\");\n/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.mjs */ \"(app-pages-browser)/./node_modules/swr/dist/_internal/constants.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n\n\n\n\n\n\n\n\n// @ts-expect-error\nconst enableDevtools = _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.i && window.__SWR_DEVTOOLS_USE__;\nconst use = enableDevtools ? window.__SWR_DEVTOOLS_USE__ : [];\nconst setupDevTools = ()=>{\n    if (enableDevtools) {\n        // @ts-expect-error\n        window.__SWR_DEVTOOLS_REACT__ = react__WEBPACK_IMPORTED_MODULE_3__;\n    }\n};\n\nconst normalize = (args)=>{\n    return (0,_config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.a)(args[1]) ? [\n        args[0],\n        args[1],\n        args[2] || {}\n    ] : [\n        args[0],\n        null,\n        (args[1] === null ? args[2] : args[1]) || {}\n    ];\n};\n\nconst useSWRConfig = ()=>{\n    return (0,_config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.m)(_config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.d, (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(_config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.S));\n};\n\nconst preload = (key_, fetcher)=>{\n    const [key, fnArg] = (0,_config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(key_);\n    const [, , , PRELOAD] = _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.b.get(_config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.c);\n    // Prevent preload to be called multiple times before used.\n    if (PRELOAD[key]) return PRELOAD[key];\n    const req = fetcher(fnArg);\n    PRELOAD[key] = req;\n    return req;\n};\nconst middleware = (useSWRNext)=>(key_, fetcher_, config)=>{\n        // fetcher might be a sync function, so this should not be an async function\n        const fetcher = fetcher_ && ((...args)=>{\n            const [key] = (0,_config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(key_);\n            const [, , , PRELOAD] = _config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.b.get(_config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.c);\n            if (key.startsWith(_constants_mjs__WEBPACK_IMPORTED_MODULE_2__.INFINITE_PREFIX)) {\n                // we want the infinite fetcher to be called.\n                // handling of the PRELOAD cache happens there.\n                return fetcher_(...args);\n            }\n            const req = PRELOAD[key];\n            if ((0,_config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.e)(req)) return fetcher_(...args);\n            delete PRELOAD[key];\n            return req;\n        });\n        return useSWRNext(key_, fetcher, config);\n    };\n\nconst BUILT_IN_MIDDLEWARE = use.concat(middleware);\n\n// It's tricky to pass generic types as parameters, so we just directly override\n// the types here.\nconst withArgs = (hook)=>{\n    return function useSWRArgs(...args) {\n        // Get the default and inherited configuration.\n        const fallbackConfig = useSWRConfig();\n        // Normalize arguments.\n        const [key, fn, _config] = normalize(args);\n        // Merge configurations.\n        const config = (0,_config_context_client_BoS53ST9_mjs__WEBPACK_IMPORTED_MODULE_0__.f)(fallbackConfig, _config);\n        // Apply middleware\n        let next = hook;\n        const { use } = config;\n        const middleware = (use || []).concat(BUILT_IN_MIDDLEWARE);\n        for(let i = middleware.length; i--;){\n            next = middleware[i](next);\n        }\n        return next(key, fn || config.fetcher || null, config);\n    };\n};\n\n// Add a callback function to a list of keyed callback functions and return\n// the unsubscribe function.\nconst subscribeCallback = (key, callbacks, callback)=>{\n    const keyedRevalidators = callbacks[key] || (callbacks[key] = []);\n    keyedRevalidators.push(callback);\n    return ()=>{\n        const index = keyedRevalidators.indexOf(callback);\n        if (index >= 0) {\n            // O(1): faster than splice\n            keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1];\n            keyedRevalidators.pop();\n        }\n    };\n};\n\n// Create a custom hook with a middleware\nconst withMiddleware = (useSWR, middleware)=>{\n    return (...args)=>{\n        const [key, fn, config] = normalize(args);\n        const uses = (config.use || []).concat(middleware);\n        return useSWR(key, fn, {\n            ...config,\n            use: uses\n        });\n    };\n};\n\nsetupDevTools();\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zd3IvZGlzdC9faW50ZXJuYWwvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaVA7QUFDb087QUFDcGE7QUFDckI7QUFDc0I7QUFDQTtBQUNSO0FBQ2Q7O0FBRTVCO0FBQ0EsdUJBQXVCLGtFQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtDQUFLO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHNFQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsc0VBQVksQ0FBQyxrRUFBYSxFQUFFLGlEQUFVLENBQUMsa0VBQWdCO0FBQ2xFOztBQUVBO0FBQ0EseUJBQXlCLHNFQUFTO0FBQ2xDLDRCQUE0QixrRUFBYyxLQUFLLGtFQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzRUFBUztBQUNuQyxvQ0FBb0Msa0VBQWMsS0FBSyxrRUFBSztBQUM1RCwrQkFBK0IsMkRBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzRUFBVztBQUMzQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNFQUFZO0FBQ25DO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBLHVDQUF1QyxJQUFJO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRWdOIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvc3dyL2Rpc3QvX2ludGVybmFsL2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpIGFzIGlzV2luZG93RGVmaW5lZCwgYSBhcyBpc0Z1bmN0aW9uLCBtIGFzIG1lcmdlT2JqZWN0cywgUyBhcyBTV1JDb25maWdDb250ZXh0LCBkIGFzIGRlZmF1bHRDb25maWcsIHMgYXMgc2VyaWFsaXplLCBiIGFzIFNXUkdsb2JhbFN0YXRlLCBjIGFzIGNhY2hlLCBlIGFzIGlzVW5kZWZpbmVkLCBmIGFzIG1lcmdlQ29uZmlncyB9IGZyb20gJy4vY29uZmlnLWNvbnRleHQtY2xpZW50LUJvUzUzU1Q5Lm1qcyc7XG5leHBvcnQgeyBJIGFzIElTX1JFQUNUX0xFR0FDWSwgciBhcyBJU19TRVJWRVIsIE8gYXMgT0JKRUNULCBnIGFzIFNXUkNvbmZpZywgVSBhcyBVTkRFRklORUQsIGsgYXMgY29tcGFyZSwgeiBhcyBjcmVhdGVDYWNoZUhlbHBlciwgcSBhcyBkZWZhdWx0Q29uZmlnT3B0aW9ucywgbyBhcyBnZXRUaW1lc3RhbXAsIHkgYXMgaGFzUmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBoIGFzIGluaXRDYWNoZSwgbiBhcyBpbnRlcm5hbE11dGF0ZSwgdyBhcyBpc0RvY3VtZW50RGVmaW5lZCwgeCBhcyBpc0xlZ2FjeURlbm8sIEIgYXMgaXNQcm9taXNlTGlrZSwgaiBhcyBtdXRhdGUsIEEgYXMgbm9vcCwgcCBhcyBwcmVzZXQsIHQgYXMgckFGLCB2IGFzIHNsb3dDb25uZWN0aW9uLCBsIGFzIHN0YWJsZUhhc2gsIHUgYXMgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCB9IGZyb20gJy4vY29uZmlnLWNvbnRleHQtY2xpZW50LUJvUzUzU1Q5Lm1qcyc7XG5pbXBvcnQgKiBhcyByZXZhbGlkYXRlRXZlbnRzIGZyb20gJy4vZXZlbnRzLm1qcyc7XG5leHBvcnQgeyByZXZhbGlkYXRlRXZlbnRzIH07XG5pbXBvcnQgeyBJTkZJTklURV9QUkVGSVggfSBmcm9tICcuL2NvbnN0YW50cy5tanMnO1xuZXhwb3J0IHsgSU5GSU5JVEVfUFJFRklYIH0gZnJvbSAnLi9jb25zdGFudHMubWpzJztcbmltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuZXhwb3J0ICogZnJvbSAnLi90eXBlcy5tanMnO1xuXG4vLyBAdHMtZXhwZWN0LWVycm9yXG5jb25zdCBlbmFibGVEZXZ0b29scyA9IGlzV2luZG93RGVmaW5lZCAmJiB3aW5kb3cuX19TV1JfREVWVE9PTFNfVVNFX187XG5jb25zdCB1c2UgPSBlbmFibGVEZXZ0b29scyA/IHdpbmRvdy5fX1NXUl9ERVZUT09MU19VU0VfXyA6IFtdO1xuY29uc3Qgc2V0dXBEZXZUb29scyA9ICgpPT57XG4gICAgaWYgKGVuYWJsZURldnRvb2xzKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgd2luZG93Ll9fU1dSX0RFVlRPT0xTX1JFQUNUX18gPSBSZWFjdDtcbiAgICB9XG59O1xuXG5jb25zdCBub3JtYWxpemUgPSAoYXJncyk9PntcbiAgICByZXR1cm4gaXNGdW5jdGlvbihhcmdzWzFdKSA/IFtcbiAgICAgICAgYXJnc1swXSxcbiAgICAgICAgYXJnc1sxXSxcbiAgICAgICAgYXJnc1syXSB8fCB7fVxuICAgIF0gOiBbXG4gICAgICAgIGFyZ3NbMF0sXG4gICAgICAgIG51bGwsXG4gICAgICAgIChhcmdzWzFdID09PSBudWxsID8gYXJnc1syXSA6IGFyZ3NbMV0pIHx8IHt9XG4gICAgXTtcbn07XG5cbmNvbnN0IHVzZVNXUkNvbmZpZyA9ICgpPT57XG4gICAgcmV0dXJuIG1lcmdlT2JqZWN0cyhkZWZhdWx0Q29uZmlnLCB1c2VDb250ZXh0KFNXUkNvbmZpZ0NvbnRleHQpKTtcbn07XG5cbmNvbnN0IHByZWxvYWQgPSAoa2V5XywgZmV0Y2hlcik9PntcbiAgICBjb25zdCBba2V5LCBmbkFyZ10gPSBzZXJpYWxpemUoa2V5Xyk7XG4gICAgY29uc3QgWywgLCAsIFBSRUxPQURdID0gU1dSR2xvYmFsU3RhdGUuZ2V0KGNhY2hlKTtcbiAgICAvLyBQcmV2ZW50IHByZWxvYWQgdG8gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGJlZm9yZSB1c2VkLlxuICAgIGlmIChQUkVMT0FEW2tleV0pIHJldHVybiBQUkVMT0FEW2tleV07XG4gICAgY29uc3QgcmVxID0gZmV0Y2hlcihmbkFyZyk7XG4gICAgUFJFTE9BRFtrZXldID0gcmVxO1xuICAgIHJldHVybiByZXE7XG59O1xuY29uc3QgbWlkZGxld2FyZSA9ICh1c2VTV1JOZXh0KT0+KGtleV8sIGZldGNoZXJfLCBjb25maWcpPT57XG4gICAgICAgIC8vIGZldGNoZXIgbWlnaHQgYmUgYSBzeW5jIGZ1bmN0aW9uLCBzbyB0aGlzIHNob3VsZCBub3QgYmUgYW4gYXN5bmMgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgZmV0Y2hlciA9IGZldGNoZXJfICYmICgoLi4uYXJncyk9PntcbiAgICAgICAgICAgIGNvbnN0IFtrZXldID0gc2VyaWFsaXplKGtleV8pO1xuICAgICAgICAgICAgY29uc3QgWywgLCAsIFBSRUxPQURdID0gU1dSR2xvYmFsU3RhdGUuZ2V0KGNhY2hlKTtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChJTkZJTklURV9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgLy8gd2Ugd2FudCB0aGUgaW5maW5pdGUgZmV0Y2hlciB0byBiZSBjYWxsZWQuXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxpbmcgb2YgdGhlIFBSRUxPQUQgY2FjaGUgaGFwcGVucyB0aGVyZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hlcl8oLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXEgPSBQUkVMT0FEW2tleV07XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQocmVxKSkgcmV0dXJuIGZldGNoZXJfKC4uLmFyZ3MpO1xuICAgICAgICAgICAgZGVsZXRlIFBSRUxPQURba2V5XTtcbiAgICAgICAgICAgIHJldHVybiByZXE7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdXNlU1dSTmV4dChrZXlfLCBmZXRjaGVyLCBjb25maWcpO1xuICAgIH07XG5cbmNvbnN0IEJVSUxUX0lOX01JRERMRVdBUkUgPSB1c2UuY29uY2F0KG1pZGRsZXdhcmUpO1xuXG4vLyBJdCdzIHRyaWNreSB0byBwYXNzIGdlbmVyaWMgdHlwZXMgYXMgcGFyYW1ldGVycywgc28gd2UganVzdCBkaXJlY3RseSBvdmVycmlkZVxuLy8gdGhlIHR5cGVzIGhlcmUuXG5jb25zdCB3aXRoQXJncyA9IChob29rKT0+e1xuICAgIHJldHVybiBmdW5jdGlvbiB1c2VTV1JBcmdzKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBkZWZhdWx0IGFuZCBpbmhlcml0ZWQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgY29uc3QgZmFsbGJhY2tDb25maWcgPSB1c2VTV1JDb25maWcoKTtcbiAgICAgICAgLy8gTm9ybWFsaXplIGFyZ3VtZW50cy5cbiAgICAgICAgY29uc3QgW2tleSwgZm4sIF9jb25maWddID0gbm9ybWFsaXplKGFyZ3MpO1xuICAgICAgICAvLyBNZXJnZSBjb25maWd1cmF0aW9ucy5cbiAgICAgICAgY29uc3QgY29uZmlnID0gbWVyZ2VDb25maWdzKGZhbGxiYWNrQ29uZmlnLCBfY29uZmlnKTtcbiAgICAgICAgLy8gQXBwbHkgbWlkZGxld2FyZVxuICAgICAgICBsZXQgbmV4dCA9IGhvb2s7XG4gICAgICAgIGNvbnN0IHsgdXNlIH0gPSBjb25maWc7XG4gICAgICAgIGNvbnN0IG1pZGRsZXdhcmUgPSAodXNlIHx8IFtdKS5jb25jYXQoQlVJTFRfSU5fTUlERExFV0FSRSk7XG4gICAgICAgIGZvcihsZXQgaSA9IG1pZGRsZXdhcmUubGVuZ3RoOyBpLS07KXtcbiAgICAgICAgICAgIG5leHQgPSBtaWRkbGV3YXJlW2ldKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0KGtleSwgZm4gfHwgY29uZmlnLmZldGNoZXIgfHwgbnVsbCwgY29uZmlnKTtcbiAgICB9O1xufTtcblxuLy8gQWRkIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYSBsaXN0IG9mIGtleWVkIGNhbGxiYWNrIGZ1bmN0aW9ucyBhbmQgcmV0dXJuXG4vLyB0aGUgdW5zdWJzY3JpYmUgZnVuY3Rpb24uXG5jb25zdCBzdWJzY3JpYmVDYWxsYmFjayA9IChrZXksIGNhbGxiYWNrcywgY2FsbGJhY2spPT57XG4gICAgY29uc3Qga2V5ZWRSZXZhbGlkYXRvcnMgPSBjYWxsYmFja3Nba2V5XSB8fCAoY2FsbGJhY2tzW2tleV0gPSBbXSk7XG4gICAga2V5ZWRSZXZhbGlkYXRvcnMucHVzaChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpPT57XG4gICAgICAgIGNvbnN0IGluZGV4ID0ga2V5ZWRSZXZhbGlkYXRvcnMuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAvLyBPKDEpOiBmYXN0ZXIgdGhhbiBzcGxpY2VcbiAgICAgICAgICAgIGtleWVkUmV2YWxpZGF0b3JzW2luZGV4XSA9IGtleWVkUmV2YWxpZGF0b3JzW2tleWVkUmV2YWxpZGF0b3JzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAga2V5ZWRSZXZhbGlkYXRvcnMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuLy8gQ3JlYXRlIGEgY3VzdG9tIGhvb2sgd2l0aCBhIG1pZGRsZXdhcmVcbmNvbnN0IHdpdGhNaWRkbGV3YXJlID0gKHVzZVNXUiwgbWlkZGxld2FyZSk9PntcbiAgICByZXR1cm4gKC4uLmFyZ3MpPT57XG4gICAgICAgIGNvbnN0IFtrZXksIGZuLCBjb25maWddID0gbm9ybWFsaXplKGFyZ3MpO1xuICAgICAgICBjb25zdCB1c2VzID0gKGNvbmZpZy51c2UgfHwgW10pLmNvbmNhdChtaWRkbGV3YXJlKTtcbiAgICAgICAgcmV0dXJuIHVzZVNXUihrZXksIGZuLCB7XG4gICAgICAgICAgICAuLi5jb25maWcsXG4gICAgICAgICAgICB1c2U6IHVzZXNcbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG5cbnNldHVwRGV2VG9vbHMoKTtcblxuZXhwb3J0IHsgU1dSR2xvYmFsU3RhdGUsIGNhY2hlLCBkZWZhdWx0Q29uZmlnLCBpc0Z1bmN0aW9uLCBpc1VuZGVmaW5lZCwgaXNXaW5kb3dEZWZpbmVkLCBtZXJnZUNvbmZpZ3MsIG1lcmdlT2JqZWN0cywgbm9ybWFsaXplLCBwcmVsb2FkLCBzZXJpYWxpemUsIHN1YnNjcmliZUNhbGxiYWNrLCB1c2VTV1JDb25maWcsIHdpdGhBcmdzLCB3aXRoTWlkZGxld2FyZSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/swr/dist/_internal/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/swr/dist/index/index.mjs":
/*!***********************************************!*\
  !*** ./node_modules/swr/dist/index/index.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SWRConfig: () => (/* binding */ SWRConfig),\n/* harmony export */   \"default\": () => (/* binding */ useSWR),\n/* harmony export */   mutate: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.j),\n/* harmony export */   preload: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.preload),\n/* harmony export */   unstable_serialize: () => (/* binding */ unstable_serialize),\n/* harmony export */   useSWRConfig: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.useSWRConfig)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\");\n/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_internal/index.mjs */ \"(app-pages-browser)/./node_modules/swr/dist/_internal/config-context-client-BoS53ST9.mjs\");\n/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../_internal/index.mjs */ \"(app-pages-browser)/./node_modules/swr/dist/_internal/events.mjs\");\n/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../_internal/index.mjs */ \"(app-pages-browser)/./node_modules/swr/dist/_internal/index.mjs\");\n\n\n\n\n\n// Shared state between server components and client components\nconst noop = ()=>{};\n// Using noop() as the undefined value as undefined can be replaced\n// by something else. Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nconst UNDEFINED = /*#__NOINLINE__*/ noop();\nconst OBJECT = Object;\nconst isUndefined = (v)=>v === UNDEFINED;\nconst isFunction = (v)=>typeof v == 'function';\n\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nconst table = new WeakMap();\nconst getTypeName = (value)=>OBJECT.prototype.toString.call(value);\nconst isObjectTypeName = (typeName, type)=>typeName === `[object ${type}]`;\n// counter of the key\nlet counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsable.\nconst stableHash = (arg)=>{\n    const type = typeof arg;\n    const typeName = getTypeName(arg);\n    const isDate = isObjectTypeName(typeName, 'Date');\n    const isRegex = isObjectTypeName(typeName, 'RegExp');\n    const isPlainObject = isObjectTypeName(typeName, 'Object');\n    let result;\n    let index;\n    if (OBJECT(arg) === arg && !isDate && !isRegex) {\n        // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n        // If it's already hashed, directly return the result.\n        result = table.get(arg);\n        if (result) return result;\n        // Store the hash first for circular reference detection before entering the\n        // recursive `stableHash` calls.\n        // For other objects like set and map, we use this id directly as the hash.\n        result = ++counter + '~';\n        table.set(arg, result);\n        if (Array.isArray(arg)) {\n            // Array.\n            result = '@';\n            for(index = 0; index < arg.length; index++){\n                result += stableHash(arg[index]) + ',';\n            }\n            table.set(arg, result);\n        }\n        if (isPlainObject) {\n            // Object, sort keys.\n            result = '#';\n            const keys = OBJECT.keys(arg).sort();\n            while(!isUndefined(index = keys.pop())){\n                if (!isUndefined(arg[index])) {\n                    result += index + ':' + stableHash(arg[index]) + ',';\n                }\n            }\n            table.set(arg, result);\n        }\n    } else {\n        result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;\n    }\n    return result;\n};\n\nconst serialize = (key)=>{\n    if (isFunction(key)) {\n        try {\n            key = key();\n        } catch (err) {\n            // dependencies not ready\n            key = '';\n        }\n    }\n    // Use the original key as the argument of fetcher. This can be a string or an\n    // array of values.\n    const args = key;\n    // If key is not falsy, or not an empty array, hash it.\n    key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';\n    return [\n        key,\n        args\n    ];\n};\n\nconst unstable_serialize = (key)=>serialize(key)[0];\n\n/// <reference types=\"react/experimental\" />\nconst use = react__WEBPACK_IMPORTED_MODULE_0__.use || // This extra generic is to avoid TypeScript mixing up the generic and JSX sytax\n// and emitting an error.\n// We assume that this is only for the `use(thenable)` case, not `use(context)`.\n// https://github.com/facebook/react/blob/aed00dacfb79d17c53218404c52b1c7aa59c4a89/packages/react-server/src/ReactFizzThenable.js#L45\n((thenable)=>{\n    switch(thenable.status){\n        case 'pending':\n            throw thenable;\n        case 'fulfilled':\n            return thenable.value;\n        case 'rejected':\n            throw thenable.reason;\n        default:\n            thenable.status = 'pending';\n            thenable.then((v)=>{\n                thenable.status = 'fulfilled';\n                thenable.value = v;\n            }, (e)=>{\n                thenable.status = 'rejected';\n                thenable.reason = e;\n            });\n            throw thenable;\n    }\n});\nconst WITH_DEDUPE = {\n    dedupe: true\n};\nconst useSWRHandler = (_key, fetcher, config)=>{\n    const { cache, compare, suspense, fallbackData, revalidateOnMount, revalidateIfStale, refreshInterval, refreshWhenHidden, refreshWhenOffline, keepPreviousData } = config;\n    const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = _internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.b.get(cache);\n    // `key` is the identifier of the SWR internal state,\n    // `fnArg` is the argument/arguments parsed from the key, which will be passed\n    // to the fetcher.\n    // All of them are derived from `_key`.\n    const [key, fnArg] = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.s)(_key);\n    // If it's the initial render of this hook.\n    const initialMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // If the hook is unmounted already. This will be used to prevent some effects\n    // to be called after unmounting.\n    const unmountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Refs to keep the key and config.\n    const keyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(key);\n    const fetcherRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(fetcher);\n    const configRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(config);\n    const getConfig = ()=>configRef.current;\n    const isActive = ()=>getConfig().isVisible() && getConfig().isOnline();\n    const [getCache, setCache, subscribeCache, getInitialCache] = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.z)(cache, key);\n    const stateDependencies = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({}).current;\n    // Resolve the fallback data from either the inline option, or the global provider.\n    // If it's a promise, we simply let React suspend and resolve it for us.\n    const fallback = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(fallbackData) ? (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(config.fallback) ? _internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.U : config.fallback[key] : fallbackData;\n    const isEqual = (prev, current)=>{\n        for(const _ in stateDependencies){\n            const t = _;\n            if (t === 'data') {\n                if (!compare(prev[t], current[t])) {\n                    if (!(0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(prev[t])) {\n                        return false;\n                    }\n                    if (!compare(returnedData, current[t])) {\n                        return false;\n                    }\n                }\n            } else {\n                if (current[t] !== prev[t]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n    const getSnapshot = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const shouldStartRequest = (()=>{\n            if (!key) return false;\n            if (!fetcher) return false;\n            // If `revalidateOnMount` is set, we take the value directly.\n            if (!(0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(revalidateOnMount)) return revalidateOnMount;\n            // If it's paused, we skip revalidation.\n            if (getConfig().isPaused()) return false;\n            if (suspense) return false;\n            return revalidateIfStale !== false;\n        })();\n        // Get the cache and merge it with expected states.\n        const getSelectedCache = (state)=>{\n            // We only select the needed fields from the state.\n            const snapshot = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(state);\n            delete snapshot._k;\n            if (!shouldStartRequest) {\n                return snapshot;\n            }\n            return {\n                isValidating: true,\n                isLoading: true,\n                ...snapshot\n            };\n        };\n        const cachedData = getCache();\n        const initialData = getInitialCache();\n        const clientSnapshot = getSelectedCache(cachedData);\n        const serverSnapshot = cachedData === initialData ? clientSnapshot : getSelectedCache(initialData);\n        // To make sure that we are returning the same object reference to avoid\n        // unnecessary re-renders, we keep the previous snapshot and use deep\n        // comparison to check if we need to return a new one.\n        let memorizedSnapshot = clientSnapshot;\n        return [\n            ()=>{\n                const newSnapshot = getSelectedCache(getCache());\n                const compareResult = isEqual(newSnapshot, memorizedSnapshot);\n                if (compareResult) {\n                    // Mentally, we should always return the `memorizedSnapshot` here\n                    // as there's no change between the new and old snapshots.\n                    // However, since the `isEqual` function only compares selected fields,\n                    // the values of the unselected fields might be changed. That's\n                    // simply because we didn't track them.\n                    // To support the case in https://github.com/vercel/swr/pull/2576,\n                    // we need to update these fields in the `memorizedSnapshot` too\n                    // with direct mutations to ensure the snapshot is always up-to-date\n                    // even for the unselected fields, but only trigger re-renders when\n                    // the selected fields are changed.\n                    memorizedSnapshot.data = newSnapshot.data;\n                    memorizedSnapshot.isLoading = newSnapshot.isLoading;\n                    memorizedSnapshot.isValidating = newSnapshot.isValidating;\n                    memorizedSnapshot.error = newSnapshot.error;\n                    return memorizedSnapshot;\n                } else {\n                    memorizedSnapshot = newSnapshot;\n                    return newSnapshot;\n                }\n            },\n            ()=>serverSnapshot\n        ];\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        cache,\n        key\n    ]);\n    // Get the current state that SWR should return.\n    const cached = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback)=>subscribeCache(key, (current, prev)=>{\n            if (!isEqual(prev, current)) callback();\n        }), // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        cache,\n        key\n    ]), getSnapshot[0], getSnapshot[1]);\n    const isInitialMount = !initialMountedRef.current;\n    const hasRevalidator = EVENT_REVALIDATORS[key] && EVENT_REVALIDATORS[key].length > 0;\n    const cachedData = cached.data;\n    const data = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(cachedData) ? fallback && (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.B)(fallback) ? use(fallback) : fallback : cachedData;\n    const error = cached.error;\n    // Use a ref to store previously returned data. Use the initial data as its initial value.\n    const laggyDataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(data);\n    const returnedData = keepPreviousData ? (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(cachedData) ? (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(laggyDataRef.current) ? data : laggyDataRef.current : cachedData : data;\n    // - Suspense mode and there's stale data for the initial render.\n    // - Not suspense mode and there is no fallback data and `revalidateIfStale` is enabled.\n    // - `revalidateIfStale` is enabled but `data` is not defined.\n    const shouldDoInitialRevalidation = (()=>{\n        // if a key already has revalidators and also has error, we should not trigger revalidation\n        if (hasRevalidator && !(0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(error)) return false;\n        // If `revalidateOnMount` is set, we take the value directly.\n        if (isInitialMount && !(0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(revalidateOnMount)) return revalidateOnMount;\n        // If it's paused, we skip revalidation.\n        if (getConfig().isPaused()) return false;\n        // Under suspense mode, it will always fetch on render if there is no\n        // stale data so no need to revalidate immediately mount it again.\n        // If data exists, only revalidate if `revalidateIfStale` is true.\n        if (suspense) return (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(data) ? false : revalidateIfStale;\n        // If there is no stale data, we need to revalidate when mount;\n        // If `revalidateIfStale` is set to true, we will always revalidate.\n        return (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(data) || revalidateIfStale;\n    })();\n    // Resolve the default validating state:\n    // If it's able to validate, and it should revalidate when mount, this will be true.\n    const defaultValidatingState = !!(key && fetcher && isInitialMount && shouldDoInitialRevalidation);\n    const isValidating = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(cached.isValidating) ? defaultValidatingState : cached.isValidating;\n    const isLoading = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(cached.isLoading) ? defaultValidatingState : cached.isLoading;\n    // The revalidation function is a carefully crafted wrapper of the original\n    // `fetcher`, to correctly handle the many edge cases.\n    const revalidate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (revalidateOpts)=>{\n        const currentFetcher = fetcherRef.current;\n        if (!key || !currentFetcher || unmountedRef.current || getConfig().isPaused()) {\n            return false;\n        }\n        let newData;\n        let startAt;\n        let loading = true;\n        const opts = revalidateOpts || {};\n        // If there is no ongoing concurrent request, or `dedupe` is not set, a\n        // new request should be initiated.\n        const shouldStartNewRequest = !FETCH[key] || !opts.dedupe;\n        /*\n         For React 17\n         Do unmount check for calls:\n         If key has changed during the revalidation, or the component has been\n         unmounted, old dispatch and old event callbacks should not take any\n         effect\n\n        For React 18\n        only check if key has changed\n        https://github.com/reactwg/react-18/discussions/82\n      */ const callbackSafeguard = ()=>{\n            if (_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.I) {\n                return !unmountedRef.current && key === keyRef.current && initialMountedRef.current;\n            }\n            return key === keyRef.current;\n        };\n        // The final state object when the request finishes.\n        const finalState = {\n            isValidating: false,\n            isLoading: false\n        };\n        const finishRequestAndUpdateState = ()=>{\n            setCache(finalState);\n        };\n        const cleanupState = ()=>{\n            // Check if it's still the same request before deleting it.\n            const requestInfo = FETCH[key];\n            if (requestInfo && requestInfo[1] === startAt) {\n                delete FETCH[key];\n            }\n        };\n        // Start fetching. Change the `isValidating` state, update the cache.\n        const initialState = {\n            isValidating: true\n        };\n        // It is in the `isLoading` state, if and only if there is no cached data.\n        // This bypasses fallback data and laggy data.\n        if ((0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(getCache().data)) {\n            initialState.isLoading = true;\n        }\n        try {\n            if (shouldStartNewRequest) {\n                setCache(initialState);\n                // If no cache is being rendered currently (it shows a blank page),\n                // we trigger the loading slow event.\n                if (config.loadingTimeout && (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(getCache().data)) {\n                    setTimeout(()=>{\n                        if (loading && callbackSafeguard()) {\n                            getConfig().onLoadingSlow(key, config);\n                        }\n                    }, config.loadingTimeout);\n                }\n                // Start the request and save the timestamp.\n                // Key must be truthy if entering here.\n                FETCH[key] = [\n                    currentFetcher(fnArg),\n                    (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.o)()\n                ];\n            }\n            // Wait until the ongoing request is done. Deduplication is also\n            // considered here.\n            ;\n            [newData, startAt] = FETCH[key];\n            newData = await newData;\n            if (shouldStartNewRequest) {\n                // If the request isn't interrupted, clean it up after the\n                // deduplication interval.\n                setTimeout(cleanupState, config.dedupingInterval);\n            }\n            // If there're other ongoing request(s), started after the current one,\n            // we need to ignore the current one to avoid possible race conditions:\n            //   req1------------------>res1        (current one)\n            //        req2---------------->res2\n            // the request that fired later will always be kept.\n            // The timestamp maybe be `undefined` or a number\n            if (!FETCH[key] || FETCH[key][1] !== startAt) {\n                if (shouldStartNewRequest) {\n                    if (callbackSafeguard()) {\n                        getConfig().onDiscarded(key);\n                    }\n                }\n                return false;\n            }\n            // Clear error.\n            finalState.error = _internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.U;\n            // If there're other mutations(s), that overlapped with the current revalidation:\n            // case 1:\n            //   req------------------>res\n            //       mutate------>end\n            // case 2:\n            //         req------------>res\n            //   mutate------>end\n            // case 3:\n            //   req------------------>res\n            //       mutate-------...---------->\n            // we have to ignore the revalidation result (res) because it's no longer fresh.\n            // meanwhile, a new revalidation should be triggered when the mutation ends.\n            const mutationInfo = MUTATION[key];\n            if (!(0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(mutationInfo) && // case 1\n            (startAt <= mutationInfo[0] || // case 2\n            startAt <= mutationInfo[1] || // case 3\n            mutationInfo[1] === 0)) {\n                finishRequestAndUpdateState();\n                if (shouldStartNewRequest) {\n                    if (callbackSafeguard()) {\n                        getConfig().onDiscarded(key);\n                    }\n                }\n                return false;\n            }\n            // Deep compare with the latest state to avoid extra re-renders.\n            // For local state, compare and assign.\n            const cacheData = getCache().data;\n            // Since the compare fn could be custom fn\n            // cacheData might be different from newData even when compare fn returns True\n            finalState.data = compare(cacheData, newData) ? cacheData : newData;\n            // Trigger the successful callback if it's the original request.\n            if (shouldStartNewRequest) {\n                if (callbackSafeguard()) {\n                    getConfig().onSuccess(newData, key, config);\n                }\n            }\n        } catch (err) {\n            cleanupState();\n            const currentConfig = getConfig();\n            const { shouldRetryOnError } = currentConfig;\n            // Not paused, we continue handling the error. Otherwise, discard it.\n            if (!currentConfig.isPaused()) {\n                // Get a new error, don't use deep comparison for errors.\n                finalState.error = err;\n                // Error event and retry logic. Only for the actual request, not\n                // deduped ones.\n                if (shouldStartNewRequest && callbackSafeguard()) {\n                    currentConfig.onError(err, key, currentConfig);\n                    if (shouldRetryOnError === true || (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.a)(shouldRetryOnError) && shouldRetryOnError(err)) {\n                        if (!getConfig().revalidateOnFocus || !getConfig().revalidateOnReconnect || isActive()) {\n                            // If it's inactive, stop. It will auto-revalidate when\n                            // refocusing or reconnecting.\n                            // When retrying, deduplication is always enabled.\n                            currentConfig.onErrorRetry(err, key, currentConfig, (_opts)=>{\n                                const revalidators = EVENT_REVALIDATORS[key];\n                                if (revalidators && revalidators[0]) {\n                                    revalidators[0](_internal_index_mjs__WEBPACK_IMPORTED_MODULE_4__.ERROR_REVALIDATE_EVENT, _opts);\n                                }\n                            }, {\n                                retryCount: (opts.retryCount || 0) + 1,\n                                dedupe: true\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        // Mark loading as stopped.\n        loading = false;\n        // Update the current hook's state.\n        finishRequestAndUpdateState();\n        return true;\n    }, // `setState` is immutable, and `eventsCallback`, `fnArg`, and\n    // `keyValidating` are depending on `key`, so we can exclude them from\n    // the deps array.\n    //\n    // FIXME:\n    // `fn` and `config` might be changed during the lifecycle,\n    // but they might be changed every render like this.\n    // `useSWR('key', () => fetch('/api/'), { suspense: true })`\n    // So we omit the values from the deps array\n    // even though it might cause unexpected behaviors.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        key,\n        cache\n    ]);\n    // Similar to the global mutate but bound to the current cache and key.\n    // `cache` isn't allowed to change during the lifecycle.\n    const boundMutate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(// Use callback to make sure `keyRef.current` returns latest result every time\n    (...args)=>{\n        return (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.n)(cache, keyRef.current, ...args);\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    []);\n    // The logic for updating refs.\n    (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(()=>{\n        fetcherRef.current = fetcher;\n        configRef.current = config;\n        // Handle laggy data updates. If there's cached data of the current key,\n        // it'll be the correct reference.\n        if (!(0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(cachedData)) {\n            laggyDataRef.current = cachedData;\n        }\n    });\n    // After mounted or key changed.\n    (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(()=>{\n        if (!key) return;\n        const softRevalidate = revalidate.bind(_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.U, WITH_DEDUPE);\n        let nextFocusRevalidatedAt = 0;\n        if (getConfig().revalidateOnFocus) {\n            const initNow = Date.now();\n            nextFocusRevalidatedAt = initNow + getConfig().focusThrottleInterval;\n        }\n        // Expose revalidators to global event listeners. So we can trigger\n        // revalidation from the outside.\n        const onRevalidate = (type, opts = {})=>{\n            if (type == _internal_index_mjs__WEBPACK_IMPORTED_MODULE_4__.FOCUS_EVENT) {\n                const now = Date.now();\n                if (getConfig().revalidateOnFocus && now > nextFocusRevalidatedAt && isActive()) {\n                    nextFocusRevalidatedAt = now + getConfig().focusThrottleInterval;\n                    softRevalidate();\n                }\n            } else if (type == _internal_index_mjs__WEBPACK_IMPORTED_MODULE_4__.RECONNECT_EVENT) {\n                if (getConfig().revalidateOnReconnect && isActive()) {\n                    softRevalidate();\n                }\n            } else if (type == _internal_index_mjs__WEBPACK_IMPORTED_MODULE_4__.MUTATE_EVENT) {\n                return revalidate();\n            } else if (type == _internal_index_mjs__WEBPACK_IMPORTED_MODULE_4__.ERROR_REVALIDATE_EVENT) {\n                return revalidate(opts);\n            }\n            return;\n        };\n        const unsubEvents = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.subscribeCallback)(key, EVENT_REVALIDATORS, onRevalidate);\n        // Mark the component as mounted and update corresponding refs.\n        unmountedRef.current = false;\n        keyRef.current = key;\n        initialMountedRef.current = true;\n        // Keep the original key in the cache.\n        setCache({\n            _k: fnArg\n        });\n        // Trigger a revalidation\n        if (shouldDoInitialRevalidation) {\n            // Performance optimization: if a request is already in progress for this key,\n            // skip the revalidation to avoid redundant work\n            if (!FETCH[key]) {\n                if ((0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(data) || _internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.r) {\n                    // Revalidate immediately.\n                    softRevalidate();\n                } else {\n                    // Delay the revalidate if we have data to return so we won't block\n                    // rendering.\n                    (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.t)(softRevalidate);\n                }\n            }\n        }\n        return ()=>{\n            // Mark it as unmounted.\n            unmountedRef.current = true;\n            unsubEvents();\n        };\n    }, [\n        key\n    ]);\n    // Polling\n    (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(()=>{\n        let timer;\n        function next() {\n            // Use the passed interval\n            // ...or invoke the function with the updated data to get the interval\n            const interval = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.a)(refreshInterval) ? refreshInterval(getCache().data) : refreshInterval;\n            // We only start the next interval if `refreshInterval` is not 0, and:\n            // - `force` is true, which is the start of polling\n            // - or `timer` is not 0, which means the effect wasn't canceled\n            if (interval && timer !== -1) {\n                timer = setTimeout(execute, interval);\n            }\n        }\n        function execute() {\n            // Check if it's OK to execute:\n            // Only revalidate when the page is visible, online, and not errored.\n            if (!getCache().error && (refreshWhenHidden || getConfig().isVisible()) && (refreshWhenOffline || getConfig().isOnline())) {\n                revalidate(WITH_DEDUPE).then(next);\n            } else {\n                // Schedule the next interval to check again.\n                next();\n            }\n        }\n        next();\n        return ()=>{\n            if (timer) {\n                clearTimeout(timer);\n                timer = -1;\n            }\n        };\n    }, [\n        refreshInterval,\n        refreshWhenHidden,\n        refreshWhenOffline,\n        key\n    ]);\n    // Display debug info in React DevTools.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(returnedData);\n    // In Suspense mode, we can't return the empty `data` state.\n    // If there is an `error`, the `error` needs to be thrown to the error boundary.\n    // If there is no `error`, the `revalidation` promise needs to be thrown to\n    // the suspense boundary.\n    if (suspense && (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(data) && key) {\n        // SWR should throw when trying to use Suspense on the server with React 18,\n        // without providing any fallback data. This causes hydration errors. See:\n        // https://github.com/vercel/swr/issues/1832\n        if (!_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.I && _internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.r) {\n            throw new Error('Fallback data is required when using Suspense in SSR.');\n        }\n        // Always update fetcher and config refs even with the Suspense mode.\n        fetcherRef.current = fetcher;\n        configRef.current = config;\n        unmountedRef.current = false;\n        const req = PRELOAD[key];\n        if (!(0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(req)) {\n            const promise = boundMutate(req);\n            use(promise);\n        }\n        if ((0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(error)) {\n            const promise = revalidate(WITH_DEDUPE);\n            if (!(0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(returnedData)) {\n                promise.status = 'fulfilled';\n                promise.value = true;\n            }\n            use(promise);\n        } else {\n            throw error;\n        }\n    }\n    const swrResponse = {\n        mutate: boundMutate,\n        get data () {\n            stateDependencies.data = true;\n            return returnedData;\n        },\n        get error () {\n            stateDependencies.error = true;\n            return error;\n        },\n        get isValidating () {\n            stateDependencies.isValidating = true;\n            return isValidating;\n        },\n        get isLoading () {\n            stateDependencies.isLoading = true;\n            return isLoading;\n        }\n    };\n    return swrResponse;\n};\nconst SWRConfig = _internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.O.defineProperty(_internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.g, 'defaultValue', {\n    value: _internal_index_mjs__WEBPACK_IMPORTED_MODULE_2__.d\n});\n/**\n * A hook to fetch data.\n *\n * @link https://swr.vercel.app\n * @example\n * ```jsx\n * import useSWR from 'swr'\n * function Profile() {\n *   const { data, error, isLoading } = useSWR('/api/user', fetcher)\n *   if (error) return <div>failed to load</div>\n *   if (isLoading) return <div>loading...</div>\n *   return <div>hello {data.name}!</div>\n * }\n * ```\n */ const useSWR = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.withArgs)(useSWRHandler);\n\n// useSWR\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zd3IvZGlzdC9pbmRleC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBMkU7QUFDRTtBQUMrVTtBQUNyVjs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLEtBQUs7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSxzQ0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlKQUF5SjtBQUNySywyREFBMkQsa0RBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0RBQVc7QUFDcEM7QUFDQSw4QkFBOEIsNkNBQU07QUFDcEM7QUFD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REFBUTs7QUFFM0I7O0FBRTREIiwic291cmNlcyI6WyIvVXNlcnMvaXNoYXFiZWxsby9XZWJzaXRlL2hhdmVucmlkZV9mdWxsX2FwcC9ub2RlX21vZHVsZXMvc3dyL2Rpc3QvaW5kZXgvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VSZWYsIHVzZU1lbW8sIHVzZUNhbGxiYWNrLCB1c2VEZWJ1Z1ZhbHVlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmUgfSBmcm9tICd1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzJztcbmltcG9ydCB7IE9CSkVDVCBhcyBPQkpFQ1QkMSwgU1dSQ29uZmlnIGFzIFNXUkNvbmZpZyQxLCBkZWZhdWx0Q29uZmlnLCB3aXRoQXJncywgU1dSR2xvYmFsU3RhdGUsIHNlcmlhbGl6ZSBhcyBzZXJpYWxpemUkMSwgY3JlYXRlQ2FjaGVIZWxwZXIsIGlzVW5kZWZpbmVkIGFzIGlzVW5kZWZpbmVkJDEsIFVOREVGSU5FRCBhcyBVTkRFRklORUQkMSwgaXNQcm9taXNlTGlrZSwgZ2V0VGltZXN0YW1wLCBpc0Z1bmN0aW9uIGFzIGlzRnVuY3Rpb24kMSwgcmV2YWxpZGF0ZUV2ZW50cywgaW50ZXJuYWxNdXRhdGUsIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QsIHN1YnNjcmliZUNhbGxiYWNrLCBJU19TRVJWRVIsIHJBRiwgSVNfUkVBQ1RfTEVHQUNZLCBtZXJnZU9iamVjdHMgfSBmcm9tICcuLi9faW50ZXJuYWwvaW5kZXgubWpzJztcbmV4cG9ydCB7IG11dGF0ZSwgcHJlbG9hZCwgdXNlU1dSQ29uZmlnIH0gZnJvbSAnLi4vX2ludGVybmFsL2luZGV4Lm1qcyc7XG5cbi8vIFNoYXJlZCBzdGF0ZSBiZXR3ZWVuIHNlcnZlciBjb21wb25lbnRzIGFuZCBjbGllbnQgY29tcG9uZW50c1xuY29uc3Qgbm9vcCA9ICgpPT57fTtcbi8vIFVzaW5nIG5vb3AoKSBhcyB0aGUgdW5kZWZpbmVkIHZhbHVlIGFzIHVuZGVmaW5lZCBjYW4gYmUgcmVwbGFjZWRcbi8vIGJ5IHNvbWV0aGluZyBlbHNlLiBQcmV0dGllciBpZ25vcmUgYW5kIGV4dHJhIHBhcmVudGhlc2VzIGFyZSBuZWNlc3NhcnkgaGVyZVxuLy8gdG8gZW5zdXJlIHRoYXQgdHNjIGRvZXNuJ3QgcmVtb3ZlIHRoZSBfX05PSU5MSU5FX18gY29tbWVudC5cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgVU5ERUZJTkVEID0gLyojX19OT0lOTElORV9fKi8gbm9vcCgpO1xuY29uc3QgT0JKRUNUID0gT2JqZWN0O1xuY29uc3QgaXNVbmRlZmluZWQgPSAodik9PnYgPT09IFVOREVGSU5FRDtcbmNvbnN0IGlzRnVuY3Rpb24gPSAodik9PnR5cGVvZiB2ID09ICdmdW5jdGlvbic7XG5cbi8vIHVzZSBXZWFrTWFwIHRvIHN0b3JlIHRoZSBvYmplY3QtPmtleSBtYXBwaW5nXG4vLyBzbyB0aGUgb2JqZWN0cyBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4vLyBXZWFrTWFwIHVzZXMgYSBoYXNodGFibGUgdW5kZXIgdGhlIGhvb2QsIHNvIHRoZSBsb29rdXBcbi8vIGNvbXBsZXhpdHkgaXMgYWxtb3N0IE8oMSkuXG5jb25zdCB0YWJsZSA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBnZXRUeXBlTmFtZSA9ICh2YWx1ZSk9Pk9CSkVDVC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5jb25zdCBpc09iamVjdFR5cGVOYW1lID0gKHR5cGVOYW1lLCB0eXBlKT0+dHlwZU5hbWUgPT09IGBbb2JqZWN0ICR7dHlwZX1dYDtcbi8vIGNvdW50ZXIgb2YgdGhlIGtleVxubGV0IGNvdW50ZXIgPSAwO1xuLy8gQSBzdGFibGUgaGFzaCBpbXBsZW1lbnRhdGlvbiB0aGF0IHN1cHBvcnRzOlxuLy8gLSBGYXN0IGFuZCBlbnN1cmVzIHVuaXF1ZSBoYXNoIHByb3BlcnRpZXNcbi8vIC0gSGFuZGxlcyB1bnNlcmlhbGl6YWJsZSB2YWx1ZXNcbi8vIC0gSGFuZGxlcyBvYmplY3Qga2V5IG9yZGVyaW5nXG4vLyAtIEdlbmVyYXRlcyBzaG9ydCByZXN1bHRzXG4vL1xuLy8gVGhpcyBpcyBub3QgYSBzZXJpYWxpemF0aW9uIGZ1bmN0aW9uLCBhbmQgdGhlIHJlc3VsdCBpcyBub3QgZ3VhcmFudGVlZCB0byBiZVxuLy8gcGFyc2FibGUuXG5jb25zdCBzdGFibGVIYXNoID0gKGFyZyk9PntcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIGFyZztcbiAgICBjb25zdCB0eXBlTmFtZSA9IGdldFR5cGVOYW1lKGFyZyk7XG4gICAgY29uc3QgaXNEYXRlID0gaXNPYmplY3RUeXBlTmFtZSh0eXBlTmFtZSwgJ0RhdGUnKTtcbiAgICBjb25zdCBpc1JlZ2V4ID0gaXNPYmplY3RUeXBlTmFtZSh0eXBlTmFtZSwgJ1JlZ0V4cCcpO1xuICAgIGNvbnN0IGlzUGxhaW5PYmplY3QgPSBpc09iamVjdFR5cGVOYW1lKHR5cGVOYW1lLCAnT2JqZWN0Jyk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBsZXQgaW5kZXg7XG4gICAgaWYgKE9CSkVDVChhcmcpID09PSBhcmcgJiYgIWlzRGF0ZSAmJiAhaXNSZWdleCkge1xuICAgICAgICAvLyBPYmplY3QvZnVuY3Rpb24sIG5vdCBudWxsL2RhdGUvcmVnZXhwLiBVc2UgV2Vha01hcCB0byBzdG9yZSB0aGUgaWQgZmlyc3QuXG4gICAgICAgIC8vIElmIGl0J3MgYWxyZWFkeSBoYXNoZWQsIGRpcmVjdGx5IHJldHVybiB0aGUgcmVzdWx0LlxuICAgICAgICByZXN1bHQgPSB0YWJsZS5nZXQoYXJnKTtcbiAgICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgLy8gU3RvcmUgdGhlIGhhc2ggZmlyc3QgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZSBkZXRlY3Rpb24gYmVmb3JlIGVudGVyaW5nIHRoZVxuICAgICAgICAvLyByZWN1cnNpdmUgYHN0YWJsZUhhc2hgIGNhbGxzLlxuICAgICAgICAvLyBGb3Igb3RoZXIgb2JqZWN0cyBsaWtlIHNldCBhbmQgbWFwLCB3ZSB1c2UgdGhpcyBpZCBkaXJlY3RseSBhcyB0aGUgaGFzaC5cbiAgICAgICAgcmVzdWx0ID0gKytjb3VudGVyICsgJ34nO1xuICAgICAgICB0YWJsZS5zZXQoYXJnLCByZXN1bHQpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICAvLyBBcnJheS5cbiAgICAgICAgICAgIHJlc3VsdCA9ICdAJztcbiAgICAgICAgICAgIGZvcihpbmRleCA9IDA7IGluZGV4IDwgYXJnLmxlbmd0aDsgaW5kZXgrKyl7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0YWJsZUhhc2goYXJnW2luZGV4XSkgKyAnLCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWJsZS5zZXQoYXJnLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBPYmplY3QsIHNvcnQga2V5cy5cbiAgICAgICAgICAgIHJlc3VsdCA9ICcjJztcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPQkpFQ1Qua2V5cyhhcmcpLnNvcnQoKTtcbiAgICAgICAgICAgIHdoaWxlKCFpc1VuZGVmaW5lZChpbmRleCA9IGtleXMucG9wKCkpKXtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGFyZ1tpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBpbmRleCArICc6JyArIHN0YWJsZUhhc2goYXJnW2luZGV4XSkgKyAnLCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFibGUuc2V0KGFyZywgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGlzRGF0ZSA/IGFyZy50b0pTT04oKSA6IHR5cGUgPT0gJ3N5bWJvbCcgPyBhcmcudG9TdHJpbmcoKSA6IHR5cGUgPT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeShhcmcpIDogJycgKyBhcmc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBzZXJpYWxpemUgPSAoa2V5KT0+e1xuICAgIGlmIChpc0Z1bmN0aW9uKGtleSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGtleSA9IGtleSgpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIGRlcGVuZGVuY2llcyBub3QgcmVhZHlcbiAgICAgICAgICAgIGtleSA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZSB0aGUgb3JpZ2luYWwga2V5IGFzIHRoZSBhcmd1bWVudCBvZiBmZXRjaGVyLiBUaGlzIGNhbiBiZSBhIHN0cmluZyBvciBhblxuICAgIC8vIGFycmF5IG9mIHZhbHVlcy5cbiAgICBjb25zdCBhcmdzID0ga2V5O1xuICAgIC8vIElmIGtleSBpcyBub3QgZmFsc3ksIG9yIG5vdCBhbiBlbXB0eSBhcnJheSwgaGFzaCBpdC5cbiAgICBrZXkgPSB0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8ga2V5IDogKEFycmF5LmlzQXJyYXkoa2V5KSA/IGtleS5sZW5ndGggOiBrZXkpID8gc3RhYmxlSGFzaChrZXkpIDogJyc7XG4gICAgcmV0dXJuIFtcbiAgICAgICAga2V5LFxuICAgICAgICBhcmdzXG4gICAgXTtcbn07XG5cbmNvbnN0IHVuc3RhYmxlX3NlcmlhbGl6ZSA9IChrZXkpPT5zZXJpYWxpemUoa2V5KVswXTtcblxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJyZWFjdC9leHBlcmltZW50YWxcIiAvPlxuY29uc3QgdXNlID0gUmVhY3QudXNlIHx8IC8vIFRoaXMgZXh0cmEgZ2VuZXJpYyBpcyB0byBhdm9pZCBUeXBlU2NyaXB0IG1peGluZyB1cCB0aGUgZ2VuZXJpYyBhbmQgSlNYIHN5dGF4XG4vLyBhbmQgZW1pdHRpbmcgYW4gZXJyb3IuXG4vLyBXZSBhc3N1bWUgdGhhdCB0aGlzIGlzIG9ubHkgZm9yIHRoZSBgdXNlKHRoZW5hYmxlKWAgY2FzZSwgbm90IGB1c2UoY29udGV4dClgLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvYWVkMDBkYWNmYjc5ZDE3YzUzMjE4NDA0YzUyYjFjN2FhNTljNGE4OS9wYWNrYWdlcy9yZWFjdC1zZXJ2ZXIvc3JjL1JlYWN0Rml6elRoZW5hYmxlLmpzI0w0NVxuKCh0aGVuYWJsZSk9PntcbiAgICBzd2l0Y2godGhlbmFibGUuc3RhdHVzKXtcbiAgICAgICAgY2FzZSAncGVuZGluZyc6XG4gICAgICAgICAgICB0aHJvdyB0aGVuYWJsZTtcbiAgICAgICAgY2FzZSAnZnVsZmlsbGVkJzpcbiAgICAgICAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICAgICAgY2FzZSAncmVqZWN0ZWQnOlxuICAgICAgICAgICAgdGhyb3cgdGhlbmFibGUucmVhc29uO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhlbmFibGUuc3RhdHVzID0gJ3BlbmRpbmcnO1xuICAgICAgICAgICAgdGhlbmFibGUudGhlbigodik9PntcbiAgICAgICAgICAgICAgICB0aGVuYWJsZS5zdGF0dXMgPSAnZnVsZmlsbGVkJztcbiAgICAgICAgICAgICAgICB0aGVuYWJsZS52YWx1ZSA9IHY7XG4gICAgICAgICAgICB9LCAoZSk9PntcbiAgICAgICAgICAgICAgICB0aGVuYWJsZS5zdGF0dXMgPSAncmVqZWN0ZWQnO1xuICAgICAgICAgICAgICAgIHRoZW5hYmxlLnJlYXNvbiA9IGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm93IHRoZW5hYmxlO1xuICAgIH1cbn0pO1xuY29uc3QgV0lUSF9ERURVUEUgPSB7XG4gICAgZGVkdXBlOiB0cnVlXG59O1xuY29uc3QgdXNlU1dSSGFuZGxlciA9IChfa2V5LCBmZXRjaGVyLCBjb25maWcpPT57XG4gICAgY29uc3QgeyBjYWNoZSwgY29tcGFyZSwgc3VzcGVuc2UsIGZhbGxiYWNrRGF0YSwgcmV2YWxpZGF0ZU9uTW91bnQsIHJldmFsaWRhdGVJZlN0YWxlLCByZWZyZXNoSW50ZXJ2YWwsIHJlZnJlc2hXaGVuSGlkZGVuLCByZWZyZXNoV2hlbk9mZmxpbmUsIGtlZXBQcmV2aW91c0RhdGEgfSA9IGNvbmZpZztcbiAgICBjb25zdCBbRVZFTlRfUkVWQUxJREFUT1JTLCBNVVRBVElPTiwgRkVUQ0gsIFBSRUxPQURdID0gU1dSR2xvYmFsU3RhdGUuZ2V0KGNhY2hlKTtcbiAgICAvLyBga2V5YCBpcyB0aGUgaWRlbnRpZmllciBvZiB0aGUgU1dSIGludGVybmFsIHN0YXRlLFxuICAgIC8vIGBmbkFyZ2AgaXMgdGhlIGFyZ3VtZW50L2FyZ3VtZW50cyBwYXJzZWQgZnJvbSB0aGUga2V5LCB3aGljaCB3aWxsIGJlIHBhc3NlZFxuICAgIC8vIHRvIHRoZSBmZXRjaGVyLlxuICAgIC8vIEFsbCBvZiB0aGVtIGFyZSBkZXJpdmVkIGZyb20gYF9rZXlgLlxuICAgIGNvbnN0IFtrZXksIGZuQXJnXSA9IHNlcmlhbGl6ZSQxKF9rZXkpO1xuICAgIC8vIElmIGl0J3MgdGhlIGluaXRpYWwgcmVuZGVyIG9mIHRoaXMgaG9vay5cbiAgICBjb25zdCBpbml0aWFsTW91bnRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgLy8gSWYgdGhlIGhvb2sgaXMgdW5tb3VudGVkIGFscmVhZHkuIFRoaXMgd2lsbCBiZSB1c2VkIHRvIHByZXZlbnQgc29tZSBlZmZlY3RzXG4gICAgLy8gdG8gYmUgY2FsbGVkIGFmdGVyIHVubW91bnRpbmcuXG4gICAgY29uc3QgdW5tb3VudGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgICAvLyBSZWZzIHRvIGtlZXAgdGhlIGtleSBhbmQgY29uZmlnLlxuICAgIGNvbnN0IGtleVJlZiA9IHVzZVJlZihrZXkpO1xuICAgIGNvbnN0IGZldGNoZXJSZWYgPSB1c2VSZWYoZmV0Y2hlcik7XG4gICAgY29uc3QgY29uZmlnUmVmID0gdXNlUmVmKGNvbmZpZyk7XG4gICAgY29uc3QgZ2V0Q29uZmlnID0gKCk9PmNvbmZpZ1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IGlzQWN0aXZlID0gKCk9PmdldENvbmZpZygpLmlzVmlzaWJsZSgpICYmIGdldENvbmZpZygpLmlzT25saW5lKCk7XG4gICAgY29uc3QgW2dldENhY2hlLCBzZXRDYWNoZSwgc3Vic2NyaWJlQ2FjaGUsIGdldEluaXRpYWxDYWNoZV0gPSBjcmVhdGVDYWNoZUhlbHBlcihjYWNoZSwga2V5KTtcbiAgICBjb25zdCBzdGF0ZURlcGVuZGVuY2llcyA9IHVzZVJlZih7fSkuY3VycmVudDtcbiAgICAvLyBSZXNvbHZlIHRoZSBmYWxsYmFjayBkYXRhIGZyb20gZWl0aGVyIHRoZSBpbmxpbmUgb3B0aW9uLCBvciB0aGUgZ2xvYmFsIHByb3ZpZGVyLlxuICAgIC8vIElmIGl0J3MgYSBwcm9taXNlLCB3ZSBzaW1wbHkgbGV0IFJlYWN0IHN1c3BlbmQgYW5kIHJlc29sdmUgaXQgZm9yIHVzLlxuICAgIGNvbnN0IGZhbGxiYWNrID0gaXNVbmRlZmluZWQkMShmYWxsYmFja0RhdGEpID8gaXNVbmRlZmluZWQkMShjb25maWcuZmFsbGJhY2spID8gVU5ERUZJTkVEJDEgOiBjb25maWcuZmFsbGJhY2tba2V5XSA6IGZhbGxiYWNrRGF0YTtcbiAgICBjb25zdCBpc0VxdWFsID0gKHByZXYsIGN1cnJlbnQpPT57XG4gICAgICAgIGZvcihjb25zdCBfIGluIHN0YXRlRGVwZW5kZW5jaWVzKXtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBfO1xuICAgICAgICAgICAgaWYgKHQgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgICAgIGlmICghY29tcGFyZShwcmV2W3RdLCBjdXJyZW50W3RdKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkJDEocHJldlt0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBhcmUocmV0dXJuZWREYXRhLCBjdXJyZW50W3RdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFt0XSAhPT0gcHJldlt0XSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgZ2V0U25hcHNob3QgPSB1c2VNZW1vKCgpPT57XG4gICAgICAgIGNvbnN0IHNob3VsZFN0YXJ0UmVxdWVzdCA9ICgoKT0+e1xuICAgICAgICAgICAgaWYgKCFrZXkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICghZmV0Y2hlcikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgLy8gSWYgYHJldmFsaWRhdGVPbk1vdW50YCBpcyBzZXQsIHdlIHRha2UgdGhlIHZhbHVlIGRpcmVjdGx5LlxuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCQxKHJldmFsaWRhdGVPbk1vdW50KSkgcmV0dXJuIHJldmFsaWRhdGVPbk1vdW50O1xuICAgICAgICAgICAgLy8gSWYgaXQncyBwYXVzZWQsIHdlIHNraXAgcmV2YWxpZGF0aW9uLlxuICAgICAgICAgICAgaWYgKGdldENvbmZpZygpLmlzUGF1c2VkKCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHJldmFsaWRhdGVJZlN0YWxlICE9PSBmYWxzZTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgLy8gR2V0IHRoZSBjYWNoZSBhbmQgbWVyZ2UgaXQgd2l0aCBleHBlY3RlZCBzdGF0ZXMuXG4gICAgICAgIGNvbnN0IGdldFNlbGVjdGVkQ2FjaGUgPSAoc3RhdGUpPT57XG4gICAgICAgICAgICAvLyBXZSBvbmx5IHNlbGVjdCB0aGUgbmVlZGVkIGZpZWxkcyBmcm9tIHRoZSBzdGF0ZS5cbiAgICAgICAgICAgIGNvbnN0IHNuYXBzaG90ID0gbWVyZ2VPYmplY3RzKHN0YXRlKTtcbiAgICAgICAgICAgIGRlbGV0ZSBzbmFwc2hvdC5faztcbiAgICAgICAgICAgIGlmICghc2hvdWxkU3RhcnRSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNMb2FkaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIC4uLnNuYXBzaG90XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYWNoZWREYXRhID0gZ2V0Q2FjaGUoKTtcbiAgICAgICAgY29uc3QgaW5pdGlhbERhdGEgPSBnZXRJbml0aWFsQ2FjaGUoKTtcbiAgICAgICAgY29uc3QgY2xpZW50U25hcHNob3QgPSBnZXRTZWxlY3RlZENhY2hlKGNhY2hlZERhdGEpO1xuICAgICAgICBjb25zdCBzZXJ2ZXJTbmFwc2hvdCA9IGNhY2hlZERhdGEgPT09IGluaXRpYWxEYXRhID8gY2xpZW50U25hcHNob3QgOiBnZXRTZWxlY3RlZENhY2hlKGluaXRpYWxEYXRhKTtcbiAgICAgICAgLy8gVG8gbWFrZSBzdXJlIHRoYXQgd2UgYXJlIHJldHVybmluZyB0aGUgc2FtZSBvYmplY3QgcmVmZXJlbmNlIHRvIGF2b2lkXG4gICAgICAgIC8vIHVubmVjZXNzYXJ5IHJlLXJlbmRlcnMsIHdlIGtlZXAgdGhlIHByZXZpb3VzIHNuYXBzaG90IGFuZCB1c2UgZGVlcFxuICAgICAgICAvLyBjb21wYXJpc29uIHRvIGNoZWNrIGlmIHdlIG5lZWQgdG8gcmV0dXJuIGEgbmV3IG9uZS5cbiAgICAgICAgbGV0IG1lbW9yaXplZFNuYXBzaG90ID0gY2xpZW50U25hcHNob3Q7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAoKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1NuYXBzaG90ID0gZ2V0U2VsZWN0ZWRDYWNoZShnZXRDYWNoZSgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wYXJlUmVzdWx0ID0gaXNFcXVhbChuZXdTbmFwc2hvdCwgbWVtb3JpemVkU25hcHNob3QpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1lbnRhbGx5LCB3ZSBzaG91bGQgYWx3YXlzIHJldHVybiB0aGUgYG1lbW9yaXplZFNuYXBzaG90YCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHRoZXJlJ3Mgbm8gY2hhbmdlIGJldHdlZW4gdGhlIG5ldyBhbmQgb2xkIHNuYXBzaG90cy5cbiAgICAgICAgICAgICAgICAgICAgLy8gSG93ZXZlciwgc2luY2UgdGhlIGBpc0VxdWFsYCBmdW5jdGlvbiBvbmx5IGNvbXBhcmVzIHNlbGVjdGVkIGZpZWxkcyxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHZhbHVlcyBvZiB0aGUgdW5zZWxlY3RlZCBmaWVsZHMgbWlnaHQgYmUgY2hhbmdlZC4gVGhhdCdzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbXBseSBiZWNhdXNlIHdlIGRpZG4ndCB0cmFjayB0aGVtLlxuICAgICAgICAgICAgICAgICAgICAvLyBUbyBzdXBwb3J0IHRoZSBjYXNlIGluIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvc3dyL3B1bGwvMjU3NixcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB1cGRhdGUgdGhlc2UgZmllbGRzIGluIHRoZSBgbWVtb3JpemVkU25hcHNob3RgIHRvb1xuICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIGRpcmVjdCBtdXRhdGlvbnMgdG8gZW5zdXJlIHRoZSBzbmFwc2hvdCBpcyBhbHdheXMgdXAtdG8tZGF0ZVxuICAgICAgICAgICAgICAgICAgICAvLyBldmVuIGZvciB0aGUgdW5zZWxlY3RlZCBmaWVsZHMsIGJ1dCBvbmx5IHRyaWdnZXIgcmUtcmVuZGVycyB3aGVuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzZWxlY3RlZCBmaWVsZHMgYXJlIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgICAgIG1lbW9yaXplZFNuYXBzaG90LmRhdGEgPSBuZXdTbmFwc2hvdC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBtZW1vcml6ZWRTbmFwc2hvdC5pc0xvYWRpbmcgPSBuZXdTbmFwc2hvdC5pc0xvYWRpbmc7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9yaXplZFNuYXBzaG90LmlzVmFsaWRhdGluZyA9IG5ld1NuYXBzaG90LmlzVmFsaWRhdGluZztcbiAgICAgICAgICAgICAgICAgICAgbWVtb3JpemVkU25hcHNob3QuZXJyb3IgPSBuZXdTbmFwc2hvdC5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbW9yaXplZFNuYXBzaG90O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9yaXplZFNuYXBzaG90ID0gbmV3U25hcHNob3Q7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdTbmFwc2hvdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKCk9PnNlcnZlclNuYXBzaG90XG4gICAgICAgIF07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIGtleVxuICAgIF0pO1xuICAgIC8vIEdldCB0aGUgY3VycmVudCBzdGF0ZSB0aGF0IFNXUiBzaG91bGQgcmV0dXJuLlxuICAgIGNvbnN0IGNhY2hlZCA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKHVzZUNhbGxiYWNrKChjYWxsYmFjayk9PnN1YnNjcmliZUNhY2hlKGtleSwgKGN1cnJlbnQsIHByZXYpPT57XG4gICAgICAgICAgICBpZiAoIWlzRXF1YWwocHJldiwgY3VycmVudCkpIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pLCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW1xuICAgICAgICBjYWNoZSxcbiAgICAgICAga2V5XG4gICAgXSksIGdldFNuYXBzaG90WzBdLCBnZXRTbmFwc2hvdFsxXSk7XG4gICAgY29uc3QgaXNJbml0aWFsTW91bnQgPSAhaW5pdGlhbE1vdW50ZWRSZWYuY3VycmVudDtcbiAgICBjb25zdCBoYXNSZXZhbGlkYXRvciA9IEVWRU5UX1JFVkFMSURBVE9SU1trZXldICYmIEVWRU5UX1JFVkFMSURBVE9SU1trZXldLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgY2FjaGVkRGF0YSA9IGNhY2hlZC5kYXRhO1xuICAgIGNvbnN0IGRhdGEgPSBpc1VuZGVmaW5lZCQxKGNhY2hlZERhdGEpID8gZmFsbGJhY2sgJiYgaXNQcm9taXNlTGlrZShmYWxsYmFjaykgPyB1c2UoZmFsbGJhY2spIDogZmFsbGJhY2sgOiBjYWNoZWREYXRhO1xuICAgIGNvbnN0IGVycm9yID0gY2FjaGVkLmVycm9yO1xuICAgIC8vIFVzZSBhIHJlZiB0byBzdG9yZSBwcmV2aW91c2x5IHJldHVybmVkIGRhdGEuIFVzZSB0aGUgaW5pdGlhbCBkYXRhIGFzIGl0cyBpbml0aWFsIHZhbHVlLlxuICAgIGNvbnN0IGxhZ2d5RGF0YVJlZiA9IHVzZVJlZihkYXRhKTtcbiAgICBjb25zdCByZXR1cm5lZERhdGEgPSBrZWVwUHJldmlvdXNEYXRhID8gaXNVbmRlZmluZWQkMShjYWNoZWREYXRhKSA/IGlzVW5kZWZpbmVkJDEobGFnZ3lEYXRhUmVmLmN1cnJlbnQpID8gZGF0YSA6IGxhZ2d5RGF0YVJlZi5jdXJyZW50IDogY2FjaGVkRGF0YSA6IGRhdGE7XG4gICAgLy8gLSBTdXNwZW5zZSBtb2RlIGFuZCB0aGVyZSdzIHN0YWxlIGRhdGEgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cbiAgICAvLyAtIE5vdCBzdXNwZW5zZSBtb2RlIGFuZCB0aGVyZSBpcyBubyBmYWxsYmFjayBkYXRhIGFuZCBgcmV2YWxpZGF0ZUlmU3RhbGVgIGlzIGVuYWJsZWQuXG4gICAgLy8gLSBgcmV2YWxpZGF0ZUlmU3RhbGVgIGlzIGVuYWJsZWQgYnV0IGBkYXRhYCBpcyBub3QgZGVmaW5lZC5cbiAgICBjb25zdCBzaG91bGREb0luaXRpYWxSZXZhbGlkYXRpb24gPSAoKCk9PntcbiAgICAgICAgLy8gaWYgYSBrZXkgYWxyZWFkeSBoYXMgcmV2YWxpZGF0b3JzIGFuZCBhbHNvIGhhcyBlcnJvciwgd2Ugc2hvdWxkIG5vdCB0cmlnZ2VyIHJldmFsaWRhdGlvblxuICAgICAgICBpZiAoaGFzUmV2YWxpZGF0b3IgJiYgIWlzVW5kZWZpbmVkJDEoZXJyb3IpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIElmIGByZXZhbGlkYXRlT25Nb3VudGAgaXMgc2V0LCB3ZSB0YWtlIHRoZSB2YWx1ZSBkaXJlY3RseS5cbiAgICAgICAgaWYgKGlzSW5pdGlhbE1vdW50ICYmICFpc1VuZGVmaW5lZCQxKHJldmFsaWRhdGVPbk1vdW50KSkgcmV0dXJuIHJldmFsaWRhdGVPbk1vdW50O1xuICAgICAgICAvLyBJZiBpdCdzIHBhdXNlZCwgd2Ugc2tpcCByZXZhbGlkYXRpb24uXG4gICAgICAgIGlmIChnZXRDb25maWcoKS5pc1BhdXNlZCgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFVuZGVyIHN1c3BlbnNlIG1vZGUsIGl0IHdpbGwgYWx3YXlzIGZldGNoIG9uIHJlbmRlciBpZiB0aGVyZSBpcyBub1xuICAgICAgICAvLyBzdGFsZSBkYXRhIHNvIG5vIG5lZWQgdG8gcmV2YWxpZGF0ZSBpbW1lZGlhdGVseSBtb3VudCBpdCBhZ2Fpbi5cbiAgICAgICAgLy8gSWYgZGF0YSBleGlzdHMsIG9ubHkgcmV2YWxpZGF0ZSBpZiBgcmV2YWxpZGF0ZUlmU3RhbGVgIGlzIHRydWUuXG4gICAgICAgIGlmIChzdXNwZW5zZSkgcmV0dXJuIGlzVW5kZWZpbmVkJDEoZGF0YSkgPyBmYWxzZSA6IHJldmFsaWRhdGVJZlN0YWxlO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBzdGFsZSBkYXRhLCB3ZSBuZWVkIHRvIHJldmFsaWRhdGUgd2hlbiBtb3VudDtcbiAgICAgICAgLy8gSWYgYHJldmFsaWRhdGVJZlN0YWxlYCBpcyBzZXQgdG8gdHJ1ZSwgd2Ugd2lsbCBhbHdheXMgcmV2YWxpZGF0ZS5cbiAgICAgICAgcmV0dXJuIGlzVW5kZWZpbmVkJDEoZGF0YSkgfHwgcmV2YWxpZGF0ZUlmU3RhbGU7XG4gICAgfSkoKTtcbiAgICAvLyBSZXNvbHZlIHRoZSBkZWZhdWx0IHZhbGlkYXRpbmcgc3RhdGU6XG4gICAgLy8gSWYgaXQncyBhYmxlIHRvIHZhbGlkYXRlLCBhbmQgaXQgc2hvdWxkIHJldmFsaWRhdGUgd2hlbiBtb3VudCwgdGhpcyB3aWxsIGJlIHRydWUuXG4gICAgY29uc3QgZGVmYXVsdFZhbGlkYXRpbmdTdGF0ZSA9ICEhKGtleSAmJiBmZXRjaGVyICYmIGlzSW5pdGlhbE1vdW50ICYmIHNob3VsZERvSW5pdGlhbFJldmFsaWRhdGlvbik7XG4gICAgY29uc3QgaXNWYWxpZGF0aW5nID0gaXNVbmRlZmluZWQkMShjYWNoZWQuaXNWYWxpZGF0aW5nKSA/IGRlZmF1bHRWYWxpZGF0aW5nU3RhdGUgOiBjYWNoZWQuaXNWYWxpZGF0aW5nO1xuICAgIGNvbnN0IGlzTG9hZGluZyA9IGlzVW5kZWZpbmVkJDEoY2FjaGVkLmlzTG9hZGluZykgPyBkZWZhdWx0VmFsaWRhdGluZ1N0YXRlIDogY2FjaGVkLmlzTG9hZGluZztcbiAgICAvLyBUaGUgcmV2YWxpZGF0aW9uIGZ1bmN0aW9uIGlzIGEgY2FyZWZ1bGx5IGNyYWZ0ZWQgd3JhcHBlciBvZiB0aGUgb3JpZ2luYWxcbiAgICAvLyBgZmV0Y2hlcmAsIHRvIGNvcnJlY3RseSBoYW5kbGUgdGhlIG1hbnkgZWRnZSBjYXNlcy5cbiAgICBjb25zdCByZXZhbGlkYXRlID0gdXNlQ2FsbGJhY2soYXN5bmMgKHJldmFsaWRhdGVPcHRzKT0+e1xuICAgICAgICBjb25zdCBjdXJyZW50RmV0Y2hlciA9IGZldGNoZXJSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFrZXkgfHwgIWN1cnJlbnRGZXRjaGVyIHx8IHVubW91bnRlZFJlZi5jdXJyZW50IHx8IGdldENvbmZpZygpLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3RGF0YTtcbiAgICAgICAgbGV0IHN0YXJ0QXQ7XG4gICAgICAgIGxldCBsb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHJldmFsaWRhdGVPcHRzIHx8IHt9O1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBvbmdvaW5nIGNvbmN1cnJlbnQgcmVxdWVzdCwgb3IgYGRlZHVwZWAgaXMgbm90IHNldCwgYVxuICAgICAgICAvLyBuZXcgcmVxdWVzdCBzaG91bGQgYmUgaW5pdGlhdGVkLlxuICAgICAgICBjb25zdCBzaG91bGRTdGFydE5ld1JlcXVlc3QgPSAhRkVUQ0hba2V5XSB8fCAhb3B0cy5kZWR1cGU7XG4gICAgICAgIC8qXG4gICAgICAgICBGb3IgUmVhY3QgMTdcbiAgICAgICAgIERvIHVubW91bnQgY2hlY2sgZm9yIGNhbGxzOlxuICAgICAgICAgSWYga2V5IGhhcyBjaGFuZ2VkIGR1cmluZyB0aGUgcmV2YWxpZGF0aW9uLCBvciB0aGUgY29tcG9uZW50IGhhcyBiZWVuXG4gICAgICAgICB1bm1vdW50ZWQsIG9sZCBkaXNwYXRjaCBhbmQgb2xkIGV2ZW50IGNhbGxiYWNrcyBzaG91bGQgbm90IHRha2UgYW55XG4gICAgICAgICBlZmZlY3RcblxuICAgICAgICBGb3IgUmVhY3QgMThcbiAgICAgICAgb25seSBjaGVjayBpZiBrZXkgaGFzIGNoYW5nZWRcbiAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0d2cvcmVhY3QtMTgvZGlzY3Vzc2lvbnMvODJcbiAgICAgICovIGNvbnN0IGNhbGxiYWNrU2FmZWd1YXJkID0gKCk9PntcbiAgICAgICAgICAgIGlmIChJU19SRUFDVF9MRUdBQ1kpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXVubW91bnRlZFJlZi5jdXJyZW50ICYmIGtleSA9PT0ga2V5UmVmLmN1cnJlbnQgJiYgaW5pdGlhbE1vdW50ZWRSZWYuY3VycmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXkgPT09IGtleVJlZi5jdXJyZW50O1xuICAgICAgICB9O1xuICAgICAgICAvLyBUaGUgZmluYWwgc3RhdGUgb2JqZWN0IHdoZW4gdGhlIHJlcXVlc3QgZmluaXNoZXMuXG4gICAgICAgIGNvbnN0IGZpbmFsU3RhdGUgPSB7XG4gICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUgPSAoKT0+e1xuICAgICAgICAgICAgc2V0Q2FjaGUoZmluYWxTdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNsZWFudXBTdGF0ZSA9ICgpPT57XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIHN0aWxsIHRoZSBzYW1lIHJlcXVlc3QgYmVmb3JlIGRlbGV0aW5nIGl0LlxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEluZm8gPSBGRVRDSFtrZXldO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RJbmZvICYmIHJlcXVlc3RJbmZvWzFdID09PSBzdGFydEF0KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIEZFVENIW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFN0YXJ0IGZldGNoaW5nLiBDaGFuZ2UgdGhlIGBpc1ZhbGlkYXRpbmdgIHN0YXRlLCB1cGRhdGUgdGhlIGNhY2hlLlxuICAgICAgICBjb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSXQgaXMgaW4gdGhlIGBpc0xvYWRpbmdgIHN0YXRlLCBpZiBhbmQgb25seSBpZiB0aGVyZSBpcyBubyBjYWNoZWQgZGF0YS5cbiAgICAgICAgLy8gVGhpcyBieXBhc3NlcyBmYWxsYmFjayBkYXRhIGFuZCBsYWdneSBkYXRhLlxuICAgICAgICBpZiAoaXNVbmRlZmluZWQkMShnZXRDYWNoZSgpLmRhdGEpKSB7XG4gICAgICAgICAgICBpbml0aWFsU3RhdGUuaXNMb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIHNldENhY2hlKGluaXRpYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gY2FjaGUgaXMgYmVpbmcgcmVuZGVyZWQgY3VycmVudGx5IChpdCBzaG93cyBhIGJsYW5rIHBhZ2UpLFxuICAgICAgICAgICAgICAgIC8vIHdlIHRyaWdnZXIgdGhlIGxvYWRpbmcgc2xvdyBldmVudC5cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmxvYWRpbmdUaW1lb3V0ICYmIGlzVW5kZWZpbmVkJDEoZ2V0Q2FjaGUoKS5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9hZGluZyAmJiBjYWxsYmFja1NhZmVndWFyZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25Mb2FkaW5nU2xvdyhrZXksIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIGNvbmZpZy5sb2FkaW5nVGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSByZXF1ZXN0IGFuZCBzYXZlIHRoZSB0aW1lc3RhbXAuXG4gICAgICAgICAgICAgICAgLy8gS2V5IG11c3QgYmUgdHJ1dGh5IGlmIGVudGVyaW5nIGhlcmUuXG4gICAgICAgICAgICAgICAgRkVUQ0hba2V5XSA9IFtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEZldGNoZXIoZm5BcmcpLFxuICAgICAgICAgICAgICAgICAgICBnZXRUaW1lc3RhbXAoKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXYWl0IHVudGlsIHRoZSBvbmdvaW5nIHJlcXVlc3QgaXMgZG9uZS4gRGVkdXBsaWNhdGlvbiBpcyBhbHNvXG4gICAgICAgICAgICAvLyBjb25zaWRlcmVkIGhlcmUuXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBbbmV3RGF0YSwgc3RhcnRBdF0gPSBGRVRDSFtrZXldO1xuICAgICAgICAgICAgbmV3RGF0YSA9IGF3YWl0IG5ld0RhdGE7XG4gICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgaXNuJ3QgaW50ZXJydXB0ZWQsIGNsZWFuIGl0IHVwIGFmdGVyIHRoZVxuICAgICAgICAgICAgICAgIC8vIGRlZHVwbGljYXRpb24gaW50ZXJ2YWwuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChjbGVhbnVwU3RhdGUsIGNvbmZpZy5kZWR1cGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3JlIG90aGVyIG9uZ29pbmcgcmVxdWVzdChzKSwgc3RhcnRlZCBhZnRlciB0aGUgY3VycmVudCBvbmUsXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGlnbm9yZSB0aGUgY3VycmVudCBvbmUgdG8gYXZvaWQgcG9zc2libGUgcmFjZSBjb25kaXRpb25zOlxuICAgICAgICAgICAgLy8gICByZXExLS0tLS0tLS0tLS0tLS0tLS0tPnJlczEgICAgICAgIChjdXJyZW50IG9uZSlcbiAgICAgICAgICAgIC8vICAgICAgICByZXEyLS0tLS0tLS0tLS0tLS0tLT5yZXMyXG4gICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCB0aGF0IGZpcmVkIGxhdGVyIHdpbGwgYWx3YXlzIGJlIGtlcHQuXG4gICAgICAgICAgICAvLyBUaGUgdGltZXN0YW1wIG1heWJlIGJlIGB1bmRlZmluZWRgIG9yIGEgbnVtYmVyXG4gICAgICAgICAgICBpZiAoIUZFVENIW2tleV0gfHwgRkVUQ0hba2V5XVsxXSAhPT0gc3RhcnRBdCkge1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrU2FmZWd1YXJkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uRGlzY2FyZGVkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2xlYXIgZXJyb3IuXG4gICAgICAgICAgICBmaW5hbFN0YXRlLmVycm9yID0gVU5ERUZJTkVEJDE7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdyZSBvdGhlciBtdXRhdGlvbnMocyksIHRoYXQgb3ZlcmxhcHBlZCB3aXRoIHRoZSBjdXJyZW50IHJldmFsaWRhdGlvbjpcbiAgICAgICAgICAgIC8vIGNhc2UgMTpcbiAgICAgICAgICAgIC8vICAgcmVxLS0tLS0tLS0tLS0tLS0tLS0tPnJlc1xuICAgICAgICAgICAgLy8gICAgICAgbXV0YXRlLS0tLS0tPmVuZFxuICAgICAgICAgICAgLy8gY2FzZSAyOlxuICAgICAgICAgICAgLy8gICAgICAgICByZXEtLS0tLS0tLS0tLS0+cmVzXG4gICAgICAgICAgICAvLyAgIG11dGF0ZS0tLS0tLT5lbmRcbiAgICAgICAgICAgIC8vIGNhc2UgMzpcbiAgICAgICAgICAgIC8vICAgcmVxLS0tLS0tLS0tLS0tLS0tLS0tPnJlc1xuICAgICAgICAgICAgLy8gICAgICAgbXV0YXRlLS0tLS0tLS4uLi0tLS0tLS0tLS0+XG4gICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIGlnbm9yZSB0aGUgcmV2YWxpZGF0aW9uIHJlc3VsdCAocmVzKSBiZWNhdXNlIGl0J3Mgbm8gbG9uZ2VyIGZyZXNoLlxuICAgICAgICAgICAgLy8gbWVhbndoaWxlLCBhIG5ldyByZXZhbGlkYXRpb24gc2hvdWxkIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBtdXRhdGlvbiBlbmRzLlxuICAgICAgICAgICAgY29uc3QgbXV0YXRpb25JbmZvID0gTVVUQVRJT05ba2V5XTtcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQkMShtdXRhdGlvbkluZm8pICYmIC8vIGNhc2UgMVxuICAgICAgICAgICAgKHN0YXJ0QXQgPD0gbXV0YXRpb25JbmZvWzBdIHx8IC8vIGNhc2UgMlxuICAgICAgICAgICAgc3RhcnRBdCA8PSBtdXRhdGlvbkluZm9bMV0gfHwgLy8gY2FzZSAzXG4gICAgICAgICAgICBtdXRhdGlvbkluZm9bMV0gPT09IDApKSB7XG4gICAgICAgICAgICAgICAgZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tTYWZlZ3VhcmQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25EaXNjYXJkZWQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWVwIGNvbXBhcmUgd2l0aCB0aGUgbGF0ZXN0IHN0YXRlIHRvIGF2b2lkIGV4dHJhIHJlLXJlbmRlcnMuXG4gICAgICAgICAgICAvLyBGb3IgbG9jYWwgc3RhdGUsIGNvbXBhcmUgYW5kIGFzc2lnbi5cbiAgICAgICAgICAgIGNvbnN0IGNhY2hlRGF0YSA9IGdldENhY2hlKCkuZGF0YTtcbiAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBjb21wYXJlIGZuIGNvdWxkIGJlIGN1c3RvbSBmblxuICAgICAgICAgICAgLy8gY2FjaGVEYXRhIG1pZ2h0IGJlIGRpZmZlcmVudCBmcm9tIG5ld0RhdGEgZXZlbiB3aGVuIGNvbXBhcmUgZm4gcmV0dXJucyBUcnVlXG4gICAgICAgICAgICBmaW5hbFN0YXRlLmRhdGEgPSBjb21wYXJlKGNhY2hlRGF0YSwgbmV3RGF0YSkgPyBjYWNoZURhdGEgOiBuZXdEYXRhO1xuICAgICAgICAgICAgLy8gVHJpZ2dlciB0aGUgc3VjY2Vzc2Z1bCBjYWxsYmFjayBpZiBpdCdzIHRoZSBvcmlnaW5hbCByZXF1ZXN0LlxuICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja1NhZmVndWFyZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uU3VjY2VzcyhuZXdEYXRhLCBrZXksIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNsZWFudXBTdGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudENvbmZpZyA9IGdldENvbmZpZygpO1xuICAgICAgICAgICAgY29uc3QgeyBzaG91bGRSZXRyeU9uRXJyb3IgfSA9IGN1cnJlbnRDb25maWc7XG4gICAgICAgICAgICAvLyBOb3QgcGF1c2VkLCB3ZSBjb250aW51ZSBoYW5kbGluZyB0aGUgZXJyb3IuIE90aGVyd2lzZSwgZGlzY2FyZCBpdC5cbiAgICAgICAgICAgIGlmICghY3VycmVudENvbmZpZy5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IGEgbmV3IGVycm9yLCBkb24ndCB1c2UgZGVlcCBjb21wYXJpc29uIGZvciBlcnJvcnMuXG4gICAgICAgICAgICAgICAgZmluYWxTdGF0ZS5lcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAvLyBFcnJvciBldmVudCBhbmQgcmV0cnkgbG9naWMuIE9ubHkgZm9yIHRoZSBhY3R1YWwgcmVxdWVzdCwgbm90XG4gICAgICAgICAgICAgICAgLy8gZGVkdXBlZCBvbmVzLlxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QgJiYgY2FsbGJhY2tTYWZlZ3VhcmQoKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29uZmlnLm9uRXJyb3IoZXJyLCBrZXksIGN1cnJlbnRDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUmV0cnlPbkVycm9yID09PSB0cnVlIHx8IGlzRnVuY3Rpb24kMShzaG91bGRSZXRyeU9uRXJyb3IpICYmIHNob3VsZFJldHJ5T25FcnJvcihlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWdldENvbmZpZygpLnJldmFsaWRhdGVPbkZvY3VzIHx8ICFnZXRDb25maWcoKS5yZXZhbGlkYXRlT25SZWNvbm5lY3QgfHwgaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgaW5hY3RpdmUsIHN0b3AuIEl0IHdpbGwgYXV0by1yZXZhbGlkYXRlIHdoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWZvY3VzaW5nIG9yIHJlY29ubmVjdGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHJldHJ5aW5nLCBkZWR1cGxpY2F0aW9uIGlzIGFsd2F5cyBlbmFibGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb25maWcub25FcnJvclJldHJ5KGVyciwga2V5LCBjdXJyZW50Q29uZmlnLCAoX29wdHMpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldmFsaWRhdG9ycyA9IEVWRU5UX1JFVkFMSURBVE9SU1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV2YWxpZGF0b3JzICYmIHJldmFsaWRhdG9yc1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0b3JzWzBdKHJldmFsaWRhdGVFdmVudHMuRVJST1JfUkVWQUxJREFURV9FVkVOVCwgX29wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeUNvdW50OiAob3B0cy5yZXRyeUNvdW50IHx8IDApICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVkdXBlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFyayBsb2FkaW5nIGFzIHN0b3BwZWQuXG4gICAgICAgIGxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IGhvb2sncyBzdGF0ZS5cbiAgICAgICAgZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIC8vIGBzZXRTdGF0ZWAgaXMgaW1tdXRhYmxlLCBhbmQgYGV2ZW50c0NhbGxiYWNrYCwgYGZuQXJnYCwgYW5kXG4gICAgLy8gYGtleVZhbGlkYXRpbmdgIGFyZSBkZXBlbmRpbmcgb24gYGtleWAsIHNvIHdlIGNhbiBleGNsdWRlIHRoZW0gZnJvbVxuICAgIC8vIHRoZSBkZXBzIGFycmF5LlxuICAgIC8vXG4gICAgLy8gRklYTUU6XG4gICAgLy8gYGZuYCBhbmQgYGNvbmZpZ2AgbWlnaHQgYmUgY2hhbmdlZCBkdXJpbmcgdGhlIGxpZmVjeWNsZSxcbiAgICAvLyBidXQgdGhleSBtaWdodCBiZSBjaGFuZ2VkIGV2ZXJ5IHJlbmRlciBsaWtlIHRoaXMuXG4gICAgLy8gYHVzZVNXUigna2V5JywgKCkgPT4gZmV0Y2goJy9hcGkvJyksIHsgc3VzcGVuc2U6IHRydWUgfSlgXG4gICAgLy8gU28gd2Ugb21pdCB0aGUgdmFsdWVzIGZyb20gdGhlIGRlcHMgYXJyYXlcbiAgICAvLyBldmVuIHRob3VnaCBpdCBtaWdodCBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9ycy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW1xuICAgICAgICBrZXksXG4gICAgICAgIGNhY2hlXG4gICAgXSk7XG4gICAgLy8gU2ltaWxhciB0byB0aGUgZ2xvYmFsIG11dGF0ZSBidXQgYm91bmQgdG8gdGhlIGN1cnJlbnQgY2FjaGUgYW5kIGtleS5cbiAgICAvLyBgY2FjaGVgIGlzbid0IGFsbG93ZWQgdG8gY2hhbmdlIGR1cmluZyB0aGUgbGlmZWN5Y2xlLlxuICAgIGNvbnN0IGJvdW5kTXV0YXRlID0gdXNlQ2FsbGJhY2soLy8gVXNlIGNhbGxiYWNrIHRvIG1ha2Ugc3VyZSBga2V5UmVmLmN1cnJlbnRgIHJldHVybnMgbGF0ZXN0IHJlc3VsdCBldmVyeSB0aW1lXG4gICAgKC4uLmFyZ3MpPT57XG4gICAgICAgIHJldHVybiBpbnRlcm5hbE11dGF0ZShjYWNoZSwga2V5UmVmLmN1cnJlbnQsIC4uLmFyZ3MpO1xuICAgIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXSk7XG4gICAgLy8gVGhlIGxvZ2ljIGZvciB1cGRhdGluZyByZWZzLlxuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgZmV0Y2hlclJlZi5jdXJyZW50ID0gZmV0Y2hlcjtcbiAgICAgICAgY29uZmlnUmVmLmN1cnJlbnQgPSBjb25maWc7XG4gICAgICAgIC8vIEhhbmRsZSBsYWdneSBkYXRhIHVwZGF0ZXMuIElmIHRoZXJlJ3MgY2FjaGVkIGRhdGEgb2YgdGhlIGN1cnJlbnQga2V5LFxuICAgICAgICAvLyBpdCdsbCBiZSB0aGUgY29ycmVjdCByZWZlcmVuY2UuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQkMShjYWNoZWREYXRhKSkge1xuICAgICAgICAgICAgbGFnZ3lEYXRhUmVmLmN1cnJlbnQgPSBjYWNoZWREYXRhO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQWZ0ZXIgbW91bnRlZCBvciBrZXkgY2hhbmdlZC5cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIGlmICgha2V5KSByZXR1cm47XG4gICAgICAgIGNvbnN0IHNvZnRSZXZhbGlkYXRlID0gcmV2YWxpZGF0ZS5iaW5kKFVOREVGSU5FRCQxLCBXSVRIX0RFRFVQRSk7XG4gICAgICAgIGxldCBuZXh0Rm9jdXNSZXZhbGlkYXRlZEF0ID0gMDtcbiAgICAgICAgaWYgKGdldENvbmZpZygpLnJldmFsaWRhdGVPbkZvY3VzKSB7XG4gICAgICAgICAgICBjb25zdCBpbml0Tm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIG5leHRGb2N1c1JldmFsaWRhdGVkQXQgPSBpbml0Tm93ICsgZ2V0Q29uZmlnKCkuZm9jdXNUaHJvdHRsZUludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4cG9zZSByZXZhbGlkYXRvcnMgdG8gZ2xvYmFsIGV2ZW50IGxpc3RlbmVycy4gU28gd2UgY2FuIHRyaWdnZXJcbiAgICAgICAgLy8gcmV2YWxpZGF0aW9uIGZyb20gdGhlIG91dHNpZGUuXG4gICAgICAgIGNvbnN0IG9uUmV2YWxpZGF0ZSA9ICh0eXBlLCBvcHRzID0ge30pPT57XG4gICAgICAgICAgICBpZiAodHlwZSA9PSByZXZhbGlkYXRlRXZlbnRzLkZPQ1VTX0VWRU5UKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0Q29uZmlnKCkucmV2YWxpZGF0ZU9uRm9jdXMgJiYgbm93ID4gbmV4dEZvY3VzUmV2YWxpZGF0ZWRBdCAmJiBpc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRGb2N1c1JldmFsaWRhdGVkQXQgPSBub3cgKyBnZXRDb25maWcoKS5mb2N1c1Rocm90dGxlSW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgIHNvZnRSZXZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IHJldmFsaWRhdGVFdmVudHMuUkVDT05ORUNUX0VWRU5UKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdldENvbmZpZygpLnJldmFsaWRhdGVPblJlY29ubmVjdCAmJiBpc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvZnRSZXZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IHJldmFsaWRhdGVFdmVudHMuTVVUQVRFX0VWRU5UKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSByZXZhbGlkYXRlRXZlbnRzLkVSUk9SX1JFVkFMSURBVEVfRVZFTlQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV2YWxpZGF0ZShvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdW5zdWJFdmVudHMgPSBzdWJzY3JpYmVDYWxsYmFjayhrZXksIEVWRU5UX1JFVkFMSURBVE9SUywgb25SZXZhbGlkYXRlKTtcbiAgICAgICAgLy8gTWFyayB0aGUgY29tcG9uZW50IGFzIG1vdW50ZWQgYW5kIHVwZGF0ZSBjb3JyZXNwb25kaW5nIHJlZnMuXG4gICAgICAgIHVubW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIGtleVJlZi5jdXJyZW50ID0ga2V5O1xuICAgICAgICBpbml0aWFsTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgLy8gS2VlcCB0aGUgb3JpZ2luYWwga2V5IGluIHRoZSBjYWNoZS5cbiAgICAgICAgc2V0Q2FjaGUoe1xuICAgICAgICAgICAgX2s6IGZuQXJnXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUcmlnZ2VyIGEgcmV2YWxpZGF0aW9uXG4gICAgICAgIGlmIChzaG91bGREb0luaXRpYWxSZXZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIC8vIFBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogaWYgYSByZXF1ZXN0IGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MgZm9yIHRoaXMga2V5LFxuICAgICAgICAgICAgLy8gc2tpcCB0aGUgcmV2YWxpZGF0aW9uIHRvIGF2b2lkIHJlZHVuZGFudCB3b3JrXG4gICAgICAgICAgICBpZiAoIUZFVENIW2tleV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQkMShkYXRhKSB8fCBJU19TRVJWRVIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV2YWxpZGF0ZSBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgICAgICAgICAgc29mdFJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBEZWxheSB0aGUgcmV2YWxpZGF0ZSBpZiB3ZSBoYXZlIGRhdGEgdG8gcmV0dXJuIHNvIHdlIHdvbid0IGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbmRlcmluZy5cbiAgICAgICAgICAgICAgICAgICAgckFGKHNvZnRSZXZhbGlkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAvLyBNYXJrIGl0IGFzIHVubW91bnRlZC5cbiAgICAgICAgICAgIHVubW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHVuc3ViRXZlbnRzKCk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBrZXlcbiAgICBdKTtcbiAgICAvLyBQb2xsaW5nXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKT0+e1xuICAgICAgICBsZXQgdGltZXI7XG4gICAgICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIHBhc3NlZCBpbnRlcnZhbFxuICAgICAgICAgICAgLy8gLi4ub3IgaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSB1cGRhdGVkIGRhdGEgdG8gZ2V0IHRoZSBpbnRlcnZhbFxuICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBpc0Z1bmN0aW9uJDEocmVmcmVzaEludGVydmFsKSA/IHJlZnJlc2hJbnRlcnZhbChnZXRDYWNoZSgpLmRhdGEpIDogcmVmcmVzaEludGVydmFsO1xuICAgICAgICAgICAgLy8gV2Ugb25seSBzdGFydCB0aGUgbmV4dCBpbnRlcnZhbCBpZiBgcmVmcmVzaEludGVydmFsYCBpcyBub3QgMCwgYW5kOlxuICAgICAgICAgICAgLy8gLSBgZm9yY2VgIGlzIHRydWUsIHdoaWNoIGlzIHRoZSBzdGFydCBvZiBwb2xsaW5nXG4gICAgICAgICAgICAvLyAtIG9yIGB0aW1lcmAgaXMgbm90IDAsIHdoaWNoIG1lYW5zIHRoZSBlZmZlY3Qgd2Fzbid0IGNhbmNlbGVkXG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgJiYgdGltZXIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWN1dGUsIGludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleGVjdXRlKCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBPSyB0byBleGVjdXRlOlxuICAgICAgICAgICAgLy8gT25seSByZXZhbGlkYXRlIHdoZW4gdGhlIHBhZ2UgaXMgdmlzaWJsZSwgb25saW5lLCBhbmQgbm90IGVycm9yZWQuXG4gICAgICAgICAgICBpZiAoIWdldENhY2hlKCkuZXJyb3IgJiYgKHJlZnJlc2hXaGVuSGlkZGVuIHx8IGdldENvbmZpZygpLmlzVmlzaWJsZSgpKSAmJiAocmVmcmVzaFdoZW5PZmZsaW5lIHx8IGdldENvbmZpZygpLmlzT25saW5lKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV2YWxpZGF0ZShXSVRIX0RFRFVQRSkudGhlbihuZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU2NoZWR1bGUgdGhlIG5leHQgaW50ZXJ2YWwgdG8gY2hlY2sgYWdhaW4uXG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIHRpbWVyID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICByZWZyZXNoSW50ZXJ2YWwsXG4gICAgICAgIHJlZnJlc2hXaGVuSGlkZGVuLFxuICAgICAgICByZWZyZXNoV2hlbk9mZmxpbmUsXG4gICAgICAgIGtleVxuICAgIF0pO1xuICAgIC8vIERpc3BsYXkgZGVidWcgaW5mbyBpbiBSZWFjdCBEZXZUb29scy5cbiAgICB1c2VEZWJ1Z1ZhbHVlKHJldHVybmVkRGF0YSk7XG4gICAgLy8gSW4gU3VzcGVuc2UgbW9kZSwgd2UgY2FuJ3QgcmV0dXJuIHRoZSBlbXB0eSBgZGF0YWAgc3RhdGUuXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gYGVycm9yYCwgdGhlIGBlcnJvcmAgbmVlZHMgdG8gYmUgdGhyb3duIHRvIHRoZSBlcnJvciBib3VuZGFyeS5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBgZXJyb3JgLCB0aGUgYHJldmFsaWRhdGlvbmAgcHJvbWlzZSBuZWVkcyB0byBiZSB0aHJvd24gdG9cbiAgICAvLyB0aGUgc3VzcGVuc2UgYm91bmRhcnkuXG4gICAgaWYgKHN1c3BlbnNlICYmIGlzVW5kZWZpbmVkJDEoZGF0YSkgJiYga2V5KSB7XG4gICAgICAgIC8vIFNXUiBzaG91bGQgdGhyb3cgd2hlbiB0cnlpbmcgdG8gdXNlIFN1c3BlbnNlIG9uIHRoZSBzZXJ2ZXIgd2l0aCBSZWFjdCAxOCxcbiAgICAgICAgLy8gd2l0aG91dCBwcm92aWRpbmcgYW55IGZhbGxiYWNrIGRhdGEuIFRoaXMgY2F1c2VzIGh5ZHJhdGlvbiBlcnJvcnMuIFNlZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9zd3IvaXNzdWVzLzE4MzJcbiAgICAgICAgaWYgKCFJU19SRUFDVF9MRUdBQ1kgJiYgSVNfU0VSVkVSKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhbGxiYWNrIGRhdGEgaXMgcmVxdWlyZWQgd2hlbiB1c2luZyBTdXNwZW5zZSBpbiBTU1IuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWx3YXlzIHVwZGF0ZSBmZXRjaGVyIGFuZCBjb25maWcgcmVmcyBldmVuIHdpdGggdGhlIFN1c3BlbnNlIG1vZGUuXG4gICAgICAgIGZldGNoZXJSZWYuY3VycmVudCA9IGZldGNoZXI7XG4gICAgICAgIGNvbmZpZ1JlZi5jdXJyZW50ID0gY29uZmlnO1xuICAgICAgICB1bm1vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBjb25zdCByZXEgPSBQUkVMT0FEW2tleV07XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQkMShyZXEpKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gYm91bmRNdXRhdGUocmVxKTtcbiAgICAgICAgICAgIHVzZShwcm9taXNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmRlZmluZWQkMShlcnJvcikpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSByZXZhbGlkYXRlKFdJVEhfREVEVVBFKTtcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQkMShyZXR1cm5lZERhdGEpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSAnZnVsZmlsbGVkJztcbiAgICAgICAgICAgICAgICBwcm9taXNlLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVzZShwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN3clJlc3BvbnNlID0ge1xuICAgICAgICBtdXRhdGU6IGJvdW5kTXV0YXRlLFxuICAgICAgICBnZXQgZGF0YSAoKSB7XG4gICAgICAgICAgICBzdGF0ZURlcGVuZGVuY2llcy5kYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5lZERhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBlcnJvciAoKSB7XG4gICAgICAgICAgICBzdGF0ZURlcGVuZGVuY2llcy5lcnJvciA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBpc1ZhbGlkYXRpbmcgKCkge1xuICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuaXNWYWxpZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkYXRpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBpc0xvYWRpbmcgKCkge1xuICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuaXNMb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBpc0xvYWRpbmc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBzd3JSZXNwb25zZTtcbn07XG5jb25zdCBTV1JDb25maWcgPSBPQkpFQ1QkMS5kZWZpbmVQcm9wZXJ0eShTV1JDb25maWckMSwgJ2RlZmF1bHRWYWx1ZScsIHtcbiAgICB2YWx1ZTogZGVmYXVsdENvbmZpZ1xufSk7XG4vKipcbiAqIEEgaG9vayB0byBmZXRjaCBkYXRhLlxuICpcbiAqIEBsaW5rIGh0dHBzOi8vc3dyLnZlcmNlbC5hcHBcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB1c2VTV1IgZnJvbSAnc3dyJ1xuICogZnVuY3Rpb24gUHJvZmlsZSgpIHtcbiAqICAgY29uc3QgeyBkYXRhLCBlcnJvciwgaXNMb2FkaW5nIH0gPSB1c2VTV1IoJy9hcGkvdXNlcicsIGZldGNoZXIpXG4gKiAgIGlmIChlcnJvcikgcmV0dXJuIDxkaXY+ZmFpbGVkIHRvIGxvYWQ8L2Rpdj5cbiAqICAgaWYgKGlzTG9hZGluZykgcmV0dXJuIDxkaXY+bG9hZGluZy4uLjwvZGl2PlxuICogICByZXR1cm4gPGRpdj5oZWxsbyB7ZGF0YS5uYW1lfSE8L2Rpdj5cbiAqIH1cbiAqIGBgYFxuICovIGNvbnN0IHVzZVNXUiA9IHdpdGhBcmdzKHVzZVNXUkhhbmRsZXIpO1xuXG4vLyB1c2VTV1JcblxuZXhwb3J0IHsgU1dSQ29uZmlnLCB1c2VTV1IgYXMgZGVmYXVsdCwgdW5zdGFibGVfc2VyaWFsaXplIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/swr/dist/index/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/swr/dist/infinite/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/swr/dist/infinite/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ useSWRInfinite),\n/* harmony export */   infinite: () => (/* binding */ infinite),\n/* harmony export */   unstable_serialize: () => (/* binding */ unstable_serialize)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _index_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../index/index.mjs */ \"(app-pages-browser)/./node_modules/swr/dist/index/index.mjs\");\n/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../_internal/index.mjs */ \"(app-pages-browser)/./node_modules/swr/dist/_internal/config-context-client-BoS53ST9.mjs\");\n/* harmony import */ var _internal_constants_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_internal/constants.mjs */ \"(app-pages-browser)/./node_modules/swr/dist/_internal/constants.mjs\");\n/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../_internal/index.mjs */ \"(app-pages-browser)/./node_modules/swr/dist/_internal/index.mjs\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\");\n\n\n\n\n\n\n// Shared state between server components and client components\nconst noop = ()=>{};\n// Using noop() as the undefined value as undefined can be replaced\n// by something else. Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nconst UNDEFINED = /*#__NOINLINE__*/ noop();\nconst OBJECT = Object;\nconst isUndefined = (v)=>v === UNDEFINED;\nconst isFunction = (v)=>typeof v == 'function';\n\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nconst table = new WeakMap();\nconst getTypeName = (value)=>OBJECT.prototype.toString.call(value);\nconst isObjectTypeName = (typeName, type)=>typeName === `[object ${type}]`;\n// counter of the key\nlet counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsable.\nconst stableHash = (arg)=>{\n    const type = typeof arg;\n    const typeName = getTypeName(arg);\n    const isDate = isObjectTypeName(typeName, 'Date');\n    const isRegex = isObjectTypeName(typeName, 'RegExp');\n    const isPlainObject = isObjectTypeName(typeName, 'Object');\n    let result;\n    let index;\n    if (OBJECT(arg) === arg && !isDate && !isRegex) {\n        // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n        // If it's already hashed, directly return the result.\n        result = table.get(arg);\n        if (result) return result;\n        // Store the hash first for circular reference detection before entering the\n        // recursive `stableHash` calls.\n        // For other objects like set and map, we use this id directly as the hash.\n        result = ++counter + '~';\n        table.set(arg, result);\n        if (Array.isArray(arg)) {\n            // Array.\n            result = '@';\n            for(index = 0; index < arg.length; index++){\n                result += stableHash(arg[index]) + ',';\n            }\n            table.set(arg, result);\n        }\n        if (isPlainObject) {\n            // Object, sort keys.\n            result = '#';\n            const keys = OBJECT.keys(arg).sort();\n            while(!isUndefined(index = keys.pop())){\n                if (!isUndefined(arg[index])) {\n                    result += index + ':' + stableHash(arg[index]) + ',';\n                }\n            }\n            table.set(arg, result);\n        }\n    } else {\n        result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;\n    }\n    return result;\n};\n\nconst serialize = (key)=>{\n    if (isFunction(key)) {\n        try {\n            key = key();\n        } catch (err) {\n            // dependencies not ready\n            key = '';\n        }\n    }\n    // Use the original key as the argument of fetcher. This can be a string or an\n    // array of values.\n    const args = key;\n    // If key is not falsy, or not an empty array, hash it.\n    key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';\n    return [\n        key,\n        args\n    ];\n};\n\nconst getFirstPageKey = (getKey)=>{\n    return serialize(getKey ? getKey(0, null) : null)[0];\n};\nconst unstable_serialize = (getKey)=>{\n    return _internal_constants_mjs__WEBPACK_IMPORTED_MODULE_2__.INFINITE_PREFIX + getFirstPageKey(getKey);\n};\n\n// We have to several type castings here because `useSWRInfinite` is a special\n// hook where `key` and return type are not like the normal `useSWR` types.\nconst EMPTY_PROMISE = Promise.resolve();\nconst infinite = (useSWRNext)=>(getKey, fn, config)=>{\n        const didMountRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n        const { cache: cache$1, initialSize = 1, revalidateAll = false, persistSize = false, revalidateFirstPage = true, revalidateOnMount = false, parallel = false } = config;\n        const [, , , PRELOAD] = _internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.b.get(_internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.c);\n        // The serialized key of the first page. This key will be used to store\n        // metadata of this SWR infinite hook.\n        let infiniteKey;\n        try {\n            infiniteKey = getFirstPageKey(getKey);\n            if (infiniteKey) infiniteKey = _internal_constants_mjs__WEBPACK_IMPORTED_MODULE_2__.INFINITE_PREFIX + infiniteKey;\n        } catch (err) {\n        // Not ready yet.\n        }\n        const [get, set, subscribeCache] = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.z)(cache$1, infiniteKey);\n        const getSnapshot = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n            const size = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.e)(get()._l) ? initialSize : get()._l;\n            return size;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            cache$1,\n            infiniteKey,\n            initialSize\n        ]);\n        (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback)=>{\n            if (infiniteKey) return subscribeCache(infiniteKey, ()=>{\n                callback();\n            });\n            return ()=>{};\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            cache$1,\n            infiniteKey\n        ]), getSnapshot, getSnapshot);\n        const resolvePageSize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n            const cachedPageSize = get()._l;\n            return (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.e)(cachedPageSize) ? initialSize : cachedPageSize;\n        // `cache` isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            infiniteKey,\n            initialSize\n        ]);\n        // keep the last page size to restore it with the persistSize option\n        const lastPageSizeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(resolvePageSize());\n        // When the page key changes, we reset the page size if it's not persisted\n        (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.u)(()=>{\n            if (!didMountRef.current) {\n                didMountRef.current = true;\n                return;\n            }\n            if (infiniteKey) {\n                // If the key has been changed, we keep the current page size if persistSize is enabled\n                // Otherwise, we reset the page size to cached pageSize\n                set({\n                    _l: persistSize ? lastPageSizeRef.current : resolvePageSize()\n                });\n            }\n        // `initialSize` isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            infiniteKey,\n            cache$1\n        ]);\n        // Needs to check didMountRef during mounting, not in the fetcher\n        const shouldRevalidateOnMount = revalidateOnMount && !didMountRef.current;\n        // Actual SWR hook to load all pages in one fetcher.\n        const swr = useSWRNext(infiniteKey, async (key)=>{\n            // get the revalidate context\n            const forceRevalidateAll = get()._i;\n            const shouldRevalidatePage = get()._r;\n            set({\n                _r: _internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.U\n            });\n            // return an array of page data\n            const data = [];\n            const pageSize = resolvePageSize();\n            const [getCache] = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.z)(cache$1, key);\n            const cacheData = getCache().data;\n            const revalidators = [];\n            let previousPageData = null;\n            for(let i = 0; i < pageSize; ++i){\n                const [pageKey, pageArg] = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.s)(getKey(i, parallel ? null : previousPageData));\n                if (!pageKey) {\n                    break;\n                }\n                const [getSWRCache, setSWRCache] = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.z)(cache$1, pageKey);\n                // Get the cached page data.\n                let pageData = getSWRCache().data;\n                // should fetch (or revalidate) if:\n                // - `revalidateAll` is enabled\n                // - `mutate()` called\n                // - the cache is missing\n                // - it's the first page and it's not the initial render\n                // - `revalidateOnMount` is enabled and it's on mount\n                // - cache for that page has changed\n                const shouldFetchPage = revalidateAll || forceRevalidateAll || (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.e)(pageData) || revalidateFirstPage && !i && !(0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.e)(cacheData) || shouldRevalidateOnMount || cacheData && !(0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.e)(cacheData[i]) && !config.compare(cacheData[i], pageData);\n                if (fn && (typeof shouldRevalidatePage === 'function' ? shouldRevalidatePage(pageData, pageArg) : shouldFetchPage)) {\n                    const revalidate = async ()=>{\n                        const hasPreloadedRequest = pageKey in PRELOAD;\n                        if (!hasPreloadedRequest) {\n                            pageData = await fn(pageArg);\n                        } else {\n                            const req = PRELOAD[pageKey];\n                            // delete the preload cache key before resolving it\n                            // in case there's an error\n                            delete PRELOAD[pageKey];\n                            // get the page data from the preload cache\n                            pageData = await req;\n                        }\n                        setSWRCache({\n                            data: pageData,\n                            _k: pageArg\n                        });\n                        data[i] = pageData;\n                    };\n                    if (parallel) {\n                        revalidators.push(revalidate);\n                    } else {\n                        await revalidate();\n                    }\n                } else {\n                    data[i] = pageData;\n                }\n                if (!parallel) {\n                    previousPageData = pageData;\n                }\n            }\n            // flush all revalidateions in parallel\n            if (parallel) {\n                await Promise.all(revalidators.map((r)=>r()));\n            }\n            // once we executed the data fetching based on the context, clear the context\n            set({\n                _i: _internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.U\n            });\n            // return the data\n            return data;\n        }, config);\n        const mutate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(// eslint-disable-next-line func-names\n        function(data, opts) {\n            // When passing as a boolean, it's explicitly used to disable/enable\n            // revalidation.\n            const options = typeof opts === 'boolean' ? {\n                revalidate: opts\n            } : opts || {};\n            // Default to true.\n            const shouldRevalidate = options.revalidate !== false;\n            // It is possible that the key is still falsy.\n            if (!infiniteKey) return EMPTY_PROMISE;\n            if (shouldRevalidate) {\n                if (!(0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.e)(data)) {\n                    // We only revalidate the pages that are changed\n                    set({\n                        _i: false,\n                        _r: options.revalidate\n                    });\n                } else {\n                    // Calling `mutate()`, we revalidate all pages\n                    set({\n                        _i: true,\n                        _r: options.revalidate\n                    });\n                }\n            }\n            return arguments.length ? swr.mutate(data, {\n                ...options,\n                revalidate: shouldRevalidate\n            }) : swr.mutate();\n        }, // swr.mutate is always the same reference\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            infiniteKey,\n            cache$1\n        ]);\n        // Extend the SWR API\n        const setSize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((arg)=>{\n            // It is possible that the key is still falsy.\n            if (!infiniteKey) return EMPTY_PROMISE;\n            const [, changeSize] = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.z)(cache$1, infiniteKey);\n            let size;\n            if ((0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.a)(arg)) {\n                size = arg(resolvePageSize());\n            } else if (typeof arg == 'number') {\n                size = arg;\n            }\n            if (typeof size != 'number') return EMPTY_PROMISE;\n            changeSize({\n                _l: size\n            });\n            lastPageSizeRef.current = size;\n            // Calculate the page data after the size change.\n            const data = [];\n            const [getInfiniteCache] = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.z)(cache$1, infiniteKey);\n            let previousPageData = null;\n            for(let i = 0; i < size; ++i){\n                const [pageKey] = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.s)(getKey(i, previousPageData));\n                const [getCache] = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.z)(cache$1, pageKey);\n                // Get the cached page data.\n                const pageData = pageKey ? getCache().data : _internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.U;\n                // Call `mutate` with infinte cache data if we can't get it from the page cache.\n                if ((0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_3__.e)(pageData)) {\n                    return mutate(getInfiniteCache().data);\n                }\n                data.push(pageData);\n                previousPageData = pageData;\n            }\n            return mutate(data);\n        }, // exclude getKey from the dependencies, which isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            infiniteKey,\n            cache$1,\n            mutate,\n            resolvePageSize\n        ]);\n        // Use getter functions to avoid unnecessary re-renders caused by triggering\n        // all the getters of the returned swr object.\n        return {\n            size: resolvePageSize(),\n            setSize,\n            mutate,\n            get data () {\n                return swr.data;\n            },\n            get error () {\n                return swr.error;\n            },\n            get isValidating () {\n                return swr.isValidating;\n            },\n            get isLoading () {\n                return swr.isLoading;\n            }\n        };\n    };\nconst useSWRInfinite = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_4__.withMiddleware)(_index_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"], infinite);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zd3IvZGlzdC9pbmZpbml0ZS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQTRDO0FBQ0o7QUFDeU87QUFDcE07QUFDaEI7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxLQUFLO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0VBQWU7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkNBQU07QUFDbEMsZ0JBQWdCLHVKQUF1SjtBQUN2SyxnQ0FBZ0Msa0RBQWMsS0FBSyxrREFBSztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG9FQUFpQjtBQUM1RCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDJDQUEyQyxzREFBaUI7QUFDNUQsNEJBQTRCLGtEQUFXO0FBQ3ZDLHlCQUF5QixzREFBYTtBQUN0QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyRkFBb0IsQ0FBQyxrREFBVztBQUN4QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtEQUFXO0FBQzNDO0FBQ0EsbUJBQW1CLHNEQUFhO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkNBQU07QUFDdEM7QUFDQSxRQUFRLHNEQUF5QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0RBQVc7QUFDL0IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzREFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekMsMkNBQTJDLHNEQUFXO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxzREFBaUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHNEQUFhLDRDQUE0QyxzREFBYSx3REFBd0Qsc0RBQWE7QUFDMU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrREFBVztBQUMvQixhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVCx1QkFBdUIsa0RBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNEQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0RBQVc7QUFDbkM7QUFDQTtBQUNBLG1DQUFtQyxzREFBaUI7QUFDcEQ7QUFDQSxnQkFBZ0Isc0RBQVk7QUFDNUI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsc0RBQWlCO0FBQ3hEO0FBQ0EsMkJBQTJCLFVBQVU7QUFDckMsa0NBQWtDLHNEQUFXO0FBQzdDLG1DQUFtQyxzREFBaUI7QUFDcEQ7QUFDQSw2REFBNkQsa0RBQVc7QUFDeEU7QUFDQSxvQkFBb0Isc0RBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtRUFBYyxDQUFDLHdEQUFNOztBQUV1QiIsInNvdXJjZXMiOlsiL1VzZXJzL2lzaGFxYmVsbG8vV2Vic2l0ZS9oYXZlbnJpZGVfZnVsbF9hcHAvbm9kZV9tb2R1bGVzL3N3ci9kaXN0L2luZmluaXRlL2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZVNXUiBmcm9tICcuLi9pbmRleC9pbmRleC5tanMnO1xuaW1wb3J0IHsgd2l0aE1pZGRsZXdhcmUsIFNXUkdsb2JhbFN0YXRlLCBjYWNoZSwgSU5GSU5JVEVfUFJFRklYIGFzIElORklOSVRFX1BSRUZJWCQxLCBjcmVhdGVDYWNoZUhlbHBlciwgaXNVbmRlZmluZWQgYXMgaXNVbmRlZmluZWQkMSwgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCwgVU5ERUZJTkVEIGFzIFVOREVGSU5FRCQxLCBzZXJpYWxpemUgYXMgc2VyaWFsaXplJDEsIGlzRnVuY3Rpb24gYXMgaXNGdW5jdGlvbiQxIH0gZnJvbSAnLi4vX2ludGVybmFsL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSB9IGZyb20gJ3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanMnO1xuaW1wb3J0IHsgSU5GSU5JVEVfUFJFRklYIH0gZnJvbSAnLi4vX2ludGVybmFsL2NvbnN0YW50cy5tanMnO1xuXG4vLyBTaGFyZWQgc3RhdGUgYmV0d2VlbiBzZXJ2ZXIgY29tcG9uZW50cyBhbmQgY2xpZW50IGNvbXBvbmVudHNcbmNvbnN0IG5vb3AgPSAoKT0+e307XG4vLyBVc2luZyBub29wKCkgYXMgdGhlIHVuZGVmaW5lZCB2YWx1ZSBhcyB1bmRlZmluZWQgY2FuIGJlIHJlcGxhY2VkXG4vLyBieSBzb21ldGhpbmcgZWxzZS4gUHJldHRpZXIgaWdub3JlIGFuZCBleHRyYSBwYXJlbnRoZXNlcyBhcmUgbmVjZXNzYXJ5IGhlcmVcbi8vIHRvIGVuc3VyZSB0aGF0IHRzYyBkb2Vzbid0IHJlbW92ZSB0aGUgX19OT0lOTElORV9fIGNvbW1lbnQuXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFVOREVGSU5FRCA9IC8qI19fTk9JTkxJTkVfXyovIG5vb3AoKTtcbmNvbnN0IE9CSkVDVCA9IE9iamVjdDtcbmNvbnN0IGlzVW5kZWZpbmVkID0gKHYpPT52ID09PSBVTkRFRklORUQ7XG5jb25zdCBpc0Z1bmN0aW9uID0gKHYpPT50eXBlb2YgdiA9PSAnZnVuY3Rpb24nO1xuXG4vLyB1c2UgV2Vha01hcCB0byBzdG9yZSB0aGUgb2JqZWN0LT5rZXkgbWFwcGluZ1xuLy8gc28gdGhlIG9iamVjdHMgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuLy8gV2Vha01hcCB1c2VzIGEgaGFzaHRhYmxlIHVuZGVyIHRoZSBob29kLCBzbyB0aGUgbG9va3VwXG4vLyBjb21wbGV4aXR5IGlzIGFsbW9zdCBPKDEpLlxuY29uc3QgdGFibGUgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgZ2V0VHlwZU5hbWUgPSAodmFsdWUpPT5PQkpFQ1QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuY29uc3QgaXNPYmplY3RUeXBlTmFtZSA9ICh0eXBlTmFtZSwgdHlwZSk9PnR5cGVOYW1lID09PSBgW29iamVjdCAke3R5cGV9XWA7XG4vLyBjb3VudGVyIG9mIHRoZSBrZXlcbmxldCBjb3VudGVyID0gMDtcbi8vIEEgc3RhYmxlIGhhc2ggaW1wbGVtZW50YXRpb24gdGhhdCBzdXBwb3J0czpcbi8vIC0gRmFzdCBhbmQgZW5zdXJlcyB1bmlxdWUgaGFzaCBwcm9wZXJ0aWVzXG4vLyAtIEhhbmRsZXMgdW5zZXJpYWxpemFibGUgdmFsdWVzXG4vLyAtIEhhbmRsZXMgb2JqZWN0IGtleSBvcmRlcmluZ1xuLy8gLSBHZW5lcmF0ZXMgc2hvcnQgcmVzdWx0c1xuLy9cbi8vIFRoaXMgaXMgbm90IGEgc2VyaWFsaXphdGlvbiBmdW5jdGlvbiwgYW5kIHRoZSByZXN1bHQgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmVcbi8vIHBhcnNhYmxlLlxuY29uc3Qgc3RhYmxlSGFzaCA9IChhcmcpPT57XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBhcmc7XG4gICAgY29uc3QgdHlwZU5hbWUgPSBnZXRUeXBlTmFtZShhcmcpO1xuICAgIGNvbnN0IGlzRGF0ZSA9IGlzT2JqZWN0VHlwZU5hbWUodHlwZU5hbWUsICdEYXRlJyk7XG4gICAgY29uc3QgaXNSZWdleCA9IGlzT2JqZWN0VHlwZU5hbWUodHlwZU5hbWUsICdSZWdFeHAnKTtcbiAgICBjb25zdCBpc1BsYWluT2JqZWN0ID0gaXNPYmplY3RUeXBlTmFtZSh0eXBlTmFtZSwgJ09iamVjdCcpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IGluZGV4O1xuICAgIGlmIChPQkpFQ1QoYXJnKSA9PT0gYXJnICYmICFpc0RhdGUgJiYgIWlzUmVnZXgpIHtcbiAgICAgICAgLy8gT2JqZWN0L2Z1bmN0aW9uLCBub3QgbnVsbC9kYXRlL3JlZ2V4cC4gVXNlIFdlYWtNYXAgdG8gc3RvcmUgdGhlIGlkIGZpcnN0LlxuICAgICAgICAvLyBJZiBpdCdzIGFscmVhZHkgaGFzaGVkLCBkaXJlY3RseSByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICAgICAgcmVzdWx0ID0gdGFibGUuZ2V0KGFyZyk7XG4gICAgICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIC8vIFN0b3JlIHRoZSBoYXNoIGZpcnN0IGZvciBjaXJjdWxhciByZWZlcmVuY2UgZGV0ZWN0aW9uIGJlZm9yZSBlbnRlcmluZyB0aGVcbiAgICAgICAgLy8gcmVjdXJzaXZlIGBzdGFibGVIYXNoYCBjYWxscy5cbiAgICAgICAgLy8gRm9yIG90aGVyIG9iamVjdHMgbGlrZSBzZXQgYW5kIG1hcCwgd2UgdXNlIHRoaXMgaWQgZGlyZWN0bHkgYXMgdGhlIGhhc2guXG4gICAgICAgIHJlc3VsdCA9ICsrY291bnRlciArICd+JztcbiAgICAgICAgdGFibGUuc2V0KGFyZywgcmVzdWx0KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgLy8gQXJyYXkuXG4gICAgICAgICAgICByZXN1bHQgPSAnQCc7XG4gICAgICAgICAgICBmb3IoaW5kZXggPSAwOyBpbmRleCA8IGFyZy5sZW5ndGg7IGluZGV4Kyspe1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdGFibGVIYXNoKGFyZ1tpbmRleF0pICsgJywnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFibGUuc2V0KGFyZywgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdCkge1xuICAgICAgICAgICAgLy8gT2JqZWN0LCBzb3J0IGtleXMuXG4gICAgICAgICAgICByZXN1bHQgPSAnIyc7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT0JKRUNULmtleXMoYXJnKS5zb3J0KCk7XG4gICAgICAgICAgICB3aGlsZSghaXNVbmRlZmluZWQoaW5kZXggPSBrZXlzLnBvcCgpKSl7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChhcmdbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gaW5kZXggKyAnOicgKyBzdGFibGVIYXNoKGFyZ1tpbmRleF0pICsgJywnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYmxlLnNldChhcmcsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBpc0RhdGUgPyBhcmcudG9KU09OKCkgOiB0eXBlID09ICdzeW1ib2wnID8gYXJnLnRvU3RyaW5nKCkgOiB0eXBlID09ICdzdHJpbmcnID8gSlNPTi5zdHJpbmdpZnkoYXJnKSA6ICcnICsgYXJnO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3Qgc2VyaWFsaXplID0gKGtleSk9PntcbiAgICBpZiAoaXNGdW5jdGlvbihrZXkpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBkZXBlbmRlbmNpZXMgbm90IHJlYWR5XG4gICAgICAgICAgICBrZXkgPSAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVc2UgdGhlIG9yaWdpbmFsIGtleSBhcyB0aGUgYXJndW1lbnQgb2YgZmV0Y2hlci4gVGhpcyBjYW4gYmUgYSBzdHJpbmcgb3IgYW5cbiAgICAvLyBhcnJheSBvZiB2YWx1ZXMuXG4gICAgY29uc3QgYXJncyA9IGtleTtcbiAgICAvLyBJZiBrZXkgaXMgbm90IGZhbHN5LCBvciBub3QgYW4gZW1wdHkgYXJyYXksIGhhc2ggaXQuXG4gICAga2V5ID0gdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/IGtleSA6IChBcnJheS5pc0FycmF5KGtleSkgPyBrZXkubGVuZ3RoIDoga2V5KSA/IHN0YWJsZUhhc2goa2V5KSA6ICcnO1xuICAgIHJldHVybiBbXG4gICAgICAgIGtleSxcbiAgICAgICAgYXJnc1xuICAgIF07XG59O1xuXG5jb25zdCBnZXRGaXJzdFBhZ2VLZXkgPSAoZ2V0S2V5KT0+e1xuICAgIHJldHVybiBzZXJpYWxpemUoZ2V0S2V5ID8gZ2V0S2V5KDAsIG51bGwpIDogbnVsbClbMF07XG59O1xuY29uc3QgdW5zdGFibGVfc2VyaWFsaXplID0gKGdldEtleSk9PntcbiAgICByZXR1cm4gSU5GSU5JVEVfUFJFRklYICsgZ2V0Rmlyc3RQYWdlS2V5KGdldEtleSk7XG59O1xuXG4vLyBXZSBoYXZlIHRvIHNldmVyYWwgdHlwZSBjYXN0aW5ncyBoZXJlIGJlY2F1c2UgYHVzZVNXUkluZmluaXRlYCBpcyBhIHNwZWNpYWxcbi8vIGhvb2sgd2hlcmUgYGtleWAgYW5kIHJldHVybiB0eXBlIGFyZSBub3QgbGlrZSB0aGUgbm9ybWFsIGB1c2VTV1JgIHR5cGVzLlxuY29uc3QgRU1QVFlfUFJPTUlTRSA9IFByb21pc2UucmVzb2x2ZSgpO1xuY29uc3QgaW5maW5pdGUgPSAodXNlU1dSTmV4dCk9PihnZXRLZXksIGZuLCBjb25maWcpPT57XG4gICAgICAgIGNvbnN0IGRpZE1vdW50UmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgICAgICAgY29uc3QgeyBjYWNoZTogY2FjaGUkMSwgaW5pdGlhbFNpemUgPSAxLCByZXZhbGlkYXRlQWxsID0gZmFsc2UsIHBlcnNpc3RTaXplID0gZmFsc2UsIHJldmFsaWRhdGVGaXJzdFBhZ2UgPSB0cnVlLCByZXZhbGlkYXRlT25Nb3VudCA9IGZhbHNlLCBwYXJhbGxlbCA9IGZhbHNlIH0gPSBjb25maWc7XG4gICAgICAgIGNvbnN0IFssICwgLCBQUkVMT0FEXSA9IFNXUkdsb2JhbFN0YXRlLmdldChjYWNoZSk7XG4gICAgICAgIC8vIFRoZSBzZXJpYWxpemVkIGtleSBvZiB0aGUgZmlyc3QgcGFnZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHN0b3JlXG4gICAgICAgIC8vIG1ldGFkYXRhIG9mIHRoaXMgU1dSIGluZmluaXRlIGhvb2suXG4gICAgICAgIGxldCBpbmZpbml0ZUtleTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluZmluaXRlS2V5ID0gZ2V0Rmlyc3RQYWdlS2V5KGdldEtleSk7XG4gICAgICAgICAgICBpZiAoaW5maW5pdGVLZXkpIGluZmluaXRlS2V5ID0gSU5GSU5JVEVfUFJFRklYJDEgKyBpbmZpbml0ZUtleTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIE5vdCByZWFkeSB5ZXQuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2dldCwgc2V0LCBzdWJzY3JpYmVDYWNoZV0gPSBjcmVhdGVDYWNoZUhlbHBlcihjYWNoZSQxLCBpbmZpbml0ZUtleSk7XG4gICAgICAgIGNvbnN0IGdldFNuYXBzaG90ID0gdXNlQ2FsbGJhY2soKCk9PntcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBpc1VuZGVmaW5lZCQxKGdldCgpLl9sKSA/IGluaXRpYWxTaXplIDogZ2V0KCkuX2w7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICB9LCBbXG4gICAgICAgICAgICBjYWNoZSQxLFxuICAgICAgICAgICAgaW5maW5pdGVLZXksXG4gICAgICAgICAgICBpbml0aWFsU2l6ZVxuICAgICAgICBdKTtcbiAgICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmUodXNlQ2FsbGJhY2soKGNhbGxiYWNrKT0+e1xuICAgICAgICAgICAgaWYgKGluZmluaXRlS2V5KSByZXR1cm4gc3Vic2NyaWJlQ2FjaGUoaW5maW5pdGVLZXksICgpPT57XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpPT57fTtcbiAgICAgICAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICBbXG4gICAgICAgICAgICBjYWNoZSQxLFxuICAgICAgICAgICAgaW5maW5pdGVLZXlcbiAgICAgICAgXSksIGdldFNuYXBzaG90LCBnZXRTbmFwc2hvdCk7XG4gICAgICAgIGNvbnN0IHJlc29sdmVQYWdlU2l6ZSA9IHVzZUNhbGxiYWNrKCgpPT57XG4gICAgICAgICAgICBjb25zdCBjYWNoZWRQYWdlU2l6ZSA9IGdldCgpLl9sO1xuICAgICAgICAgICAgcmV0dXJuIGlzVW5kZWZpbmVkJDEoY2FjaGVkUGFnZVNpemUpID8gaW5pdGlhbFNpemUgOiBjYWNoZWRQYWdlU2l6ZTtcbiAgICAgICAgLy8gYGNhY2hlYCBpc24ndCBhbGxvd2VkIHRvIGNoYW5nZSBkdXJpbmcgdGhlIGxpZmVjeWNsZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICAgIH0sIFtcbiAgICAgICAgICAgIGluZmluaXRlS2V5LFxuICAgICAgICAgICAgaW5pdGlhbFNpemVcbiAgICAgICAgXSk7XG4gICAgICAgIC8vIGtlZXAgdGhlIGxhc3QgcGFnZSBzaXplIHRvIHJlc3RvcmUgaXQgd2l0aCB0aGUgcGVyc2lzdFNpemUgb3B0aW9uXG4gICAgICAgIGNvbnN0IGxhc3RQYWdlU2l6ZVJlZiA9IHVzZVJlZihyZXNvbHZlUGFnZVNpemUoKSk7XG4gICAgICAgIC8vIFdoZW4gdGhlIHBhZ2Uga2V5IGNoYW5nZXMsIHdlIHJlc2V0IHRoZSBwYWdlIHNpemUgaWYgaXQncyBub3QgcGVyc2lzdGVkXG4gICAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgICAgIGlmICghZGlkTW91bnRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGRpZE1vdW50UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmZpbml0ZUtleSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBrZXkgaGFzIGJlZW4gY2hhbmdlZCwgd2Uga2VlcCB0aGUgY3VycmVudCBwYWdlIHNpemUgaWYgcGVyc2lzdFNpemUgaXMgZW5hYmxlZFxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgcmVzZXQgdGhlIHBhZ2Ugc2l6ZSB0byBjYWNoZWQgcGFnZVNpemVcbiAgICAgICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgICAgICBfbDogcGVyc2lzdFNpemUgPyBsYXN0UGFnZVNpemVSZWYuY3VycmVudCA6IHJlc29sdmVQYWdlU2l6ZSgpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIC8vIGBpbml0aWFsU2l6ZWAgaXNuJ3QgYWxsb3dlZCB0byBjaGFuZ2UgZHVyaW5nIHRoZSBsaWZlY3ljbGVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICB9LCBbXG4gICAgICAgICAgICBpbmZpbml0ZUtleSxcbiAgICAgICAgICAgIGNhY2hlJDFcbiAgICAgICAgXSk7XG4gICAgICAgIC8vIE5lZWRzIHRvIGNoZWNrIGRpZE1vdW50UmVmIGR1cmluZyBtb3VudGluZywgbm90IGluIHRoZSBmZXRjaGVyXG4gICAgICAgIGNvbnN0IHNob3VsZFJldmFsaWRhdGVPbk1vdW50ID0gcmV2YWxpZGF0ZU9uTW91bnQgJiYgIWRpZE1vdW50UmVmLmN1cnJlbnQ7XG4gICAgICAgIC8vIEFjdHVhbCBTV1IgaG9vayB0byBsb2FkIGFsbCBwYWdlcyBpbiBvbmUgZmV0Y2hlci5cbiAgICAgICAgY29uc3Qgc3dyID0gdXNlU1dSTmV4dChpbmZpbml0ZUtleSwgYXN5bmMgKGtleSk9PntcbiAgICAgICAgICAgIC8vIGdldCB0aGUgcmV2YWxpZGF0ZSBjb250ZXh0XG4gICAgICAgICAgICBjb25zdCBmb3JjZVJldmFsaWRhdGVBbGwgPSBnZXQoKS5faTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFJldmFsaWRhdGVQYWdlID0gZ2V0KCkuX3I7XG4gICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgIF9yOiBVTkRFRklORUQkMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyByZXR1cm4gYW4gYXJyYXkgb2YgcGFnZSBkYXRhXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgICAgICBjb25zdCBwYWdlU2l6ZSA9IHJlc29sdmVQYWdlU2l6ZSgpO1xuICAgICAgICAgICAgY29uc3QgW2dldENhY2hlXSA9IGNyZWF0ZUNhY2hlSGVscGVyKGNhY2hlJDEsIGtleSk7XG4gICAgICAgICAgICBjb25zdCBjYWNoZURhdGEgPSBnZXRDYWNoZSgpLmRhdGE7XG4gICAgICAgICAgICBjb25zdCByZXZhbGlkYXRvcnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBwcmV2aW91c1BhZ2VEYXRhID0gbnVsbDtcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwYWdlU2l6ZTsgKytpKXtcbiAgICAgICAgICAgICAgICBjb25zdCBbcGFnZUtleSwgcGFnZUFyZ10gPSBzZXJpYWxpemUkMShnZXRLZXkoaSwgcGFyYWxsZWwgPyBudWxsIDogcHJldmlvdXNQYWdlRGF0YSkpO1xuICAgICAgICAgICAgICAgIGlmICghcGFnZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgW2dldFNXUkNhY2hlLCBzZXRTV1JDYWNoZV0gPSBjcmVhdGVDYWNoZUhlbHBlcihjYWNoZSQxLCBwYWdlS2V5KTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGNhY2hlZCBwYWdlIGRhdGEuXG4gICAgICAgICAgICAgICAgbGV0IHBhZ2VEYXRhID0gZ2V0U1dSQ2FjaGUoKS5kYXRhO1xuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBmZXRjaCAob3IgcmV2YWxpZGF0ZSkgaWY6XG4gICAgICAgICAgICAgICAgLy8gLSBgcmV2YWxpZGF0ZUFsbGAgaXMgZW5hYmxlZFxuICAgICAgICAgICAgICAgIC8vIC0gYG11dGF0ZSgpYCBjYWxsZWRcbiAgICAgICAgICAgICAgICAvLyAtIHRoZSBjYWNoZSBpcyBtaXNzaW5nXG4gICAgICAgICAgICAgICAgLy8gLSBpdCdzIHRoZSBmaXJzdCBwYWdlIGFuZCBpdCdzIG5vdCB0aGUgaW5pdGlhbCByZW5kZXJcbiAgICAgICAgICAgICAgICAvLyAtIGByZXZhbGlkYXRlT25Nb3VudGAgaXMgZW5hYmxlZCBhbmQgaXQncyBvbiBtb3VudFxuICAgICAgICAgICAgICAgIC8vIC0gY2FjaGUgZm9yIHRoYXQgcGFnZSBoYXMgY2hhbmdlZFxuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZEZldGNoUGFnZSA9IHJldmFsaWRhdGVBbGwgfHwgZm9yY2VSZXZhbGlkYXRlQWxsIHx8IGlzVW5kZWZpbmVkJDEocGFnZURhdGEpIHx8IHJldmFsaWRhdGVGaXJzdFBhZ2UgJiYgIWkgJiYgIWlzVW5kZWZpbmVkJDEoY2FjaGVEYXRhKSB8fCBzaG91bGRSZXZhbGlkYXRlT25Nb3VudCB8fCBjYWNoZURhdGEgJiYgIWlzVW5kZWZpbmVkJDEoY2FjaGVEYXRhW2ldKSAmJiAhY29uZmlnLmNvbXBhcmUoY2FjaGVEYXRhW2ldLCBwYWdlRGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKGZuICYmICh0eXBlb2Ygc2hvdWxkUmV2YWxpZGF0ZVBhZ2UgPT09ICdmdW5jdGlvbicgPyBzaG91bGRSZXZhbGlkYXRlUGFnZShwYWdlRGF0YSwgcGFnZUFyZykgOiBzaG91bGRGZXRjaFBhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldmFsaWRhdGUgPSBhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzUHJlbG9hZGVkUmVxdWVzdCA9IHBhZ2VLZXkgaW4gUFJFTE9BRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzUHJlbG9hZGVkUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VEYXRhID0gYXdhaXQgZm4ocGFnZUFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcSA9IFBSRUxPQURbcGFnZUtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVsZXRlIHRoZSBwcmVsb2FkIGNhY2hlIGtleSBiZWZvcmUgcmVzb2x2aW5nIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGVyZSdzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIFBSRUxPQURbcGFnZUtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBwYWdlIGRhdGEgZnJvbSB0aGUgcHJlbG9hZCBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VEYXRhID0gYXdhaXQgcmVxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0U1dSQ2FjaGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHBhZ2VEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9rOiBwYWdlQXJnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaV0gPSBwYWdlRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFsbGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXZhbGlkYXRvcnMucHVzaChyZXZhbGlkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaV0gPSBwYWdlRGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbGxlbCkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1BhZ2VEYXRhID0gcGFnZURhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmx1c2ggYWxsIHJldmFsaWRhdGVpb25zIGluIHBhcmFsbGVsXG4gICAgICAgICAgICBpZiAocGFyYWxsZWwpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChyZXZhbGlkYXRvcnMubWFwKChyKT0+cigpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvbmNlIHdlIGV4ZWN1dGVkIHRoZSBkYXRhIGZldGNoaW5nIGJhc2VkIG9uIHRoZSBjb250ZXh0LCBjbGVhciB0aGUgY29udGV4dFxuICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgICBfaTogVU5ERUZJTkVEJDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBkYXRhXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSwgY29uZmlnKTtcbiAgICAgICAgY29uc3QgbXV0YXRlID0gdXNlQ2FsbGJhY2soLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICAgICAgZnVuY3Rpb24oZGF0YSwgb3B0cykge1xuICAgICAgICAgICAgLy8gV2hlbiBwYXNzaW5nIGFzIGEgYm9vbGVhbiwgaXQncyBleHBsaWNpdGx5IHVzZWQgdG8gZGlzYWJsZS9lbmFibGVcbiAgICAgICAgICAgIC8vIHJldmFsaWRhdGlvbi5cbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygb3B0cyA9PT0gJ2Jvb2xlYW4nID8ge1xuICAgICAgICAgICAgICAgIHJldmFsaWRhdGU6IG9wdHNcbiAgICAgICAgICAgIH0gOiBvcHRzIHx8IHt9O1xuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byB0cnVlLlxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkUmV2YWxpZGF0ZSA9IG9wdGlvbnMucmV2YWxpZGF0ZSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSBrZXkgaXMgc3RpbGwgZmFsc3kuXG4gICAgICAgICAgICBpZiAoIWluZmluaXRlS2V5KSByZXR1cm4gRU1QVFlfUFJPTUlTRTtcbiAgICAgICAgICAgIGlmIChzaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCQxKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgcmV2YWxpZGF0ZSB0aGUgcGFnZXMgdGhhdCBhcmUgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgX2k6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgX3I6IG9wdGlvbnMucmV2YWxpZGF0ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsaW5nIGBtdXRhdGUoKWAsIHdlIHJldmFsaWRhdGUgYWxsIHBhZ2VzXG4gICAgICAgICAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yOiBvcHRpb25zLnJldmFsaWRhdGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBzd3IubXV0YXRlKGRhdGEsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHJldmFsaWRhdGU6IHNob3VsZFJldmFsaWRhdGVcbiAgICAgICAgICAgIH0pIDogc3dyLm11dGF0ZSgpO1xuICAgICAgICB9LCAvLyBzd3IubXV0YXRlIGlzIGFsd2F5cyB0aGUgc2FtZSByZWZlcmVuY2VcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICBbXG4gICAgICAgICAgICBpbmZpbml0ZUtleSxcbiAgICAgICAgICAgIGNhY2hlJDFcbiAgICAgICAgXSk7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgU1dSIEFQSVxuICAgICAgICBjb25zdCBzZXRTaXplID0gdXNlQ2FsbGJhY2soKGFyZyk9PntcbiAgICAgICAgICAgIC8vIEl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlIGtleSBpcyBzdGlsbCBmYWxzeS5cbiAgICAgICAgICAgIGlmICghaW5maW5pdGVLZXkpIHJldHVybiBFTVBUWV9QUk9NSVNFO1xuICAgICAgICAgICAgY29uc3QgWywgY2hhbmdlU2l6ZV0gPSBjcmVhdGVDYWNoZUhlbHBlcihjYWNoZSQxLCBpbmZpbml0ZUtleSk7XG4gICAgICAgICAgICBsZXQgc2l6ZTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uJDEoYXJnKSkge1xuICAgICAgICAgICAgICAgIHNpemUgPSBhcmcocmVzb2x2ZVBhZ2VTaXplKCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IGFyZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2l6ZSAhPSAnbnVtYmVyJykgcmV0dXJuIEVNUFRZX1BST01JU0U7XG4gICAgICAgICAgICBjaGFuZ2VTaXplKHtcbiAgICAgICAgICAgICAgICBfbDogc2l6ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsYXN0UGFnZVNpemVSZWYuY3VycmVudCA9IHNpemU7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHBhZ2UgZGF0YSBhZnRlciB0aGUgc2l6ZSBjaGFuZ2UuXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgICAgICBjb25zdCBbZ2V0SW5maW5pdGVDYWNoZV0gPSBjcmVhdGVDYWNoZUhlbHBlcihjYWNoZSQxLCBpbmZpbml0ZUtleSk7XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNQYWdlRGF0YSA9IG51bGw7XG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgc2l6ZTsgKytpKXtcbiAgICAgICAgICAgICAgICBjb25zdCBbcGFnZUtleV0gPSBzZXJpYWxpemUkMShnZXRLZXkoaSwgcHJldmlvdXNQYWdlRGF0YSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtnZXRDYWNoZV0gPSBjcmVhdGVDYWNoZUhlbHBlcihjYWNoZSQxLCBwYWdlS2V5KTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGNhY2hlZCBwYWdlIGRhdGEuXG4gICAgICAgICAgICAgICAgY29uc3QgcGFnZURhdGEgPSBwYWdlS2V5ID8gZ2V0Q2FjaGUoKS5kYXRhIDogVU5ERUZJTkVEJDE7XG4gICAgICAgICAgICAgICAgLy8gQ2FsbCBgbXV0YXRlYCB3aXRoIGluZmludGUgY2FjaGUgZGF0YSBpZiB3ZSBjYW4ndCBnZXQgaXQgZnJvbSB0aGUgcGFnZSBjYWNoZS5cbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQkMShwYWdlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG11dGF0ZShnZXRJbmZpbml0ZUNhY2hlKCkuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGEucHVzaChwYWdlRGF0YSk7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNQYWdlRGF0YSA9IHBhZ2VEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG11dGF0ZShkYXRhKTtcbiAgICAgICAgfSwgLy8gZXhjbHVkZSBnZXRLZXkgZnJvbSB0aGUgZGVwZW5kZW5jaWVzLCB3aGljaCBpc24ndCBhbGxvd2VkIHRvIGNoYW5nZSBkdXJpbmcgdGhlIGxpZmVjeWNsZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICAgIFtcbiAgICAgICAgICAgIGluZmluaXRlS2V5LFxuICAgICAgICAgICAgY2FjaGUkMSxcbiAgICAgICAgICAgIG11dGF0ZSxcbiAgICAgICAgICAgIHJlc29sdmVQYWdlU2l6ZVxuICAgICAgICBdKTtcbiAgICAgICAgLy8gVXNlIGdldHRlciBmdW5jdGlvbnMgdG8gYXZvaWQgdW5uZWNlc3NhcnkgcmUtcmVuZGVycyBjYXVzZWQgYnkgdHJpZ2dlcmluZ1xuICAgICAgICAvLyBhbGwgdGhlIGdldHRlcnMgb2YgdGhlIHJldHVybmVkIHN3ciBvYmplY3QuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaXplOiByZXNvbHZlUGFnZVNpemUoKSxcbiAgICAgICAgICAgIHNldFNpemUsXG4gICAgICAgICAgICBtdXRhdGUsXG4gICAgICAgICAgICBnZXQgZGF0YSAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN3ci5kYXRhO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBlcnJvciAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN3ci5lcnJvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgaXNWYWxpZGF0aW5nICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3dyLmlzVmFsaWRhdGluZztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgaXNMb2FkaW5nICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3dyLmlzTG9hZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuY29uc3QgdXNlU1dSSW5maW5pdGUgPSB3aXRoTWlkZGxld2FyZSh1c2VTV1IsIGluZmluaXRlKTtcblxuZXhwb3J0IHsgdXNlU1dSSW5maW5pdGUgYXMgZGVmYXVsdCwgaW5maW5pdGUsIHVuc3RhYmxlX3NlcmlhbGl6ZSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/swr/dist/infinite/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/swr/dist/mutation/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/swr/dist/mutation/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ useSWRMutation)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _index_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_internal/index.mjs */ \"(app-pages-browser)/./node_modules/swr/dist/_internal/index.mjs\");\n/* harmony import */ var _index_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../index/index.mjs */ \"(app-pages-browser)/./node_modules/swr/dist/index/index.mjs\");\n/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_internal/index.mjs */ \"(app-pages-browser)/./node_modules/swr/dist/_internal/config-context-client-BoS53ST9.mjs\");\n\n\n\n\nconst startTransition = _internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.I ? (cb)=>{\n    cb();\n} : react__WEBPACK_IMPORTED_MODULE_0__.startTransition;\n/**\n * An implementation of state with dependency-tracking.\n * @param initialState - The initial state object.\n */ const useStateWithDeps = (initialState)=>{\n    const [, rerender] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const unmountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const stateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialState);\n    // If a state property (data, error, or isValidating) is accessed by the render\n    // function, we mark the property as a dependency so if it is updated again\n    // in the future, we trigger a rerender.\n    // This is also known as dependency-tracking.\n    const stateDependenciesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        data: false,\n        error: false,\n        isValidating: false\n    });\n    /**\n   * Updates state and triggers re-render if necessary.\n   * @param payload To change stateRef, pass the values explicitly to setState:\n   * @example\n   * ```js\n   * setState({\n   *   isValidating: false\n   *   data: newData // set data to newData\n   *   error: undefined // set error to undefined\n   * })\n   *\n   * setState({\n   *   isValidating: false\n   *   data: undefined // set data to undefined\n   *   error: err // set error to err\n   * })\n   * ```\n   */ const setState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((payload)=>{\n        let shouldRerender = false;\n        const currentState = stateRef.current;\n        for(const key in payload){\n            if (Object.prototype.hasOwnProperty.call(payload, key)) {\n                const k = key;\n                // If the property has changed, update the state and mark rerender as\n                // needed.\n                if (currentState[k] !== payload[k]) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    currentState[k] = payload[k];\n                    // If the property is accessed by the component, a rerender should be\n                    // triggered.\n                    if (stateDependenciesRef.current[k]) {\n                        shouldRerender = true;\n                    }\n                }\n            }\n        }\n        if (shouldRerender && !unmountedRef.current) {\n            rerender({});\n        }\n    }, []);\n    (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.u)(()=>{\n        unmountedRef.current = false;\n        return ()=>{\n            unmountedRef.current = true;\n        };\n    });\n    return [\n        stateRef,\n        stateDependenciesRef.current,\n        setState\n    ];\n};\n\nconst mutation = ()=>(key, fetcher, config = {})=>{\n        const { mutate } = (0,_index_index_mjs__WEBPACK_IMPORTED_MODULE_2__.useSWRConfig)();\n        const keyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(key);\n        const fetcherRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(fetcher);\n        const configRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(config);\n        // Ditch all mutation results that happened earlier than this timestamp.\n        const ditchMutationsUntilRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n        const [stateRef, stateDependencies, setState] = useStateWithDeps({\n            data: _internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.U,\n            error: _internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.U,\n            isMutating: false\n        });\n        const currentState = stateRef.current;\n        const trigger = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (arg, opts)=>{\n            const [serializedKey, resolvedKey] = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(keyRef.current);\n            if (!fetcherRef.current) {\n                throw new Error('Can’t trigger the mutation: missing fetcher.');\n            }\n            if (!serializedKey) {\n                throw new Error('Can’t trigger the mutation: missing key.');\n            }\n            // Disable cache population by default.\n            const options = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.m)((0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.m)({\n                populateCache: false,\n                throwOnError: true\n            }, configRef.current), opts);\n            // Trigger a mutation, and also track the timestamp. Any mutation that happened\n            // earlier this timestamp should be ignored.\n            const mutationStartedAt = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.o)();\n            ditchMutationsUntilRef.current = mutationStartedAt;\n            setState({\n                isMutating: true\n            });\n            try {\n                const data = await mutate(serializedKey, fetcherRef.current(resolvedKey, {\n                    arg\n                }), // We must throw the error here so we can catch and update the states.\n                (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(options, {\n                    throwOnError: true\n                }));\n                // If it's reset after the mutation, we don't broadcast any state change.\n                if (ditchMutationsUntilRef.current <= mutationStartedAt) {\n                    startTransition(()=>setState({\n                            data,\n                            isMutating: false,\n                            error: undefined\n                        }));\n                    options.onSuccess == null ? void 0 : options.onSuccess.call(options, data, serializedKey, options);\n                }\n                return data;\n            } catch (error) {\n                // If it's reset after the mutation, we don't broadcast any state change\n                // or throw because it's discarded.\n                if (ditchMutationsUntilRef.current <= mutationStartedAt) {\n                    startTransition(()=>setState({\n                            error: error,\n                            isMutating: false\n                        }));\n                    options.onError == null ? undefined : options.onError.call(options, error, serializedKey, options);\n                    if (options.throwOnError) {\n                        throw error;\n                    }\n                }\n            }\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        []);\n        const reset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n            ditchMutationsUntilRef.current = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.o)();\n            setState({\n                data: _internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.U,\n                error: _internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.U,\n                isMutating: false\n            });\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, []);\n        (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.u)(()=>{\n            keyRef.current = key;\n            fetcherRef.current = fetcher;\n            configRef.current = config;\n        });\n        // We don't return `mutate` here as it can be pretty confusing (e.g. people\n        // calling `mutate` but they actually mean `trigger`).\n        // And also, `mutate` relies on the useSWR hook to exist too.\n        return {\n            trigger,\n            reset,\n            get data () {\n                stateDependencies.data = true;\n                return currentState.data;\n            },\n            get error () {\n                stateDependencies.error = true;\n                return currentState.error;\n            },\n            get isMutating () {\n                stateDependencies.isMutating = true;\n                return currentState.isMutating;\n            }\n        };\n    };\n/**\n * A hook to define and manually trigger remote mutations like POST, PUT, DELETE and PATCH use cases.\n *\n * @link https://swr.vercel.app/docs/mutation\n * @example\n * ```jsx\n * import useSWRMutation from 'swr/mutation'\n *\n * const {\n *   data,\n *   error,\n *   trigger,\n *   reset,\n *   isMutating\n * } = useSWRMutation(key, fetcher, options?)\n * ```\n */ const useSWRMutation = (0,_index_index_mjs__WEBPACK_IMPORTED_MODULE_2__.withMiddleware)(_index_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"], mutation);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zd3IvZGlzdC9tdXRhdGlvbi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBNkQ7QUFDSDtBQUM0Rjs7QUFFdEosd0JBQXdCLGtEQUFlO0FBQ3ZDO0FBQ0EsRUFBRSxFQUFFLGtEQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwrQ0FBUSxHQUFHO0FBQ3BDLHlCQUF5Qiw2Q0FBTTtBQUMvQixxQkFBcUIsNkNBQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNkNBQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsdUJBQXVCLGtEQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsS0FBSztBQUNMLElBQUksc0RBQXlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0MsZ0JBQWdCLFNBQVMsRUFBRSw4REFBWTtBQUN2Qyx1QkFBdUIsNkNBQU07QUFDN0IsMkJBQTJCLDZDQUFNO0FBQ2pDLDBCQUEwQiw2Q0FBTTtBQUNoQztBQUNBLHVDQUF1Qyw2Q0FBTTtBQUM3QztBQUNBLGtCQUFrQixrREFBUztBQUMzQixtQkFBbUIsa0RBQVM7QUFDNUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3QkFBd0Isa0RBQVc7QUFDbkMsaURBQWlELHNEQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNEQUFZLENBQUMsc0RBQVk7QUFDckQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esc0NBQXNDLHNEQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0JBQWdCLHNEQUFZO0FBQzVCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNCQUFzQixrREFBVztBQUNqQyw2Q0FBNkMsc0RBQVk7QUFDekQ7QUFDQSxzQkFBc0Isa0RBQVM7QUFDL0IsdUJBQXVCLGtEQUFTO0FBQ2hDO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULFFBQVEsc0RBQXlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkIsZ0VBQWMsQ0FBQyx3REFBTTs7QUFFWCIsInNvdXJjZXMiOlsiL1VzZXJzL2lzaGFxYmVsbG8vV2Vic2l0ZS9oYXZlbnJpZGVfZnVsbF9hcHAvbm9kZV9tb2R1bGVzL3N3ci9kaXN0L211dGF0aW9uL2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZVJlZiwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlU1dSLCB7IHVzZVNXUkNvbmZpZyB9IGZyb20gJy4uL2luZGV4L2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBJU19SRUFDVF9MRUdBQ1ksIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QsIHdpdGhNaWRkbGV3YXJlLCBzZXJpYWxpemUsIG1lcmdlT2JqZWN0cywgZ2V0VGltZXN0YW1wLCBVTkRFRklORUQgfSBmcm9tICcuLi9faW50ZXJuYWwvaW5kZXgubWpzJztcblxuY29uc3Qgc3RhcnRUcmFuc2l0aW9uID0gSVNfUkVBQ1RfTEVHQUNZID8gKGNiKT0+e1xuICAgIGNiKCk7XG59IDogUmVhY3Quc3RhcnRUcmFuc2l0aW9uO1xuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBzdGF0ZSB3aXRoIGRlcGVuZGVuY3ktdHJhY2tpbmcuXG4gKiBAcGFyYW0gaW5pdGlhbFN0YXRlIC0gVGhlIGluaXRpYWwgc3RhdGUgb2JqZWN0LlxuICovIGNvbnN0IHVzZVN0YXRlV2l0aERlcHMgPSAoaW5pdGlhbFN0YXRlKT0+e1xuICAgIGNvbnN0IFssIHJlcmVuZGVyXSA9IHVzZVN0YXRlKHt9KTtcbiAgICBjb25zdCB1bm1vdW50ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IHN0YXRlUmVmID0gdXNlUmVmKGluaXRpYWxTdGF0ZSk7XG4gICAgLy8gSWYgYSBzdGF0ZSBwcm9wZXJ0eSAoZGF0YSwgZXJyb3IsIG9yIGlzVmFsaWRhdGluZykgaXMgYWNjZXNzZWQgYnkgdGhlIHJlbmRlclxuICAgIC8vIGZ1bmN0aW9uLCB3ZSBtYXJrIHRoZSBwcm9wZXJ0eSBhcyBhIGRlcGVuZGVuY3kgc28gaWYgaXQgaXMgdXBkYXRlZCBhZ2FpblxuICAgIC8vIGluIHRoZSBmdXR1cmUsIHdlIHRyaWdnZXIgYSByZXJlbmRlci5cbiAgICAvLyBUaGlzIGlzIGFsc28ga25vd24gYXMgZGVwZW5kZW5jeS10cmFja2luZy5cbiAgICBjb25zdCBzdGF0ZURlcGVuZGVuY2llc1JlZiA9IHVzZVJlZih7XG4gICAgICAgIGRhdGE6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZmFsc2UsXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2VcbiAgICB9KTtcbiAgICAvKipcbiAgICogVXBkYXRlcyBzdGF0ZSBhbmQgdHJpZ2dlcnMgcmUtcmVuZGVyIGlmIG5lY2Vzc2FyeS5cbiAgICogQHBhcmFtIHBheWxvYWQgVG8gY2hhbmdlIHN0YXRlUmVmLCBwYXNzIHRoZSB2YWx1ZXMgZXhwbGljaXRseSB0byBzZXRTdGF0ZTpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogc2V0U3RhdGUoe1xuICAgKiAgIGlzVmFsaWRhdGluZzogZmFsc2VcbiAgICogICBkYXRhOiBuZXdEYXRhIC8vIHNldCBkYXRhIHRvIG5ld0RhdGFcbiAgICogICBlcnJvcjogdW5kZWZpbmVkIC8vIHNldCBlcnJvciB0byB1bmRlZmluZWRcbiAgICogfSlcbiAgICpcbiAgICogc2V0U3RhdGUoe1xuICAgKiAgIGlzVmFsaWRhdGluZzogZmFsc2VcbiAgICogICBkYXRhOiB1bmRlZmluZWQgLy8gc2V0IGRhdGEgdG8gdW5kZWZpbmVkXG4gICAqICAgZXJyb3I6IGVyciAvLyBzZXQgZXJyb3IgdG8gZXJyXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi8gY29uc3Qgc2V0U3RhdGUgPSB1c2VDYWxsYmFjaygocGF5bG9hZCk9PntcbiAgICAgICAgbGV0IHNob3VsZFJlcmVuZGVyID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHN0YXRlUmVmLmN1cnJlbnQ7XG4gICAgICAgIGZvcihjb25zdCBrZXkgaW4gcGF5bG9hZCl7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBheWxvYWQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrID0ga2V5O1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBoYXMgY2hhbmdlZCwgdXBkYXRlIHRoZSBzdGF0ZSBhbmQgbWFyayByZXJlbmRlciBhc1xuICAgICAgICAgICAgICAgIC8vIG5lZWRlZC5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlW2tdICE9PSBwYXlsb2FkW2tdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZVtrXSA9IHBheWxvYWRba107XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBpcyBhY2Nlc3NlZCBieSB0aGUgY29tcG9uZW50LCBhIHJlcmVuZGVyIHNob3VsZCBiZVxuICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZURlcGVuZGVuY2llc1JlZi5jdXJyZW50W2tdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRSZXJlbmRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFJlcmVuZGVyICYmICF1bm1vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgcmVyZW5kZXIoe30pO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgdW5tb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICB1bm1vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc3RhdGVSZWYsXG4gICAgICAgIHN0YXRlRGVwZW5kZW5jaWVzUmVmLmN1cnJlbnQsXG4gICAgICAgIHNldFN0YXRlXG4gICAgXTtcbn07XG5cbmNvbnN0IG11dGF0aW9uID0gKCk9PihrZXksIGZldGNoZXIsIGNvbmZpZyA9IHt9KT0+e1xuICAgICAgICBjb25zdCB7IG11dGF0ZSB9ID0gdXNlU1dSQ29uZmlnKCk7XG4gICAgICAgIGNvbnN0IGtleVJlZiA9IHVzZVJlZihrZXkpO1xuICAgICAgICBjb25zdCBmZXRjaGVyUmVmID0gdXNlUmVmKGZldGNoZXIpO1xuICAgICAgICBjb25zdCBjb25maWdSZWYgPSB1c2VSZWYoY29uZmlnKTtcbiAgICAgICAgLy8gRGl0Y2ggYWxsIG11dGF0aW9uIHJlc3VsdHMgdGhhdCBoYXBwZW5lZCBlYXJsaWVyIHRoYW4gdGhpcyB0aW1lc3RhbXAuXG4gICAgICAgIGNvbnN0IGRpdGNoTXV0YXRpb25zVW50aWxSZWYgPSB1c2VSZWYoMCk7XG4gICAgICAgIGNvbnN0IFtzdGF0ZVJlZiwgc3RhdGVEZXBlbmRlbmNpZXMsIHNldFN0YXRlXSA9IHVzZVN0YXRlV2l0aERlcHMoe1xuICAgICAgICAgICAgZGF0YTogVU5ERUZJTkVELFxuICAgICAgICAgICAgZXJyb3I6IFVOREVGSU5FRCxcbiAgICAgICAgICAgIGlzTXV0YXRpbmc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBzdGF0ZVJlZi5jdXJyZW50O1xuICAgICAgICBjb25zdCB0cmlnZ2VyID0gdXNlQ2FsbGJhY2soYXN5bmMgKGFyZywgb3B0cyk9PntcbiAgICAgICAgICAgIGNvbnN0IFtzZXJpYWxpemVkS2V5LCByZXNvbHZlZEtleV0gPSBzZXJpYWxpemUoa2V5UmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKCFmZXRjaGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbuKAmXQgdHJpZ2dlciB0aGUgbXV0YXRpb246IG1pc3NpbmcgZmV0Y2hlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VyaWFsaXplZEtleSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fu4oCZdCB0cmlnZ2VyIHRoZSBtdXRhdGlvbjogbWlzc2luZyBrZXkuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEaXNhYmxlIGNhY2hlIHBvcHVsYXRpb24gYnkgZGVmYXVsdC5cbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtZXJnZU9iamVjdHMobWVyZ2VPYmplY3RzKHtcbiAgICAgICAgICAgICAgICBwb3B1bGF0ZUNhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0aHJvd09uRXJyb3I6IHRydWVcbiAgICAgICAgICAgIH0sIGNvbmZpZ1JlZi5jdXJyZW50KSwgb3B0cyk7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIGEgbXV0YXRpb24sIGFuZCBhbHNvIHRyYWNrIHRoZSB0aW1lc3RhbXAuIEFueSBtdXRhdGlvbiB0aGF0IGhhcHBlbmVkXG4gICAgICAgICAgICAvLyBlYXJsaWVyIHRoaXMgdGltZXN0YW1wIHNob3VsZCBiZSBpZ25vcmVkLlxuICAgICAgICAgICAgY29uc3QgbXV0YXRpb25TdGFydGVkQXQgPSBnZXRUaW1lc3RhbXAoKTtcbiAgICAgICAgICAgIGRpdGNoTXV0YXRpb25zVW50aWxSZWYuY3VycmVudCA9IG11dGF0aW9uU3RhcnRlZEF0O1xuICAgICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGlzTXV0YXRpbmc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgbXV0YXRlKHNlcmlhbGl6ZWRLZXksIGZldGNoZXJSZWYuY3VycmVudChyZXNvbHZlZEtleSwge1xuICAgICAgICAgICAgICAgICAgICBhcmdcbiAgICAgICAgICAgICAgICB9KSwgLy8gV2UgbXVzdCB0aHJvdyB0aGUgZXJyb3IgaGVyZSBzbyB3ZSBjYW4gY2F0Y2ggYW5kIHVwZGF0ZSB0aGUgc3RhdGVzLlxuICAgICAgICAgICAgICAgIG1lcmdlT2JqZWN0cyhvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93T25FcnJvcjogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIHJlc2V0IGFmdGVyIHRoZSBtdXRhdGlvbiwgd2UgZG9uJ3QgYnJvYWRjYXN0IGFueSBzdGF0ZSBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgaWYgKGRpdGNoTXV0YXRpb25zVW50aWxSZWYuY3VycmVudCA8PSBtdXRhdGlvblN0YXJ0ZWRBdCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFRyYW5zaXRpb24oKCk9PnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTXV0YXRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vblN1Y2Nlc3MgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMub25TdWNjZXNzLmNhbGwob3B0aW9ucywgZGF0YSwgc2VyaWFsaXplZEtleSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIHJlc2V0IGFmdGVyIHRoZSBtdXRhdGlvbiwgd2UgZG9uJ3QgYnJvYWRjYXN0IGFueSBzdGF0ZSBjaGFuZ2VcbiAgICAgICAgICAgICAgICAvLyBvciB0aHJvdyBiZWNhdXNlIGl0J3MgZGlzY2FyZGVkLlxuICAgICAgICAgICAgICAgIGlmIChkaXRjaE11dGF0aW9uc1VudGlsUmVmLmN1cnJlbnQgPD0gbXV0YXRpb25TdGFydGVkQXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpPT5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTXV0YXRpbmc6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25FcnJvciA9PSBudWxsID8gdW5kZWZpbmVkIDogb3B0aW9ucy5vbkVycm9yLmNhbGwob3B0aW9ucywgZXJyb3IsIHNlcmlhbGl6ZWRLZXksIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50aHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICAgIFtdKTtcbiAgICAgICAgY29uc3QgcmVzZXQgPSB1c2VDYWxsYmFjaygoKT0+e1xuICAgICAgICAgICAgZGl0Y2hNdXRhdGlvbnNVbnRpbFJlZi5jdXJyZW50ID0gZ2V0VGltZXN0YW1wKCk7XG4gICAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogVU5ERUZJTkVELFxuICAgICAgICAgICAgICAgIGVycm9yOiBVTkRFRklORUQsXG4gICAgICAgICAgICAgICAgaXNNdXRhdGluZzogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKT0+e1xuICAgICAgICAgICAga2V5UmVmLmN1cnJlbnQgPSBrZXk7XG4gICAgICAgICAgICBmZXRjaGVyUmVmLmN1cnJlbnQgPSBmZXRjaGVyO1xuICAgICAgICAgICAgY29uZmlnUmVmLmN1cnJlbnQgPSBjb25maWc7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZSBkb24ndCByZXR1cm4gYG11dGF0ZWAgaGVyZSBhcyBpdCBjYW4gYmUgcHJldHR5IGNvbmZ1c2luZyAoZS5nLiBwZW9wbGVcbiAgICAgICAgLy8gY2FsbGluZyBgbXV0YXRlYCBidXQgdGhleSBhY3R1YWxseSBtZWFuIGB0cmlnZ2VyYCkuXG4gICAgICAgIC8vIEFuZCBhbHNvLCBgbXV0YXRlYCByZWxpZXMgb24gdGhlIHVzZVNXUiBob29rIHRvIGV4aXN0IHRvby5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyaWdnZXIsXG4gICAgICAgICAgICByZXNldCxcbiAgICAgICAgICAgIGdldCBkYXRhICgpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZURlcGVuZGVuY2llcy5kYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFN0YXRlLmRhdGE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGVycm9yICgpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZURlcGVuZGVuY2llcy5lcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTdGF0ZS5lcnJvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgaXNNdXRhdGluZyAoKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuaXNNdXRhdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTdGF0ZS5pc011dGF0aW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4vKipcbiAqIEEgaG9vayB0byBkZWZpbmUgYW5kIG1hbnVhbGx5IHRyaWdnZXIgcmVtb3RlIG11dGF0aW9ucyBsaWtlIFBPU1QsIFBVVCwgREVMRVRFIGFuZCBQQVRDSCB1c2UgY2FzZXMuXG4gKlxuICogQGxpbmsgaHR0cHM6Ly9zd3IudmVyY2VsLmFwcC9kb2NzL211dGF0aW9uXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKiBpbXBvcnQgdXNlU1dSTXV0YXRpb24gZnJvbSAnc3dyL211dGF0aW9uJ1xuICpcbiAqIGNvbnN0IHtcbiAqICAgZGF0YSxcbiAqICAgZXJyb3IsXG4gKiAgIHRyaWdnZXIsXG4gKiAgIHJlc2V0LFxuICogICBpc011dGF0aW5nXG4gKiB9ID0gdXNlU1dSTXV0YXRpb24oa2V5LCBmZXRjaGVyLCBvcHRpb25zPylcbiAqIGBgYFxuICovIGNvbnN0IHVzZVNXUk11dGF0aW9uID0gd2l0aE1pZGRsZXdhcmUodXNlU1dSLCBtdXRhdGlvbik7XG5cbmV4cG9ydCB7IHVzZVNXUk11dGF0aW9uIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/swr/dist/mutation/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function useSyncExternalStore$2(subscribe, getSnapshot) {\n      didWarnOld18Alpha ||\n        void 0 === React.startTransition ||\n        ((didWarnOld18Alpha = !0),\n        console.error(\n          \"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\"\n        ));\n      var value = getSnapshot();\n      if (!didWarnUncachedGetSnapshot) {\n        var cachedValue = getSnapshot();\n        objectIs(value, cachedValue) ||\n          (console.error(\n            \"The result of getSnapshot should be cached to avoid an infinite loop\"\n          ),\n          (didWarnUncachedGetSnapshot = !0));\n      }\n      cachedValue = useState({\n        inst: { value: value, getSnapshot: getSnapshot }\n      });\n      var inst = cachedValue[0].inst,\n        forceUpdate = cachedValue[1];\n      useLayoutEffect(\n        function () {\n          inst.value = value;\n          inst.getSnapshot = getSnapshot;\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n        },\n        [subscribe, value, getSnapshot]\n      );\n      useEffect(\n        function () {\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          return subscribe(function () {\n            checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          });\n        },\n        [subscribe]\n      );\n      useDebugValue(value);\n      return value;\n    }\n    function checkIfSnapshotChanged(inst) {\n      var latestGetSnapshot = inst.getSnapshot;\n      inst = inst.value;\n      try {\n        var nextValue = latestGetSnapshot();\n        return !objectIs(inst, nextValue);\n      } catch (error) {\n        return !0;\n      }\n    }\n    function useSyncExternalStore$1(subscribe, getSnapshot) {\n      return getSnapshot();\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useState = React.useState,\n      useEffect = React.useEffect,\n      useLayoutEffect = React.useLayoutEffect,\n      useDebugValue = React.useDebugValue,\n      didWarnOld18Alpha = !1,\n      didWarnUncachedGetSnapshot = !1,\n      shim =\n        \"undefined\" === typeof window ||\n        \"undefined\" === typeof window.document ||\n        \"undefined\" === typeof window.document.createElement\n          ? useSyncExternalStore$1\n          : useSyncExternalStore$2;\n    exports.useSyncExternalStore =\n      void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFO0FBQ0EsMERBQTBELFlBQVk7QUFDdEUsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiL1VzZXJzL2lzaGFxYmVsbG8vV2Vic2l0ZS9oYXZlbnJpZGVfZnVsbF9hcHAvbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0uZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgICAgcmV0dXJuICh4ID09PSB5ICYmICgwICE9PSB4IHx8IDEgLyB4ID09PSAxIC8geSkpIHx8ICh4ICE9PSB4ICYmIHkgIT09IHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQyKHN1YnNjcmliZSwgZ2V0U25hcHNob3QpIHtcbiAgICAgIGRpZFdhcm5PbGQxOEFscGhhIHx8XG4gICAgICAgIHZvaWQgMCA9PT0gUmVhY3Quc3RhcnRUcmFuc2l0aW9uIHx8XG4gICAgICAgICgoZGlkV2Fybk9sZDE4QWxwaGEgPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJZb3UgYXJlIHVzaW5nIGFuIG91dGRhdGVkLCBwcmUtcmVsZWFzZSBhbHBoYSBvZiBSZWFjdCAxOCB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdXNlU3luY0V4dGVybmFsU3RvcmUuIFRoZSB1c2Utc3luYy1leHRlcm5hbC1zdG9yZSBzaGltIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5LiBVcGdyYWRlIHRvIGEgbmV3ZXIgcHJlLXJlbGVhc2UuXCJcbiAgICAgICAgKSk7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRTbmFwc2hvdCgpO1xuICAgICAgaWYgKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCkge1xuICAgICAgICB2YXIgY2FjaGVkVmFsdWUgPSBnZXRTbmFwc2hvdCgpO1xuICAgICAgICBvYmplY3RJcyh2YWx1ZSwgY2FjaGVkVmFsdWUpIHx8XG4gICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSByZXN1bHQgb2YgZ2V0U25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9ICEwKSk7XG4gICAgICB9XG4gICAgICBjYWNoZWRWYWx1ZSA9IHVzZVN0YXRlKHtcbiAgICAgICAgaW5zdDogeyB2YWx1ZTogdmFsdWUsIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdCB9XG4gICAgICB9KTtcbiAgICAgIHZhciBpbnN0ID0gY2FjaGVkVmFsdWVbMF0uaW5zdCxcbiAgICAgICAgZm9yY2VVcGRhdGUgPSBjYWNoZWRWYWx1ZVsxXTtcbiAgICAgIHVzZUxheW91dEVmZmVjdChcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGluc3QudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBpbnN0LmdldFNuYXBzaG90ID0gZ2V0U25hcHNob3Q7XG4gICAgICAgICAgY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSAmJiBmb3JjZVVwZGF0ZSh7IGluc3Q6IGluc3QgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFtzdWJzY3JpYmUsIHZhbHVlLCBnZXRTbmFwc2hvdF1cbiAgICAgICk7XG4gICAgICB1c2VFZmZlY3QoXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpICYmIGZvcmNlVXBkYXRlKHsgaW5zdDogaW5zdCB9KTtcbiAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkgJiYgZm9yY2VVcGRhdGUoeyBpbnN0OiBpbnN0IH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBbc3Vic2NyaWJlXVxuICAgICAgKTtcbiAgICAgIHVzZURlYnVnVmFsdWUodmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpIHtcbiAgICAgIHZhciBsYXRlc3RHZXRTbmFwc2hvdCA9IGluc3QuZ2V0U25hcHNob3Q7XG4gICAgICBpbnN0ID0gaW5zdC52YWx1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuZXh0VmFsdWUgPSBsYXRlc3RHZXRTbmFwc2hvdCgpO1xuICAgICAgICByZXR1cm4gIW9iamVjdElzKGluc3QsIG5leHRWYWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlJDEoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCkge1xuICAgICAgcmV0dXJuIGdldFNuYXBzaG90KCk7XG4gICAgfVxuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgJiZcbiAgICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQoRXJyb3IoKSk7XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpLFxuICAgICAgb2JqZWN0SXMgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiBpcyxcbiAgICAgIHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUsXG4gICAgICB1c2VFZmZlY3QgPSBSZWFjdC51c2VFZmZlY3QsXG4gICAgICB1c2VMYXlvdXRFZmZlY3QgPSBSZWFjdC51c2VMYXlvdXRFZmZlY3QsXG4gICAgICB1c2VEZWJ1Z1ZhbHVlID0gUmVhY3QudXNlRGVidWdWYWx1ZSxcbiAgICAgIGRpZFdhcm5PbGQxOEFscGhhID0gITEsXG4gICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9ICExLFxuICAgICAgc2hpbSA9XG4gICAgICAgIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiB3aW5kb3cgfHxcbiAgICAgICAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIHdpbmRvdy5kb2N1bWVudCB8fFxuICAgICAgICBcInVuZGVmaW5lZFwiID09PSB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnRcbiAgICAgICAgICA/IHVzZVN5bmNFeHRlcm5hbFN0b3JlJDFcbiAgICAgICAgICA6IHVzZVN5bmNFeHRlcm5hbFN0b3JlJDI7XG4gICAgZXhwb3J0cy51c2VTeW5jRXh0ZXJuYWxTdG9yZSA9XG4gICAgICB2b2lkIDAgIT09IFJlYWN0LnVzZVN5bmNFeHRlcm5hbFN0b3JlID8gUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUgOiBzaGltO1xuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKEVycm9yKCkpO1xuICB9KSgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js":
/*!************************************************************!*\
  !*** ./node_modules/use-sync-external-store/shim/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim.development.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw0TUFBOEU7QUFDaEYiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2hhcWJlbGxvL1dlYnNpdGUvaGF2ZW5yaWRlX2Z1bGxfYXBwL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fishaqbello%2FWebsite%2Fhavenride_full_app%2Fapp%2Fdriver%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);